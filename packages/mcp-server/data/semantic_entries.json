[
  {
    "id": "C:/Users/Vipac/Desktop/final_project/src/indexer.ts:walkDir",
    "file": "src/indexer.ts",
    "symbol": "walkDir",
    "startLine": 21,
    "endLine": 37,
    "text": "function walkDir(dir: string): string[] {\n  const files: string[] = [];\n  const entries = fs.readdirSync(dir, { withFileTypes: true });\n  for (const entry of entries) {\n    if (entry.name.startsWith('.')) continue; // skip hidden\n    const fullPath = path.join(dir, entry.name);\n    if (entry.isDirectory()) {\n      if (entry.name === 'node_modules' || entry.name === 'dist') continue;\n      files.push(...walkDir(fullPath));\n    } else if (entry.isFile()) {\n      if (/\\.tsx?$/.test(entry.name)) {\n        files.push(fullPath);\n      }\n    }\n  }\n  return files;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/src/indexer.ts:extractSymbols",
    "file": "src/indexer.ts",
    "symbol": "extractSymbols",
    "startLine": 45,
    "endLine": 95,
    "text": "function extractSymbols(sourceFile: ts.SourceFile): SymbolMeta[] {\n  const symbols: SymbolMeta[] = [];\n  const visit = (node: ts.Node) => {\n    if (ts.isFunctionDeclaration(node) && node.name) {\n      // Include leading JSDoc comments when computing the start position so\n      // that documentation is part of the snippet. Without setting\n      // includeJsDocComment=true the comment lines are excluded from the\n      // node's start position.\n      const start = sourceFile.getLineAndCharacterOfPosition(node.getStart(sourceFile, true));\n      const end = sourceFile.getLineAndCharacterOfPosition(node.getEnd());\n      symbols.push({\n        name: node.name.getText(),\n        kind: 'function',\n        file: sourceFile.fileName,\n        startLine: start.line + 1,\n        endLine: end.line + 1,\n      });\n    } else if (ts.isClassDeclaration(node) && node.name) {\n      const start = sourceFile.getLineAndCharacterOfPosition(node.getStart(sourceFile, true));\n      const end = sourceFile.getLineAndCharacterOfPosition(node.getEnd());\n      symbols.push({\n        name: node.name.getText(),\n        kind: 'class',\n        file: sourceFile.fileName,\n        startLine: start.line + 1,\n        endLine: end.line + 1,\n      });\n      // Extract methods within the class\n      node.members.forEach(member => {\n        if (\n          ts.isMethodDeclaration(member) &&\n          member.name &&\n          ts.isIdentifier(member.name)\n        ) {\n          const mStart = sourceFile.getLineAndCharacterOfPosition(member.getStart(sourceFile, true));\n          const mEnd = sourceFile.getLineAndCharacterOfPosition(member.getEnd());\n          symbols.push({\n            name: `${node.name!.getText()}.${member.name.getText()}`,\n            kind: 'method',\n            file: sourceFile.fileName,\n            startLine: mStart.line + 1,\n            endLine: mEnd.line + 1,\n          });\n        }\n      });\n    }\n    ts.forEachChild(node, visit);\n  };\n  visit(sourceFile);\n  return symbols;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/src/indexer.ts:createSemanticEntries",
    "file": "src/indexer.ts",
    "symbol": "createSemanticEntries",
    "startLine": 103,
    "endLine": 119,
    "text": "function createSemanticEntries(fileMeta: FileMeta): SemanticEntry[] {\n  const lines = fileMeta.content.split(/\\r?\\n/);\n  const entries: SemanticEntry[] = [];\n  for (const sym of fileMeta.symbols) {\n    const snippetLines = lines.slice(sym.startLine - 1, sym.endLine);\n    const text = snippetLines.join('\\n');\n    entries.push({\n      id: `${fileMeta.path}:${sym.name}`,\n      file: fileMeta.path,\n      symbol: sym.name,\n      startLine: sym.startLine,\n      endLine: sym.endLine,\n      text,\n    });\n  }\n  return entries;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/src/indexer.ts:runIndexer",
    "file": "src/indexer.ts",
    "symbol": "runIndexer",
    "startLine": 126,
    "endLine": 153,
    "text": "export function runIndexer(rootDir: string, outDir: string): void {\n  const tsFiles = walkDir(rootDir);\n  const fileMetas: FileMeta[] = [];\n  const semanticEntries: SemanticEntry[] = [];\n  for (const file of tsFiles) {\n    const content = fs.readFileSync(file, 'utf8');\n    const sourceFile = ts.createSourceFile(file, content, ts.ScriptTarget.Latest, true);\n    const symbols = extractSymbols(sourceFile);\n    const relativePath = path.relative(rootDir, file).replace(/\\\\/g, '/');\n    const fileMeta: FileMeta = {\n      path: relativePath,\n      content,\n      symbols,\n    };\n    fileMetas.push(fileMeta);\n    const entries = createSemanticEntries(fileMeta);\n    semanticEntries.push(...entries);\n  }\n  if (!fs.existsSync(outDir)) {\n    fs.mkdirSync(outDir, { recursive: true });\n  }\n  fs.writeFileSync(path.join(outDir, 'index.json'), JSON.stringify(fileMetas, null, 2), 'utf8');\n  fs.writeFileSync(\n    path.join(outDir, 'semantic_entries.json'),\n    JSON.stringify(semanticEntries, null, 2),\n    'utf8'\n  );\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/src/orchestrator.ts:Orchestrator",
    "file": "src/orchestrator.ts",
    "symbol": "Orchestrator",
    "startLine": 28,
    "endLine": 118,
    "text": "export class Orchestrator {\n  private fileIndex: Map<string, FileMeta> = new Map();\n  private engineUrl: string;\n\n  constructor(dataDir: string, engineUrl: string = 'http://localhost:8000') {\n    this.engineUrl = engineUrl;\n    this.loadIndex(dataDir);\n  }\n\n  /**\n   * Load the file metadata index from the specified directory. The file\n   * `index.json` is expected to contain an array of FileMeta objects.\n   */\n  private loadIndex(dataDir: string) {\n    const idxPath = path.join(dataDir, 'index.json');\n    const json = fs.readFileSync(idxPath, 'utf8');\n    const files: FileMeta[] = JSON.parse(json);\n    for (const file of files) {\n      // Use relative path as key for lookup.\n      this.fileIndex.set(file.path, file);\n    }\n  }\n\n  /**\n   * Retrieve the contents of a file by its relative path. Throws if the\n   * file cannot be found in the index.\n   */\n  public getFile(filePath: string): string {\n    const fileMeta = this.fileIndex.get(filePath);\n    if (!fileMeta) {\n      throw new Error(`File not found in index: ${filePath}`);\n    }\n    return fileMeta.content;\n  }\n\n  /**\n   * Perform a semantic search through the Python engine and combine its\n   * scores with a simple lexical match. The lexical score boosts results\n   * containing the query terms within their snippet. The final score is\n   * a weighted sum of semantic (0.7) and lexical (0.3) scores.\n   */\n  public async searchCode(query: string, topK = 5): Promise<SearchResult[]> {\n    // Query the Python semantic engine via HTTP GET. URL encode the query.\n    const url = new URL('/search', this.engineUrl);\n    url.searchParams.set('q', query);\n    url.searchParams.set('top_k', topK.toString());\n\n    const engineResults: EngineSearchResult[] = await new Promise((resolve, reject) => {\n      const req = http.get(url.toString(), res => {\n        const chunks: Buffer[] = [];\n        res.on('data', chunk => chunks.push(chunk));\n        res.on('end', () => {\n          const body = Buffer.concat(chunks).toString('utf8');\n          try {\n            const parsed = JSON.parse(body);\n            resolve(parsed.results as EngineSearchResult[]);\n          } catch (err) {\n            reject(new Error(`Failed to parse engine response: ${body}`));\n          }\n        });\n      });\n      req.on('error', err => reject(err));\n    });\n\n    // Compute lexical score: proportion of query terms present in the snippet.\n    const tokens = query\n      .toLowerCase()\n      .split(/\\W+/)\n      .filter(t => t.length > 0);\n    const results: SearchResult[] = engineResults.map(er => {\n      const snippetLower = er.snippet.toLowerCase();\n      let hits = 0;\n      for (const token of tokens) {\n        if (snippetLower.includes(token)) hits++;\n      }\n      const lexicalScore = tokens.length > 0 ? hits / tokens.length : 0;\n      const finalScore = er.score * 0.7 + lexicalScore * 0.3;\n      return {\n        file: er.file,\n        symbol: er.symbol,\n        startLine: er.startLine,\n        endLine: er.endLine,\n        score: finalScore,\n        snippet: er.snippet,\n      };\n    });\n    // Sort by final score descending and return topK.\n    results.sort((a, b) => b.score - a.score);\n    return results.slice(0, topK);\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/src/orchestrator.ts:Orchestrator.loadIndex",
    "file": "src/orchestrator.ts",
    "symbol": "Orchestrator.loadIndex",
    "startLine": 41,
    "endLine": 49,
    "text": "  private loadIndex(dataDir: string) {\n    const idxPath = path.join(dataDir, 'index.json');\n    const json = fs.readFileSync(idxPath, 'utf8');\n    const files: FileMeta[] = JSON.parse(json);\n    for (const file of files) {\n      // Use relative path as key for lookup.\n      this.fileIndex.set(file.path, file);\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/src/orchestrator.ts:Orchestrator.getFile",
    "file": "src/orchestrator.ts",
    "symbol": "Orchestrator.getFile",
    "startLine": 55,
    "endLine": 61,
    "text": "  public getFile(filePath: string): string {\n    const fileMeta = this.fileIndex.get(filePath);\n    if (!fileMeta) {\n      throw new Error(`File not found in index: ${filePath}`);\n    }\n    return fileMeta.content;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/src/orchestrator.ts:Orchestrator.searchCode",
    "file": "src/orchestrator.ts",
    "symbol": "Orchestrator.searchCode",
    "startLine": 69,
    "endLine": 117,
    "text": "  public async searchCode(query: string, topK = 5): Promise<SearchResult[]> {\n    // Query the Python semantic engine via HTTP GET. URL encode the query.\n    const url = new URL('/search', this.engineUrl);\n    url.searchParams.set('q', query);\n    url.searchParams.set('top_k', topK.toString());\n\n    const engineResults: EngineSearchResult[] = await new Promise((resolve, reject) => {\n      const req = http.get(url.toString(), res => {\n        const chunks: Buffer[] = [];\n        res.on('data', chunk => chunks.push(chunk));\n        res.on('end', () => {\n          const body = Buffer.concat(chunks).toString('utf8');\n          try {\n            const parsed = JSON.parse(body);\n            resolve(parsed.results as EngineSearchResult[]);\n          } catch (err) {\n            reject(new Error(`Failed to parse engine response: ${body}`));\n          }\n        });\n      });\n      req.on('error', err => reject(err));\n    });\n\n    // Compute lexical score: proportion of query terms present in the snippet.\n    const tokens = query\n      .toLowerCase()\n      .split(/\\W+/)\n      .filter(t => t.length > 0);\n    const results: SearchResult[] = engineResults.map(er => {\n      const snippetLower = er.snippet.toLowerCase();\n      let hits = 0;\n      for (const token of tokens) {\n        if (snippetLower.includes(token)) hits++;\n      }\n      const lexicalScore = tokens.length > 0 ? hits / tokens.length : 0;\n      const finalScore = er.score * 0.7 + lexicalScore * 0.3;\n      return {\n        file: er.file,\n        symbol: er.symbol,\n        startLine: er.startLine,\n        endLine: er.endLine,\n        score: finalScore,\n        snippet: er.snippet,\n      };\n    });\n    // Sort by final score descending and return topK.\n    results.sort((a, b) => b.score - a.score);\n    return results.slice(0, topK);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/external_sample/src/hello.ts:hello",
    "file": "external_sample/src/hello.ts",
    "symbol": "hello",
    "startLine": 1,
    "endLine": 3,
    "text": "export function hello(name: string) {\n  return `Hello, ${name}!`;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod-to-json-schema/createIndex.ts:checkSrcDir",
    "file": "mcp-rag-server/node_modules/zod-to-json-schema/createIndex.ts",
    "symbol": "checkSrcDir",
    "startLine": 5,
    "endLine": 23,
    "text": "function checkSrcDir(path: string): string[] {\n  const lines: string[] = [];\n\n  for (const item of readdirSync(path)) {\n    const itemPath = path + \"/\" + item;\n\n    if (ignore.includes(itemPath)) {\n      continue;\n    }\n\n    if (statSync(itemPath).isDirectory()) {\n      lines.push(...checkSrcDir(itemPath));\n    } else if (item.endsWith(\".ts\")) {\n      lines.push('export * from \"./' + itemPath.slice(4, -2) + 'js\"');\n    }\n  }\n\n  return lines;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts:CAC",
    "file": "node_modules/cac/deno/CAC.ts",
    "symbol": "CAC",
    "startLine": 14,
    "endLine": 329,
    "text": "class CAC extends EventEmitter {\n  /** The program name to display in help and version message */\n  name: string;\n  commands: Command[];\n  globalCommand: GlobalCommand;\n  matchedCommand?: Command;\n  matchedCommandName?: string;\n  /**\n   * Raw CLI arguments\n   */\n\n  rawArgs: string[];\n  /**\n   * Parsed CLI arguments\n   */\n\n  args: ParsedArgv['args'];\n  /**\n   * Parsed CLI options, camelCased\n   */\n\n  options: ParsedArgv['options'];\n  showHelpOnExit?: boolean;\n  showVersionOnExit?: boolean;\n  /**\n   * @param name The program name to display in help and version message\n   */\n\n  constructor(name = '') {\n    super();\n    this.name = name;\n    this.commands = [];\n    this.rawArgs = [];\n    this.args = [];\n    this.options = {};\n    this.globalCommand = new GlobalCommand(this);\n    this.globalCommand.usage('<command> [options]');\n  }\n  /**\n   * Add a global usage text.\n   *\n   * This is not used by sub-commands.\n   */\n\n\n  usage(text: string) {\n    this.globalCommand.usage(text);\n    return this;\n  }\n  /**\n   * Add a sub-command\n   */\n\n\n  command(rawName: string, description?: string, config?: CommandConfig) {\n    const command = new Command(rawName, description || '', config, this);\n    command.globalCommand = this.globalCommand;\n    this.commands.push(command);\n    return command;\n  }\n  /**\n   * Add a global CLI option.\n   *\n   * Which is also applied to sub-commands.\n   */\n\n\n  option(rawName: string, description: string, config?: OptionConfig) {\n    this.globalCommand.option(rawName, description, config);\n    return this;\n  }\n  /**\n   * Show help message when `-h, --help` flags appear.\n   *\n   */\n\n\n  help(callback?: HelpCallback) {\n    this.globalCommand.option('-h, --help', 'Display this message');\n    this.globalCommand.helpCallback = callback;\n    this.showHelpOnExit = true;\n    return this;\n  }\n  /**\n   * Show version number when `-v, --version` flags appear.\n   *\n   */\n\n\n  version(version: string, customFlags = '-v, --version') {\n    this.globalCommand.version(version, customFlags);\n    this.showVersionOnExit = true;\n    return this;\n  }\n  /**\n   * Add a global example.\n   *\n   * This example added here will not be used by sub-commands.\n   */\n\n\n  example(example: CommandExample) {\n    this.globalCommand.example(example);\n    return this;\n  }\n  /**\n   * Output the corresponding help message\n   * When a sub-command is matched, output the help message for the command\n   * Otherwise output the global one.\n   *\n   */\n\n\n  outputHelp() {\n    if (this.matchedCommand) {\n      this.matchedCommand.outputHelp();\n    } else {\n      this.globalCommand.outputHelp();\n    }\n  }\n  /**\n   * Output the version number.\n   *\n   */\n\n\n  outputVersion() {\n    this.globalCommand.outputVersion();\n  }\n\n  private setParsedInfo({\n    args,\n    options\n  }: ParsedArgv, matchedCommand?: Command, matchedCommandName?: string) {\n    this.args = args;\n    this.options = options;\n\n    if (matchedCommand) {\n      this.matchedCommand = matchedCommand;\n    }\n\n    if (matchedCommandName) {\n      this.matchedCommandName = matchedCommandName;\n    }\n\n    return this;\n  }\n\n  unsetMatchedCommand() {\n    this.matchedCommand = undefined;\n    this.matchedCommandName = undefined;\n  }\n  /**\n   * Parse argv\n   */\n\n\n  parse(argv = processArgs, {\n    /** Whether to run the action for matched command */\n    run = true\n  } = {}): ParsedArgv {\n    this.rawArgs = argv;\n\n    if (!this.name) {\n      this.name = argv[1] ? getFileName(argv[1]) : 'cli';\n    }\n\n    let shouldParse = true; // Search sub-commands\n\n    for (const command of this.commands) {\n      const parsed = this.mri(argv.slice(2), command);\n      const commandName = parsed.args[0];\n\n      if (command.isMatched(commandName)) {\n        shouldParse = false;\n        const parsedInfo = { ...parsed,\n          args: parsed.args.slice(1)\n        };\n        this.setParsedInfo(parsedInfo, command, commandName);\n        this.emit(`command:${commandName}`, command);\n      }\n    }\n\n    if (shouldParse) {\n      // Search the default command\n      for (const command of this.commands) {\n        if (command.name === '') {\n          shouldParse = false;\n          const parsed = this.mri(argv.slice(2), command);\n          this.setParsedInfo(parsed, command);\n          this.emit(`command:!`, command);\n        }\n      }\n    }\n\n    if (shouldParse) {\n      const parsed = this.mri(argv.slice(2));\n      this.setParsedInfo(parsed);\n    }\n\n    if (this.options.help && this.showHelpOnExit) {\n      this.outputHelp();\n      run = false;\n      this.unsetMatchedCommand();\n    }\n\n    if (this.options.version && this.showVersionOnExit && this.matchedCommandName == null) {\n      this.outputVersion();\n      run = false;\n      this.unsetMatchedCommand();\n    }\n\n    const parsedArgv = {\n      args: this.args,\n      options: this.options\n    };\n\n    if (run) {\n      this.runMatchedCommand();\n    }\n\n    if (!this.matchedCommand && this.args[0]) {\n      this.emit('command:*');\n    }\n\n    return parsedArgv;\n  }\n\n  private mri(argv: string[],\n  /** Matched command */\n  command?: Command): ParsedArgv {\n    // All added options\n    const cliOptions = [...this.globalCommand.options, ...(command ? command.options : [])];\n    const mriOptions = getMriOptions(cliOptions); // Extract everything after `--` since mri doesn't support it\n\n    let argsAfterDoubleDashes: string[] = [];\n    const doubleDashesIndex = argv.indexOf('--');\n\n    if (doubleDashesIndex > -1) {\n      argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);\n      argv = argv.slice(0, doubleDashesIndex);\n    }\n\n    let parsed = mri(argv, mriOptions);\n    parsed = Object.keys(parsed).reduce((res, name) => {\n      return { ...res,\n        [camelcaseOptionName(name)]: parsed[name]\n      };\n    }, {\n      _: []\n    });\n    const args = parsed._;\n    const options: {\n      [k: string]: any;\n    } = {\n      '--': argsAfterDoubleDashes\n    }; // Set option default value\n\n    const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;\n    let transforms = Object.create(null);\n\n    for (const cliOption of cliOptions) {\n      if (!ignoreDefault && cliOption.config.default !== undefined) {\n        for (const name of cliOption.names) {\n          options[name] = cliOption.config.default;\n        }\n      } // If options type is defined\n\n\n      if (Array.isArray(cliOption.config.type)) {\n        if (transforms[cliOption.name] === undefined) {\n          transforms[cliOption.name] = Object.create(null);\n          transforms[cliOption.name]['shouldTransform'] = true;\n          transforms[cliOption.name]['transformFunction'] = cliOption.config.type[0];\n        }\n      }\n    } // Set option values (support dot-nested property name)\n\n\n    for (const key of Object.keys(parsed)) {\n      if (key !== '_') {\n        const keys = key.split('.');\n        setDotProp(options, keys, parsed[key]);\n        setByType(options, transforms);\n      }\n    }\n\n    return {\n      args,\n      options\n    };\n  }\n\n  runMatchedCommand() {\n    const {\n      args,\n      options,\n      matchedCommand: command\n    } = this;\n    if (!command || !command.commandAction) return;\n    command.checkUnknownOptions();\n    command.checkOptionValue();\n    command.checkRequiredArgs();\n    const actionArgs: any[] = [];\n    command.args.forEach((arg, index) => {\n      if (arg.variadic) {\n        actionArgs.push(args.slice(index));\n      } else {\n        actionArgs.push(args[index]);\n      }\n    });\n    actionArgs.push(options);\n    return command.commandAction.apply(this, actionArgs);\n  }\n\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts:CAC.usage",
    "file": "node_modules/cac/deno/CAC.ts",
    "symbol": "CAC.usage",
    "startLine": 59,
    "endLine": 62,
    "text": "  usage(text: string) {\n    this.globalCommand.usage(text);\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts:CAC.command",
    "file": "node_modules/cac/deno/CAC.ts",
    "symbol": "CAC.command",
    "startLine": 68,
    "endLine": 73,
    "text": "  command(rawName: string, description?: string, config?: CommandConfig) {\n    const command = new Command(rawName, description || '', config, this);\n    command.globalCommand = this.globalCommand;\n    this.commands.push(command);\n    return command;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts:CAC.option",
    "file": "node_modules/cac/deno/CAC.ts",
    "symbol": "CAC.option",
    "startLine": 81,
    "endLine": 84,
    "text": "  option(rawName: string, description: string, config?: OptionConfig) {\n    this.globalCommand.option(rawName, description, config);\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts:CAC.help",
    "file": "node_modules/cac/deno/CAC.ts",
    "symbol": "CAC.help",
    "startLine": 91,
    "endLine": 96,
    "text": "  help(callback?: HelpCallback) {\n    this.globalCommand.option('-h, --help', 'Display this message');\n    this.globalCommand.helpCallback = callback;\n    this.showHelpOnExit = true;\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts:CAC.version",
    "file": "node_modules/cac/deno/CAC.ts",
    "symbol": "CAC.version",
    "startLine": 103,
    "endLine": 107,
    "text": "  version(version: string, customFlags = '-v, --version') {\n    this.globalCommand.version(version, customFlags);\n    this.showVersionOnExit = true;\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts:CAC.example",
    "file": "node_modules/cac/deno/CAC.ts",
    "symbol": "CAC.example",
    "startLine": 115,
    "endLine": 118,
    "text": "  example(example: CommandExample) {\n    this.globalCommand.example(example);\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts:CAC.outputHelp",
    "file": "node_modules/cac/deno/CAC.ts",
    "symbol": "CAC.outputHelp",
    "startLine": 127,
    "endLine": 133,
    "text": "  outputHelp() {\n    if (this.matchedCommand) {\n      this.matchedCommand.outputHelp();\n    } else {\n      this.globalCommand.outputHelp();\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts:CAC.outputVersion",
    "file": "node_modules/cac/deno/CAC.ts",
    "symbol": "CAC.outputVersion",
    "startLine": 140,
    "endLine": 142,
    "text": "  outputVersion() {\n    this.globalCommand.outputVersion();\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts:CAC.setParsedInfo",
    "file": "node_modules/cac/deno/CAC.ts",
    "symbol": "CAC.setParsedInfo",
    "startLine": 144,
    "endLine": 160,
    "text": "  private setParsedInfo({\n    args,\n    options\n  }: ParsedArgv, matchedCommand?: Command, matchedCommandName?: string) {\n    this.args = args;\n    this.options = options;\n\n    if (matchedCommand) {\n      this.matchedCommand = matchedCommand;\n    }\n\n    if (matchedCommandName) {\n      this.matchedCommandName = matchedCommandName;\n    }\n\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts:CAC.unsetMatchedCommand",
    "file": "node_modules/cac/deno/CAC.ts",
    "symbol": "CAC.unsetMatchedCommand",
    "startLine": 162,
    "endLine": 165,
    "text": "  unsetMatchedCommand() {\n    this.matchedCommand = undefined;\n    this.matchedCommandName = undefined;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts:CAC.parse",
    "file": "node_modules/cac/deno/CAC.ts",
    "symbol": "CAC.parse",
    "startLine": 171,
    "endLine": 240,
    "text": "  parse(argv = processArgs, {\n    /** Whether to run the action for matched command */\n    run = true\n  } = {}): ParsedArgv {\n    this.rawArgs = argv;\n\n    if (!this.name) {\n      this.name = argv[1] ? getFileName(argv[1]) : 'cli';\n    }\n\n    let shouldParse = true; // Search sub-commands\n\n    for (const command of this.commands) {\n      const parsed = this.mri(argv.slice(2), command);\n      const commandName = parsed.args[0];\n\n      if (command.isMatched(commandName)) {\n        shouldParse = false;\n        const parsedInfo = { ...parsed,\n          args: parsed.args.slice(1)\n        };\n        this.setParsedInfo(parsedInfo, command, commandName);\n        this.emit(`command:${commandName}`, command);\n      }\n    }\n\n    if (shouldParse) {\n      // Search the default command\n      for (const command of this.commands) {\n        if (command.name === '') {\n          shouldParse = false;\n          const parsed = this.mri(argv.slice(2), command);\n          this.setParsedInfo(parsed, command);\n          this.emit(`command:!`, command);\n        }\n      }\n    }\n\n    if (shouldParse) {\n      const parsed = this.mri(argv.slice(2));\n      this.setParsedInfo(parsed);\n    }\n\n    if (this.options.help && this.showHelpOnExit) {\n      this.outputHelp();\n      run = false;\n      this.unsetMatchedCommand();\n    }\n\n    if (this.options.version && this.showVersionOnExit && this.matchedCommandName == null) {\n      this.outputVersion();\n      run = false;\n      this.unsetMatchedCommand();\n    }\n\n    const parsedArgv = {\n      args: this.args,\n      options: this.options\n    };\n\n    if (run) {\n      this.runMatchedCommand();\n    }\n\n    if (!this.matchedCommand && this.args[0]) {\n      this.emit('command:*');\n    }\n\n    return parsedArgv;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts:CAC.mri",
    "file": "node_modules/cac/deno/CAC.ts",
    "symbol": "CAC.mri",
    "startLine": 242,
    "endLine": 305,
    "text": "  private mri(argv: string[],\n  /** Matched command */\n  command?: Command): ParsedArgv {\n    // All added options\n    const cliOptions = [...this.globalCommand.options, ...(command ? command.options : [])];\n    const mriOptions = getMriOptions(cliOptions); // Extract everything after `--` since mri doesn't support it\n\n    let argsAfterDoubleDashes: string[] = [];\n    const doubleDashesIndex = argv.indexOf('--');\n\n    if (doubleDashesIndex > -1) {\n      argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);\n      argv = argv.slice(0, doubleDashesIndex);\n    }\n\n    let parsed = mri(argv, mriOptions);\n    parsed = Object.keys(parsed).reduce((res, name) => {\n      return { ...res,\n        [camelcaseOptionName(name)]: parsed[name]\n      };\n    }, {\n      _: []\n    });\n    const args = parsed._;\n    const options: {\n      [k: string]: any;\n    } = {\n      '--': argsAfterDoubleDashes\n    }; // Set option default value\n\n    const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;\n    let transforms = Object.create(null);\n\n    for (const cliOption of cliOptions) {\n      if (!ignoreDefault && cliOption.config.default !== undefined) {\n        for (const name of cliOption.names) {\n          options[name] = cliOption.config.default;\n        }\n      } // If options type is defined\n\n\n      if (Array.isArray(cliOption.config.type)) {\n        if (transforms[cliOption.name] === undefined) {\n          transforms[cliOption.name] = Object.create(null);\n          transforms[cliOption.name]['shouldTransform'] = true;\n          transforms[cliOption.name]['transformFunction'] = cliOption.config.type[0];\n        }\n      }\n    } // Set option values (support dot-nested property name)\n\n\n    for (const key of Object.keys(parsed)) {\n      if (key !== '_') {\n        const keys = key.split('.');\n        setDotProp(options, keys, parsed[key]);\n        setByType(options, transforms);\n      }\n    }\n\n    return {\n      args,\n      options\n    };\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts:CAC.runMatchedCommand",
    "file": "node_modules/cac/deno/CAC.ts",
    "symbol": "CAC.runMatchedCommand",
    "startLine": 307,
    "endLine": 327,
    "text": "  runMatchedCommand() {\n    const {\n      args,\n      options,\n      matchedCommand: command\n    } = this;\n    if (!command || !command.commandAction) return;\n    command.checkUnknownOptions();\n    command.checkOptionValue();\n    command.checkRequiredArgs();\n    const actionArgs: any[] = [];\n    command.args.forEach((arg, index) => {\n      if (arg.variadic) {\n        actionArgs.push(args.slice(index));\n      } else {\n        actionArgs.push(args[index]);\n      }\n    });\n    actionArgs.push(options);\n    return command.commandAction.apply(this, actionArgs);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command",
    "startLine": 21,
    "endLine": 258,
    "text": "class Command {\n  options: Option[];\n  aliasNames: string[];\n  /* Parsed command name */\n\n  name: string;\n  args: CommandArg[];\n  commandAction?: (...args: any[]) => any;\n  usageText?: string;\n  versionNumber?: string;\n  examples: CommandExample[];\n  helpCallback?: HelpCallback;\n  globalCommand?: GlobalCommand;\n\n  constructor(public rawName: string, public description: string, public config: CommandConfig = {}, public cli: CAC) {\n    this.options = [];\n    this.aliasNames = [];\n    this.name = removeBrackets(rawName);\n    this.args = findAllBrackets(rawName);\n    this.examples = [];\n  }\n\n  usage(text: string) {\n    this.usageText = text;\n    return this;\n  }\n\n  allowUnknownOptions() {\n    this.config.allowUnknownOptions = true;\n    return this;\n  }\n\n  ignoreOptionDefaultValue() {\n    this.config.ignoreOptionDefaultValue = true;\n    return this;\n  }\n\n  version(version: string, customFlags = '-v, --version') {\n    this.versionNumber = version;\n    this.option(customFlags, 'Display version number');\n    return this;\n  }\n\n  example(example: CommandExample) {\n    this.examples.push(example);\n    return this;\n  }\n  /**\n   * Add a option for this command\n   * @param rawName Raw option name(s)\n   * @param description Option description\n   * @param config Option config\n   */\n\n\n  option(rawName: string, description: string, config?: OptionConfig) {\n    const option = new Option(rawName, description, config);\n    this.options.push(option);\n    return this;\n  }\n\n  alias(name: string) {\n    this.aliasNames.push(name);\n    return this;\n  }\n\n  action(callback: (...args: any[]) => any) {\n    this.commandAction = callback;\n    return this;\n  }\n  /**\n   * Check if a command name is matched by this command\n   * @param name Command name\n   */\n\n\n  isMatched(name: string) {\n    return this.name === name || this.aliasNames.includes(name);\n  }\n\n  get isDefaultCommand() {\n    return this.name === '' || this.aliasNames.includes('!');\n  }\n\n  get isGlobalCommand(): boolean {\n    return this instanceof GlobalCommand;\n  }\n  /**\n   * Check if an option is registered in this command\n   * @param name Option name\n   */\n\n\n  hasOption(name: string) {\n    name = name.split('.')[0];\n    return this.options.find(option => {\n      return option.names.includes(name);\n    });\n  }\n\n  outputHelp() {\n    const {\n      name,\n      commands\n    } = this.cli;\n    const {\n      versionNumber,\n      options: globalOptions,\n      helpCallback\n    } = this.cli.globalCommand;\n    let sections: HelpSection[] = [{\n      body: `${name}${versionNumber ? `/${versionNumber}` : ''}`\n    }];\n    sections.push({\n      title: 'Usage',\n      body: `  $ ${name} ${this.usageText || this.rawName}`\n    });\n    const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;\n\n    if (showCommands) {\n      const longestCommandName = findLongest(commands.map(command => command.rawName));\n      sections.push({\n        title: 'Commands',\n        body: commands.map(command => {\n          return `  ${padRight(command.rawName, longestCommandName.length)}  ${command.description}`;\n        }).join('\\n')\n      });\n      sections.push({\n        title: `For more info, run any command with the \\`--help\\` flag`,\n        body: commands.map(command => `  $ ${name}${command.name === '' ? '' : ` ${command.name}`} --help`).join('\\n')\n      });\n    }\n\n    let options = this.isGlobalCommand ? globalOptions : [...this.options, ...(globalOptions || [])];\n\n    if (!this.isGlobalCommand && !this.isDefaultCommand) {\n      options = options.filter(option => option.name !== 'version');\n    }\n\n    if (options.length > 0) {\n      const longestOptionName = findLongest(options.map(option => option.rawName));\n      sections.push({\n        title: 'Options',\n        body: options.map(option => {\n          return `  ${padRight(option.rawName, longestOptionName.length)}  ${option.description} ${option.config.default === undefined ? '' : `(default: ${option.config.default})`}`;\n        }).join('\\n')\n      });\n    }\n\n    if (this.examples.length > 0) {\n      sections.push({\n        title: 'Examples',\n        body: this.examples.map(example => {\n          if (typeof example === 'function') {\n            return example(name);\n          }\n\n          return example;\n        }).join('\\n')\n      });\n    }\n\n    if (helpCallback) {\n      sections = helpCallback(sections) || sections;\n    }\n\n    console.log(sections.map(section => {\n      return section.title ? `${section.title}:\\n${section.body}` : section.body;\n    }).join('\\n\\n'));\n  }\n\n  outputVersion() {\n    const {\n      name\n    } = this.cli;\n    const {\n      versionNumber\n    } = this.cli.globalCommand;\n\n    if (versionNumber) {\n      console.log(`${name}/${versionNumber} ${platformInfo}`);\n    }\n  }\n\n  checkRequiredArgs() {\n    const minimalArgsCount = this.args.filter(arg => arg.required).length;\n\n    if (this.cli.args.length < minimalArgsCount) {\n      throw new CACError(`missing required args for command \\`${this.rawName}\\``);\n    }\n  }\n  /**\n   * Check if the parsed options contain any unknown options\n   *\n   * Exit and output error when true\n   */\n\n\n  checkUnknownOptions() {\n    const {\n      options,\n      globalCommand\n    } = this.cli;\n\n    if (!this.config.allowUnknownOptions) {\n      for (const name of Object.keys(options)) {\n        if (name !== '--' && !this.hasOption(name) && !globalCommand.hasOption(name)) {\n          throw new CACError(`Unknown option \\`${name.length > 1 ? `--${name}` : `-${name}`}\\``);\n        }\n      }\n    }\n  }\n  /**\n   * Check if the required string-type options exist\n   */\n\n\n  checkOptionValue() {\n    const {\n      options: parsedOptions,\n      globalCommand\n    } = this.cli;\n    const options = [...globalCommand.options, ...this.options];\n\n    for (const option of options) {\n      const value = parsedOptions[option.name.split('.')[0]]; // Check required option value\n\n      if (option.required) {\n        const hasNegated = options.some(o => o.negated && o.names.includes(option.name));\n\n        if (value === true || value === false && !hasNegated) {\n          throw new CACError(`option \\`${option.rawName}\\` value is missing`);\n        }\n      }\n    }\n  }\n\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.usage",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.usage",
    "startLine": 43,
    "endLine": 46,
    "text": "  usage(text: string) {\n    this.usageText = text;\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.allowUnknownOptions",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.allowUnknownOptions",
    "startLine": 48,
    "endLine": 51,
    "text": "  allowUnknownOptions() {\n    this.config.allowUnknownOptions = true;\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.ignoreOptionDefaultValue",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.ignoreOptionDefaultValue",
    "startLine": 53,
    "endLine": 56,
    "text": "  ignoreOptionDefaultValue() {\n    this.config.ignoreOptionDefaultValue = true;\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.version",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.version",
    "startLine": 58,
    "endLine": 62,
    "text": "  version(version: string, customFlags = '-v, --version') {\n    this.versionNumber = version;\n    this.option(customFlags, 'Display version number');\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.example",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.example",
    "startLine": 64,
    "endLine": 67,
    "text": "  example(example: CommandExample) {\n    this.examples.push(example);\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.option",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.option",
    "startLine": 76,
    "endLine": 80,
    "text": "  option(rawName: string, description: string, config?: OptionConfig) {\n    const option = new Option(rawName, description, config);\n    this.options.push(option);\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.alias",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.alias",
    "startLine": 82,
    "endLine": 85,
    "text": "  alias(name: string) {\n    this.aliasNames.push(name);\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.action",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.action",
    "startLine": 87,
    "endLine": 90,
    "text": "  action(callback: (...args: any[]) => any) {\n    this.commandAction = callback;\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.isMatched",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.isMatched",
    "startLine": 97,
    "endLine": 99,
    "text": "  isMatched(name: string) {\n    return this.name === name || this.aliasNames.includes(name);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.hasOption",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.hasOption",
    "startLine": 114,
    "endLine": 119,
    "text": "  hasOption(name: string) {\n    name = name.split('.')[0];\n    return this.options.find(option => {\n      return option.names.includes(name);\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.outputHelp",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.outputHelp",
    "startLine": 121,
    "endLine": 190,
    "text": "  outputHelp() {\n    const {\n      name,\n      commands\n    } = this.cli;\n    const {\n      versionNumber,\n      options: globalOptions,\n      helpCallback\n    } = this.cli.globalCommand;\n    let sections: HelpSection[] = [{\n      body: `${name}${versionNumber ? `/${versionNumber}` : ''}`\n    }];\n    sections.push({\n      title: 'Usage',\n      body: `  $ ${name} ${this.usageText || this.rawName}`\n    });\n    const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;\n\n    if (showCommands) {\n      const longestCommandName = findLongest(commands.map(command => command.rawName));\n      sections.push({\n        title: 'Commands',\n        body: commands.map(command => {\n          return `  ${padRight(command.rawName, longestCommandName.length)}  ${command.description}`;\n        }).join('\\n')\n      });\n      sections.push({\n        title: `For more info, run any command with the \\`--help\\` flag`,\n        body: commands.map(command => `  $ ${name}${command.name === '' ? '' : ` ${command.name}`} --help`).join('\\n')\n      });\n    }\n\n    let options = this.isGlobalCommand ? globalOptions : [...this.options, ...(globalOptions || [])];\n\n    if (!this.isGlobalCommand && !this.isDefaultCommand) {\n      options = options.filter(option => option.name !== 'version');\n    }\n\n    if (options.length > 0) {\n      const longestOptionName = findLongest(options.map(option => option.rawName));\n      sections.push({\n        title: 'Options',\n        body: options.map(option => {\n          return `  ${padRight(option.rawName, longestOptionName.length)}  ${option.description} ${option.config.default === undefined ? '' : `(default: ${option.config.default})`}`;\n        }).join('\\n')\n      });\n    }\n\n    if (this.examples.length > 0) {\n      sections.push({\n        title: 'Examples',\n        body: this.examples.map(example => {\n          if (typeof example === 'function') {\n            return example(name);\n          }\n\n          return example;\n        }).join('\\n')\n      });\n    }\n\n    if (helpCallback) {\n      sections = helpCallback(sections) || sections;\n    }\n\n    console.log(sections.map(section => {\n      return section.title ? `${section.title}:\\n${section.body}` : section.body;\n    }).join('\\n\\n'));\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.outputVersion",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.outputVersion",
    "startLine": 192,
    "endLine": 203,
    "text": "  outputVersion() {\n    const {\n      name\n    } = this.cli;\n    const {\n      versionNumber\n    } = this.cli.globalCommand;\n\n    if (versionNumber) {\n      console.log(`${name}/${versionNumber} ${platformInfo}`);\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.checkRequiredArgs",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.checkRequiredArgs",
    "startLine": 205,
    "endLine": 211,
    "text": "  checkRequiredArgs() {\n    const minimalArgsCount = this.args.filter(arg => arg.required).length;\n\n    if (this.cli.args.length < minimalArgsCount) {\n      throw new CACError(`missing required args for command \\`${this.rawName}\\``);\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.checkUnknownOptions",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.checkUnknownOptions",
    "startLine": 219,
    "endLine": 232,
    "text": "  checkUnknownOptions() {\n    const {\n      options,\n      globalCommand\n    } = this.cli;\n\n    if (!this.config.allowUnknownOptions) {\n      for (const name of Object.keys(options)) {\n        if (name !== '--' && !this.hasOption(name) && !globalCommand.hasOption(name)) {\n          throw new CACError(`Unknown option \\`${name.length > 1 ? `--${name}` : `-${name}`}\\``);\n        }\n      }\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:Command.checkOptionValue",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "Command.checkOptionValue",
    "startLine": 238,
    "endLine": 256,
    "text": "  checkOptionValue() {\n    const {\n      options: parsedOptions,\n      globalCommand\n    } = this.cli;\n    const options = [...globalCommand.options, ...this.options];\n\n    for (const option of options) {\n      const value = parsedOptions[option.name.split('.')[0]]; // Check required option value\n\n      if (option.required) {\n        const hasNegated = options.some(o => o.negated && o.names.includes(option.name));\n\n        if (value === true || value === false && !hasNegated) {\n          throw new CACError(`option \\`${option.rawName}\\` value is missing`);\n        }\n      }\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts:GlobalCommand",
    "file": "node_modules/cac/deno/Command.ts",
    "symbol": "GlobalCommand",
    "startLine": 260,
    "endLine": 265,
    "text": "class GlobalCommand extends Command {\n  constructor(cli: CAC) {\n    super('@@global@@', '', {}, cli);\n  }\n\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Option.ts:Option",
    "file": "node_modules/cac/deno/Option.ts",
    "symbol": "Option",
    "startLine": 6,
    "endLine": 51,
    "text": "export default class Option {\n  /** Option name */\n  name: string;\n  /** Option name and aliases */\n\n  names: string[];\n  isBoolean?: boolean; // `required` will be a boolean for options with brackets\n\n  required?: boolean;\n  config: OptionConfig;\n  negated: boolean;\n\n  constructor(public rawName: string, public description: string, config?: OptionConfig) {\n    this.config = Object.assign({}, config); // You may use cli.option('--env.* [value]', 'desc') to denote a dot-nested option\n\n    rawName = rawName.replace(/\\.\\*/g, '');\n    this.negated = false;\n    this.names = removeBrackets(rawName).split(',').map((v: string) => {\n      let name = v.trim().replace(/^-{1,2}/, '');\n\n      if (name.startsWith('no-')) {\n        this.negated = true;\n        name = name.replace(/^no-/, '');\n      }\n\n      return camelcaseOptionName(name);\n    }).sort((a, b) => a.length > b.length ? 1 : -1); // Sort names\n    // Use the longest name (last one) as actual option name\n\n    this.name = this.names[this.names.length - 1];\n\n    if (this.negated && this.config.default == null) {\n      this.config.default = true;\n    }\n\n    if (rawName.includes('<')) {\n      this.required = true;\n    } else if (rawName.includes('[')) {\n      this.required = false;\n    } else {\n      // No arg needed, it's boolean flag\n      this.isBoolean = true;\n    }\n  }\n\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/utils.ts:CACError",
    "file": "node_modules/cac/deno/utils.ts",
    "symbol": "CACError",
    "startLine": 133,
    "endLine": 145,
    "text": "export class CACError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = this.constructor.name;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error(message).stack;\n    }\n  }\n\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/fastq/test/example.ts:worker",
    "file": "node_modules/fastq/test/example.ts",
    "symbol": "worker",
    "startLine": 46,
    "endLine": 48,
    "text": "function worker(task: any, cb: fastq.done) {\n  cb(null, 'hello ' + task)\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/fastq/test/example.ts:genericsWorker",
    "file": "node_modules/fastq/test/example.ts",
    "symbol": "genericsWorker",
    "startLine": 68,
    "endLine": 70,
    "text": "function genericsWorker(this: GenericsContext, task: number, cb: fastq.done<string>) {\n  cb(null, 'the meaning of life is ' + (this.base * task))\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/fastq/test/example.ts:asyncWorker",
    "file": "node_modules/fastq/test/example.ts",
    "symbol": "asyncWorker",
    "startLine": 74,
    "endLine": 76,
    "text": "async function asyncWorker(task: any) {\n  return 'hello ' + task\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/fastq/test/example.ts:run",
    "file": "node_modules/fastq/test/example.ts",
    "symbol": "run",
    "startLine": 78,
    "endLine": 81,
    "text": "async function run () {\n  await queue.push(42)\n  await queue.unshift(42)\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/abort.ts:AbortError",
    "file": "node_modules/piscina/src/abort.ts",
    "symbol": "AbortError",
    "startLine": 23,
    "endLine": 33,
    "text": "export class AbortError extends Error {\n  constructor (reason?: AbortSignalEventTarget['reason']) {\n    // TS does not recognizes the cause clause\n    // @ts-expect-error\n    super('The task has been aborted', { cause: reason });\n  }\n\n  get name () {\n    return 'AbortError';\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/abort.ts:onabort",
    "file": "node_modules/piscina/src/abort.ts",
    "symbol": "onabort",
    "startLine": 35,
    "endLine": 41,
    "text": "export function onabort (abortSignal: AbortSignalAny, listener: () => void) {\n  if ('addEventListener' in abortSignal) {\n    abortSignal.addEventListener('abort', listener, { once: true });\n  } else {\n    abortSignal.once('abort', listener);\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/common.ts:isTransferable",
    "file": "node_modules/piscina/src/common.ts",
    "symbol": "isTransferable",
    "startLine": 18,
    "endLine": 25,
    "text": "export function isTransferable (value: unknown): boolean {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    kTransferable in value &&\n    kValue in value\n  );\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/common.ts:isMovable",
    "file": "node_modules/piscina/src/common.ts",
    "symbol": "isMovable",
    "startLine": 36,
    "endLine": 38,
    "text": "export function isMovable (value: any): boolean {\n  return isTransferable(value) && value[kMovable] === true;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/common.ts:markMovable",
    "file": "node_modules/piscina/src/common.ts",
    "symbol": "markMovable",
    "startLine": 40,
    "endLine": 47,
    "text": "export function markMovable (value: {}): void {\n  Object.defineProperty(value, kMovable, {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: true\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/common.ts:createHistogramSummary",
    "file": "node_modules/piscina/src/common.ts",
    "symbol": "createHistogramSummary",
    "startLine": 55,
    "endLine": 80,
    "text": "export function createHistogramSummary (histogram: Histogram): HistogramSummary {\n  const { mean, stddev, min, max } = histogram;\n\n  return {\n    average: mean / 1000,\n    mean: mean / 1000,\n    stddev,\n    min: min / 1000,\n    max: max / 1000,\n    p0_001: histogram.percentile(0.001) / 1000,\n    p0_01: histogram.percentile(0.01) / 1000,\n    p0_1: histogram.percentile(0.1) / 1000,\n    p1: histogram.percentile(1) / 1000,\n    p2_5: histogram.percentile(2.5) / 1000,\n    p10: histogram.percentile(10) / 1000,\n    p25: histogram.percentile(25) / 1000,\n    p50: histogram.percentile(50) / 1000,\n    p75: histogram.percentile(75) / 1000,\n    p90: histogram.percentile(90) / 1000,\n    p97_5: histogram.percentile(97.5) / 1000,\n    p99: histogram.percentile(99) / 1000,\n    p99_9: histogram.percentile(99.9) / 1000,\n    p99_99: histogram.percentile(99.99) / 1000,\n    p99_999: histogram.percentile(99.999) / 1000\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/common.ts:toHistogramIntegerNano",
    "file": "node_modules/piscina/src/common.ts",
    "symbol": "toHistogramIntegerNano",
    "startLine": 82,
    "endLine": 84,
    "text": "export function toHistogramIntegerNano (milliseconds: number): number {\n  return Math.max(1, Math.trunc(milliseconds * 1000));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/common.ts:maybeFileURLToPath",
    "file": "node_modules/piscina/src/common.ts",
    "symbol": "maybeFileURLToPath",
    "startLine": 86,
    "endLine": 90,
    "text": "export function maybeFileURLToPath (filename : string) : string {\n  return filename.startsWith('file:')\n    ? fileURLToPath(new URL(filename))\n    : filename;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/common.ts:getAvailableParallelism",
    "file": "node_modules/piscina/src/common.ts",
    "symbol": "getAvailableParallelism",
    "startLine": 93,
    "endLine": 103,
    "text": "export function getAvailableParallelism () : number {\n  if (typeof availableParallelism === 'function') {\n    return availableParallelism();\n  }\n\n  try {\n    return cpus().length;\n  } catch {\n    return 1;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:DirectlyTransferable",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "DirectlyTransferable",
    "startLine": 136,
    "endLine": 145,
    "text": "class DirectlyTransferable implements Transferable {\n  #value : object;\n  constructor (value : object) {\n    this.#value = value;\n  }\n\n  get [kTransferable] () : object { return this.#value; }\n\n  get [kValue] () : object { return this.#value; }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:ArrayBufferViewTransferable",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "ArrayBufferViewTransferable",
    "startLine": 147,
    "endLine": 156,
    "text": "class ArrayBufferViewTransferable implements Transferable {\n  #view : ArrayBufferView;\n  constructor (view : ArrayBufferView) {\n    this.#view = view;\n  }\n\n  get [kTransferable] () : object { return this.#view.buffer; }\n\n  get [kValue] () : object { return this.#view; }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:ThreadPool",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "ThreadPool",
    "startLine": 158,
    "endLine": 662,
    "text": "class ThreadPool {\n  publicInterface : Piscina;\n  workers : AsynchronouslyCreatedResourcePool<WorkerInfo>;\n  options : FilledOptions;\n  taskQueue : TaskQueue;\n  skipQueue : TaskInfo[] = [];\n  completed : number = 0;\n  runTime? : RecordableHistogram;\n  waitTime? : RecordableHistogram;\n  needsDrain : boolean;\n  start : number = performance.now();\n  inProcessPendingMessages : boolean = false;\n  startingUp : boolean = false;\n  closingUp : boolean = false;\n  workerFailsDuringBootstrap : boolean = false;\n  destroying : boolean = false;\n\n  constructor (publicInterface : Piscina, options : Options) {\n    this.publicInterface = publicInterface;\n    this.taskQueue = options.taskQueue || new ArrayTaskQueue();\n\n    const filename =\n      options.filename ? maybeFileURLToPath(options.filename) : null;\n    this.options = { ...kDefaultOptions, ...options, filename, maxQueue: 0 };\n\n    if (this.options.recordTiming) {\n      this.runTime = createHistogram();\n      this.waitTime = createHistogram();\n    }\n\n    // The >= and <= could be > and < but this way we get 100 % coverage \n    if (options.maxThreads !== undefined &&\n        this.options.minThreads >= options.maxThreads) {\n      this.options.minThreads = options.maxThreads;\n    }\n    if (options.minThreads !== undefined &&\n        this.options.maxThreads <= options.minThreads) {\n      this.options.maxThreads = options.minThreads;\n    }\n    if (options.maxQueue === 'auto') {\n      this.options.maxQueue = this.options.maxThreads ** 2;\n    } else {\n      this.options.maxQueue = options.maxQueue ?? kDefaultOptions.maxQueue;\n    }\n\n    this.workers = new AsynchronouslyCreatedResourcePool<WorkerInfo>(\n      this.options.concurrentTasksPerWorker);\n    this.workers.onAvailable((w : WorkerInfo) => this._onWorkerAvailable(w));\n\n    this.startingUp = true;\n    this._ensureMinimumWorkers();\n    this.startingUp = false;\n    this.needsDrain = false;\n  }\n\n  _ensureMinimumWorkers () : void {\n    if (this.closingUp || this.destroying) {\n      return;\n    }\n    while (this.workers.size < this.options.minThreads) {\n      this._addNewWorker();\n    }\n  }\n\n  _addNewWorker () : void {\n    const pool = this;\n    const worker = new Worker(resolve(__dirname, 'worker.js'), {\n      env: this.options.env,\n      argv: this.options.argv,\n      execArgv: this.options.execArgv,\n      resourceLimits: this.options.resourceLimits,\n      workerData: this.options.workerData,\n      trackUnmanagedFds: this.options.trackUnmanagedFds\n    });\n\n    const { port1, port2 } = new MessageChannel();\n    const workerInfo = new WorkerInfo(worker, port1, onMessage);\n    if (this.startingUp) {\n      // There is no point in waiting for the initial set of Workers to indicate\n      // that they are ready, we just mark them as such from the start.\n      workerInfo.markAsReady();\n    }\n\n    const message : StartupMessage = {\n      filename: this.options.filename,\n      name: this.options.name,\n      port: port2,\n      sharedBuffer: workerInfo.sharedBuffer,\n      useAtomics: this.options.useAtomics,\n      niceIncrement: this.options.niceIncrement\n    };\n    worker.postMessage(message, [port2]);\n\n    function onMessage (message : ResponseMessage) {\n      const { taskId, result } = message;\n      // In case of success: Call the callback that was passed to `runTask`,\n      // remove the `TaskInfo` associated with the Worker, which marks it as\n      // free again.\n      const taskInfo = workerInfo.taskInfos.get(taskId);\n      workerInfo.taskInfos.delete(taskId);\n\n      pool.workers.maybeAvailable(workerInfo);\n\n      /* istanbul ignore if */\n      if (taskInfo === undefined) {\n        const err = new Error(\n          `Unexpected message from Worker: ${inspect(message)}`);\n        pool.publicInterface.emit('error', err);\n      } else {\n        taskInfo.done(message.error, result);\n      }\n\n      pool._processPendingMessages();\n    }\n\n    function onReady () {\n      if (workerInfo.currentUsage() === 0) {\n        workerInfo.unref();\n      }\n\n      if (!workerInfo.isReady()) {\n        workerInfo.markAsReady();\n      }\n    }\n\n    function onEventMessage (message: any) {\n      pool.publicInterface.emit('message', message);\n    }\n\n    worker.on('message', (message : any) => {\n      message instanceof Object && READY in message ? onReady() : onEventMessage(message);\n    });\n\n    worker.on('error', (err : Error) => {\n      this._onError(worker, workerInfo, err, false);\n    });\n\n    worker.on('exit', (exitCode : number) => {\n      if (this.destroying) {\n        return;\n      }\n\n      const err = new Error(`worker exited with code: ${exitCode}`);\n      // Only error unfinished tasks on process exit, since there are legitimate\n      // reasons to exit workers and we want to handle that gracefully when possible.\n      this._onError(worker, workerInfo, err, true);\n    });\n\n    worker.unref();\n    port1.on('close', () => {\n      // The port is only closed if the Worker stops for some reason, but we\n      // always .unref() the Worker itself. We want to receive e.g. 'error'\n      // events on it, so we ref it once we know it's going to exit anyway.\n      worker.ref();\n    });\n\n    this.workers.add(workerInfo);\n  }\n\n  _onError (worker: Worker, workerInfo: WorkerInfo, err: Error, onlyErrorUnfinishedTasks: boolean) {\n    // Work around the bug in https://github.com/nodejs/node/pull/33394\n    worker.ref = () => {};\n\n    const taskInfos = [...workerInfo.taskInfos.values()];\n    workerInfo.taskInfos.clear();\n\n    // Remove the worker from the list and potentially start a new Worker to\n    // replace the current one.\n    this._removeWorker(workerInfo);\n\n    if (workerInfo.isReady() && !this.workerFailsDuringBootstrap) {\n      this._ensureMinimumWorkers();\n    } else {\n      // Do not start new workers over and over if they already fail during\n      // bootstrap, there's no point.\n      this.workerFailsDuringBootstrap = true;\n    }\n\n    if (taskInfos.length > 0) {\n      // If there are remaining unfinished tasks, call the callback that was\n      // passed to `postTask` with the error\n      for (const taskInfo of taskInfos) {\n        taskInfo.done(err, null);\n      }\n    } else if (!onlyErrorUnfinishedTasks) {\n      // If there are no unfinished tasks, instead emit an 'error' event\n      this.publicInterface.emit('error', err);\n    }\n  }\n\n  _processPendingMessages () {\n    if (this.inProcessPendingMessages || !this.options.useAtomics) {\n      return;\n    }\n\n    this.inProcessPendingMessages = true;\n    try {\n      for (const workerInfo of this.workers) {\n        workerInfo.processPendingMessages();\n      }\n    } finally {\n      this.inProcessPendingMessages = false;\n    }\n  }\n\n  _removeWorker (workerInfo : WorkerInfo) : void {\n    workerInfo.destroy();\n\n    this.workers.delete(workerInfo);\n  }\n\n  _onWorkerAvailable (workerInfo : WorkerInfo) : void {\n    while ((this.taskQueue.size > 0 || this.skipQueue.length > 0) &&\n      workerInfo.currentUsage() < this.options.concurrentTasksPerWorker) {\n      // The skipQueue will have tasks that we previously shifted off\n      // the task queue but had to skip over... we have to make sure\n      // we drain that before we drain the taskQueue.\n      const taskInfo = this.skipQueue.shift() ||\n                       this.taskQueue.shift() as TaskInfo;\n      // If the task has an abortSignal and the worker has any other\n      // tasks, we cannot distribute the task to it. Skip for now.\n      if (taskInfo.abortSignal && workerInfo.taskInfos.size > 0) {\n        this.skipQueue.push(taskInfo);\n        break;\n      }\n      const now = performance.now();\n      this.waitTime?.record(toHistogramIntegerNano(now - taskInfo.created));\n      taskInfo.started = now;\n      workerInfo.postTask(taskInfo);\n      this._maybeDrain();\n      return;\n    }\n\n    // If Infinity was sent as a parameter, we skip setting the Timeout that clears the worker\n    if (this.options.idleTimeout === Infinity) {\n      return;\n    }\n\n    if (workerInfo.taskInfos.size === 0 &&\n        this.workers.size > this.options.minThreads) {\n      workerInfo.idleTimeout = setTimeout(() => {\n        assert.strictEqual(workerInfo.taskInfos.size, 0);\n        if (this.workers.size > this.options.minThreads) {\n          this._removeWorker(workerInfo);\n        }\n      }, this.options.idleTimeout).unref();\n    }\n  }\n\n  runTask (\n    task : any,\n    options : RunOptions) : Promise<any> {\n    let {\n      filename,\n      name\n    } = options;\n    const {\n      transferList = []\n    } = options;\n    if (filename == null) {\n      filename = this.options.filename;\n    }\n    if (name == null) {\n      name = this.options.name;\n    }\n    if (typeof filename !== 'string') {\n      return Promise.reject(Errors.FilenameNotProvided());\n    }\n    filename = maybeFileURLToPath(filename);\n\n    let signal: AbortSignalAny | null;\n    if (this.closingUp) {\n      const closingUpAbortController = new AbortController();\n      closingUpAbortController.abort('queue is closing up');\n\n      signal = closingUpAbortController.signal;\n    } else {\n      signal = options.signal ?? null;\n    }\n\n    let resolve : (result : any) => void;\n    let reject : (err : Error) => void;\n    // eslint-disable-next-line\n    const ret = new Promise((res, rej) => { resolve = res; reject = rej; });\n    const taskInfo = new TaskInfo(\n      task,\n      transferList,\n      filename,\n      name,\n      (err : Error | null, result : any) => {\n        this.completed++;\n        if (taskInfo.started) {\n          this.runTime?.record(toHistogramIntegerNano(performance.now() - taskInfo.started));\n        }\n        if (err !== null) {\n          reject(err);\n        } else {\n          resolve(result);\n        }\n\n        this._maybeDrain();\n      },\n      signal,\n      this.publicInterface.asyncResource.asyncId());\n\n    if (signal !== null) {\n      // If the AbortSignal has an aborted property and it's truthy,\n      // reject immediately.\n      if ((signal as AbortSignalEventTarget).aborted) {\n        return Promise.reject(new AbortError((signal as AbortSignalEventTarget).reason));\n      }\n      taskInfo.abortListener = () => {\n        // Call reject() first to make sure we always reject with the AbortError\n        // if the task is aborted, not with an Error from the possible\n        // thread termination below.\n        reject(new AbortError((signal as AbortSignalEventTarget).reason));\n\n        if (taskInfo.workerInfo !== null) {\n          // Already running: We cancel the Worker this is running on.\n          this._removeWorker(taskInfo.workerInfo);\n          this._ensureMinimumWorkers();\n        } else {\n          // Not yet running: Remove it from the queue.\n          this.taskQueue.remove(taskInfo);\n        }\n      };\n      onabort(signal, taskInfo.abortListener);\n    }\n\n    // If there is a task queue, there's no point in looking for an available\n    // Worker thread. Add this task to the queue, if possible.\n    if (this.taskQueue.size > 0) {\n      const totalCapacity = this.options.maxQueue + this.pendingCapacity();\n      if (this.taskQueue.size >= totalCapacity) {\n        if (this.options.maxQueue === 0) {\n          return Promise.reject(Errors.NoTaskQueueAvailable());\n        } else {\n          return Promise.reject(Errors.TaskQueueAtLimit());\n        }\n      } else {\n        if (this.workers.size < this.options.maxThreads) {\n          this._addNewWorker();\n        }\n        this.taskQueue.push(taskInfo);\n      }\n\n      this._maybeDrain();\n      return ret;\n    }\n\n    // Look for a Worker with a minimum number of tasks it is currently running.\n    let workerInfo : WorkerInfo | null = this.workers.findAvailable();\n\n    // If we want the ability to abort this task, use only workers that have\n    // no running tasks.\n    if (workerInfo !== null && workerInfo.currentUsage() > 0 && signal) {\n      workerInfo = null;\n    }\n\n    // If no Worker was found, or that Worker was handling another task in some\n    // way, and we still have the ability to spawn new threads, do so.\n    let waitingForNewWorker = false;\n    if ((workerInfo === null || workerInfo.currentUsage() > 0) &&\n        this.workers.size < this.options.maxThreads) {\n      this._addNewWorker();\n      waitingForNewWorker = true;\n    }\n\n    // If no Worker is found, try to put the task into the queue.\n    if (workerInfo === null) {\n      if (this.options.maxQueue <= 0 && !waitingForNewWorker) {\n        return Promise.reject(Errors.NoTaskQueueAvailable());\n      } else {\n        this.taskQueue.push(taskInfo);\n      }\n\n      this._maybeDrain();\n      return ret;\n    }\n\n    // TODO(addaleax): Clean up the waitTime/runTime recording.\n    const now = performance.now();\n    this.waitTime?.record(toHistogramIntegerNano(now - taskInfo.created));\n    taskInfo.started = now;\n    workerInfo.postTask(taskInfo);\n    this._maybeDrain();\n    return ret;\n  }\n\n  pendingCapacity () : number {\n    return this.workers.pendingItems.size *\n      this.options.concurrentTasksPerWorker;\n  }\n\n  _maybeDrain () {\n    const totalCapacity = this.options.maxQueue + this.pendingCapacity();\n    const totalQueueSize = this.taskQueue.size + this.skipQueue.length;\n\n    if (totalQueueSize === 0) {\n      this.needsDrain = false;\n      this.publicInterface.emit('drain');\n    }\n\n    if (totalQueueSize >= totalCapacity) {\n      this.needsDrain = true;\n      this.publicInterface.emit('needsDrain');\n    }\n  }\n\n  async destroy () {\n    this.destroying = true;\n    while (this.skipQueue.length > 0) {\n      const taskInfo : TaskInfo = this.skipQueue.shift() as TaskInfo;\n      taskInfo.done(new Error('Terminating worker thread'));\n    }\n    while (this.taskQueue.size > 0) {\n      const taskInfo : TaskInfo = this.taskQueue.shift() as TaskInfo;\n      taskInfo.done(new Error('Terminating worker thread'));\n    }\n\n    const exitEvents : Promise<any[]>[] = [];\n    while (this.workers.size > 0) {\n      const [workerInfo] = this.workers;\n      exitEvents.push(once(workerInfo.worker, 'exit'));\n      this._removeWorker(workerInfo);\n    }\n\n    try {\n      await Promise.all(exitEvents);\n    } finally {\n      this.destroying = false;\n    }\n  }\n\n  async close (options : Required<CloseOptions>) {\n    this.closingUp = true;\n\n    if (options.force) {\n      const skipQueueLength = this.skipQueue.length;\n      for (let i = 0; i < skipQueueLength; i++) {\n        const taskInfo : TaskInfo = this.skipQueue.shift() as TaskInfo;\n        if (taskInfo.workerInfo === null) {\n          taskInfo.done(new AbortError('pool is closed'));\n        } else {\n          this.skipQueue.push(taskInfo);\n        }\n      }\n\n      const taskQueueLength = this.taskQueue.size;\n      for (let i = 0; i < taskQueueLength; i++) {\n        const taskInfo : TaskInfo = this.taskQueue.shift() as TaskInfo;\n        if (taskInfo.workerInfo === null) {\n          taskInfo.done(new AbortError('pool is closed'));\n        } else {\n          this.taskQueue.push(taskInfo);\n        }\n      }\n    }\n\n    const onPoolFlushed = () => new Promise<void>((resolve) => {\n      const numberOfWorkers = this.workers.size;\n\n      if (numberOfWorkers === 0) {\n        resolve();\n        return;\n      }\n\n      let numberOfWorkersDone = 0;\n\n      const checkIfWorkerIsDone = (workerInfo: WorkerInfo) => {\n        if (workerInfo.taskInfos.size === 0) {\n          numberOfWorkersDone++;\n        }\n\n        if (numberOfWorkers === numberOfWorkersDone) {\n          resolve();\n        }\n      };\n\n      for (const workerInfo of this.workers) {\n        checkIfWorkerIsDone(workerInfo);\n\n        workerInfo.port.on('message', () => checkIfWorkerIsDone(workerInfo));\n      }\n    });\n\n    const throwOnTimeOut = async (timeout: number) => {\n      await sleep(timeout);\n      throw Errors.CloseTimeout();\n    };\n\n    try {\n      await Promise.race([\n        onPoolFlushed(),\n        throwOnTimeOut(this.options.closeTimeout)\n      ]);\n    } catch (error) {\n      this.publicInterface.emit('error', error);\n    } finally {\n      await this.destroy();\n      this.publicInterface.emit('close');\n      this.closingUp = false;\n    }\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:ThreadPool._ensureMinimumWorkers",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "ThreadPool._ensureMinimumWorkers",
    "startLine": 213,
    "endLine": 220,
    "text": "  _ensureMinimumWorkers () : void {\n    if (this.closingUp || this.destroying) {\n      return;\n    }\n    while (this.workers.size < this.options.minThreads) {\n      this._addNewWorker();\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:ThreadPool._addNewWorker",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "ThreadPool._addNewWorker",
    "startLine": 222,
    "endLine": 315,
    "text": "  _addNewWorker () : void {\n    const pool = this;\n    const worker = new Worker(resolve(__dirname, 'worker.js'), {\n      env: this.options.env,\n      argv: this.options.argv,\n      execArgv: this.options.execArgv,\n      resourceLimits: this.options.resourceLimits,\n      workerData: this.options.workerData,\n      trackUnmanagedFds: this.options.trackUnmanagedFds\n    });\n\n    const { port1, port2 } = new MessageChannel();\n    const workerInfo = new WorkerInfo(worker, port1, onMessage);\n    if (this.startingUp) {\n      // There is no point in waiting for the initial set of Workers to indicate\n      // that they are ready, we just mark them as such from the start.\n      workerInfo.markAsReady();\n    }\n\n    const message : StartupMessage = {\n      filename: this.options.filename,\n      name: this.options.name,\n      port: port2,\n      sharedBuffer: workerInfo.sharedBuffer,\n      useAtomics: this.options.useAtomics,\n      niceIncrement: this.options.niceIncrement\n    };\n    worker.postMessage(message, [port2]);\n\n    function onMessage (message : ResponseMessage) {\n      const { taskId, result } = message;\n      // In case of success: Call the callback that was passed to `runTask`,\n      // remove the `TaskInfo` associated with the Worker, which marks it as\n      // free again.\n      const taskInfo = workerInfo.taskInfos.get(taskId);\n      workerInfo.taskInfos.delete(taskId);\n\n      pool.workers.maybeAvailable(workerInfo);\n\n      /* istanbul ignore if */\n      if (taskInfo === undefined) {\n        const err = new Error(\n          `Unexpected message from Worker: ${inspect(message)}`);\n        pool.publicInterface.emit('error', err);\n      } else {\n        taskInfo.done(message.error, result);\n      }\n\n      pool._processPendingMessages();\n    }\n\n    function onReady () {\n      if (workerInfo.currentUsage() === 0) {\n        workerInfo.unref();\n      }\n\n      if (!workerInfo.isReady()) {\n        workerInfo.markAsReady();\n      }\n    }\n\n    function onEventMessage (message: any) {\n      pool.publicInterface.emit('message', message);\n    }\n\n    worker.on('message', (message : any) => {\n      message instanceof Object && READY in message ? onReady() : onEventMessage(message);\n    });\n\n    worker.on('error', (err : Error) => {\n      this._onError(worker, workerInfo, err, false);\n    });\n\n    worker.on('exit', (exitCode : number) => {\n      if (this.destroying) {\n        return;\n      }\n\n      const err = new Error(`worker exited with code: ${exitCode}`);\n      // Only error unfinished tasks on process exit, since there are legitimate\n      // reasons to exit workers and we want to handle that gracefully when possible.\n      this._onError(worker, workerInfo, err, true);\n    });\n\n    worker.unref();\n    port1.on('close', () => {\n      // The port is only closed if the Worker stops for some reason, but we\n      // always .unref() the Worker itself. We want to receive e.g. 'error'\n      // events on it, so we ref it once we know it's going to exit anyway.\n      worker.ref();\n    });\n\n    this.workers.add(workerInfo);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:ThreadPool._onError",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "ThreadPool._onError",
    "startLine": 317,
    "endLine": 346,
    "text": "  _onError (worker: Worker, workerInfo: WorkerInfo, err: Error, onlyErrorUnfinishedTasks: boolean) {\n    // Work around the bug in https://github.com/nodejs/node/pull/33394\n    worker.ref = () => {};\n\n    const taskInfos = [...workerInfo.taskInfos.values()];\n    workerInfo.taskInfos.clear();\n\n    // Remove the worker from the list and potentially start a new Worker to\n    // replace the current one.\n    this._removeWorker(workerInfo);\n\n    if (workerInfo.isReady() && !this.workerFailsDuringBootstrap) {\n      this._ensureMinimumWorkers();\n    } else {\n      // Do not start new workers over and over if they already fail during\n      // bootstrap, there's no point.\n      this.workerFailsDuringBootstrap = true;\n    }\n\n    if (taskInfos.length > 0) {\n      // If there are remaining unfinished tasks, call the callback that was\n      // passed to `postTask` with the error\n      for (const taskInfo of taskInfos) {\n        taskInfo.done(err, null);\n      }\n    } else if (!onlyErrorUnfinishedTasks) {\n      // If there are no unfinished tasks, instead emit an 'error' event\n      this.publicInterface.emit('error', err);\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:ThreadPool._processPendingMessages",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "ThreadPool._processPendingMessages",
    "startLine": 348,
    "endLine": 361,
    "text": "  _processPendingMessages () {\n    if (this.inProcessPendingMessages || !this.options.useAtomics) {\n      return;\n    }\n\n    this.inProcessPendingMessages = true;\n    try {\n      for (const workerInfo of this.workers) {\n        workerInfo.processPendingMessages();\n      }\n    } finally {\n      this.inProcessPendingMessages = false;\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:ThreadPool._removeWorker",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "ThreadPool._removeWorker",
    "startLine": 363,
    "endLine": 367,
    "text": "  _removeWorker (workerInfo : WorkerInfo) : void {\n    workerInfo.destroy();\n\n    this.workers.delete(workerInfo);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:ThreadPool._onWorkerAvailable",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "ThreadPool._onWorkerAvailable",
    "startLine": 369,
    "endLine": 405,
    "text": "  _onWorkerAvailable (workerInfo : WorkerInfo) : void {\n    while ((this.taskQueue.size > 0 || this.skipQueue.length > 0) &&\n      workerInfo.currentUsage() < this.options.concurrentTasksPerWorker) {\n      // The skipQueue will have tasks that we previously shifted off\n      // the task queue but had to skip over... we have to make sure\n      // we drain that before we drain the taskQueue.\n      const taskInfo = this.skipQueue.shift() ||\n                       this.taskQueue.shift() as TaskInfo;\n      // If the task has an abortSignal and the worker has any other\n      // tasks, we cannot distribute the task to it. Skip for now.\n      if (taskInfo.abortSignal && workerInfo.taskInfos.size > 0) {\n        this.skipQueue.push(taskInfo);\n        break;\n      }\n      const now = performance.now();\n      this.waitTime?.record(toHistogramIntegerNano(now - taskInfo.created));\n      taskInfo.started = now;\n      workerInfo.postTask(taskInfo);\n      this._maybeDrain();\n      return;\n    }\n\n    // If Infinity was sent as a parameter, we skip setting the Timeout that clears the worker\n    if (this.options.idleTimeout === Infinity) {\n      return;\n    }\n\n    if (workerInfo.taskInfos.size === 0 &&\n        this.workers.size > this.options.minThreads) {\n      workerInfo.idleTimeout = setTimeout(() => {\n        assert.strictEqual(workerInfo.taskInfos.size, 0);\n        if (this.workers.size > this.options.minThreads) {\n          this._removeWorker(workerInfo);\n        }\n      }, this.options.idleTimeout).unref();\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:ThreadPool.runTask",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "ThreadPool.runTask",
    "startLine": 407,
    "endLine": 545,
    "text": "  runTask (\n    task : any,\n    options : RunOptions) : Promise<any> {\n    let {\n      filename,\n      name\n    } = options;\n    const {\n      transferList = []\n    } = options;\n    if (filename == null) {\n      filename = this.options.filename;\n    }\n    if (name == null) {\n      name = this.options.name;\n    }\n    if (typeof filename !== 'string') {\n      return Promise.reject(Errors.FilenameNotProvided());\n    }\n    filename = maybeFileURLToPath(filename);\n\n    let signal: AbortSignalAny | null;\n    if (this.closingUp) {\n      const closingUpAbortController = new AbortController();\n      closingUpAbortController.abort('queue is closing up');\n\n      signal = closingUpAbortController.signal;\n    } else {\n      signal = options.signal ?? null;\n    }\n\n    let resolve : (result : any) => void;\n    let reject : (err : Error) => void;\n    // eslint-disable-next-line\n    const ret = new Promise((res, rej) => { resolve = res; reject = rej; });\n    const taskInfo = new TaskInfo(\n      task,\n      transferList,\n      filename,\n      name,\n      (err : Error | null, result : any) => {\n        this.completed++;\n        if (taskInfo.started) {\n          this.runTime?.record(toHistogramIntegerNano(performance.now() - taskInfo.started));\n        }\n        if (err !== null) {\n          reject(err);\n        } else {\n          resolve(result);\n        }\n\n        this._maybeDrain();\n      },\n      signal,\n      this.publicInterface.asyncResource.asyncId());\n\n    if (signal !== null) {\n      // If the AbortSignal has an aborted property and it's truthy,\n      // reject immediately.\n      if ((signal as AbortSignalEventTarget).aborted) {\n        return Promise.reject(new AbortError((signal as AbortSignalEventTarget).reason));\n      }\n      taskInfo.abortListener = () => {\n        // Call reject() first to make sure we always reject with the AbortError\n        // if the task is aborted, not with an Error from the possible\n        // thread termination below.\n        reject(new AbortError((signal as AbortSignalEventTarget).reason));\n\n        if (taskInfo.workerInfo !== null) {\n          // Already running: We cancel the Worker this is running on.\n          this._removeWorker(taskInfo.workerInfo);\n          this._ensureMinimumWorkers();\n        } else {\n          // Not yet running: Remove it from the queue.\n          this.taskQueue.remove(taskInfo);\n        }\n      };\n      onabort(signal, taskInfo.abortListener);\n    }\n\n    // If there is a task queue, there's no point in looking for an available\n    // Worker thread. Add this task to the queue, if possible.\n    if (this.taskQueue.size > 0) {\n      const totalCapacity = this.options.maxQueue + this.pendingCapacity();\n      if (this.taskQueue.size >= totalCapacity) {\n        if (this.options.maxQueue === 0) {\n          return Promise.reject(Errors.NoTaskQueueAvailable());\n        } else {\n          return Promise.reject(Errors.TaskQueueAtLimit());\n        }\n      } else {\n        if (this.workers.size < this.options.maxThreads) {\n          this._addNewWorker();\n        }\n        this.taskQueue.push(taskInfo);\n      }\n\n      this._maybeDrain();\n      return ret;\n    }\n\n    // Look for a Worker with a minimum number of tasks it is currently running.\n    let workerInfo : WorkerInfo | null = this.workers.findAvailable();\n\n    // If we want the ability to abort this task, use only workers that have\n    // no running tasks.\n    if (workerInfo !== null && workerInfo.currentUsage() > 0 && signal) {\n      workerInfo = null;\n    }\n\n    // If no Worker was found, or that Worker was handling another task in some\n    // way, and we still have the ability to spawn new threads, do so.\n    let waitingForNewWorker = false;\n    if ((workerInfo === null || workerInfo.currentUsage() > 0) &&\n        this.workers.size < this.options.maxThreads) {\n      this._addNewWorker();\n      waitingForNewWorker = true;\n    }\n\n    // If no Worker is found, try to put the task into the queue.\n    if (workerInfo === null) {\n      if (this.options.maxQueue <= 0 && !waitingForNewWorker) {\n        return Promise.reject(Errors.NoTaskQueueAvailable());\n      } else {\n        this.taskQueue.push(taskInfo);\n      }\n\n      this._maybeDrain();\n      return ret;\n    }\n\n    // TODO(addaleax): Clean up the waitTime/runTime recording.\n    const now = performance.now();\n    this.waitTime?.record(toHistogramIntegerNano(now - taskInfo.created));\n    taskInfo.started = now;\n    workerInfo.postTask(taskInfo);\n    this._maybeDrain();\n    return ret;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:ThreadPool.pendingCapacity",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "ThreadPool.pendingCapacity",
    "startLine": 547,
    "endLine": 550,
    "text": "  pendingCapacity () : number {\n    return this.workers.pendingItems.size *\n      this.options.concurrentTasksPerWorker;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:ThreadPool._maybeDrain",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "ThreadPool._maybeDrain",
    "startLine": 552,
    "endLine": 565,
    "text": "  _maybeDrain () {\n    const totalCapacity = this.options.maxQueue + this.pendingCapacity();\n    const totalQueueSize = this.taskQueue.size + this.skipQueue.length;\n\n    if (totalQueueSize === 0) {\n      this.needsDrain = false;\n      this.publicInterface.emit('drain');\n    }\n\n    if (totalQueueSize >= totalCapacity) {\n      this.needsDrain = true;\n      this.publicInterface.emit('needsDrain');\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:ThreadPool.destroy",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "ThreadPool.destroy",
    "startLine": 567,
    "endLine": 590,
    "text": "  async destroy () {\n    this.destroying = true;\n    while (this.skipQueue.length > 0) {\n      const taskInfo : TaskInfo = this.skipQueue.shift() as TaskInfo;\n      taskInfo.done(new Error('Terminating worker thread'));\n    }\n    while (this.taskQueue.size > 0) {\n      const taskInfo : TaskInfo = this.taskQueue.shift() as TaskInfo;\n      taskInfo.done(new Error('Terminating worker thread'));\n    }\n\n    const exitEvents : Promise<any[]>[] = [];\n    while (this.workers.size > 0) {\n      const [workerInfo] = this.workers;\n      exitEvents.push(once(workerInfo.worker, 'exit'));\n      this._removeWorker(workerInfo);\n    }\n\n    try {\n      await Promise.all(exitEvents);\n    } finally {\n      this.destroying = false;\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:ThreadPool.close",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "ThreadPool.close",
    "startLine": 592,
    "endLine": 661,
    "text": "  async close (options : Required<CloseOptions>) {\n    this.closingUp = true;\n\n    if (options.force) {\n      const skipQueueLength = this.skipQueue.length;\n      for (let i = 0; i < skipQueueLength; i++) {\n        const taskInfo : TaskInfo = this.skipQueue.shift() as TaskInfo;\n        if (taskInfo.workerInfo === null) {\n          taskInfo.done(new AbortError('pool is closed'));\n        } else {\n          this.skipQueue.push(taskInfo);\n        }\n      }\n\n      const taskQueueLength = this.taskQueue.size;\n      for (let i = 0; i < taskQueueLength; i++) {\n        const taskInfo : TaskInfo = this.taskQueue.shift() as TaskInfo;\n        if (taskInfo.workerInfo === null) {\n          taskInfo.done(new AbortError('pool is closed'));\n        } else {\n          this.taskQueue.push(taskInfo);\n        }\n      }\n    }\n\n    const onPoolFlushed = () => new Promise<void>((resolve) => {\n      const numberOfWorkers = this.workers.size;\n\n      if (numberOfWorkers === 0) {\n        resolve();\n        return;\n      }\n\n      let numberOfWorkersDone = 0;\n\n      const checkIfWorkerIsDone = (workerInfo: WorkerInfo) => {\n        if (workerInfo.taskInfos.size === 0) {\n          numberOfWorkersDone++;\n        }\n\n        if (numberOfWorkers === numberOfWorkersDone) {\n          resolve();\n        }\n      };\n\n      for (const workerInfo of this.workers) {\n        checkIfWorkerIsDone(workerInfo);\n\n        workerInfo.port.on('message', () => checkIfWorkerIsDone(workerInfo));\n      }\n    });\n\n    const throwOnTimeOut = async (timeout: number) => {\n      await sleep(timeout);\n      throw Errors.CloseTimeout();\n    };\n\n    try {\n      await Promise.race([\n        onPoolFlushed(),\n        throwOnTimeOut(this.options.closeTimeout)\n      ]);\n    } catch (error) {\n      this.publicInterface.emit('error', error);\n    } finally {\n      await this.destroy();\n      this.publicInterface.emit('close');\n      this.closingUp = false;\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:onMessage",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "onMessage",
    "startLine": 251,
    "endLine": 271,
    "text": "    function onMessage (message : ResponseMessage) {\n      const { taskId, result } = message;\n      // In case of success: Call the callback that was passed to `runTask`,\n      // remove the `TaskInfo` associated with the Worker, which marks it as\n      // free again.\n      const taskInfo = workerInfo.taskInfos.get(taskId);\n      workerInfo.taskInfos.delete(taskId);\n\n      pool.workers.maybeAvailable(workerInfo);\n\n      /* istanbul ignore if */\n      if (taskInfo === undefined) {\n        const err = new Error(\n          `Unexpected message from Worker: ${inspect(message)}`);\n        pool.publicInterface.emit('error', err);\n      } else {\n        taskInfo.done(message.error, result);\n      }\n\n      pool._processPendingMessages();\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:onReady",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "onReady",
    "startLine": 273,
    "endLine": 281,
    "text": "    function onReady () {\n      if (workerInfo.currentUsage() === 0) {\n        workerInfo.unref();\n      }\n\n      if (!workerInfo.isReady()) {\n        workerInfo.markAsReady();\n      }\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:onEventMessage",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "onEventMessage",
    "startLine": 283,
    "endLine": 285,
    "text": "    function onEventMessage (message: any) {\n      pool.publicInterface.emit('message', message);\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:Piscina",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "Piscina",
    "startLine": 664,
    "endLine": 954,
    "text": "export default class Piscina<T = any, R = any> extends EventEmitterAsyncResource {\n  #pool : ThreadPool;\n\n  constructor (options : Options = {}) {\n    super({ ...options, name: 'Piscina' });\n\n    if (typeof options.filename !== 'string' && options.filename != null) {\n      throw new TypeError('options.filename must be a string or null');\n    }\n    if (typeof options.name !== 'string' && options.name != null) {\n      throw new TypeError('options.name must be a string or null');\n    }\n    if (options.minThreads !== undefined &&\n        (typeof options.minThreads !== 'number' || options.minThreads < 0)) {\n      throw new TypeError('options.minThreads must be a non-negative integer');\n    }\n    if (options.maxThreads !== undefined &&\n        (typeof options.maxThreads !== 'number' || options.maxThreads < 1)) {\n      throw new TypeError('options.maxThreads must be a positive integer');\n    }\n    if (options.minThreads !== undefined && options.maxThreads !== undefined &&\n        options.minThreads > options.maxThreads) {\n      throw new RangeError('options.minThreads and options.maxThreads must not conflict');\n    }\n    if (options.idleTimeout !== undefined &&\n        (typeof options.idleTimeout !== 'number' || options.idleTimeout < 0)) {\n      throw new TypeError('options.idleTimeout must be a non-negative integer');\n    }\n    if (options.maxQueue !== undefined &&\n        options.maxQueue !== 'auto' &&\n          (typeof options.maxQueue !== 'number' || options.maxQueue < 0)) {\n      throw new TypeError('options.maxQueue must be a non-negative integer');\n    }\n    if (options.concurrentTasksPerWorker !== undefined &&\n        (typeof options.concurrentTasksPerWorker !== 'number' ||\n         options.concurrentTasksPerWorker < 1)) {\n      throw new TypeError(\n        'options.concurrentTasksPerWorker must be a positive integer');\n    }\n    if (options.useAtomics !== undefined &&\n        typeof options.useAtomics !== 'boolean') {\n      throw new TypeError('options.useAtomics must be a boolean value');\n    }\n    if (options.resourceLimits !== undefined &&\n        (typeof options.resourceLimits !== 'object' ||\n         options.resourceLimits === null)) {\n      throw new TypeError('options.resourceLimits must be an object');\n    }\n    if (options.taskQueue !== undefined && !isTaskQueue(options.taskQueue)) {\n      throw new TypeError('options.taskQueue must be a TaskQueue object');\n    }\n    if (options.niceIncrement !== undefined &&\n        (typeof options.niceIncrement !== 'number' || (options.niceIncrement < 0 && process.platform !== 'win32'))) {\n      throw new TypeError('options.niceIncrement must be a non-negative integer on Unix systems');\n    }\n    if (options.trackUnmanagedFds !== undefined &&\n        typeof options.trackUnmanagedFds !== 'boolean') {\n      throw new TypeError('options.trackUnmanagedFds must be a boolean value');\n    }\n    if (options.closeTimeout !== undefined && (typeof options.closeTimeout !== 'number' || options.closeTimeout < 0)) {\n      throw new TypeError('options.closeTimeout must be a non-negative integer');\n    }\n\n    this.#pool = new ThreadPool(this, options);\n  }\n\n  /** @deprecated Use run(task, options) instead **/\n  runTask (task : T, transferList? : TransferList, filename? : string, abortSignal? : AbortSignalAny) : Promise<R>;\n\n  /** @deprecated Use run(task, options) instead **/\n  runTask (task : T, transferList? : TransferList, filename? : AbortSignalAny, abortSignal? : undefined) : Promise<R>;\n\n  /** @deprecated Use run(task, options) instead **/\n  runTask (task : T, transferList? : string, filename? : AbortSignalAny, abortSignal? : undefined) : Promise<R>;\n\n  /** @deprecated Use run(task, options) instead **/\n  runTask (task : T, transferList? : AbortSignalAny, filename? : undefined, abortSignal? : undefined) : Promise<R>;\n\n  /** @deprecated Use run(task, options) instead **/\n  runTask (task : T, transferList? : any, filename? : any, signal? : any): Promise<R> {\n    // If transferList is a string or AbortSignal, shift it.\n    if ((typeof transferList === 'object' && !Array.isArray(transferList)) ||\n        typeof transferList === 'string') {\n      signal = filename as (AbortSignalAny | undefined);\n      filename = transferList;\n      transferList = undefined;\n    }\n    // If filename is an AbortSignal, shift it.\n    if (typeof filename === 'object' && !Array.isArray(filename)) {\n      signal = filename;\n      filename = undefined;\n    }\n\n    if (transferList !== undefined && !Array.isArray(transferList)) {\n      return Promise.reject(\n        new TypeError('transferList argument must be an Array'));\n    }\n    if (filename !== undefined && typeof filename !== 'string') {\n      return Promise.reject(\n        new TypeError('filename argument must be a string'));\n    }\n    if (signal !== undefined && typeof signal !== 'object') {\n      return Promise.reject(\n        new TypeError('signal argument must be an object'));\n    }\n    return this.#pool.runTask(\n      task, {\n        transferList,\n        filename: filename || null,\n        name: 'default',\n        signal: signal || null\n      });\n  }\n\n  run (task : T, options : RunOptions = kDefaultRunOptions): Promise<R> {\n    if (options === null || typeof options !== 'object') {\n      return Promise.reject(\n        new TypeError('options must be an object'));\n    }\n    const {\n      transferList,\n      filename,\n      name,\n      signal\n    } = options;\n    if (transferList !== undefined && !Array.isArray(transferList)) {\n      return Promise.reject(\n        new TypeError('transferList argument must be an Array'));\n    }\n    if (filename != null && typeof filename !== 'string') {\n      return Promise.reject(\n        new TypeError('filename argument must be a string'));\n    }\n    if (name != null && typeof name !== 'string') {\n      return Promise.reject(new TypeError('name argument must be a string'));\n    }\n    if (signal != null && typeof signal !== 'object') {\n      return Promise.reject(\n        new TypeError('signal argument must be an object'));\n    }\n    return this.#pool.runTask(task, { transferList, filename, name, signal });\n  }\n\n  async close (options : CloseOptions = kDefaultCloseOptions) {\n    if (options === null || typeof options !== 'object') {\n      throw TypeError('options must be an object');\n    }\n\n    let { force } = options;\n\n    if (force !== undefined && typeof force !== 'boolean') {\n      return Promise.reject(\n        new TypeError('force argument must be a boolean'));\n    }\n    force ??= kDefaultCloseOptions.force;\n\n    return this.#pool.close({\n      force\n    });\n  }\n\n  destroy () {\n    return this.#pool.destroy();\n  }\n\n  get maxThreads (): number {\n    return this.#pool.options.maxThreads;\n  }\n\n  get minThreads (): number {\n    return this.#pool.options.minThreads;\n  }\n\n  get options () : FilledOptions {\n    return this.#pool.options;\n  }\n\n  get threads () : Worker[] {\n    const ret : Worker[] = [];\n    for (const workerInfo of this.#pool.workers) { ret.push(workerInfo.worker); }\n    return ret;\n  }\n\n  get queueSize () : number {\n    const pool = this.#pool;\n    return Math.max(pool.taskQueue.size - pool.pendingCapacity(), 0);\n  }\n\n  get completed () : number {\n    return this.#pool.completed;\n  }\n\n  get waitTime () : any {\n    if (!this.#pool.waitTime) {\n      return null;\n    }\n\n    return createHistogramSummary(this.#pool.waitTime);\n  }\n\n  get runTime () : any {\n    if (!this.#pool.runTime) {\n      return null;\n    }\n\n    return createHistogramSummary(this.#pool.runTime);\n  }\n\n  get utilization () : number {\n    if (!this.#pool.runTime) {\n      return 0;\n    }\n\n    // count is available as of Node.js v16.14.0 but not present in the types\n    const count = (this.#pool.runTime as RecordableHistogram & { count: number}).count;\n    if (count === 0) {\n      return 0;\n    }\n\n    // The capacity is the max compute time capacity of the\n    // pool to this point in time as determined by the length\n    // of time the pool has been running multiplied by the\n    // maximum number of threads.\n    const capacity = this.duration * this.#pool.options.maxThreads;\n    const totalMeanRuntime = (this.#pool.runTime.mean / 1000) * count;\n\n    // We calculate the appoximate pool utilization by multiplying\n    // the mean run time of all tasks by the number of runtime\n    // samples taken and dividing that by the capacity. The\n    // theory here is that capacity represents the absolute upper\n    // limit of compute time this pool could ever attain (but\n    // never will for a variety of reasons. Multiplying the\n    // mean run time by the number of tasks sampled yields an\n    // approximation of the realized compute time. The utilization\n    // then becomes a point-in-time measure of how active the\n    // pool is.\n    return totalMeanRuntime / capacity;\n  }\n\n  get duration () : number {\n    return performance.now() - this.#pool.start;\n  }\n\n  get needsDrain () : boolean {\n    return this.#pool.needsDrain;\n  }\n\n  static get isWorkerThread () : boolean {\n    return commonState.isWorkerThread;\n  }\n\n  static get workerData () : any {\n    return commonState.workerData;\n  }\n\n  static get version () : string {\n    return version;\n  }\n\n  static get Piscina () {\n    return Piscina;\n  }\n\n  static get FixedQueue () {\n    return FixedQueue;\n  }\n\n  static get ArrayTaskQueue () {\n    return ArrayTaskQueue;\n  }\n\n  static move (val : Transferable | TransferListItem | ArrayBufferView | ArrayBuffer | MessagePort) {\n    if (val != null && typeof val === 'object' && typeof val !== 'function') {\n      if (!isTransferable(val)) {\n        if ((types as any).isArrayBufferView(val)) {\n          val = new ArrayBufferViewTransferable(val as ArrayBufferView);\n        } else {\n          val = new DirectlyTransferable(val);\n        }\n      }\n      markMovable(val);\n    }\n    return val;\n  }\n\n  static get transferableSymbol () { return kTransferable; }\n\n  static get valueSymbol () { return kValue; }\n\n  static get queueOptionsSymbol () { return kQueueOptions; }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:Piscina.runTask",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "Piscina.runTask",
    "startLine": 743,
    "endLine": 776,
    "text": "  runTask (task : T, transferList? : any, filename? : any, signal? : any): Promise<R> {\n    // If transferList is a string or AbortSignal, shift it.\n    if ((typeof transferList === 'object' && !Array.isArray(transferList)) ||\n        typeof transferList === 'string') {\n      signal = filename as (AbortSignalAny | undefined);\n      filename = transferList;\n      transferList = undefined;\n    }\n    // If filename is an AbortSignal, shift it.\n    if (typeof filename === 'object' && !Array.isArray(filename)) {\n      signal = filename;\n      filename = undefined;\n    }\n\n    if (transferList !== undefined && !Array.isArray(transferList)) {\n      return Promise.reject(\n        new TypeError('transferList argument must be an Array'));\n    }\n    if (filename !== undefined && typeof filename !== 'string') {\n      return Promise.reject(\n        new TypeError('filename argument must be a string'));\n    }\n    if (signal !== undefined && typeof signal !== 'object') {\n      return Promise.reject(\n        new TypeError('signal argument must be an object'));\n    }\n    return this.#pool.runTask(\n      task, {\n        transferList,\n        filename: filename || null,\n        name: 'default',\n        signal: signal || null\n      });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:Piscina.run",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "Piscina.run",
    "startLine": 778,
    "endLine": 805,
    "text": "  run (task : T, options : RunOptions = kDefaultRunOptions): Promise<R> {\n    if (options === null || typeof options !== 'object') {\n      return Promise.reject(\n        new TypeError('options must be an object'));\n    }\n    const {\n      transferList,\n      filename,\n      name,\n      signal\n    } = options;\n    if (transferList !== undefined && !Array.isArray(transferList)) {\n      return Promise.reject(\n        new TypeError('transferList argument must be an Array'));\n    }\n    if (filename != null && typeof filename !== 'string') {\n      return Promise.reject(\n        new TypeError('filename argument must be a string'));\n    }\n    if (name != null && typeof name !== 'string') {\n      return Promise.reject(new TypeError('name argument must be a string'));\n    }\n    if (signal != null && typeof signal !== 'object') {\n      return Promise.reject(\n        new TypeError('signal argument must be an object'));\n    }\n    return this.#pool.runTask(task, { transferList, filename, name, signal });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:Piscina.close",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "Piscina.close",
    "startLine": 807,
    "endLine": 823,
    "text": "  async close (options : CloseOptions = kDefaultCloseOptions) {\n    if (options === null || typeof options !== 'object') {\n      throw TypeError('options must be an object');\n    }\n\n    let { force } = options;\n\n    if (force !== undefined && typeof force !== 'boolean') {\n      return Promise.reject(\n        new TypeError('force argument must be a boolean'));\n    }\n    force ??= kDefaultCloseOptions.force;\n\n    return this.#pool.close({\n      force\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:Piscina.destroy",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "Piscina.destroy",
    "startLine": 825,
    "endLine": 827,
    "text": "  destroy () {\n    return this.#pool.destroy();\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts:Piscina.move",
    "file": "node_modules/piscina/src/index.ts",
    "symbol": "Piscina.move",
    "startLine": 935,
    "endLine": 947,
    "text": "  static move (val : Transferable | TransferListItem | ArrayBufferView | ArrayBuffer | MessagePort) {\n    if (val != null && typeof val === 'object' && typeof val !== 'function') {\n      if (!isTransferable(val)) {\n        if ((types as any).isArrayBufferView(val)) {\n          val = new ArrayBufferViewTransferable(val as ArrayBufferView);\n        } else {\n          val = new DirectlyTransferable(val);\n        }\n      }\n      markMovable(val);\n    }\n    return val;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker.ts:getImportESM",
    "file": "node_modules/piscina/src/worker.ts",
    "symbol": "getImportESM",
    "startLine": 33,
    "endLine": 39,
    "text": "function getImportESM () {\n  if (importESMCached === undefined) {\n    // eslint-disable-next-line no-new-func\n    importESMCached = new Function('specifier', 'return import(specifier)') as typeof importESMCached;\n  }\n  return importESMCached;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker.ts:getHandler",
    "file": "node_modules/piscina/src/worker.ts",
    "symbol": "getHandler",
    "startLine": 43,
    "endLine": 76,
    "text": "async function getHandler (filename : string, name : string) : Promise<Function | null> {\n  let handler = handlerCache.get(`${filename}/${name}`);\n  if (handler !== undefined) {\n    return handler;\n  }\n\n  try {\n    // With our current set of TypeScript options, this is transpiled to\n    // `require(filename)`.\n    handler = await import(filename);\n    if (typeof handler !== 'function') {\n      handler = await ((handler as any)[name]);\n    }\n  } catch {}\n  if (typeof handler !== 'function') {\n    handler = await getImportESM()(pathToFileURL(filename).href);\n    if (typeof handler !== 'function') {\n      handler = await ((handler as any)[name]);\n    }\n  }\n  if (typeof handler !== 'function') {\n    return null;\n  }\n\n  // Limit the handler cache size. This should not usually be an issue and is\n  // only provided for pathological cases.\n  if (handlerCache.size > 1000) {\n    const [[key]] = handlerCache;\n    handlerCache.delete(key);\n  }\n\n  handlerCache.set(`${filename}/${name}`, handler);\n  return handler;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker.ts:atomicsWaitLoop",
    "file": "node_modules/piscina/src/worker.ts",
    "symbol": "atomicsWaitLoop",
    "startLine": 106,
    "endLine": 134,
    "text": "function atomicsWaitLoop (port : MessagePort, sharedBuffer : Int32Array) {\n  if (!useAtomics) return;\n\n  // This function is entered either after receiving the startup message, or\n  // when we are done with a task. In those situations, the *only* thing we\n  // expect to happen next is a 'message' on `port`.\n  // That call would come with the overhead of a C++  JS boundary crossing,\n  // including async tracking. So, instead, if there is no task currently\n  // running, we wait for a signal from the parent thread using Atomics.wait(),\n  // and read the message from the port instead of generating an event,\n  // in order to avoid that overhead.\n  // The one catch is that this stops asynchronous operations that are still\n  // running from proceeding. Generally, tasks should not spawn asynchronous\n  // operations without waiting for them to finish, though.\n  while (currentTasks === 0) {\n    // Check whether there are new messages by testing whether the current\n    // number of requests posted by the parent thread matches the number of\n    // requests received.\n    Atomics.wait(sharedBuffer, kRequestCountField, lastSeenRequestCount);\n    lastSeenRequestCount = Atomics.load(sharedBuffer, kRequestCountField);\n\n    // We have to read messages *after* updating lastSeenRequestCount in order\n    // to avoid race conditions.\n    let entry;\n    while ((entry = receiveMessageOnPort(port)) !== undefined) {\n      onMessage(port, sharedBuffer, entry.message);\n    }\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker.ts:onMessage",
    "file": "node_modules/piscina/src/worker.ts",
    "symbol": "onMessage",
    "startLine": 136,
    "endLine": 190,
    "text": "function onMessage (\n  port : MessagePort,\n  sharedBuffer : Int32Array,\n  message : RequestMessage) {\n  currentTasks++;\n  const { taskId, task, filename, name } = message;\n\n  (async function () {\n    let response : ResponseMessage;\n    let transferList : any[] = [];\n    try {\n      const handler = await getHandler(filename, name);\n      if (handler === null) {\n        throw new Error(`No handler function exported from ${filename}`);\n      }\n      let result = await handler(task);\n      if (isMovable(result)) {\n        transferList = transferList.concat(result[kTransferable]);\n        result = result[kValue];\n      }\n      response = {\n        taskId,\n        result: result,\n        error: null\n      };\n\n      // If the task used e.g. console.log(), wait for the stream to drain\n      // before potentially entering the `Atomics.wait()` loop, and before\n      // returning the result so that messages will always be printed even\n      // if the process would otherwise be ready to exit.\n      if (process.stdout.writableLength > 0) {\n        await new Promise((resolve) => process.stdout.write('', resolve));\n      }\n      if (process.stderr.writableLength > 0) {\n        await new Promise((resolve) => process.stderr.write('', resolve));\n      }\n    } catch (error) {\n      response = {\n        taskId,\n        result: null,\n        // It may be worth taking a look at the error cloning algorithm we\n        // use in Node.js core here, it's quite a bit more flexible\n        error: <Error>error\n      };\n    }\n    currentTasks--;\n\n    // Post the response to the parent thread, and let it know that we have\n    // an additional message available. If possible, use Atomics.wait()\n    // to wait for the next message.\n    port.postMessage(response, transferList);\n    Atomics.add(sharedBuffer, kResponseCountField, 1);\n    atomicsWaitLoop(port, sharedBuffer);\n  })().catch(throwInNextTick);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker.ts:throwInNextTick",
    "file": "node_modules/piscina/src/worker.ts",
    "symbol": "throwInNextTick",
    "startLine": 192,
    "endLine": 194,
    "text": "function throwInNextTick (error : Error) {\n  process.nextTick(() => { throw error; });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/atomics-optimization.ts:popcount8",
    "file": "node_modules/piscina/test/atomics-optimization.ts",
    "symbol": "popcount8",
    "startLine": 60,
    "endLine": 66,
    "text": "function popcount8 (v : number) : number {\n  v &= 0xff;\n  if (v & 0b11110000) return popcount8(v >>> 4) + popcount8(v & 0xb00001111);\n  if (v & 0b00001100) return popcount8(v >>> 2) + popcount8(v & 0xb00000011);\n  if (v & 0b00000010) return popcount8(v >>> 1) + popcount8(v & 0xb00000001);\n  return v;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/fixed-queue.ts:QueueTask",
    "file": "node_modules/piscina/test/fixed-queue.ts",
    "symbol": "QueueTask",
    "startLine": 7,
    "endLine": 11,
    "text": "class QueueTask implements Task {\n  get [kQueueOptions] () {\n    return null;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/task-queue.ts:CustomTaskPool",
    "file": "node_modules/piscina/test/task-queue.ts",
    "symbol": "CustomTaskPool",
    "startLine": 222,
    "endLine": 252,
    "text": "  class CustomTaskPool implements TaskQueue {\n    tasks: PiscinaTask[] = [];\n\n    get size () : number {\n      sizeCalled = true;\n      return this.tasks.length;\n    }\n\n    shift () : PiscinaTask | null {\n      shiftCalled = true;\n      return this.tasks.length > 0 ? this.tasks.shift() as PiscinaTask : null;\n    }\n\n    push (task : PiscinaTask) : void {\n      pushCalled = true;\n      this.tasks.push(task);\n\n      ok(Piscina.queueOptionsSymbol in task);\n      if ((task as any).task.a === 3) {\n        equal(task[Piscina.queueOptionsSymbol], null);\n      } else {\n        equal(task[Piscina.queueOptionsSymbol].option,\n          (task as any).task.a);\n      }\n    }\n\n    remove (task : PiscinaTask) : void {\n      const index = this.tasks.indexOf(task);\n      this.tasks.splice(index, 1);\n    }\n  };"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/task-queue.ts:CustomTaskPool.shift",
    "file": "node_modules/piscina/test/task-queue.ts",
    "symbol": "CustomTaskPool.shift",
    "startLine": 230,
    "endLine": 233,
    "text": "    shift () : PiscinaTask | null {\n      shiftCalled = true;\n      return this.tasks.length > 0 ? this.tasks.shift() as PiscinaTask : null;\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/task-queue.ts:CustomTaskPool.push",
    "file": "node_modules/piscina/test/task-queue.ts",
    "symbol": "CustomTaskPool.push",
    "startLine": 235,
    "endLine": 246,
    "text": "    push (task : PiscinaTask) : void {\n      pushCalled = true;\n      this.tasks.push(task);\n\n      ok(Piscina.queueOptionsSymbol in task);\n      if ((task as any).task.a === 3) {\n        equal(task[Piscina.queueOptionsSymbol], null);\n      } else {\n        equal(task[Piscina.queueOptionsSymbol].option,\n          (task as any).task.a);\n      }\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/task-queue.ts:CustomTaskPool.remove",
    "file": "node_modules/piscina/test/task-queue.ts",
    "symbol": "CustomTaskPool.remove",
    "startLine": 248,
    "endLine": 251,
    "text": "    remove (task : PiscinaTask) : void {\n      const index = this.tasks.indexOf(task);\n      this.tasks.splice(index, 1);\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/task-queue.ts:makeTask",
    "file": "node_modules/piscina/test/task-queue.ts",
    "symbol": "makeTask",
    "startLine": 262,
    "endLine": 264,
    "text": "  function makeTask (task, option) {\n    return { ...task, [Piscina.queueOptionsSymbol]: { option } };\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/test-is-buffer-transferred.ts:wait",
    "file": "node_modules/piscina/test/test-is-buffer-transferred.ts",
    "symbol": "wait",
    "startLine": 5,
    "endLine": 7,
    "text": "function wait () {\n  return new Promise((resolve) => setTimeout(resolve, 1500));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/config-loader.ts:loadConfig",
    "file": "node_modules/tsconfig-paths/src/config-loader.ts",
    "symbol": "loadConfig",
    "startLine": 41,
    "endLine": 43,
    "text": "export function loadConfig(cwd: string = options.cwd): ConfigLoaderResult {\n  return configLoader({ cwd: cwd });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/config-loader.ts:configLoader",
    "file": "node_modules/tsconfig-paths/src/config-loader.ts",
    "symbol": "configLoader",
    "startLine": 45,
    "endLine": 97,
    "text": "export function configLoader({\n  cwd,\n  explicitParams,\n  tsConfigLoader = TsConfigLoader2.tsConfigLoader,\n}: ConfigLoaderParams): ConfigLoaderResult {\n  if (explicitParams) {\n    // tslint:disable-next-line:no-shadowed-variable\n    const absoluteBaseUrl = path.isAbsolute(explicitParams.baseUrl)\n      ? explicitParams.baseUrl\n      : path.join(cwd, explicitParams.baseUrl);\n\n    return {\n      resultType: \"success\",\n      configFileAbsolutePath: \"\",\n      baseUrl: explicitParams.baseUrl,\n      absoluteBaseUrl,\n      paths: explicitParams.paths,\n      mainFields: explicitParams.mainFields,\n      addMatchAll: explicitParams.addMatchAll,\n    };\n  }\n\n  // Load tsconfig and create path matching function\n  const loadResult = tsConfigLoader({\n    cwd,\n    getEnv: (key: string) => process.env[key],\n  });\n\n  if (!loadResult.tsConfigPath) {\n    return {\n      resultType: \"failed\",\n      message: \"Couldn't find tsconfig.json\",\n    };\n  }\n\n  if (!loadResult.baseUrl) {\n    return {\n      resultType: \"failed\",\n      message: \"Missing baseUrl in compilerOptions\",\n    };\n  }\n\n  const tsConfigDir = path.dirname(loadResult.tsConfigPath);\n  const absoluteBaseUrl = path.join(tsConfigDir, loadResult.baseUrl);\n\n  return {\n    resultType: \"success\",\n    configFileAbsolutePath: loadResult.tsConfigPath,\n    baseUrl: loadResult.baseUrl,\n    absoluteBaseUrl,\n    paths: loadResult.paths || {},\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/filesystem.ts:fileExistsSync",
    "file": "node_modules/tsconfig-paths/src/filesystem.ts",
    "symbol": "fileExistsSync",
    "startLine": 35,
    "endLine": 43,
    "text": "export function fileExistsSync(path: string): boolean {\n  try {\n    const stats = fs.statSync(path);\n    return stats.isFile();\n  } catch (err) {\n    // If error, assume file did not exist\n    return false;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/filesystem.ts:readJsonFromDiskSync",
    "file": "node_modules/tsconfig-paths/src/filesystem.ts",
    "symbol": "readJsonFromDiskSync",
    "startLine": 50,
    "endLine": 55,
    "text": "export function readJsonFromDiskSync(packageJsonPath: string): any | undefined {\n  if (!fs.existsSync(packageJsonPath)) {\n    return undefined;\n  }\n  return require(packageJsonPath);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/filesystem.ts:readJsonFromDiskAsync",
    "file": "node_modules/tsconfig-paths/src/filesystem.ts",
    "symbol": "readJsonFromDiskAsync",
    "startLine": 57,
    "endLine": 70,
    "text": "export function readJsonFromDiskAsync(\n  path: string,\n  // tslint:disable-next-line:no-any\n  callback: (err?: Error, content?: any) => void\n): void {\n  fs.readFile(path, \"utf8\", (err, result) => {\n    // If error, assume file did not exist\n    if (err || !result) {\n      return callback();\n    }\n    const json = JSON.parse(result);\n    return callback(undefined, json);\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/filesystem.ts:fileExistsAsync",
    "file": "node_modules/tsconfig-paths/src/filesystem.ts",
    "symbol": "fileExistsAsync",
    "startLine": 72,
    "endLine": 83,
    "text": "export function fileExistsAsync(\n  path2: string,\n  callback2: (err?: Error, exists?: boolean) => void\n): void {\n  fs.stat(path2, (err: Error, stats: fs.Stats) => {\n    if (err) {\n      // If error assume file does not exist\n      return callback2(undefined, false);\n    }\n    callback2(undefined, stats ? stats.isFile() : false);\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/filesystem.ts:removeExtension",
    "file": "node_modules/tsconfig-paths/src/filesystem.ts",
    "symbol": "removeExtension",
    "startLine": 85,
    "endLine": 87,
    "text": "export function removeExtension(path: string): string {\n  return path.substring(0, path.lastIndexOf(\".\")) || path;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/mapping-entry.ts:getAbsoluteMappingEntries",
    "file": "node_modules/tsconfig-paths/src/mapping-entry.ts",
    "symbol": "getAbsoluteMappingEntries",
    "startLine": 21,
    "endLine": 49,
    "text": "export function getAbsoluteMappingEntries(\n  absoluteBaseUrl: string,\n  paths: Paths,\n  addMatchAll: boolean\n): ReadonlyArray<MappingEntry> {\n  // Resolve all paths to absolute form once here, and sort them by\n  // longest prefix once here, this saves time on each request later.\n  // We need to put them in an array to preserve the sorting order.\n  const sortedKeys = sortByLongestPrefix(Object.keys(paths));\n  const absolutePaths: Array<MappingEntry> = [];\n  for (const key of sortedKeys) {\n    absolutePaths.push({\n      pattern: key,\n      paths: paths[key].map((pathToResolve) =>\n        path.join(absoluteBaseUrl, pathToResolve)\n      ),\n    });\n  }\n  // If there is no match-all path specified in the paths section of tsconfig, then try to match\n  // all paths relative to baseUrl, this is how typescript works.\n  if (!paths[\"*\"] && addMatchAll) {\n    absolutePaths.push({\n      pattern: \"*\",\n      paths: [`${absoluteBaseUrl.replace(/\\/$/, \"\")}/*`],\n    });\n  }\n\n  return absolutePaths;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/mapping-entry.ts:sortByLongestPrefix",
    "file": "node_modules/tsconfig-paths/src/mapping-entry.ts",
    "symbol": "sortByLongestPrefix",
    "startLine": 55,
    "endLine": 59,
    "text": "function sortByLongestPrefix(arr: Array<string>): Array<string> {\n  return arr\n    .concat()\n    .sort((a: string, b: string) => getPrefixLength(b) - getPrefixLength(a));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/mapping-entry.ts:getPrefixLength",
    "file": "node_modules/tsconfig-paths/src/mapping-entry.ts",
    "symbol": "getPrefixLength",
    "startLine": 61,
    "endLine": 64,
    "text": "function getPrefixLength(pattern: string): number {\n  const prefixLength = pattern.indexOf(\"*\");\n  return pattern.substr(0, prefixLength).length;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-async.ts:createMatchPathAsync",
    "file": "node_modules/tsconfig-paths/src/match-path-async.ts",
    "symbol": "createMatchPathAsync",
    "startLine": 26,
    "endLine": 54,
    "text": "export function createMatchPathAsync(\n  absoluteBaseUrl: string,\n  paths: { [key: string]: Array<string> },\n  mainFields: string[] = [\"main\"],\n  addMatchAll: boolean = true\n): MatchPathAsync {\n  const absolutePaths = MappingEntry.getAbsoluteMappingEntries(\n    absoluteBaseUrl,\n    paths,\n    addMatchAll\n  );\n\n  return (\n    requestedModule: string,\n    readJson: Filesystem.ReadJsonAsync | undefined,\n    fileExists: Filesystem.FileExistsAsync | undefined,\n    extensions: ReadonlyArray<string> | undefined,\n    callback: MatchPathAsyncCallback\n  ) =>\n    matchFromAbsolutePathsAsync(\n      absolutePaths,\n      requestedModule,\n      readJson,\n      fileExists,\n      extensions,\n      callback,\n      mainFields\n    );\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-async.ts:matchFromAbsolutePathsAsync",
    "file": "node_modules/tsconfig-paths/src/match-path-async.ts",
    "symbol": "matchFromAbsolutePathsAsync",
    "startLine": 59,
    "endLine": 86,
    "text": "export function matchFromAbsolutePathsAsync(\n  absolutePathMappings: ReadonlyArray<MappingEntry.MappingEntry>,\n  requestedModule: string,\n  readJson: Filesystem.ReadJsonAsync = Filesystem.readJsonFromDiskAsync,\n  fileExists: Filesystem.FileExistsAsync = Filesystem.fileExistsAsync,\n  extensions: ReadonlyArray<string> = Object.keys(require.extensions),\n  callback: MatchPathAsyncCallback,\n  mainFields: string[] = [\"main\"]\n): void {\n  const tryPaths = TryPath.getPathsToTry(\n    extensions,\n    absolutePathMappings,\n    requestedModule\n  );\n\n  if (!tryPaths) {\n    return callback();\n  }\n\n  findFirstExistingPath(\n    tryPaths,\n    readJson,\n    fileExists,\n    callback,\n    0,\n    mainFields\n  );\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-async.ts:findFirstExistingMainFieldMappedFile",
    "file": "node_modules/tsconfig-paths/src/match-path-async.ts",
    "symbol": "findFirstExistingMainFieldMappedFile",
    "startLine": 88,
    "endLine": 129,
    "text": "function findFirstExistingMainFieldMappedFile(\n  packageJson: Filesystem.PackageJson,\n  mainFields: string[],\n  packageJsonPath: string,\n  fileExistsAsync: Filesystem.FileExistsAsync,\n  doneCallback: (err?: Error, filepath?: string) => void,\n  index: number = 0\n): void {\n  if (index >= mainFields.length) {\n    return doneCallback(undefined, undefined);\n  }\n\n  const tryNext = () =>\n    findFirstExistingMainFieldMappedFile(\n      packageJson,\n      mainFields,\n      packageJsonPath,\n      fileExistsAsync,\n      doneCallback,\n      index + 1\n    );\n\n  const mainFieldMapping = packageJson[mainFields[index]];\n  if (typeof mainFieldMapping !== \"string\") {\n    // Skip mappings that are not pointers to replacement files\n    return tryNext();\n  }\n\n  const mappedFilePath = path.join(\n    path.dirname(packageJsonPath),\n    mainFieldMapping\n  );\n  fileExistsAsync(mappedFilePath, (err?: Error, exists?: boolean) => {\n    if (err) {\n      return doneCallback(err);\n    }\n    if (exists) {\n      return doneCallback(undefined, mappedFilePath);\n    }\n    return tryNext();\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-async.ts:findFirstExistingPath",
    "file": "node_modules/tsconfig-paths/src/match-path-async.ts",
    "symbol": "findFirstExistingPath",
    "startLine": 132,
    "endLine": 218,
    "text": "function findFirstExistingPath(\n  tryPaths: ReadonlyArray<TryPath.TryPath>,\n  readJson: Filesystem.ReadJsonAsync,\n  fileExists: Filesystem.FileExistsAsync,\n  doneCallback: MatchPathAsyncCallback,\n  index: number = 0,\n  mainFields: string[] = [\"main\"]\n): void {\n  const tryPath = tryPaths[index];\n  if (\n    tryPath.type === \"file\" ||\n    tryPath.type === \"extension\" ||\n    tryPath.type === \"index\"\n  ) {\n    fileExists(tryPath.path, (err: Error, exists: boolean) => {\n      if (err) {\n        return doneCallback(err);\n      }\n      if (exists) {\n        return doneCallback(undefined, TryPath.getStrippedPath(tryPath));\n      }\n      if (index === tryPaths.length - 1) {\n        return doneCallback();\n      }\n      // Continue with the next path\n      return findFirstExistingPath(\n        tryPaths,\n        readJson,\n        fileExists,\n        doneCallback,\n        index + 1,\n        mainFields\n      );\n    });\n  } else if (tryPath.type === \"package\") {\n    readJson(tryPath.path, (err, packageJson) => {\n      if (err) {\n        return doneCallback(err);\n      }\n      if (packageJson) {\n        return findFirstExistingMainFieldMappedFile(\n          packageJson,\n          mainFields,\n          tryPath.path,\n          fileExists,\n          (mainFieldErr?: Error, mainFieldMappedFile?: string) => {\n            if (mainFieldErr) {\n              return doneCallback(mainFieldErr);\n            }\n            if (mainFieldMappedFile) {\n              return doneCallback(undefined, mainFieldMappedFile);\n            }\n\n            // No field in package json was a valid option. Continue with the next path.\n            return findFirstExistingPath(\n              tryPaths,\n              readJson,\n              fileExists,\n              doneCallback,\n              index + 1,\n              mainFields\n            );\n          }\n        );\n      }\n\n      // This is async code, we need to return unconditionally, otherwise the code still falls\n      // through and keeps recursing. While this might work in general, libraries that use neo-async\n      // like Webpack will actually not allow you to call the same callback twice.\n      //\n      // An example of where this caused issues:\n      // https://github.com/dividab/tsconfig-paths-webpack-plugin/issues/11\n      //\n      // Continue with the next path\n      return findFirstExistingPath(\n        tryPaths,\n        readJson,\n        fileExists,\n        doneCallback,\n        index + 1,\n        mainFields\n      );\n    });\n  } else {\n    TryPath.exhaustiveTypeException(tryPath.type);\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-sync.ts:createMatchPath",
    "file": "node_modules/tsconfig-paths/src/match-path-sync.ts",
    "symbol": "createMatchPath",
    "startLine": 26,
    "endLine": 52,
    "text": "export function createMatchPath(\n  absoluteBaseUrl: string,\n  paths: { [key: string]: Array<string> },\n  mainFields: string[] = [\"main\"],\n  addMatchAll: boolean = true\n): MatchPath {\n  const absolutePaths = MappingEntry.getAbsoluteMappingEntries(\n    absoluteBaseUrl,\n    paths,\n    addMatchAll\n  );\n\n  return (\n    requestedModule: string,\n    readJson?: Filesystem.ReadJsonSync,\n    fileExists?: Filesystem.FileExistsSync,\n    extensions?: Array<string>\n  ) =>\n    matchFromAbsolutePaths(\n      absolutePaths,\n      requestedModule,\n      readJson,\n      fileExists,\n      extensions,\n      mainFields\n    );\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-sync.ts:matchFromAbsolutePaths",
    "file": "node_modules/tsconfig-paths/src/match-path-sync.ts",
    "symbol": "matchFromAbsolutePaths",
    "startLine": 64,
    "endLine": 83,
    "text": "export function matchFromAbsolutePaths(\n  absolutePathMappings: ReadonlyArray<MappingEntry.MappingEntry>,\n  requestedModule: string,\n  readJson: Filesystem.ReadJsonSync = Filesystem.readJsonFromDiskSync,\n  fileExists: Filesystem.FileExistsSync = Filesystem.fileExistsSync,\n  extensions: Array<string> = Object.keys(require.extensions),\n  mainFields: string[] = [\"main\"]\n): string | undefined {\n  const tryPaths = TryPath.getPathsToTry(\n    extensions,\n    absolutePathMappings,\n    requestedModule\n  );\n\n  if (!tryPaths) {\n    return undefined;\n  }\n\n  return findFirstExistingPath(tryPaths, readJson, fileExists, mainFields);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-sync.ts:findFirstExistingMainFieldMappedFile",
    "file": "node_modules/tsconfig-paths/src/match-path-sync.ts",
    "symbol": "findFirstExistingMainFieldMappedFile",
    "startLine": 85,
    "endLine": 106,
    "text": "function findFirstExistingMainFieldMappedFile(\n  packageJson: Filesystem.PackageJson,\n  mainFields: string[],\n  packageJsonPath: string,\n  fileExists: Filesystem.FileExistsSync\n): string | undefined {\n  for (let index = 0; index < mainFields.length; index++) {\n    const mainFieldName = mainFields[index];\n    const candidateMapping = packageJson[mainFieldName];\n    if (candidateMapping && typeof candidateMapping === \"string\") {\n      const candidateFilePath = path.join(\n        path.dirname(packageJsonPath),\n        candidateMapping\n      );\n      if (fileExists(candidateFilePath)) {\n        return candidateFilePath;\n      }\n    }\n  }\n\n  return undefined;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-sync.ts:findFirstExistingPath",
    "file": "node_modules/tsconfig-paths/src/match-path-sync.ts",
    "symbol": "findFirstExistingPath",
    "startLine": 108,
    "endLine": 141,
    "text": "function findFirstExistingPath(\n  tryPaths: ReadonlyArray<TryPath.TryPath>,\n  readJson: Filesystem.ReadJsonSync = Filesystem.readJsonFromDiskSync,\n  fileExists: Filesystem.FileExistsSync,\n  mainFields: string[] = [\"main\"]\n): string | undefined {\n  for (const tryPath of tryPaths) {\n    if (\n      tryPath.type === \"file\" ||\n      tryPath.type === \"extension\" ||\n      tryPath.type === \"index\"\n    ) {\n      if (fileExists(tryPath.path)) {\n        return TryPath.getStrippedPath(tryPath);\n      }\n    } else if (tryPath.type === \"package\") {\n      const packageJson: Filesystem.PackageJson = readJson(tryPath.path);\n      if (packageJson) {\n        const mainFieldMappedFile = findFirstExistingMainFieldMappedFile(\n          packageJson,\n          mainFields,\n          tryPath.path,\n          fileExists\n        );\n        if (mainFieldMappedFile) {\n          return mainFieldMappedFile;\n        }\n      }\n    } else {\n      TryPath.exhaustiveTypeException(tryPath.type);\n    }\n  }\n  return undefined;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/register.ts:getCoreModules",
    "file": "node_modules/tsconfig-paths/src/register.ts",
    "symbol": "getCoreModules",
    "startLine": 7,
    "endLine": 46,
    "text": "function getCoreModules(\n  builtinModules: string[] | undefined\n): { [key: string]: boolean } {\n  builtinModules = builtinModules || [\n    \"assert\",\n    \"buffer\",\n    \"child_process\",\n    \"cluster\",\n    \"crypto\",\n    \"dgram\",\n    \"dns\",\n    \"domain\",\n    \"events\",\n    \"fs\",\n    \"http\",\n    \"https\",\n    \"net\",\n    \"os\",\n    \"path\",\n    \"punycode\",\n    \"querystring\",\n    \"readline\",\n    \"stream\",\n    \"string_decoder\",\n    \"tls\",\n    \"tty\",\n    \"url\",\n    \"util\",\n    \"v8\",\n    \"vm\",\n    \"zlib\",\n  ];\n\n  const coreModules: { [key: string]: boolean } = {};\n  for (let module of builtinModules) {\n    coreModules[module] = true;\n  }\n\n  return coreModules;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/register.ts:register",
    "file": "node_modules/tsconfig-paths/src/register.ts",
    "symbol": "register",
    "startLine": 52,
    "endLine": 97,
    "text": "export function register(explicitParams: ExplicitParams): () => void {\n  const configLoaderResult = configLoader({\n    cwd: options.cwd,\n    explicitParams,\n  });\n\n  if (configLoaderResult.resultType === \"failed\") {\n    console.warn(\n      `${configLoaderResult.message}. tsconfig-paths will be skipped`\n    );\n\n    return noOp;\n  }\n\n  const matchPath = createMatchPath(\n    configLoaderResult.absoluteBaseUrl,\n    configLoaderResult.paths,\n    configLoaderResult.mainFields,\n    configLoaderResult.addMatchAll\n  );\n\n  // Patch node's module loading\n  // tslint:disable-next-line:no-require-imports variable-name\n  const Module = require(\"module\");\n  const originalResolveFilename = Module._resolveFilename;\n  const coreModules = getCoreModules(Module.builtinModules);\n  // tslint:disable-next-line:no-any\n  Module._resolveFilename = function (request: string, _parent: any): string {\n    const isCoreModule = coreModules.hasOwnProperty(request);\n    if (!isCoreModule) {\n      const found = matchPath(request);\n      if (found) {\n        const modifiedArguments = [found, ...[].slice.call(arguments, 1)]; // Passes all arguments. Even those that is not specified above.\n        // tslint:disable-next-line:no-invalid-this\n        return originalResolveFilename.apply(this, modifiedArguments);\n      }\n    }\n    // tslint:disable-next-line:no-invalid-this\n    return originalResolveFilename.apply(this, arguments);\n  };\n\n  return () => {\n    // Return node's module loading to original state.\n    Module._resolveFilename = originalResolveFilename;\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/try-path.ts:getPathsToTry",
    "file": "node_modules/tsconfig-paths/src/try-path.ts",
    "symbol": "getPathsToTry",
    "startLine": 18,
    "endLine": 56,
    "text": "export function getPathsToTry(\n  extensions: ReadonlyArray<string>,\n  absolutePathMappings: ReadonlyArray<MappingEntry>,\n  requestedModule: string\n): ReadonlyArray<TryPath> | undefined {\n  if (!absolutePathMappings || !requestedModule || requestedModule[0] === \".\") {\n    return undefined;\n  }\n\n  const pathsToTry: Array<TryPath> = [];\n  for (const entry of absolutePathMappings) {\n    const starMatch =\n      entry.pattern === requestedModule\n        ? \"\"\n        : matchStar(entry.pattern, requestedModule);\n    if (starMatch !== undefined) {\n      for (const physicalPathPattern of entry.paths) {\n        const physicalPath = physicalPathPattern.replace(\"*\", starMatch);\n        pathsToTry.push({ type: \"file\", path: physicalPath });\n        pathsToTry.push(\n          ...extensions.map(\n            (e) => ({ type: \"extension\", path: physicalPath + e } as TryPath)\n          )\n        );\n        pathsToTry.push({\n          type: \"package\",\n          path: path.join(physicalPath, \"/package.json\"),\n        });\n        const indexPath = path.join(physicalPath, \"/index\");\n        pathsToTry.push(\n          ...extensions.map(\n            (e) => ({ type: \"index\", path: indexPath + e } as TryPath)\n          )\n        );\n      }\n    }\n  }\n  return pathsToTry.length === 0 ? undefined : pathsToTry;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/try-path.ts:getStrippedPath",
    "file": "node_modules/tsconfig-paths/src/try-path.ts",
    "symbol": "getStrippedPath",
    "startLine": 59,
    "endLine": 69,
    "text": "export function getStrippedPath(tryPath: TryPath): string {\n  return tryPath.type === \"index\"\n    ? dirname(tryPath.path)\n    : tryPath.type === \"file\"\n    ? tryPath.path\n    : tryPath.type === \"extension\"\n    ? removeExtension(tryPath.path)\n    : tryPath.type === \"package\"\n    ? tryPath.path\n    : exhaustiveTypeException(tryPath.type);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/try-path.ts:exhaustiveTypeException",
    "file": "node_modules/tsconfig-paths/src/try-path.ts",
    "symbol": "exhaustiveTypeException",
    "startLine": 71,
    "endLine": 73,
    "text": "export function exhaustiveTypeException(check: never): never {\n  throw new Error(`Unknown type ${check}`);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/try-path.ts:matchStar",
    "file": "node_modules/tsconfig-paths/src/try-path.ts",
    "symbol": "matchStar",
    "startLine": 82,
    "endLine": 102,
    "text": "function matchStar(pattern: string, search: string): string | undefined {\n  if (search.length < pattern.length) {\n    return undefined;\n  }\n  if (pattern === \"*\") {\n    return search;\n  }\n  const star = pattern.indexOf(\"*\");\n  if (star === -1) {\n    return undefined;\n  }\n  const part1 = pattern.substring(0, star);\n  const part2 = pattern.substring(star + 1);\n  if (search.substr(0, star) !== part1) {\n    return undefined;\n  }\n  if (search.substr(search.length - part2.length) !== part2) {\n    return undefined;\n  }\n  return search.substr(star, search.length - part2.length);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/tsconfig-loader.ts:tsConfigLoader",
    "file": "node_modules/tsconfig-paths/src/tsconfig-loader.ts",
    "symbol": "tsConfigLoader",
    "startLine": 36,
    "endLine": 48,
    "text": "export function tsConfigLoader({\n  getEnv,\n  cwd,\n  loadSync = loadSyncDefault,\n}: TsConfigLoaderParams): TsConfigLoaderResult {\n  const TS_NODE_PROJECT = getEnv(\"TS_NODE_PROJECT\");\n  const TS_NODE_BASEURL = getEnv(\"TS_NODE_BASEURL\");\n\n  // tsconfig.loadSync handles if TS_NODE_PROJECT is a file or directory\n  // and also overrides baseURL if TS_NODE_BASEURL is available.\n  const loadResult = loadSync(cwd, TS_NODE_PROJECT, TS_NODE_BASEURL);\n  return loadResult;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/tsconfig-loader.ts:loadSyncDefault",
    "file": "node_modules/tsconfig-paths/src/tsconfig-loader.ts",
    "symbol": "loadSyncDefault",
    "startLine": 50,
    "endLine": 75,
    "text": "function loadSyncDefault(\n  cwd: string,\n  filename?: string,\n  baseUrl?: string\n): TsConfigLoaderResult {\n  // Tsconfig.loadSync uses path.resolve. This is why we can use an absolute path as filename\n\n  const configPath = resolveConfigPath(cwd, filename);\n\n  if (!configPath) {\n    return {\n      tsConfigPath: undefined,\n      baseUrl: undefined,\n      paths: undefined,\n    };\n  }\n  const config = loadTsconfig(configPath);\n\n  return {\n    tsConfigPath: configPath,\n    baseUrl:\n      baseUrl ||\n      (config && config.compilerOptions && config.compilerOptions.baseUrl),\n    paths: config && config.compilerOptions && config.compilerOptions.paths,\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/tsconfig-loader.ts:resolveConfigPath",
    "file": "node_modules/tsconfig-paths/src/tsconfig-loader.ts",
    "symbol": "resolveConfigPath",
    "startLine": 77,
    "endLine": 92,
    "text": "function resolveConfigPath(cwd: string, filename?: string): string | undefined {\n  if (filename) {\n    const absolutePath = fs.lstatSync(filename).isDirectory()\n      ? path.resolve(filename, \"./tsconfig.json\")\n      : path.resolve(cwd, filename);\n\n    return absolutePath;\n  }\n\n  if (fs.statSync(cwd).isFile()) {\n    return path.resolve(cwd);\n  }\n\n  const configAbsolutePath = walkForTsConfig(cwd);\n  return configAbsolutePath ? path.resolve(configAbsolutePath) : undefined;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/tsconfig-loader.ts:walkForTsConfig",
    "file": "node_modules/tsconfig-paths/src/tsconfig-loader.ts",
    "symbol": "walkForTsConfig",
    "startLine": 94,
    "endLine": 111,
    "text": "export function walkForTsConfig(\n  directory: string,\n  existsSync: (path: string) => boolean = fs.existsSync\n): string | undefined {\n  const configPath = path.join(directory, \"./tsconfig.json\");\n  if (existsSync(configPath)) {\n    return configPath;\n  }\n\n  const parentDirectory = path.join(directory, \"../\");\n\n  // If we reached the top\n  if (directory === parentDirectory) {\n    return undefined;\n  }\n\n  return walkForTsConfig(parentDirectory, existsSync);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/tsconfig-loader.ts:loadTsconfig",
    "file": "node_modules/tsconfig-paths/src/tsconfig-loader.ts",
    "symbol": "loadTsconfig",
    "startLine": 113,
    "endLine": 162,
    "text": "export function loadTsconfig(\n  configFilePath: string,\n  existsSync: (path: string) => boolean = fs.existsSync,\n  readFileSync: (filename: string) => string = (filename: string) =>\n    fs.readFileSync(filename, \"utf8\")\n): Tsconfig | undefined {\n  if (!existsSync(configFilePath)) {\n    return undefined;\n  }\n\n  const configString = readFileSync(configFilePath);\n  const cleanedJson = StripBom(configString);\n  let config: Tsconfig;\n  try {\n    config = JSON5.parse(cleanedJson);\n  } catch (e) {\n    throw new Error(`${configFilePath} is malformed ${e.message}`);\n  }\n\n  let extendedConfig = config.extends;\n  if (extendedConfig) {\n    let base: Tsconfig;\n\n    if (Array.isArray(extendedConfig)) {\n      base = extendedConfig.reduce(\n        (currBase, extendedConfigElement) =>\n          mergeTsconfigs(\n            currBase,\n            loadTsconfigFromExtends(\n              configFilePath,\n              extendedConfigElement,\n              existsSync,\n              readFileSync\n            )\n          ),\n        {}\n      );\n    } else {\n      base = loadTsconfigFromExtends(\n        configFilePath,\n        extendedConfig,\n        existsSync,\n        readFileSync\n      );\n    }\n\n    return mergeTsconfigs(base, config);\n  }\n  return config;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/tsconfig-loader.ts:loadTsconfigFromExtends",
    "file": "node_modules/tsconfig-paths/src/tsconfig-loader.ts",
    "symbol": "loadTsconfigFromExtends",
    "startLine": 168,
    "endLine": 209,
    "text": "function loadTsconfigFromExtends(\n  configFilePath: string,\n  extendedConfigValue: string,\n  // eslint-disable-next-line no-shadow\n  existsSync: (path: string) => boolean,\n  readFileSync: (filename: string) => string\n): Tsconfig {\n  if (\n    typeof extendedConfigValue === \"string\" &&\n    extendedConfigValue.indexOf(\".json\") === -1\n  ) {\n    extendedConfigValue += \".json\";\n  }\n  const currentDir = path.dirname(configFilePath);\n  let extendedConfigPath = path.join(currentDir, extendedConfigValue);\n  if (\n    extendedConfigValue.indexOf(\"/\") !== -1 &&\n    extendedConfigValue.indexOf(\".\") !== -1 &&\n    !existsSync(extendedConfigPath)\n  ) {\n    extendedConfigPath = path.join(\n      currentDir,\n      \"node_modules\",\n      extendedConfigValue\n    );\n  }\n\n  const config =\n    loadTsconfig(extendedConfigPath, existsSync, readFileSync) || {};\n\n  // baseUrl should be interpreted as relative to extendedConfigPath,\n  // but we need to update it so it is relative to the original tsconfig being loaded\n  if (config.compilerOptions?.baseUrl) {\n    const extendsDir = path.dirname(extendedConfigValue);\n    config.compilerOptions.baseUrl = path.join(\n      extendsDir,\n      config.compilerOptions.baseUrl\n    );\n  }\n\n  return config;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/tsconfig-loader.ts:mergeTsconfigs",
    "file": "node_modules/tsconfig-paths/src/tsconfig-loader.ts",
    "symbol": "mergeTsconfigs",
    "startLine": 211,
    "endLine": 226,
    "text": "function mergeTsconfigs(\n  base: Tsconfig | undefined,\n  config: Tsconfig | undefined\n): Tsconfig {\n  base = base || {};\n  config = config || {};\n\n  return {\n    ...base,\n    ...config,\n    compilerOptions: {\n      ...base.compilerOptions,\n      ...config.compilerOptions,\n    },\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/cache.ts:QueryCache",
    "file": "packages/mcp-server/src/cache.ts",
    "symbol": "QueryCache",
    "startLine": 3,
    "endLine": 28,
    "text": "export class QueryCache {\n  private redis?: Redis;\n  private mem = new Map<string, { v: any; exp: number }>();\n  constructor(url?: string) {\n    if (url) {\n      try { this.redis = new Redis(url); } catch { this.redis = undefined; }\n    }\n  }\n  async get(key: string): Promise<any | undefined> {\n    if (this.redis) {\n      const v = await this.redis.get(key);\n      return v ? JSON.parse(v) : undefined;\n    }\n    const e = this.mem.get(key);\n    if (!e) return undefined;\n    if (Date.now() > e.exp) { this.mem.delete(key); return undefined; }\n    return e.v;\n  }\n  async set(key: string, value: any, ttlSec: number) {\n    if (this.redis) {\n      await this.redis.set(key, JSON.stringify(value), 'EX', ttlSec);\n      return;\n    }\n    this.mem.set(key, { v: value, exp: Date.now() + ttlSec * 1000 });\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/cache.ts:QueryCache.get",
    "file": "packages/mcp-server/src/cache.ts",
    "symbol": "QueryCache.get",
    "startLine": 11,
    "endLine": 20,
    "text": "  async get(key: string): Promise<any | undefined> {\n    if (this.redis) {\n      const v = await this.redis.get(key);\n      return v ? JSON.parse(v) : undefined;\n    }\n    const e = this.mem.get(key);\n    if (!e) return undefined;\n    if (Date.now() > e.exp) { this.mem.delete(key); return undefined; }\n    return e.v;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/cache.ts:QueryCache.set",
    "file": "packages/mcp-server/src/cache.ts",
    "symbol": "QueryCache.set",
    "startLine": 21,
    "endLine": 27,
    "text": "  async set(key: string, value: any, ttlSec: number) {\n    if (this.redis) {\n      await this.redis.set(key, JSON.stringify(value), 'EX', ttlSec);\n      return;\n    }\n    this.mem.set(key, { v: value, exp: Date.now() + ttlSec * 1000 });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/context_profiler.ts:profileContext",
    "file": "packages/mcp-server/src/context_profiler.ts",
    "symbol": "profileContext",
    "startLine": 49,
    "endLine": 69,
    "text": "export function profileContext(query: string, requestedTopK: number): ContextProfile {\n  const trimmed = query.trim();\n  for (const candidate of KEYWORDS) {\n    if (candidate.words.some(re => re.test(trimmed))) {\n      return {\n        intent: candidate.intent,\n        tokenBudget: candidate.budget,\n        requestedTopK,\n        effectiveTopK: Math.max(1, Math.min(candidate.topK, requestedTopK || candidate.topK)),\n        notes: [candidate.note],\n      };\n    }\n  }\n  return {\n    intent: 'general',\n    tokenBudget: 600,\n    requestedTopK,\n    effectiveTopK: Math.max(1, Math.min(requestedTopK || 5, 5)),\n    notes: ['General search; apply balanced context selection.'],\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/generate_telemetry.ts:parseArgs",
    "file": "packages/mcp-server/src/generate_telemetry.ts",
    "symbol": "parseArgs",
    "startLine": 5,
    "endLine": 20,
    "text": "function parseArgs(argv: string[]): { root?: string; output?: string } {\n  const result: { root?: string; output?: string } = {};\n  for (let i = 0; i < argv.length; i++) {\n    const arg = argv[i];\n    if (arg.startsWith('--root=')) {\n      result.root = arg.slice('--root='.length);\n    } else if (arg === '--root' && argv[i + 1]) {\n      result.root = argv[++i];\n    } else if (arg.startsWith('--output=')) {\n      result.output = arg.slice('--output='.length);\n    } else if (arg === '--output' && argv[i + 1]) {\n      result.output = argv[++i];\n    }\n  }\n  return result;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/generate_telemetry.ts:main",
    "file": "packages/mcp-server/src/generate_telemetry.ts",
    "symbol": "main",
    "startLine": 22,
    "endLine": 28,
    "text": "function main() {\n  const args = parseArgs(process.argv.slice(2));\n  const repoRoot = args.root ? path.resolve(args.root) : process.cwd();\n  const result = generate_telemetry_panel(repoRoot, args.output);\n  // eslint-disable-next-line no-console\n  console.log(JSON.stringify(result, null, 2));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/graph_store.ts:GraphStore",
    "file": "packages/mcp-server/src/graph_store.ts",
    "symbol": "GraphStore",
    "startLine": 4,
    "endLine": 74,
    "text": "export class GraphStore {\n  private db: Database.Database;\n  constructor(dbPath: string) {\n    const resolved = path.resolve(dbPath);\n    this.db = new Database(resolved);\n    this.bootstrap();\n  }\n  private bootstrap() {\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS files (\n        id INTEGER PRIMARY KEY,\n        path TEXT UNIQUE\n      );\n      CREATE TABLE IF NOT EXISTS symbols (\n        id INTEGER PRIMARY KEY,\n        file_id INTEGER,\n        name TEXT,\n        kind TEXT,\n        start_line INTEGER,\n        end_line INTEGER,\n        FOREIGN KEY(file_id) REFERENCES files(id)\n      );\n      CREATE TABLE IF NOT EXISTS edges (\n        from_file INTEGER,\n        to_file INTEGER,\n        kind TEXT,\n        UNIQUE(from_file, to_file, kind)\n      );\n    `);\n  }\n  listSymbols(file?: string) {\n    if (file) {\n      const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(file) as any;\n      if (!row) return [] as any[];\n      return this.db.prepare('SELECT name, kind, start_line AS startLine, end_line AS endLine FROM symbols WHERE file_id=?').all(row.id) as any[];\n    }\n    return this.db.prepare('SELECT f.path AS file, s.name, s.kind, s.start_line AS startLine, s.end_line AS endLine FROM symbols s JOIN files f ON s.file_id=f.id').all() as any[];\n  }\n  listImports(filePath: string): string[] {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return [];\n    const rows = this.db\n      .prepare('SELECT f.path AS path FROM edges e JOIN files f ON e.to_file=f.id WHERE e.from_file=?')\n      .all(row.id) as Array<{ path: string }>;\n    return rows.map(r => r.path);\n  }\n  listDependents(filePath: string): string[] {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return [];\n    const rows = this.db\n      .prepare('SELECT f.path AS path FROM edges e JOIN files f ON e.from_file=f.id WHERE e.to_file=?')\n      .all(row.id) as Array<{ path: string }>;\n    return rows.map(r => r.path);\n  }\n  findRefs(symbol: string) {\n    // Simple heuristic: return files that import the file containing the symbol\n    const fileRows = this.db.prepare('SELECT f.id, f.path, s.name FROM symbols s JOIN files f ON s.file_id=f.id WHERE s.name LIKE ?').all(`%${symbol}%`);\n    if (fileRows.length === 0) return [];\n    const fileIds = fileRows.map((r: any) => r.id);\n    const placeholders = fileIds.map(() => '?').join(',');\n    const refRows = this.db.prepare(`SELECT DISTINCT f2.path AS file FROM edges e JOIN files f1 ON e.to_file=f1.id JOIN files f2 ON e.from_file=f2.id WHERE e.kind='import' AND e.to_file IN (${placeholders})`).all(...fileIds) as any[];\n    return refRows as any[];\n  }\n  degree(filePath: string) {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return 0;\n    const out = this.db.prepare('SELECT COUNT(*) AS c FROM edges WHERE from_file=?').get(row.id) as any;\n    const inn = this.db.prepare('SELECT COUNT(*) AS c FROM edges WHERE to_file=?').get(row.id) as any;\n    return (out?.c || 0) + (inn?.c || 0);\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/graph_store.ts:GraphStore.bootstrap",
    "file": "packages/mcp-server/src/graph_store.ts",
    "symbol": "GraphStore.bootstrap",
    "startLine": 11,
    "endLine": 33,
    "text": "  private bootstrap() {\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS files (\n        id INTEGER PRIMARY KEY,\n        path TEXT UNIQUE\n      );\n      CREATE TABLE IF NOT EXISTS symbols (\n        id INTEGER PRIMARY KEY,\n        file_id INTEGER,\n        name TEXT,\n        kind TEXT,\n        start_line INTEGER,\n        end_line INTEGER,\n        FOREIGN KEY(file_id) REFERENCES files(id)\n      );\n      CREATE TABLE IF NOT EXISTS edges (\n        from_file INTEGER,\n        to_file INTEGER,\n        kind TEXT,\n        UNIQUE(from_file, to_file, kind)\n      );\n    `);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/graph_store.ts:GraphStore.listSymbols",
    "file": "packages/mcp-server/src/graph_store.ts",
    "symbol": "GraphStore.listSymbols",
    "startLine": 34,
    "endLine": 41,
    "text": "  listSymbols(file?: string) {\n    if (file) {\n      const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(file) as any;\n      if (!row) return [] as any[];\n      return this.db.prepare('SELECT name, kind, start_line AS startLine, end_line AS endLine FROM symbols WHERE file_id=?').all(row.id) as any[];\n    }\n    return this.db.prepare('SELECT f.path AS file, s.name, s.kind, s.start_line AS startLine, s.end_line AS endLine FROM symbols s JOIN files f ON s.file_id=f.id').all() as any[];\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/graph_store.ts:GraphStore.listImports",
    "file": "packages/mcp-server/src/graph_store.ts",
    "symbol": "GraphStore.listImports",
    "startLine": 42,
    "endLine": 49,
    "text": "  listImports(filePath: string): string[] {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return [];\n    const rows = this.db\n      .prepare('SELECT f.path AS path FROM edges e JOIN files f ON e.to_file=f.id WHERE e.from_file=?')\n      .all(row.id) as Array<{ path: string }>;\n    return rows.map(r => r.path);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/graph_store.ts:GraphStore.listDependents",
    "file": "packages/mcp-server/src/graph_store.ts",
    "symbol": "GraphStore.listDependents",
    "startLine": 50,
    "endLine": 57,
    "text": "  listDependents(filePath: string): string[] {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return [];\n    const rows = this.db\n      .prepare('SELECT f.path AS path FROM edges e JOIN files f ON e.from_file=f.id WHERE e.to_file=?')\n      .all(row.id) as Array<{ path: string }>;\n    return rows.map(r => r.path);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/graph_store.ts:GraphStore.findRefs",
    "file": "packages/mcp-server/src/graph_store.ts",
    "symbol": "GraphStore.findRefs",
    "startLine": 58,
    "endLine": 66,
    "text": "  findRefs(symbol: string) {\n    // Simple heuristic: return files that import the file containing the symbol\n    const fileRows = this.db.prepare('SELECT f.id, f.path, s.name FROM symbols s JOIN files f ON s.file_id=f.id WHERE s.name LIKE ?').all(`%${symbol}%`);\n    if (fileRows.length === 0) return [];\n    const fileIds = fileRows.map((r: any) => r.id);\n    const placeholders = fileIds.map(() => '?').join(',');\n    const refRows = this.db.prepare(`SELECT DISTINCT f2.path AS file FROM edges e JOIN files f1 ON e.to_file=f1.id JOIN files f2 ON e.from_file=f2.id WHERE e.kind='import' AND e.to_file IN (${placeholders})`).all(...fileIds) as any[];\n    return refRows as any[];\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/graph_store.ts:GraphStore.degree",
    "file": "packages/mcp-server/src/graph_store.ts",
    "symbol": "GraphStore.degree",
    "startLine": 67,
    "endLine": 73,
    "text": "  degree(filePath: string) {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return 0;\n    const out = this.db.prepare('SELECT COUNT(*) AS c FROM edges WHERE from_file=?').get(row.id) as any;\n    const inn = this.db.prepare('SELECT COUNT(*) AS c FROM edges WHERE to_file=?').get(row.id) as any;\n    return (out?.c || 0) + (inn?.c || 0);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/indexer.ts:writeSQLite",
    "file": "packages/mcp-server/src/indexer.ts",
    "symbol": "writeSQLite",
    "startLine": 8,
    "endLine": 58,
    "text": "function writeSQLite(dbPath: string, files: FileMeta[], imports: Array<{ from: string; to: string }>) {\n  // Ensure directory and file exist\n  try {\n    const dir = path.dirname(dbPath);\n    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n    if (!fs.existsSync(dbPath)) {\n      const fd = fs.openSync(dbPath, 'a');\n      fs.closeSync(fd);\n    }\n  } catch {}\n  const db = new Database(dbPath);\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS files (\n      id INTEGER PRIMARY KEY,\n      path TEXT UNIQUE\n    );\n    CREATE TABLE IF NOT EXISTS symbols (\n      id INTEGER PRIMARY KEY,\n      file_id INTEGER,\n      name TEXT,\n      kind TEXT,\n      start_line INTEGER,\n      end_line INTEGER,\n      FOREIGN KEY(file_id) REFERENCES files(id)\n    );\n    CREATE TABLE IF NOT EXISTS edges (\n      from_file INTEGER,\n      to_file INTEGER,\n      kind TEXT,\n      UNIQUE(from_file, to_file, kind)\n    );\n  `);\n  db.exec('BEGIN');\n  db.exec('DELETE FROM edges; DELETE FROM symbols; DELETE FROM files;');\n  const insertFile = db.prepare('INSERT OR IGNORE INTO files(path) VALUES (?)');\n  const getFileId = db.prepare('SELECT id FROM files WHERE path=?');\n  const insertSym = db.prepare('INSERT INTO symbols(file_id,name,kind,start_line,end_line) VALUES (?,?,?,?,?)');\n  for (const f of files) {\n    insertFile.run(f.path);\n    const row = getFileId.get(f.path) as any;\n    for (const s of f.symbols) insertSym.run(row.id, s.name, s.kind, s.startLine, s.endLine);\n  }\n  const insertEdge = db.prepare('INSERT OR IGNORE INTO edges(from_file,to_file,kind) VALUES (?,?,?)');\n  for (const e of imports) {\n    const fromRow = getFileId.get(e.from) as any;\n    const toRow = getFileId.get(e.to) as any;\n    if (fromRow && toRow) insertEdge.run(fromRow.id, toRow.id, 'import');\n  }\n  db.exec('COMMIT');\n  db.close();\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/indexer.ts:buildEdgesWithTsMorph",
    "file": "packages/mcp-server/src/indexer.ts",
    "symbol": "buildEdgesWithTsMorph",
    "startLine": 60,
    "endLine": 97,
    "text": "function buildEdgesWithTsMorph(project: Project, rootDir: string): Array<{ from: string; to: string }> {\n  const edges: Array<{ from: string; to: string }> = [];\n  const files = project.getSourceFiles();\n  // Debug root info if needed\n  try {\n    const info = `rootDir=${rootDir}\\nfirstFile=${files[0]?.getFilePath()}`;\n    const out = path.join(process.cwd(), 'data', 'edges_info.txt');\n    fs.mkdirSync(path.dirname(out), { recursive: true });\n    fs.writeFileSync(out, info, 'utf8');\n  } catch {}\n  for (const sf of files) {\n    const fromAbs = sf.getFilePath();\n    const fromRel = path.relative(rootDir, fromAbs).replace(/\\\\/g, '/');\n    // import declarations\n    for (const imp of sf.getImportDeclarations()) {\n      const target = imp.getModuleSpecifierSourceFile();\n      if (!target) continue;\n      const toAbs = target.getFilePath();\n      if (!toAbs.startsWith(rootDir)) continue;\n      const toRel = path.relative(rootDir, toAbs).replace(/\\\\/g, '/');\n      if (fromRel !== toRel) edges.push({ from: fromRel, to: toRel });\n    }\n    // export declarations (re-exports)\n    for (const exp of sf.getExportDeclarations()) {\n      const target = exp.getModuleSpecifierSourceFile();\n      if (!target) continue;\n      const toAbs = target.getFilePath();\n      if (!toAbs.startsWith(rootDir)) continue;\n      const toRel = path.relative(rootDir, toAbs).replace(/\\\\/g, '/');\n      if (fromRel !== toRel) edges.push({ from: fromRel, to: toRel });\n    }\n  }\n  // de-duplicate\n  const key = (e: { from: string; to: string }) => `${e.from}=>${e.to}`;\n  const map = new Map<string, { from: string; to: string }>();\n  for (const e of edges) map.set(key(e), e);\n  return Array.from(map.values());\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/indexer.ts:resolveTsConfig",
    "file": "packages/mcp-server/src/indexer.ts",
    "symbol": "resolveTsConfig",
    "startLine": 99,
    "endLine": 112,
    "text": "function resolveTsConfig(): string | undefined {\n  const envPath = process.env.TS_CONFIG_PATH;\n  if (envPath && fs.existsSync(envPath)) return envPath;\n  // Prefer the package-local tsconfig to avoid relying on process.cwd()\n  const pkgTs = path.resolve(__dirname, '..', 'tsconfig.json');\n  if (fs.existsSync(pkgTs)) return pkgTs;\n  // Next, try repository root tsconfig relative to this file\n  const repoRootTs = path.resolve(__dirname, '..', '..', '..', 'tsconfig.json');\n  if (fs.existsSync(repoRootTs)) return repoRootTs;\n  // Finally, try current working directory only if it actually exists\n  const cwdTs = path.resolve(process.cwd(), 'tsconfig.json');\n  if (fs.existsSync(cwdTs)) return cwdTs;\n  return undefined;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/indexer.ts:runIndexer",
    "file": "packages/mcp-server/src/indexer.ts",
    "symbol": "runIndexer",
    "startLine": 114,
    "endLine": 201,
    "text": "export async function runIndexer(rootDir: string, outDir: string, sqlitePath?: string) {\n  const tsConfigPath = resolveTsConfig();\n  let project: Project;\n  try {\n    project = tsConfigPath\n      ? new Project({ tsConfigFilePath: tsConfigPath })\n      : new Project({ skipAddingFilesFromTsConfig: true });\n  } catch {\n    // Fall back to a minimal config that avoids reading any tsconfig\n    project = new Project({ skipAddingFilesFromTsConfig: true });\n  }\n  const tsFiles = project.addSourceFilesAtPaths([path.join(rootDir, '**/*.ts'), '!' + path.join(rootDir, '**/*.d.ts')]);\n  const fileMetas: FileMeta[] = [];\n  const semanticEntries: SemanticEntry[] = [];\n  for (const sf of tsFiles) {\n    const fullPath = sf.getFilePath();\n    const content = sf.getFullText();\n    const symbols: SymbolMeta[] = [];\n    sf.forEachDescendant(node => {\n      if (node.getKind() === SyntaxKind.FunctionDeclaration) {\n        const fn = node.asKind(SyntaxKind.FunctionDeclaration)!;\n        const name = fn.getName();\n        if (name) {\n          const start = fn.getStartLineNumber();\n          const end = fn.getEndLineNumber();\n          symbols.push({ name, kind: 'function', file: fullPath, startLine: start, endLine: end });\n        }\n      } else if (node.getKind() === SyntaxKind.ClassDeclaration) {\n        const cls = node.asKind(SyntaxKind.ClassDeclaration)!;\n        const name = cls.getName();\n        if (name) {\n          const start = cls.getStartLineNumber();\n          const end = cls.getEndLineNumber();\n          symbols.push({ name, kind: 'class', file: fullPath, startLine: start, endLine: end });\n          for (const m of cls.getMethods()) {\n            symbols.push({ name: `${name}.${m.getName()}`, kind: 'method', file: fullPath, startLine: m.getStartLineNumber(), endLine: m.getEndLineNumber() });\n          }\n        }\n      }\n    });\n    const relativePath = path.relative(rootDir, fullPath).replace(/\\\\/g, '/');\n    const fm: FileMeta = { path: relativePath, content, symbols };\n    fileMetas.push(fm);\n    const lines = content.split(/\\r?\\n/);\n    for (const s of symbols) {\n      const snippet = lines.slice(s.startLine - 1, s.endLine).join('\\n');\n      semanticEntries.push({ id: `${s.file}:${s.name}`, file: relativePath, symbol: s.name, startLine: s.startLine, endLine: s.endLine, text: snippet });\n    }\n  }\n  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });\n  fs.writeFileSync(path.join(outDir, 'index.json'), JSON.stringify(fileMetas, null, 2), 'utf8');\n  fs.writeFileSync(path.join(outDir, 'semantic_entries.json'), JSON.stringify(semanticEntries, null, 2), 'utf8');\n\n  // Build edges via madge (best-effort)\n  let edges: Array<{ from: string; to: string }> = [];\n  try {\n    const result = await madge(rootDir, {\n      fileExtensions: ['ts', 'tsx', 'js', 'jsx'],\n      // Provide a stable tsconfig path that actually exists\n      tsConfig: (tsConfigPath && fs.existsSync(tsConfigPath))\n        ? tsConfigPath\n        : path.resolve(__dirname, '..', 'tsconfig.json'),\n      detectiveOptions: { ts: { skipTypeImports: true } } as any,\n      includeNpm: false,\n      baseDir: rootDir,\n    } as any);\n    const graph = await result.obj();\n    for (const [from, tos] of Object.entries(graph)) {\n      const fromAbs = path.isAbsolute(from) ? from : path.resolve(rootDir, from);\n      const fromRel = path.relative(rootDir, fromAbs).replace(/\\\\/g, '/');\n      for (const to of tos as string[]) {\n        const toAbs = path.isAbsolute(to) ? to : path.resolve(rootDir, to);\n        const toRel = path.relative(rootDir, toAbs).replace(/\\\\/g, '/');\n        if (fromRel && toRel && fromRel !== toRel) edges.push({ from: fromRel, to: toRel });\n      }\n    }\n  } catch {\n    // ignore madge errors; fallback to ts-morph\n  }\n\n  // Fallback/union with ts-morph derived edges\n  const morphEdges = buildEdgesWithTsMorph(project, rootDir);\n  const existing = new Set(edges.map(e => `${e.from}=>${e.to}`));\n  for (const e of morphEdges) if (!existing.has(`${e.from}=>${e.to}`)) edges.push(e);\n  // Debug: dump edges\n  try { fs.writeFileSync(path.join(outDir, 'edges.json'), JSON.stringify(edges, null, 2), 'utf8'); } catch {}\n  if (sqlitePath) writeSQLite(sqlitePath, fileMetas, edges);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/index_cli.ts:main",
    "file": "packages/mcp-server/src/index_cli.ts",
    "symbol": "main",
    "startLine": 5,
    "endLine": 16,
    "text": "async function main() {\n  const envRoot = process.env.INDEX_ROOT || process.env.MCP_INDEX_ROOT || process.env.WORKSPACE_ROOT;\n  const envData = process.env.DATA_DIR || process.env.MCP_DATA_DIR;\n  const rootDir = envRoot ? path.resolve(envRoot) : process.cwd();\n  const outDir = envData ? path.resolve(envData) : path.join(process.cwd(), 'data');\n  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });\n  const sqlite = path.join(outDir, 'graph.db');\n  await runIndexer(rootDir, outDir, sqlite);\n  // Also set env so any subsequent child tools could reuse\n  process.env.DATA_DIR = outDir;\n  process.env.SQLITE_DB = sqlite;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/job_queue.ts:createQueue",
    "file": "packages/mcp-server/src/job_queue.ts",
    "symbol": "createQueue",
    "startLine": 5,
    "endLine": 9,
    "text": "export function createQueue(name = 'mcp-jobs', connection?: string) {\n  const conn = connection ? new IORedis(connection) : undefined;\n  const queue = new Queue(name, { connection: conn as any });\n  return queue;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/job_queue.ts:startWorker",
    "file": "packages/mcp-server/src/job_queue.ts",
    "symbol": "startWorker",
    "startLine": 11,
    "endLine": 20,
    "text": "export function startWorker(name = 'mcp-jobs', connection?: string) {\n  const conn = connection ? new IORedis(connection) : undefined;\n  const worker = new Worker(name, async job => {\n    if (job.name === 'reindex') {\n      const { rootDir, outDir, sqlite } = job.data as { rootDir: string; outDir: string; sqlite: string };\n      await runIndexer(rootDir, outDir, sqlite);\n    }\n  }, { connection: conn as any });\n  return worker;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/job_queue.ts:enqueueReindex",
    "file": "packages/mcp-server/src/job_queue.ts",
    "symbol": "enqueueReindex",
    "startLine": 22,
    "endLine": 24,
    "text": "export async function enqueueReindex(queue: Queue, payload: { rootDir: string; outDir: string; sqlite: string }, opts?: JobsOptions) {\n  await queue.add('reindex', payload, opts);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/langchain_bridge.ts:LangChainBridge",
    "file": "packages/mcp-server/src/langchain_bridge.ts",
    "symbol": "LangChainBridge",
    "startLine": 19,
    "endLine": 109,
    "text": "export class LangChainBridge {\n  private entries: SemanticEntry[] = [];\n  private available = false;\n  private reason = 'langchain package not detected';\n\n  constructor(private dataDir: string) {\n    this.loadEntries();\n    this.detectLangChain();\n  }\n\n  private loadEntries() {\n    const semanticPath = path.join(this.dataDir, 'semantic_entries.json');\n    if (!fs.existsSync(semanticPath)) return;\n    try {\n      const parsed = JSON.parse(fs.readFileSync(semanticPath, 'utf8')) as Array<any>;\n      this.entries = parsed.map(e => ({\n        id: String(e.id ?? `${e.file}:${e.symbol}`),\n        file: String(e.file),\n        symbol: String(e.symbol),\n        text: String(e.text ?? ''),\n      }));\n    } catch {\n      this.entries = [];\n    }\n  }\n\n  private detectLangChain() {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      require.resolve('langchain');\n      this.available = true;\n      this.reason = '';\n    } catch {\n      this.available = false;\n    }\n  }\n\n  private lexicalQuery(query: string, topK: number): BridgeResult[] {\n    const tokens = query\n      .toLowerCase()\n      .split(/\\W+/)\n      .filter(Boolean);\n    const scored = this.entries.map(entry => {\n      const text = entry.text.toLowerCase();\n      let hits = 0;\n      for (const token of tokens) {\n        if (text.includes(token)) hits += 1;\n      }\n      const score = tokens.length ? hits / tokens.length : 0;\n      return {\n        id: entry.id,\n        file: entry.file,\n        symbol: entry.symbol,\n        score,\n        snippet: entry.text.slice(0, 200),\n      };\n    });\n    return scored\n      .sort((a, b) => b.score - a.score)\n      .slice(0, Math.max(1, Math.min(topK, scored.length)));\n  }\n\n  async query(query: string, topK: number): Promise<{ available: boolean; provider: 'langchain' | 'fallback'; reason?: string; results: BridgeResult[] }> {\n    if (!this.entries.length) {\n      return {\n        available: this.available,\n        provider: this.available ? 'langchain' : 'fallback',\n        reason: this.entries.length ? undefined : 'semantic_entries.json not found or empty',\n        results: [],\n      };\n    }\n\n    if (!this.available) {\n      return {\n        available: false,\n        provider: 'fallback',\n        reason: this.reason,\n        results: this.lexicalQuery(query, topK),\n      };\n    }\n\n    // Placeholder for real LangChain integration. Until dependencies are present,\n    // fall back to lexical scoring while reporting availability.\n    return {\n      available: true,\n      provider: 'langchain',\n      reason: 'LangChain detected but no vector store configured; using lexical fallback.',\n      results: this.lexicalQuery(query, topK),\n    };\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/langchain_bridge.ts:LangChainBridge.loadEntries",
    "file": "packages/mcp-server/src/langchain_bridge.ts",
    "symbol": "LangChainBridge.loadEntries",
    "startLine": 29,
    "endLine": 43,
    "text": "  private loadEntries() {\n    const semanticPath = path.join(this.dataDir, 'semantic_entries.json');\n    if (!fs.existsSync(semanticPath)) return;\n    try {\n      const parsed = JSON.parse(fs.readFileSync(semanticPath, 'utf8')) as Array<any>;\n      this.entries = parsed.map(e => ({\n        id: String(e.id ?? `${e.file}:${e.symbol}`),\n        file: String(e.file),\n        symbol: String(e.symbol),\n        text: String(e.text ?? ''),\n      }));\n    } catch {\n      this.entries = [];\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/langchain_bridge.ts:LangChainBridge.detectLangChain",
    "file": "packages/mcp-server/src/langchain_bridge.ts",
    "symbol": "LangChainBridge.detectLangChain",
    "startLine": 45,
    "endLine": 54,
    "text": "  private detectLangChain() {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      require.resolve('langchain');\n      this.available = true;\n      this.reason = '';\n    } catch {\n      this.available = false;\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/langchain_bridge.ts:LangChainBridge.lexicalQuery",
    "file": "packages/mcp-server/src/langchain_bridge.ts",
    "symbol": "LangChainBridge.lexicalQuery",
    "startLine": 56,
    "endLine": 79,
    "text": "  private lexicalQuery(query: string, topK: number): BridgeResult[] {\n    const tokens = query\n      .toLowerCase()\n      .split(/\\W+/)\n      .filter(Boolean);\n    const scored = this.entries.map(entry => {\n      const text = entry.text.toLowerCase();\n      let hits = 0;\n      for (const token of tokens) {\n        if (text.includes(token)) hits += 1;\n      }\n      const score = tokens.length ? hits / tokens.length : 0;\n      return {\n        id: entry.id,\n        file: entry.file,\n        symbol: entry.symbol,\n        score,\n        snippet: entry.text.slice(0, 200),\n      };\n    });\n    return scored\n      .sort((a, b) => b.score - a.score)\n      .slice(0, Math.max(1, Math.min(topK, scored.length)));\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/langchain_bridge.ts:LangChainBridge.query",
    "file": "packages/mcp-server/src/langchain_bridge.ts",
    "symbol": "LangChainBridge.query",
    "startLine": 81,
    "endLine": 108,
    "text": "  async query(query: string, topK: number): Promise<{ available: boolean; provider: 'langchain' | 'fallback'; reason?: string; results: BridgeResult[] }> {\n    if (!this.entries.length) {\n      return {\n        available: this.available,\n        provider: this.available ? 'langchain' : 'fallback',\n        reason: this.entries.length ? undefined : 'semantic_entries.json not found or empty',\n        results: [],\n      };\n    }\n\n    if (!this.available) {\n      return {\n        available: false,\n        provider: 'fallback',\n        reason: this.reason,\n        results: this.lexicalQuery(query, topK),\n      };\n    }\n\n    // Placeholder for real LangChain integration. Until dependencies are present,\n    // fall back to lexical scoring while reporting availability.\n    return {\n      available: true,\n      provider: 'langchain',\n      reason: 'LangChain detected but no vector store configured; using lexical fallback.',\n      results: this.lexicalQuery(query, topK),\n    };\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp.ts:ensureIndex",
    "file": "packages/mcp-server/src/launch_mcp.ts",
    "symbol": "ensureIndex",
    "startLine": 10,
    "endLine": 12,
    "text": "async function ensureIndex(rootDir: string, outDir: string, sqlite: string) {\n  await runIndexer(rootDir, outDir, sqlite);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp.ts:tryStartMemurai",
    "file": "packages/mcp-server/src/launch_mcp.ts",
    "symbol": "tryStartMemurai",
    "startLine": 14,
    "endLine": 21,
    "text": "function tryStartMemurai() {\n  try {\n    // Start Memurai service if installed; ignore failures.\n    if (process.platform === 'win32') {\n      execSync('powershell -NoProfile -Command \"$s=Get-Service -Name Memurai* -ErrorAction SilentlyContinue | Select-Object -First 1; if ($s -and $s.Status -ne \\\"Running\\\") { Start-Service -InputObject $s }\"', { stdio: 'ignore' });\n    }\n  } catch {}\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp.ts:checkPortFree",
    "file": "packages/mcp-server/src/launch_mcp.ts",
    "symbol": "checkPortFree",
    "startLine": 23,
    "endLine": 30,
    "text": "function checkPortFree(port: number): Promise<boolean> {\n  return new Promise(resolve => {\n    const srv = net.createServer();\n    srv.once('error', () => resolve(false));\n    srv.once('listening', () => { srv.close(() => resolve(true)); });\n    srv.listen(port, '127.0.0.1');\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp.ts:findFreePort",
    "file": "packages/mcp-server/src/launch_mcp.ts",
    "symbol": "findFreePort",
    "startLine": 32,
    "endLine": 38,
    "text": "async function findFreePort(start: number, max: number): Promise<number> {\n  for (let p = start; p <= max; p++) {\n    // eslint-disable-next-line no-await-in-loop\n    if (await checkPortFree(p)) return p;\n  }\n  return start;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp.ts:waitForHealth",
    "file": "packages/mcp-server/src/launch_mcp.ts",
    "symbol": "waitForHealth",
    "startLine": 40,
    "endLine": 58,
    "text": "function waitForHealth(url: string, attempts = 30, delayMs = 500): Promise<void> {\n  return new Promise((resolve, reject) => {\n    let tries = 0;\n    const tick = () => {\n      tries++;\n      const req = http.get(url, res => {\n        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\n          res.resume();\n          resolve();\n        } else {\n          res.resume();\n          if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health timeout'));\n        }\n      });\n      req.on('error', () => { if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health error')); });\n    };\n    tick();\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp.ts:startFastApi",
    "file": "packages/mcp-server/src/launch_mcp.ts",
    "symbol": "startFastApi",
    "startLine": 60,
    "endLine": 73,
    "text": "async function startFastApi(dataDir: string, port: number) {\n  const script = path.join(process.cwd(), 'packages', 'semantic-engine', 'semantic_engine_fastapi.py');\n  const env = { ...process.env, DATA_DIR: dataDir, ENGINE_PORT: String(port) };\n  // Quick preflight to ensure python + fastapi are usable; if not, throw and fallback\n  try {\n    execSync('python -V', { stdio: 'ignore' });\n    execSync('python -c \"import fastapi,uvicorn\"', { stdio: 'ignore' });\n  } catch {\n    throw new Error('python or fastapi/uvicorn not available');\n  }\n  const proc = spawn('python', [script], { env, stdio: 'ignore', windowsHide: true });\n  await waitForHealth(`http://127.0.0.1:${port}/health`, 40, 500);\n  return proc;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp.ts:startLocalNodeEngine",
    "file": "packages/mcp-server/src/launch_mcp.ts",
    "symbol": "startLocalNodeEngine",
    "startLine": 75,
    "endLine": 123,
    "text": "function startLocalNodeEngine(dataDir: string, port: number) {\n  // Minimal in-process engine with /health and /search using naive scoring\n  const entriesPath = path.join(dataDir, 'semantic_entries.json');\n  let entries: Array<{ id: string; file: string; symbol: string; startLine: number; endLine: number; text: string }> = [];\n  try {\n    const raw = fs.readFileSync(entriesPath, 'utf8');\n    entries = JSON.parse(raw);\n  } catch {\n    entries = [];\n  }\n  const server = http.createServer((req, res) => {\n    try {\n      const url = new URL(req.url || '/', `http://127.0.0.1:${port}`);\n      if (url.pathname === '/health') {\n        res.writeHead(200, { 'content-type': 'application/json' });\n        res.end(JSON.stringify({ ok: true }));\n        return;\n      }\n      if (url.pathname === '/search') {\n        const q = (url.searchParams.get('q') || '').toLowerCase();\n        const topK = Math.max(1, Math.min(50, Number(url.searchParams.get('top_k') || '5')));\n        const scored = entries.map(e => {\n          const text = (e.text || '').toLowerCase();\n          let score = 0;\n          if (q) {\n            // naive: frequency of query tokens present\n            const tokens = q.split(/\\s+/).filter(Boolean);\n            for (const t of tokens) {\n              if (!t) continue;\n              const matches = text.split(t).length - 1;\n              score += matches;\n            }\n          }\n          return { file: e.file, symbol: e.symbol, startLine: e.startLine, endLine: e.endLine, score, snippet: e.text?.slice(0, 200) || '' };\n        }).sort((a, b) => b.score - a.score).slice(0, topK);\n        res.writeHead(200, { 'content-type': 'application/json' });\n        res.end(JSON.stringify({ query: q, results: scored }));\n        return;\n      }\n      res.writeHead(404);\n      res.end();\n    } catch (e) {\n      res.writeHead(500);\n      res.end();\n    }\n  });\n  server.listen(port, '127.0.0.1');\n  return server;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp_http.ts:ensureIndex",
    "file": "packages/mcp-server/src/launch_mcp_http.ts",
    "symbol": "ensureIndex",
    "startLine": 7,
    "endLine": 14,
    "text": "async function ensureIndex() {\n  const envRoot = process.env.INDEX_ROOT || process.env.MCP_INDEX_ROOT;\n  const envData = process.env.DATA_DIR;\n  const rootDir = envRoot ? path.resolve(envRoot) : path.join(__dirname, '..', 'src');\n  const outDir = envData ? path.resolve(envData) : path.join(__dirname, '..', 'data');\n  const sqlite = path.join(outDir, 'graph.db');\n  await runIndexer(rootDir, outDir, sqlite);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp_http.ts:waitForHealth",
    "file": "packages/mcp-server/src/launch_mcp_http.ts",
    "symbol": "waitForHealth",
    "startLine": 16,
    "endLine": 30,
    "text": "function waitForHealth(url: string, attempts = 30, delayMs = 500): Promise<void> {\n  return new Promise((resolve, reject) => {\n    let tries = 0;\n    const tick = () => {\n      tries++;\n      const req = http.get(url, res => {\n        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\n          res.resume(); resolve();\n        } else { res.resume(); if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health timeout')); }\n      });\n      req.on('error', () => { if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health error')); });\n    };\n    tick();\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp_http.ts:startFastApi",
    "file": "packages/mcp-server/src/launch_mcp_http.ts",
    "symbol": "startFastApi",
    "startLine": 32,
    "endLine": 40,
    "text": "async function startFastApi(dataDir: string, port: number) {\n  const script = path.join(process.cwd(), 'packages', 'semantic-engine', 'semantic_engine_fastapi.py');\n  const env = { ...process.env, DATA_DIR: dataDir, ENGINE_PORT: String(port) };\n  try { execSync('python -V', { stdio: 'ignore' }); execSync('python -c \"import fastapi,uvicorn\"', { stdio: 'ignore' }); }\n  catch { throw new Error('python or fastapi/uvicorn not available'); }\n  const proc = spawn('python', [script], { env, stdio: 'ignore', windowsHide: true });\n  await waitForHealth(`http://127.0.0.1:${port}/health`, 40, 500);\n  return proc;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp.ts:respond",
    "file": "packages/mcp-server/src/mcp.ts",
    "symbol": "respond",
    "startLine": 48,
    "endLine": 52,
    "text": "function respond(id: RpcRequest['id'], result?: Json, error?: { code: number; message: string }) {\n  const payload: any = { jsonrpc: '2.0', id };\n  if (error) payload.error = error; else payload.result = result ?? null;\n  process.stdout.write(JSON.stringify(payload) + '\\n');\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp.ts:handle",
    "file": "packages/mcp-server/src/mcp.ts",
    "symbol": "handle",
    "startLine": 54,
    "endLine": 196,
    "text": "async function handle(req: RpcRequest) {\n  try {\n    switch (req.method) {\n      case 'search_code': {\n        const stop = startTimer('search_code', { source: 'mcp:tools' });\n        const q = String(req.params?.q ?? '');\n        const topK = Number(req.params?.top_k ?? 5);\n        const results = await orchestrator.searchCode(q, topK);\n        const profile = orchestrator.getLastProfile();\n        respond(req.id, { query: q, profile, results });\n        stop({ query_length: q.length, result_count: results.length, top_k: topK, intent: profile?.intent });\n        return;\n      }\n      case 'get_file': {\n        const stop = startTimer('get_file', { source: 'mcp:tools' });\n        const filePath = String(req.params?.path ?? '');\n        const content = orchestrator.getFile(filePath);\n        respond(req.id, { path: filePath, content });\n        stop({ path: filePath, content_length: content.length });\n        return;\n      }\n      case 'list_symbols': {\n        const file = req.params?.file ? String(req.params.file) : undefined;\n        const symbols = graph.listSymbols(file);\n        respond(req.id, symbols);\n        return;\n      }\n      case 'find_refs': {\n        const symbol = String(req.params?.symbol ?? '');\n        const refs = graph.findRefs(symbol);\n        respond(req.id, refs);\n        return;\n      }\n      case 'plan_refactor': {\n        const file = req.params?.file ? String(req.params.file) : undefined;\n        const symbol = req.params?.symbol ? String(req.params.symbol) : undefined;\n        const goal = req.params?.goal ? String(req.params.goal) : undefined;\n        const plan = plan_refactor(orchestrator, graph, process.cwd(), { file, symbol, goal });\n        respond(req.id, plan);\n        return;\n      }\n      case 'gen_patch': {\n        const file = String(req.params?.path ?? '');\n        const operations = Array.isArray(req.params?.operations) ? (req.params.operations as any[]) : [];\n        const patch = generate_patch(process.cwd(), file, operations);\n        respond(req.id, patch);\n        return;\n      }\n      case 'apply_patch': {\n        const file = String(req.params?.path ?? '');\n        const operations = Array.isArray(req.params?.operations) ? (req.params.operations as any[]) : [];\n        const result = applyPatchOperations(process.cwd(), file, operations);\n        respond(req.id, result);\n        return;\n      }\n      case 'analyze_performance': {\n        const file = String(req.params?.path ?? '');\n        const insight = analyze_performance(process.cwd(), file);\n        respond(req.id, insight);\n        return;\n      }\n      case 'compare_versions': {\n        const pathA = String(req.params?.pathA ?? '');\n        const pathB = String(req.params?.pathB ?? '');\n        const diff = compare_versions(process.cwd(), pathA, pathB);\n        respond(req.id, diff);\n        return;\n      }\n      case 'auto_docs': {\n        const file = String(req.params?.path ?? '');\n        const docs = auto_docs(orchestrator, graph, process.cwd(), file);\n        respond(req.id, docs);\n        return;\n      }\n      case 'run_tests': {\n        const command = req.params?.command ? String(req.params.command) : 'npm test';\n        const outcome = run_tests(process.cwd(), command);\n        respond(req.id, outcome);\n        return;\n      }\n      case 'run_task': {\n        const script = String(req.params?.script ?? '');\n        const outcome = run_task(process.cwd(), script);\n        respond(req.id, outcome);\n        return;\n      }\n      case 'generate_telemetry_panel': {\n        const output = req.params?.output ? String(req.params.output) : undefined;\n        const panel = generate_telemetry_panel(process.cwd(), output);\n        respond(req.id, panel);\n        return;\n      }\n      case 'open_telemetry_webview': {\n        const regenerate = req.params?.regenerate === true;\n        const output = req.params?.output ? String(req.params.output) : undefined;\n        const webview = open_telemetry_webview(process.cwd(), { regenerate, output });\n        respond(req.id, webview);\n        return;\n      }\n      case 'langchain_query': {\n        const query = String(req.params?.q ?? '');\n        const topK = Number(req.params?.top_k ?? 5);\n        const dataDir = process.env.DATA_DIR || path.join(process.cwd(), 'data');\n        langchain_query(dataDir, query, topK)\n          .then(result => respond(req.id, result))\n          .catch(err => respond(req.id, undefined, { code: -32000, message: err?.message || 'LangChain query failed' }));\n        return;\n      }\n      case 'summarize_architecture': {\n        const summary = summarize_architecture(graph);\n        respond(req.id, summary);\n        return;\n      }\n      case 'detect_smells': {\n        const repo = String(req.params?.root ?? process.cwd());\n        const res = detect_smells(repo);\n        respond(req.id, res);\n        return;\n      }\n      case 'suggest_tests': {\n        const symbols = (req.params?.symbols ?? []) as Array<{ file: string; name: string }>;\n        const suggestions = suggest_tests(symbols);\n        respond(req.id, suggestions);\n        return;\n      }\n      case 'submit_feedback': {\n        const kind = String(req.params?.kind ?? 'up');\n        wm.feedback(kind === 'down' ? 'down' : 'up');\n        set_weights(wm.get());\n        respond(req.id, { ok: true, weights: wm.get() });\n        return;\n      }\n      case 'get_weights': {\n        respond(req.id, wm.get());\n        return;\n      }\n      default:\n        respond(req.id, undefined, { code: -32601, message: 'Method not found' });\n    }\n  } catch (e: any) {\n    respond(req.id, undefined, { code: -32000, message: e?.message || 'Internal error' });\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:getOrchestrator",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "getOrchestrator",
    "startLine": 39,
    "endLine": 46,
    "text": "function getOrchestrator(): Orchestrator {\n  if (!orchestrator) {\n    const dir = process.env.DATA_DIR || DATA_DIR;\n    const url = process.env.ENGINE_URL || ENGINE_URL;\n    orchestrator = new Orchestrator(dir, url);\n  }\n  return orchestrator;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:getGraph",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "getGraph",
    "startLine": 48,
    "endLine": 54,
    "text": "function getGraph(): GraphStore {\n  if (!graph) {\n    const db = process.env.SQLITE_DB || SQLITE_DB;\n    graph = new GraphStore(db);\n  }\n  return graph;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:write",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "write",
    "startLine": 69,
    "endLine": 69,
    "text": "function write(obj: any) { process.stdout.write(JSON.stringify(obj) + '\\n'); }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:ok",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "ok",
    "startLine": 70,
    "endLine": 70,
    "text": "function ok(id: RpcRequest['id'], result: any) { write({ jsonrpc: '2.0', id, result }); }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:err",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "err",
    "startLine": 71,
    "endLine": 75,
    "text": "function err(id: RpcRequest['id'], code: number, message: string, data?: any) {\n  const e: any = { code, message };\n  if (data) e.data = data;\n  write({ jsonrpc: '2.0', id, error: e });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:toFileUri",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "toFileUri",
    "startLine": 84,
    "endLine": 92,
    "text": "function toFileUri(p: string): string {\n  const abs = path.resolve(p);\n  const withSlashes = abs.replace(/\\\\/g, '/');\n  // Ensure file:/// prefix with Windows drive support\n  if (/^[A-Za-z]:\\//.test(withSlashes)) {\n    return `file:///${withSlashes}`;\n  }\n  return `file://${withSlashes.startsWith('/') ? '' : '/'}${withSlashes}`;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:fromFileUri",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "fromFileUri",
    "startLine": 94,
    "endLine": 107,
    "text": "function fromFileUri(u: string): string {\n  try {\n    if (!u.startsWith('file://')) return u;\n    const url = new URL(u);\n    let p = decodeURIComponent(url.pathname);\n    // Windows path like /C:/...\n    if (process.platform === 'win32' && /^\\/[A-Za-z]:\\//.test(p)) {\n      p = p.slice(1);\n    }\n    return path.normalize(p);\n  } catch {\n    return u;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:safeJoin",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "safeJoin",
    "startLine": 109,
    "endLine": 113,
    "text": "function safeJoin(root: string, rel: string): string | null {\n  const p = path.resolve(root, rel);\n  if (!p.startsWith(path.resolve(root))) return null;\n  return p;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:listFiles",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "listFiles",
    "startLine": 115,
    "endLine": 136,
    "text": "function listFiles(root: string, max = 200): string[] {\n  const out: string[] = [];\n  const stack: string[] = [root];\n  while (stack.length && out.length < max) {\n    const cur = stack.pop()!;\n    try {\n      const st = fs.statSync(cur);\n      if (st.isDirectory()) {\n        for (const name of fs.readdirSync(cur)) {\n          const full = path.join(cur, name);\n          try {\n            const s2 = fs.statSync(full);\n            if (s2.isDirectory()) stack.push(full);\n            else if (s2.isFile() && allowPath(full)) out.push(full);\n          } catch { }\n          if (out.length >= max) break;\n        }\n      } else if (st.isFile() && allowPath(cur)) out.push(cur);\n    } catch { }\n  }\n  return out;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:normalizeRepoPath",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "normalizeRepoPath",
    "startLine": 140,
    "endLine": 142,
    "text": "function normalizeRepoPath(p: string): string {\n  return p.replace(/\\\\/g, '/');\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:uniqueList",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "uniqueList",
    "startLine": 144,
    "endLine": 155,
    "text": "function uniqueList(values: string[]): string[] {\n  const seen = new Set<string>();\n  const result: string[] = [];\n  for (const value of values) {\n    const normalized = normalizeRepoPath(value);\n    if (!seen.has(normalized)) {\n      seen.add(normalized);\n      result.push(normalized);\n    }\n  }\n  return result;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:filePreview",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "filePreview",
    "startLine": 157,
    "endLine": 165,
    "text": "function filePreview(file: string, maxLines = MAX_PROMPT_SNIPPET_LINES): string {\n  try {\n    const content = getOrchestrator().getFile(file);\n    const lines = content.split(/\\r?\\n/).slice(0, maxLines);\n    return lines.join('\\n').trimEnd();\n  } catch {\n    return '';\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:formatList",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "formatList",
    "startLine": 167,
    "endLine": 171,
    "text": "function formatList(label: string, items: string[]): string {\n  const list = uniqueList(items).slice(0, 8);\n  if (!list.length) return '';\n  return `${label}:\\n${list.map(item => `- ${item}`).join('\\n')}`;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:buildPromptContext",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "buildPromptContext",
    "startLine": 173,
    "endLine": 208,
    "text": "function buildPromptContext(args: { file?: string; symbol?: string; extraNote?: string }): string {\n  const segments: string[] = [];\n  const graph = getGraph();\n  const file = args.file ? normalizeRepoPath(String(args.file)) : undefined;\n  const symbol = args.symbol ? String(args.symbol) : undefined;\n\n  if (file) {\n    segments.push(`File Scope: ${file}`);\n    const symbols = graph.listSymbols(file).slice(0, 8).map((s: any) => `${s.kind}:${s.name} (L${s.startLine}-${s.endLine})`);\n    const imports = graph.listImports(file);\n    const dependents = graph.listDependents(file);\n    const preview = filePreview(file);\n    if (symbols.length) segments.push(formatList('Local symbols', symbols));\n    const importBlock = formatList('Imports', imports);\n    if (importBlock) segments.push(importBlock);\n    const dependentsBlock = formatList('Referenced by', dependents);\n    if (dependentsBlock) segments.push(dependentsBlock);\n    if (preview) {\n      const previewLines = preview.split(/\\r?\\n/).length;\n      segments.push(`File preview (first ${Math.min(previewLines, MAX_PROMPT_SNIPPET_LINES)} lines):\\n${preview}`);\n    }\n  }\n\n  if (symbol) {\n    segments.push(`Focus symbol: ${symbol}`);\n    const refs = (graph.findRefs(symbol) as Array<{ file?: string }> | undefined) ?? [];\n    const refList = uniqueList(refs.map(r => r.file || '').filter(Boolean));\n    if (refList.length) segments.push(formatList('Referenced in', refList));\n  }\n\n  if (args.extraNote) {\n    segments.push(`Additional notes: ${args.extraNote}`);\n  }\n\n  return segments.filter(Boolean).join('\\n\\n');\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:buildPromptText",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "buildPromptText",
    "startLine": 210,
    "endLine": 246,
    "text": "function buildPromptText(name: string, args: Record<string, unknown>): string | null {\n  const fileArg = typeof args.file === 'string' ? args.file : undefined;\n  const symbolArg = typeof args.symbol === 'string' ? args.symbol : undefined;\n  const userContext = typeof args.context === 'string' ? args.context : undefined;\n  const extra = typeof args.notes === 'string' ? args.notes : undefined;\n  const baseContext = buildPromptContext({ file: fileArg, symbol: symbolArg, extraNote: extra });\n\n  const sections: string[] = [];\n  switch (name) {\n    case 'refactor': {\n      sections.push('Goal: Refactor the target code to improve readability and maintainability without altering behaviour.');\n      if (baseContext) sections.push(`Context:\\n${baseContext}`);\n      if (userContext) sections.push(`Caller notes:\\n${userContext}`);\n      sections.push('Guidelines:\\n- Preserve public contracts and side-effects.\\n- Identify technical debt hotspots and propose concise fixes.\\n- Provide updated code excerpts with rationale for each change.');\n      break;\n    }\n    case 'test': {\n      const subject = symbolArg || fileArg || 'the specified module';\n      sections.push(`Goal: Design a focused test strategy for ${subject}.`);\n      if (baseContext) sections.push(`Context:\\n${baseContext}`);\n      if (userContext) sections.push(`Caller notes:\\n${userContext}`);\n      sections.push('Checklist:\\n- Enumerate critical behaviours and edge cases.\\n- Recommend unit/integration test boundaries.\\n- Suggest fixtures or mocks and expected assertions.');\n      break;\n    }\n    case 'perf': {\n      const scope = fileArg || symbolArg || 'the target codebase';\n      sections.push(`Goal: Investigate potential performance issues in ${scope}.`);\n      if (baseContext) sections.push(`Context:\\n${baseContext}`);\n      if (userContext) sections.push(`Caller notes:\\n${userContext}`);\n      sections.push('Focus:\\n- Highlight expensive code paths or dependency hot spots.\\n- Suggest measurement approaches (profilers, metrics).\\n- Recommend optimisation tactics while keeping clarity.');\n      break;\n    }\n    default:\n      return null;\n  }\n  return sections.filter(Boolean).join('\\n\\n');\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:handle",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "handle",
    "startLine": 512,
    "endLine": 754,
    "text": "async function handle(req: RpcRequest) {\n  try {\n    // Ignore notifications (JSON-RPC without id). MCP may send sessionConfigured, etc.\n    if (req.id === null || typeof req.id === 'undefined') {\n      // Known MCP notifications we can safely ignore\n      if (req.method === 'sessionConfigured' || req.method === 'ping' || req.method === 'initialized') {\n        return; // no response for notifications\n      }\n      return; // silently ignore unknown notifications per JSON-RPC\n    }\n    if (req.method === 'initialize') {\n      return ok(req.id, {\n        protocolVersion: '2024-11-05',\n        capabilities: { tools: {}, resources: {}, prompts: {} },\n        serverInfo: { name: 'mcp-local', version: '1.0.0' }\n      });\n    }\n    if (req.method === 'ping') {\n      return ok(req.id, { ok: true });\n    }\n    if (req.method === 'shutdown') {\n      ok(req.id, { ok: true });\n      process.exit(0);\n      return;\n    }\n    if (req.method === 'tools/list') {\n      return ok(req.id, { tools });\n    }\n    if (req.method === 'tools/call') {\n      const name = String(req.params?.name || '');\n      const args = (req.params?.arguments as any) || {};\n      switch (name) {\n        case 'search_code': {\n          const orchestrator = getOrchestrator();\n          const q = String(args.q || '');\n          const topK = Number.isFinite(args.top_k) ? Number(args.top_k) : 5;\n          const results = await orchestrator.searchCode(q, topK);\n          const profile = orchestrator.getLastProfile();\n          return ok(req.id, {\n            content: [{\n              type: 'text',\n              text: JSON.stringify({ query: q, profile, results }),\n            }],\n          });\n        }\n        case 'get_file': {\n          const p = String(args.path || '');\n          const content = getOrchestrator().getFile(p);\n          return ok(req.id, { content: [{ type: 'text', text: content }] });\n        }\n        case 'list_symbols': {\n          const file = args.file ? String(args.file) : undefined;\n          const syms = getGraph().listSymbols(file);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(syms) }] });\n        }\n        case 'find_refs': {\n          const sym = String(args.symbol || '');\n          const refs = getGraph().findRefs(sym);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(refs) }] });\n        }\n        case 'plan_refactor': {\n          const file = args.file ? String(args.file) : undefined;\n          const symbol = args.symbol ? String(args.symbol) : undefined;\n          const goal = args.goal ? String(args.goal) : undefined;\n          const plan = plan_refactor(getOrchestrator(), getGraph(), process.cwd(), { file, symbol, goal });\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(plan) }] });\n        }\n        case 'gen_patch': {\n          const file = String(args.path || '');\n          const operations = Array.isArray(args.operations) ? args.operations as any[] : [];\n          const patch = generate_patch(process.cwd(), file, operations);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(patch) }] });\n        }\n        case 'apply_patch': {\n          const file = String(args.path || '');\n          const operations = Array.isArray(args.operations) ? args.operations as any[] : [];\n          const res = applyPatchOperations(process.cwd(), file, operations);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(res) }] });\n        }\n        case 'analyze_performance': {\n          const file = String(args.path || '');\n          const insight = analyze_performance(process.cwd(), file);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(insight) }] });\n        }\n        case 'compare_versions': {\n          const pathA = String(args.pathA || '');\n          const pathB = String(args.pathB || '');\n          const cmp = compare_versions(process.cwd(), pathA, pathB);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(cmp) }] });\n        }\n        case 'auto_docs': {\n          const file = String(args.path || '');\n          const docs = auto_docs(getOrchestrator(), getGraph(), process.cwd(), file);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(docs) }] });\n        }\n        case 'run_tests': {\n          const command = args.command ? String(args.command) : 'npm test';\n          const outcome = run_tests(process.cwd(), command);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(outcome) }] });\n        }\n        case 'run_task': {\n          const script = String(args.script || '');\n          const outcome = run_task(process.cwd(), script);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(outcome) }] });\n        }\n        case 'generate_telemetry_panel': {\n          const output = args.output ? String(args.output) : undefined;\n          const panel = generate_telemetry_panel(process.cwd(), output);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(panel) }] });\n        }\n        case 'open_telemetry_webview': {\n          const regenerate = args.regenerate === true;\n          const output = args.output ? String(args.output) : undefined;\n          const webview = open_telemetry_webview(process.cwd(), { regenerate, output });\n          return ok(req.id, {\n            content: [{\n              type: 'text',\n              text: webview.html,\n              mimeType: 'text/html',\n              metadata: { path: webview.path },\n            }],\n          });\n        }\n        case 'langchain_query': {\n          const q = String(args.q || '');\n          const topK = Number.isFinite(args.top_k) ? Number(args.top_k) : 5;\n          const dataDir = process.env.DATA_DIR || DATA_DIR;\n          const result = await langchain_query(dataDir, q, topK);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(result) }] });\n        }\n        case 'summarize_architecture': {\n          const s = summarize_architecture(getGraph());\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(s) }] });\n        }\n        case 'detect_smells': {\n          const root = String(args.root || process.cwd());\n          const res = detect_smells(root);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(res) }] });\n        }\n        case 'suggest_tests': {\n          const symbols = (args.symbols as Array<{ file: string; name: string }>) || [];\n          const sugg = suggest_tests(symbols);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(sugg) }] });\n        }\n        case 'submit_feedback': {\n          const kind = String(args.kind || 'up');\n          wm.feedback(kind === 'down' ? 'down' : 'up');\n          set_weights(wm.get());\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify({ ok: true, weights: wm.get() }) }] });\n        }\n        case 'get_weights': {\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(wm.get()) }] });\n        }\n        case 'resources-list': {\n          const root = args.root ? String(args.root) : ROOTS[0];\n          const max = Number.isFinite(args.max) ? Number(args.max) : 200;\n          if (!ROOTS.some(r => path.resolve(root).startsWith(path.resolve(r)))) {\n            return err(req.id, -32001, 'Root not allowed', { root, allowed: ROOTS });\n          }\n          const files = listFiles(root, max).map(f => path.normalize(f));\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(files) }] });\n        }\n        case 'resources-read': {\n          const p = String(args.path || '');\n          const maxChars = Number.isFinite(args.maxChars) ? Number(args.maxChars) : 200_000;\n          if (!ROOTS.some(r => path.resolve(p).startsWith(path.resolve(r)))) {\n            return err(req.id, -32001, 'Path not under allowed roots', { path: p, allowed: ROOTS });\n          }\n          if (!allowPath(p)) return err(req.id, -32002, 'Path not allowed by policy', { path: p });\n          try {\n            const buf = fs.readFileSync(p, 'utf8');\n            const text = buf.slice(0, maxChars);\n            return ok(req.id, { content: [{ type: 'text', text }] });\n          } catch (e: any) {\n            return err(req.id, -32003, 'Failed to read file', { path: p, error: e?.message });\n          }\n        }\n        case 'roots-list': {\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(ROOTS) }] });\n        }\n        case 'prompts-list': {\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(PROMPT_DESCRIPTORS) }] });\n        }\n        case 'prompts-call': {\n          const pname = String(args.name || '');\n          const a = (args.args || {}) as Record<string, unknown>;\n          const text = buildPromptText(pname, a);\n          if (!text) return err(req.id, -32601, 'Prompt not found', { name: pname });\n          return ok(req.id, { content: [{ type: 'text', text }] });\n        }\n        default:\n          return err(req.id, -32601, 'Tool not found');\n      }\n    }\n    // Expose top-level MCP resource/prompt methods for IDE panels\n    if (req.method === 'resources/list') {\n      const args = (req.params as any) || {};\n      const rootArg = String(args.root || args.uri || ROOTS[0]);\n      const root = rootArg.startsWith('file://') ? fromFileUri(rootArg) : rootArg;\n      const max = Number.isFinite(args.max) ? Number(args.max) : 200;\n      if (!ROOTS.some(r => path.resolve(root).startsWith(path.resolve(r)))) {\n        return err(req.id, -32001, 'Root not allowed', { root, allowed: ROOTS });\n      }\n      const files = listFiles(root, max).map(f => path.normalize(f));\n      return ok(req.id, { resources: files.map(f => ({ uri: toFileUri(f), name: path.basename(f) })) });\n    }\n    if (req.method === 'resources/read') {\n      const args = (req.params as any) || {};\n      const raw = String(args.path || args.uri || '');\n      const p = raw.startsWith('file://') ? fromFileUri(raw) : raw;\n      const maxChars = Number.isFinite(args.maxChars) ? Number(args.maxChars) : 200_000;\n      if (!ROOTS.some(r => path.resolve(p).startsWith(path.resolve(r)))) {\n        return err(req.id, -32001, 'Path not under allowed roots', { path: p, allowed: ROOTS });\n      }\n      if (!allowPath(p)) return err(req.id, -32002, 'Path not allowed by policy', { path: p });\n      try {\n        const buf = fs.readFileSync(p, 'utf8');\n        const text = buf.slice(0, maxChars);\n        const mimeType = p.endsWith('.html') ? 'text/html' : 'text/plain';\n        return ok(req.id, { contents: [{ uri: toFileUri(p), mimeType, text }] });\n      } catch (e: any) {\n        return err(req.id, -32003, 'Failed to read file', { path: p, error: e?.message });\n      }\n    }\n    if (req.method === 'roots/list') {\n      return ok(req.id, { roots: ROOTS.map(r => ({ uri: toFileUri(r), name: r })) });\n    }\n    if (req.method === 'prompts/list') {\n      return ok(req.id, { prompts: PROMPT_DESCRIPTORS });\n    }\n    if (req.method === 'prompts/call') {\n      const args = (req.params as any) || {};\n      const pname = String(args.name || '');\n      const a = (args.args || {}) as Record<string, unknown>;\n      const text = buildPromptText(pname, a);\n      if (!text) return err(req.id, -32601, 'Prompt not found', { name: pname });\n      return ok(req.id, { content: [{ type: 'text', text }] });\n    }\n    return err(req.id, -32601, 'Method not found');\n  } catch (e: any) {\n    return err(req.id, -32000, e?.message || 'Internal error');\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts:parseEnvironmentContext",
    "file": "packages/mcp-server/src/mcp_adapter.ts",
    "symbol": "parseEnvironmentContext",
    "startLine": 781,
    "endLine": 788,
    "text": "function parseEnvironmentContext(xmlStr: string): any {\n  const matches = {\n    cwd: xmlStr.match(/<cwd>(.*?)<\\/cwd>/)?.[1] || '',\n    approval_policy: xmlStr.match(/<approval_policy>(.*?)<\\/approval_policy>/)?.[1] || 'on-request',\n    sandbox_mode: xmlStr.match(/<sandbox_mode>(.*?)<\\/sandbox_mode>/)?.[1] || 'workspace-write'\n  };\n  return matches;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_http_bridge.ts:startMcpHttpBridge",
    "file": "packages/mcp-server/src/mcp_http_bridge.ts",
    "symbol": "startMcpHttpBridge",
    "startLine": 10,
    "endLine": 81,
    "text": "export function startMcpHttpBridge(port: number) {\n  const adapterPath = path.join(__dirname, 'mcp_adapter.js');\n  const child: ChildProcessByStdio<Writable, Readable, Readable> = spawn(process.execPath, [adapterPath], {\n    stdio: ['pipe', 'pipe', 'pipe'],\n    env: process.env,\n  });\n\n  const rl = readline.createInterface({ input: child.stdout });\n  const pending = new Map<string, (resp: any) => void>();\n\n  rl.on('line', line => {\n    try {\n      const obj = JSON.parse(line);\n      const id = String(obj.id);\n      const resolve = pending.get(id);\n      if (resolve) {\n        pending.delete(id);\n        resolve(obj);\n      }\n    } catch { /* ignore non-JSON lines */ }\n  });\n\n  const server = http.createServer(async (req, res) => {\n    try {\n      if (req.method !== 'POST' || !req.url) { res.writeHead(405); return res.end(); }\n      const url = new URL(req.url, `http://${req.headers.host}`);\n      if (url.pathname !== '/mcp') { res.writeHead(404); return res.end(); }\n      const chunks: Buffer[] = [];\n      req.on('data', c => chunks.push(c));\n      req.on('end', async () => {\n        try {\n          const body = Buffer.concat(chunks).toString('utf8');\n          const payload = JSON.parse(body);\n          const handleOne = (p: RpcRequest) => new Promise<any>((resolveOne, rejectOne) => {\n            if (p.id === null || typeof p.id === 'undefined') {\n              // notification: just forward and return 204 later\n              child.stdin.write(JSON.stringify(p) + '\\n');\n              resolveOne(undefined);\n              return;\n            }\n            const key = String(p.id);\n            pending.set(key, resp => resolveOne(resp));\n            child.stdin.write(JSON.stringify(p) + '\\n');\n            // Optionally add a timeout\n            setTimeout(() => {\n              if (pending.has(key)) { pending.delete(key); rejectOne(new Error('timeout')); }\n            }, 30000);\n          });\n\n          if (Array.isArray(payload)) {\n            const responses = await Promise.all(payload.map(p => handleOne(p)));\n            const filtered = responses.filter(r => r !== undefined);\n            res.writeHead(200, { 'content-type': 'application/json' });\n            res.end(JSON.stringify(filtered));\n          } else {\n            const response = await handleOne(payload);\n            if (response === undefined) { res.writeHead(204); res.end(); }\n            else { res.writeHead(200, { 'content-type': 'application/json' }); res.end(JSON.stringify(response)); }\n          }\n        } catch (e: any) {\n          res.writeHead(400, { 'content-type': 'application/json' });\n          res.end(JSON.stringify({ error: e?.message || 'bad request' }));\n        }\n      });\n    } catch {\n      res.writeHead(500); res.end();\n    }\n  });\n\n  server.listen(port, '127.0.0.1');\n  return { server, child };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/orchestrator.ts:Orchestrator",
    "file": "packages/mcp-server/src/orchestrator.ts",
    "symbol": "Orchestrator",
    "startLine": 18,
    "endLine": 81,
    "text": "export class Orchestrator {\n  private fileIndex: Map<string, FileMeta> = new Map();\n  private engineUrl: string;\n  private graph?: GraphStore;\n  private lastProfile: ContextProfile | null = null;\n\n  constructor(dataDir: string, engineUrl: string = 'http://localhost:8000', graph?: GraphStore) {\n    this.engineUrl = engineUrl;\n    this.loadIndex(dataDir);\n    this.graph = graph;\n  }\n\n  private loadIndex(dataDir: string) {\n    const idxPath = path.join(dataDir, 'index.json');\n    const json = fs.readFileSync(idxPath, 'utf8');\n    const files: FileMeta[] = JSON.parse(json);\n    for (const file of files) {\n      this.fileIndex.set(file.path, file);\n    }\n  }\n\n  public getFile(filePath: string): string {\n    const fileMeta = this.fileIndex.get(filePath);\n    if (!fileMeta) throw new Error(`File not found in index: ${filePath}`);\n    return fileMeta.content;\n  }\n\n  public getLastProfile(): ContextProfile | null {\n    return this.lastProfile ? { ...this.lastProfile } : null;\n  }\n\n  public async searchCode(query: string, topK = 5): Promise<SearchResult[]> {\n    const url = new URL('/search', this.engineUrl);\n    url.searchParams.set('q', query);\n    url.searchParams.set('top_k', topK.toString());\n    const engineResults: EngineSearchResult[] = await new Promise((resolve, reject) => {\n      const req = http.get(url.toString(), res => {\n        const chunks: Buffer[] = [];\n        res.on('data', c => chunks.push(c));\n        res.on('end', () => {\n          try {\n            const parsed = JSON.parse(Buffer.concat(chunks).toString('utf8'));\n            resolve(parsed.results as EngineSearchResult[]);\n          } catch (err) {\n            reject(err);\n          }\n        });\n      });\n      req.on('error', err => reject(err));\n    });\n    const initial: SearchResult[] = engineResults.map(er => ({ ...er } as SearchResult));\n    const profile = profileContext(query, topK);\n    const ranked = rank_hybrid(initial, query, this.graph ? (f => this.graph!.degree(f)) : undefined);\n    let curated = pack_tokens(ranked, profile.tokenBudget);\n    if (!curated.length) {\n      curated = ranked.slice(0, Math.max(1, profile.effectiveTopK));\n    }\n    if (curated.length > profile.effectiveTopK) {\n      curated = curated.slice(0, profile.effectiveTopK);\n    }\n    this.lastProfile = profile;\n    return curated;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/orchestrator.ts:Orchestrator.loadIndex",
    "file": "packages/mcp-server/src/orchestrator.ts",
    "symbol": "Orchestrator.loadIndex",
    "startLine": 30,
    "endLine": 37,
    "text": "  private loadIndex(dataDir: string) {\n    const idxPath = path.join(dataDir, 'index.json');\n    const json = fs.readFileSync(idxPath, 'utf8');\n    const files: FileMeta[] = JSON.parse(json);\n    for (const file of files) {\n      this.fileIndex.set(file.path, file);\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/orchestrator.ts:Orchestrator.getFile",
    "file": "packages/mcp-server/src/orchestrator.ts",
    "symbol": "Orchestrator.getFile",
    "startLine": 39,
    "endLine": 43,
    "text": "  public getFile(filePath: string): string {\n    const fileMeta = this.fileIndex.get(filePath);\n    if (!fileMeta) throw new Error(`File not found in index: ${filePath}`);\n    return fileMeta.content;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/orchestrator.ts:Orchestrator.getLastProfile",
    "file": "packages/mcp-server/src/orchestrator.ts",
    "symbol": "Orchestrator.getLastProfile",
    "startLine": 45,
    "endLine": 47,
    "text": "  public getLastProfile(): ContextProfile | null {\n    return this.lastProfile ? { ...this.lastProfile } : null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/orchestrator.ts:Orchestrator.searchCode",
    "file": "packages/mcp-server/src/orchestrator.ts",
    "symbol": "Orchestrator.searchCode",
    "startLine": 49,
    "endLine": 80,
    "text": "  public async searchCode(query: string, topK = 5): Promise<SearchResult[]> {\n    const url = new URL('/search', this.engineUrl);\n    url.searchParams.set('q', query);\n    url.searchParams.set('top_k', topK.toString());\n    const engineResults: EngineSearchResult[] = await new Promise((resolve, reject) => {\n      const req = http.get(url.toString(), res => {\n        const chunks: Buffer[] = [];\n        res.on('data', c => chunks.push(c));\n        res.on('end', () => {\n          try {\n            const parsed = JSON.parse(Buffer.concat(chunks).toString('utf8'));\n            resolve(parsed.results as EngineSearchResult[]);\n          } catch (err) {\n            reject(err);\n          }\n        });\n      });\n      req.on('error', err => reject(err));\n    });\n    const initial: SearchResult[] = engineResults.map(er => ({ ...er } as SearchResult));\n    const profile = profileContext(query, topK);\n    const ranked = rank_hybrid(initial, query, this.graph ? (f => this.graph!.degree(f)) : undefined);\n    let curated = pack_tokens(ranked, profile.tokenBudget);\n    if (!curated.length) {\n      curated = ranked.slice(0, Math.max(1, profile.effectiveTopK));\n    }\n    if (curated.length > profile.effectiveTopK) {\n      curated = curated.slice(0, profile.effectiveTopK);\n    }\n    this.lastProfile = profile;\n    return curated;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/policy.ts:allowPath",
    "file": "packages/mcp-server/src/policy.ts",
    "symbol": "allowPath",
    "startLine": 4,
    "endLine": 14,
    "text": "export function allowPath(p: string): boolean {\n  const basename = path.basename(p).toLowerCase();\n  if (basename.endsWith('.env') || basename.endsWith('.key') || basename.endsWith('.pem')) return false;\n  try {\n    const stat = fs.statSync(p);\n    if (stat.size > 50 * 1024 * 1024) return false;\n  } catch {\n    // ignore\n  }\n  return true;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/policy.ts:filterPaths",
    "file": "packages/mcp-server/src/policy.ts",
    "symbol": "filterPaths",
    "startLine": 16,
    "endLine": 18,
    "text": "export function filterPaths(paths: string[]): string[] {\n  return paths.filter(allowPath);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/ranker.ts:set_weights",
    "file": "packages/mcp-server/src/ranker.ts",
    "symbol": "set_weights",
    "startLine": 10,
    "endLine": 13,
    "text": "export function set_weights(w: { semantic: number; lexical: number; graph: number }) {\n  const s = w.semantic + w.lexical + w.graph;\n  weights = { semantic: w.semantic / s, lexical: w.lexical / s, graph: w.graph / s };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/ranker.ts:rank_hybrid",
    "file": "packages/mcp-server/src/ranker.ts",
    "symbol": "rank_hybrid",
    "startLine": 15,
    "endLine": 36,
    "text": "export function rank_hybrid(results: SearchResult[], query: string, fileDegree?: (file: string) => number): SearchResult[] {\n  const tokens = query.toLowerCase().split(/\\W+/).filter(Boolean);\n  const degrees = new Map<string, number>();\n  let maxDeg = 1;\n  if (fileDegree) {\n    for (const r of results) {\n      const d = fileDegree(r.file) || 0;\n      degrees.set(r.file, d);\n      if (d > maxDeg) maxDeg = d;\n    }\n  }\n  return results.map(r => {\n    const snippetLower = r.snippet.toLowerCase();\n    let hits = 0;\n    for (const t of tokens) if (snippetLower.includes(t)) hits++;\n    const lexical = tokens.length ? hits / tokens.length : 0;\n    const graph = degrees.has(r.file) ? (degrees.get(r.file)! / maxDeg) : 0;\n    const semantic = r.score; // assume engine score in [0..1]\n    const score = semantic * weights.semantic + lexical * weights.lexical + graph * weights.graph;\n    return { ...r, score };\n  }).sort((a, b) => b.score - a.score);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/ranker.ts:pack_tokens",
    "file": "packages/mcp-server/src/ranker.ts",
    "symbol": "pack_tokens",
    "startLine": 38,
    "endLine": 64,
    "text": "export function pack_tokens(results: SearchResult[], budgetTokens: number): SearchResult[] {\n  // naive token estimate: ~1 token per 4 chars\n  const estimate = (s: string) => Math.ceil(s.length / 4);\n  const selected: SearchResult[] = [];\n  let used = 0;\n  // MMR-like greedy selection with diversity by file\n  const usedFiles = new Set<string>();\n  for (const r of results) {\n    const cost = estimate(r.snippet);\n    if (used + cost > budgetTokens) continue;\n    if (usedFiles.has(r.file)) continue; // diversity: one per file first\n    selected.push(r);\n    used += cost;\n    usedFiles.add(r.file);\n  }\n  // fill remaining budget regardless of file if space left\n  if (used < budgetTokens) {\n    for (const r of results) {\n      if (selected.includes(r)) continue;\n      const cost = estimate(r.snippet);\n      if (used + cost > budgetTokens) continue;\n      selected.push(r);\n      used += cost;\n    }\n  }\n  return selected;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts:configureTelemetry",
    "file": "packages/mcp-server/src/telemetry.ts",
    "symbol": "configureTelemetry",
    "startLine": 25,
    "endLine": 34,
    "text": "export function configureTelemetry(options: { promFile?: string; jsonSnapshotFile?: string; disableProm?: boolean; disableSnapshot?: boolean } = {}) {\n  if (options.promFile) {\n    promFile = path.resolve(process.cwd(), options.promFile);\n  }\n  if (options.jsonSnapshotFile) {\n    jsonSnapshotFile = path.resolve(process.cwd(), options.jsonSnapshotFile);\n  }\n  if (typeof options.disableProm === 'boolean') promEnabled = !options.disableProm;\n  if (typeof options.disableSnapshot === 'boolean') jsonSnapshotEnabled = !options.disableSnapshot;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts:startTimer",
    "file": "packages/mcp-server/src/telemetry.ts",
    "symbol": "startTimer",
    "startLine": 36,
    "endLine": 49,
    "text": "export function startTimer(name: string, attributes: Record<string, unknown> = {}) {\n  const start = Date.now();\n  return (extra: Record<string, unknown> = {}) => {\n    const dur = Date.now() - start;\n    const payload: MetricPayload = {\n      name,\n      duration_ms: dur,\n      ts: new Date().toISOString(),\n      ...attributes,\n      ...extra,\n    };\n    writeMetric(payload);\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts:ensureDir",
    "file": "packages/mcp-server/src/telemetry.ts",
    "symbol": "ensureDir",
    "startLine": 51,
    "endLine": 53,
    "text": "function ensureDir(filePath: string) {\n  fs.mkdirSync(path.dirname(filePath), { recursive: true });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts:writeMetric",
    "file": "packages/mcp-server/src/telemetry.ts",
    "symbol": "writeMetric",
    "startLine": 55,
    "endLine": 68,
    "text": "function writeMetric(m: MetricPayload) {\n  try {\n    ensureDir(JSON_LOG_FILE);\n    fs.appendFileSync(JSON_LOG_FILE, JSON.stringify(m) + '\\n', 'utf8');\n  } catch (err) {\n    if (process.env.DEBUG_TELEMETRY) {\n      // eslint-disable-next-line no-console\n      console.warn('[telemetry] failed to write JSON log', err);\n    }\n  }\n  updateAggregates(m);\n  if (promEnabled) emitPrometheus();\n  if (jsonSnapshotEnabled) emitJsonSnapshot();\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts:aggregateKey",
    "file": "packages/mcp-server/src/telemetry.ts",
    "symbol": "aggregateKey",
    "startLine": 70,
    "endLine": 72,
    "text": "function aggregateKey(m: MetricPayload): AggregateKey {\n  return `${m.name}:${m.source ?? 'unknown'}`;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts:updateAggregates",
    "file": "packages/mcp-server/src/telemetry.ts",
    "symbol": "updateAggregates",
    "startLine": 74,
    "endLine": 82,
    "text": "function updateAggregates(m: MetricPayload) {\n  const key = aggregateKey(m);\n  const entry = aggregates.get(key) ?? { count: 0, total: 0, max: Number.MIN_SAFE_INTEGER, min: Number.MAX_SAFE_INTEGER };\n  entry.count += 1;\n  entry.total += m.duration_ms;\n  entry.max = Math.max(entry.max, m.duration_ms);\n  entry.min = Math.min(entry.min, m.duration_ms);\n  aggregates.set(key, entry);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts:emitPrometheus",
    "file": "packages/mcp-server/src/telemetry.ts",
    "symbol": "emitPrometheus",
    "startLine": 84,
    "endLine": 107,
    "text": "function emitPrometheus() {\n  try {\n    ensureDir(promFile);\n    const lines: string[] = [\n      '# HELP mcp_request_duration_ms MCP request durations in milliseconds.',\n      '# TYPE mcp_request_duration_ms summary',\n    ];\n    for (const [key, stats] of aggregates.entries()) {\n      const [name, source] = key.split(':');\n      const avg = stats.count ? stats.total / stats.count : 0;\n      lines.push(`mcp_request_duration_ms_count{name=\"${name}\",source=\"${source}\"} ${stats.count}`);\n      lines.push(`mcp_request_duration_ms_sum{name=\"${name}\",source=\"${source}\"} ${stats.total}`);\n      lines.push(`mcp_request_duration_ms_avg{name=\"${name}\",source=\"${source}\"} ${avg.toFixed(2)}`);\n      lines.push(`mcp_request_duration_ms_max{name=\"${name}\",source=\"${source}\"} ${stats.max}`);\n      lines.push(`mcp_request_duration_ms_min{name=\"${name}\",source=\"${source}\"} ${stats.min}`);\n    }\n    fs.writeFileSync(promFile, lines.join('\\n') + '\\n', 'utf8');\n  } catch (err) {\n    if (process.env.DEBUG_TELEMETRY) {\n      // eslint-disable-next-line no-console\n      console.warn('[telemetry] failed to write Prometheus output', err);\n    }\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts:emitJsonSnapshot",
    "file": "packages/mcp-server/src/telemetry.ts",
    "symbol": "emitJsonSnapshot",
    "startLine": 109,
    "endLine": 124,
    "text": "function emitJsonSnapshot() {\n  try {\n    ensureDir(jsonSnapshotFile);\n    const snapshot = Array.from(aggregates.entries()).map(([key, stats]) => {\n      const [name, source] = key.split(':');\n      const avg = stats.count ? stats.total / stats.count : 0;\n      return { name, source, count: stats.count, total: stats.total, avg, max: stats.max, min: stats.min };\n    });\n    fs.writeFileSync(jsonSnapshotFile, JSON.stringify(snapshot, null, 2), 'utf8');\n  } catch (err) {\n    if (process.env.DEBUG_TELEMETRY) {\n      // eslint-disable-next-line no-console\n      console.warn('[telemetry] failed to write JSON snapshot', err);\n    }\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:safeRelative",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "safeRelative",
    "startLine": 104,
    "endLine": 106,
    "text": "function safeRelative(root: string, target: string) {\n  return path.relative(root, target).replace(/\\\\/g, '/');\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:slicePreview",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "slicePreview",
    "startLine": 108,
    "endLine": 112,
    "text": "function slicePreview(lines: string[], startLine: number, endLine: number): string[] {\n  const start = Math.max(0, startLine - 1);\n  const end = Math.min(lines.length, endLine);\n  return lines.slice(start, Math.min(end, start + MAX_PREVIEW_LINES));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:applyOperations",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "applyOperations",
    "startLine": 114,
    "endLine": 129,
    "text": "function applyOperations(content: string, operations: PatchOperation[]): { updated: string; applied: number } {\n  let current = content;\n  let applied = 0;\n  for (const op of operations) {\n    const occurrences = typeof op.occurrences === 'number' && op.occurrences > 0 ? op.occurrences : 1;\n    let count = 0;\n    let idx = current.indexOf(op.find);\n    while (idx !== -1 && count < occurrences) {\n      current = current.slice(0, idx) + op.replace + current.slice(idx + op.find.length);\n      applied += 1;\n      count += 1;\n      idx = current.indexOf(op.find, idx + op.replace.length);\n    }\n  }\n  return { updated: current, applied };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:plan_refactor",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "plan_refactor",
    "startLine": 131,
    "endLine": 201,
    "text": "export function plan_refactor(orchestrator: Orchestrator, graph: GraphStore, repoRoot: string, input: RefactorPlanInput): RefactorPlan {\n  const targetFile = input.file ?? '';\n  let summary = 'High level refactor plan for the repository';\n  const steps: string[] = [];\n  const risks: string[] = [];\n  let imports: string[] = [];\n  let dependents: string[] = [];\n\n  if (targetFile) {\n    try {\n      const content = orchestrator.getFile(targetFile);\n      const lines = content.split(/\\r?\\n/);\n      const symbols = graph.listSymbols(targetFile) as Array<{ name: string; kind: string; startLine: number; endLine: number }> | [];\n\n      if (input.symbol) {\n        const sym = symbols.find(s => s.name === input.symbol);\n        if (sym) {\n          summary = `Targeted refactor plan for ${input.symbol}`;\n          const preview = slicePreview(lines, sym.startLine, sym.endLine);\n          steps.push(`Review ${input.symbol} (${sym.kind}) lines ${sym.startLine}-${sym.endLine}`);\n          steps.push(`Update dependent tests and call sites for ${input.symbol}`);\n          if (input.goal) steps.push(`Apply requested goal: ${input.goal}`);\n          risks.push('Run existing tests to catch regressions');\n          risks.push('Update documentation if the public API changes');\n          if (preview.length) {\n            steps.push(`Current snippet:\\n${preview.join('\\n')}`);\n          }\n        } else {\n          summary = `${input.symbol} symbol not found in GraphStore`;\n          steps.push(`Inspect ${targetFile} and verify symbol naming`);\n        }\n      } else {\n        summary = `High level refactor plan for ${targetFile}`;\n        const topSymbols = symbols.slice(0, 5).map(s => `${s.name} (${s.kind})`);\n        if (topSymbols.length) steps.push(`Review structure: ${topSymbols.join(', ')}`);\n        if (input.goal) steps.push(`Focus goal: ${input.goal}`);\n        steps.push('Simplify dependencies and deduplicate logic');\n      }\n\n      imports = graph.listImports(targetFile);\n      dependents = graph.listDependents(targetFile);\n\n      if (!imports.length && !dependents.length) {\n        risks.push('File is isolated in the dependency graph; check downstream impact manually');\n      } else {\n        if (imports.length) risks.push(`${imports.length} imports must remain coherent`);\n        if (dependents.length) risks.push(`${dependents.length} files depend on this module; plan regression tests`);\n      }\n    } catch (err: any) {\n      summary = `Failed to produce refactor plan for ${targetFile} (${err?.message ?? 'unknown error'})`;\n      steps.push('Verify that the file is indexed (run build and index tasks)');\n    }\n  } else {\n    steps.push('No target file or symbol supplied; outline global refactor goals');\n    steps.push('Use GraphStore metadata to pick high-impact modules');\n  }\n\n  if (!steps.length) steps.push('Additional context required to craft actionable steps');\n  if (!risks.length) risks.push('Follow standard code review and regression testing workflow');\n\n  return {\n    intent: input.goal ?? (input.symbol ? 'targeted-refactor' : 'structural-refactor'),\n    summary,\n    steps,\n    risks,\n    impact: {\n      imports,\n      dependents,\n    },\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:generate_patch",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "generate_patch",
    "startLine": 203,
    "endLine": 217,
    "text": "export function generate_patch(repoRoot: string, filePath: string, operations: PatchOperation[]): GeneratedPatch {\n  const abs = path.resolve(repoRoot, filePath);\n  const content = fs.readFileSync(abs, 'utf8');\n  const { updated } = applyOperations(content, operations);\n  const originalPreview = slicePreview(content.split(/\\r?\\n/), 1, MAX_PREVIEW_LINES);\n  const updatedPreview = slicePreview(updated.split(/\\r?\\n/), 1, MAX_PREVIEW_LINES);\n  return {\n    path: safeRelative(repoRoot, abs),\n    operations,\n    preview: {\n      before: originalPreview,\n      after: updatedPreview,\n    },\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:apply_patch",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "apply_patch",
    "startLine": 219,
    "endLine": 229,
    "text": "export function apply_patch(repoRoot: string, filePath: string, operations: PatchOperation[]): PatchResult {\n  const abs = path.resolve(repoRoot, filePath);\n  const content = fs.readFileSync(abs, 'utf8');\n  const { updated, applied } = applyOperations(content, operations);\n  fs.writeFileSync(abs, updated, 'utf8');\n  return {\n    path: safeRelative(repoRoot, abs),\n    applied,\n    total: operations.length,\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:analyze_performance",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "analyze_performance",
    "startLine": 231,
    "endLine": 257,
    "text": "export function analyze_performance(repoRoot: string, filePath: string): PerformanceInsight {\n  const abs = path.resolve(repoRoot, filePath);\n  const content = fs.readFileSync(abs, 'utf8');\n  const issues: string[] = [];\n  const suggestions: string[] = [];\n\n  if (/for\\s*\\([^)]*\\)[\\s\\S]*for\\s*\\(/.test(content) || /for\\s*\\([^)]*\\)[\\s\\S]*while\\s*\\(/.test(content)) {\n    issues.push('Nested loops detected');\n    suggestions.push('Flatten or refactor nested loops to reduce complexity');\n  }\n  if (/JSON\\.stringify\\(.{400,}\\)/.test(content)) {\n    issues.push('Large JSON.stringify usage may impact performance');\n    suggestions.push('Stream or chunk large JSON payloads');\n  }\n  if (/fs\\.(readFileSync|writeFileSync|readdirSync)/.test(content)) {\n    issues.push('Synchronous fs calls detected');\n    suggestions.push('Prefer async fs APIs to avoid blocking the event loop');\n  }\n  if (/await\\s+.*\\.map\\(/.test(content) && !/await\\s+Promise\\.all\\([^)]*map\\(/.test(content)) {\n    issues.push('Await inside Array.map without Promise.all');\n    suggestions.push('Wrap async map calls with Promise.all for parallel execution');\n  }\n  if (!issues.length) {\n    suggestions.push('No obvious performance smells detected; capture runtime metrics to confirm');\n  }\n  return { file: safeRelative(repoRoot, abs), issues, suggestions };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:diffLines",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "diffLines",
    "startLine": 259,
    "endLine": 276,
    "text": "function diffLines(a: string[], b: string[]) {\n  const removed: string[] = [];\n  const added: string[] = [];\n  const changed: string[] = [];\n  const len = Math.max(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    const left = a[i];\n    const right = b[i];\n    if (left === undefined) {\n      added.push(`${i + 1}: ${right}`);\n    } else if (right === undefined) {\n      removed.push(`${i + 1}: ${left}`);\n    } else if (left !== right) {\n      changed.push(`${i + 1}: ${left} -> ${right}`);\n    }\n  }\n  return { added, removed, changed };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:compare_versions",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "compare_versions",
    "startLine": 278,
    "endLine": 291,
    "text": "export function compare_versions(repoRoot: string, fileA: string, fileB: string): VersionComparison {\n  const absA = path.resolve(repoRoot, fileA);\n  const absB = path.resolve(repoRoot, fileB);\n  const contentA = fs.readFileSync(absA, 'utf8').split(/\\r?\\n/);\n  const contentB = fs.readFileSync(absB, 'utf8').split(/\\r?\\n/);\n  const diff = diffLines(contentA, contentB);\n  return {\n    fileA: safeRelative(repoRoot, absA),\n    fileB: safeRelative(repoRoot, absB),\n    added: diff.added,\n    removed: diff.removed,\n    changed: diff.changed,\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:auto_docs",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "auto_docs",
    "startLine": 293,
    "endLine": 314,
    "text": "export function auto_docs(orchestrator: Orchestrator, graph: GraphStore, repoRoot: string, filePath: string): AutoDoc {\n  const abs = path.resolve(repoRoot, filePath);\n  const rel = safeRelative(repoRoot, abs);\n  const content = orchestrator.getFile(rel);\n  const lines = content.split(/\\r?\\n/);\n  const symbols = graph.listSymbols(rel) as Array<{ name: string; kind: string; startLine: number; endLine: number }>;\n  const exports = symbols.map(s => ({\n    name: s.name,\n    kind: s.kind,\n    range: `${s.startLine}-${s.endLine}`,\n  }));\n  const summary = `${rel} contains ${symbols.length} symbols across ${lines.length} lines.`;\n  return {\n    file: rel,\n    summary,\n    exports,\n    deps: {\n      imports: graph.listImports(rel),\n      dependents: graph.listDependents(rel),\n    },\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:run_tests",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "run_tests",
    "startLine": 316,
    "endLine": 329,
    "text": "export function run_tests(repoRoot: string, testCommand = 'npm test'): TestRunResult {\n  const [cmd, ...args] = testCommand.split(/\\s+/).filter(Boolean);\n  const binary = process.platform === 'win32' && cmd === 'npm' ? 'npm.cmd' : cmd;\n  const result = spawnSync(binary, args, {\n    cwd: repoRoot,\n    encoding: 'utf8',\n  });\n  return {\n    command: testCommand,\n    status: result.status,\n    stdout: result.stdout ?? '',\n    stderr: result.stderr ?? '',\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:run_task",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "run_task",
    "startLine": 331,
    "endLine": 377,
    "text": "export function run_task(repoRoot: string, scriptName: string): TestRunResult {\n  const pkgPath = path.join(repoRoot, 'package.json');\n  if (!fs.existsSync(pkgPath)) {\n    throw new Error(`package.json not found under ${repoRoot}`);\n  }\n  const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));\n  const scripts = pkg.scripts || {};\n  if (!scripts[scriptName]) {\n    throw new Error(`Script \"${scriptName}\" is not defined in package.json`);\n  }\n  const scriptCommand = String(scripts[scriptName]);\n  const bin = process.platform === 'win32' ? 'npm.cmd' : 'npm';\n  const result = spawnSync(bin, ['run', scriptName], {\n    cwd: repoRoot,\n    encoding: 'utf8',\n  });\n  const status =\n    typeof result.status === 'number'\n      ? result.status\n      : result.error\n      ? -1\n      : 0;\n  let finalStatus = status;\n  let stdout = result.stdout ?? '';\n  let stderr = result.stderr ?? '';\n  if (finalStatus !== 0) {\n    const fallback = spawnSync(scriptCommand, {\n      cwd: repoRoot,\n      encoding: 'utf8',\n      shell: true,\n    });\n    finalStatus =\n      typeof fallback.status === 'number'\n        ? fallback.status\n        : fallback.error\n        ? -1\n        : 0;\n    stdout += fallback.stdout ?? '';\n    stderr += fallback.stderr ?? '';\n  }\n  return {\n    command: `npm run ${scriptName}`,\n    status: finalStatus,\n    stdout,\n    stderr,\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:summarize_architecture",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "summarize_architecture",
    "startLine": 379,
    "endLine": 384,
    "text": "export function summarize_architecture(graph: GraphStore) {\n  const files = graph['db'].prepare('SELECT COUNT(*) AS c FROM files').get() as any;\n  const symbols = graph['db'].prepare('SELECT COUNT(*) AS c FROM symbols').get() as any;\n  const edges = graph['db'].prepare('SELECT COUNT(*) AS c FROM edges').get() as any;\n  return { files: files?.c || 0, symbols: symbols?.c || 0, edges: edges?.c || 0 };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:detect_smells",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "detect_smells",
    "startLine": 386,
    "endLine": 405,
    "text": "export function detect_smells(repoRoot: string) {\n  const smells: Array<{ file: string; issue: string }> = [];\n  const walk = (dir: string) => {\n    for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {\n      const full = path.join(dir, entry.name);\n      if (entry.isDirectory()) {\n        if (entry.name === 'node_modules' || entry.name === 'dist' || entry.name.startsWith('.')) continue;\n        walk(full);\n      } else if (entry.isFile() && (entry.name.endsWith('.ts') || entry.name.endsWith('.tsx'))) {\n        const content = fs.readFileSync(full, 'utf8');\n        if (/TODO|FIXME/.test(content)) smells.push({ file: safeRelative(repoRoot, full), issue: 'TODO/FIXME marker present' });\n        if (content.split(/\\r?\\n/).some(line => line.length > 200)) {\n          smells.push({ file: safeRelative(repoRoot, full), issue: 'Line longer than 200 chars' });\n        }\n      }\n    }\n  };\n  walk(repoRoot);\n  return smells;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:suggest_tests",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "suggest_tests",
    "startLine": 407,
    "endLine": 409,
    "text": "export function suggest_tests(symbols: Array<{ file: string; name: string }>) {\n  return symbols.map(s => ({ symbol: s.name, suggestion: `Add unit test for ${s.name} in ${s.file}` }));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:langchain_query",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "langchain_query",
    "startLine": 411,
    "endLine": 414,
    "text": "export async function langchain_query(dataDir: string, query: string, topK = 5): Promise<LangChainQueryResult> {\n  const bridge = new LangChainBridge(dataDir);\n  return bridge.query(query, topK);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:generate_telemetry_panel",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "generate_telemetry_panel",
    "startLine": 416,
    "endLine": 473,
    "text": "export function generate_telemetry_panel(repoRoot: string, outputPath?: string): TelemetryPanelResult {\n  const logsDir = path.join(repoRoot, 'logs');\n  const snapshotPath = path.join(logsDir, 'telemetry_latest.json');\n  let entries: Array<{ name: string; source: string; count: number; total: number; avg: number; max: number; min: number }> = [];\n  if (fs.existsSync(snapshotPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(snapshotPath, 'utf8'));\n    } catch {\n      entries = [];\n    }\n  }\n  const outFile = outputPath ? path.resolve(repoRoot, outputPath) : path.join(logsDir, 'telemetry_panel.html');\n  fs.mkdirSync(path.dirname(outFile), { recursive: true });\n  const rows = entries\n    .map(\n      entry =>\n        `<tr><td>${entry.name}</td><td>${entry.source}</td><td>${entry.count}</td><td>${entry.total}</td><td>${entry.avg.toFixed(\n          2\n        )}</td><td>${entry.max}</td><td>${entry.min}</td></tr>`\n    )\n    .join('');\n  const html = `<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\" />\n  <title>MCP Telemetry Panel</title>\n  <style>\n    body { font-family: Arial, sans-serif; margin: 2rem; background: #111; color: #eee; }\n    table { border-collapse: collapse; width: 100%; }\n    th, td { border: 1px solid #444; padding: 0.5rem; text-align: left; }\n    th { background: #222; }\n    tbody tr:nth-child(even) { background: #1a1a1a; }\n  </style>\n</head>\n<body>\n  <h1>Telemetry Metrics</h1>\n  <p>Generated at ${new Date().toISOString()}</p>\n  <table>\n    <thead>\n      <tr>\n        <th>Name</th>\n        <th>Source</th>\n        <th>Count</th>\n        <th>Total (ms)</th>\n        <th>Avg (ms)</th>\n        <th>Max (ms)</th>\n        <th>Min (ms)</th>\n      </tr>\n    </thead>\n    <tbody>\n      ${rows || '<tr><td colspan=\"7\">No telemetry entries recorded.</td></tr>'}\n    </tbody>\n  </table>\n</body>\n</html>`;\n  fs.writeFileSync(outFile, html, 'utf8');\n  return { output: safeRelative(repoRoot, outFile), entries: entries.length };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:open_telemetry_webview",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "open_telemetry_webview",
    "startLine": 475,
    "endLine": 489,
    "text": "export function open_telemetry_webview(repoRoot: string, options: { regenerate?: boolean; output?: string } = {}): TelemetryWebview {\n  const shouldRegenerate = options.regenerate ?? false;\n  const preferredPath = options.output\n    ? path.resolve(repoRoot, options.output)\n    : path.join(repoRoot, 'logs', 'telemetry_panel.html');\n\n  let htmlPath = preferredPath;\n  if (shouldRegenerate || !fs.existsSync(preferredPath)) {\n    const generated = generate_telemetry_panel(repoRoot, options.output);\n    htmlPath = path.resolve(repoRoot, generated.output);\n  }\n\n  const html = fs.readFileSync(htmlPath, 'utf8');\n  return { path: safeRelative(repoRoot, htmlPath), html };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts:select_context",
    "file": "packages/mcp-server/src/tools.ts",
    "symbol": "select_context",
    "startLine": 491,
    "endLine": 504,
    "text": "export function select_context(results: SearchResult[], budgetTokens: number) {\n  if (!results.length) return results;\n  if (budgetTokens <= 0) return results;\n  const approxTokens = (snippet: string) => Math.ceil(snippet.length / 4);\n  const selected: SearchResult[] = [];\n  let used = 0;\n  for (const res of results) {\n    const cost = approxTokens(res.snippet);\n    if (used + cost > budgetTokens) continue;\n    selected.push(res);\n    used += cost;\n  }\n  return selected.length ? selected : results.slice(0, Math.max(1, Math.min(results.length, 3)));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/watcher.ts:startWatcher",
    "file": "packages/mcp-server/src/watcher.ts",
    "symbol": "startWatcher",
    "startLine": 6,
    "endLine": 23,
    "text": "export function startWatcher(rootDir: string, outDir: string, sqlitePath: string) {\n  const watcher = chokidar.watch([path.join(rootDir, '**/*.ts'), path.join(rootDir, '**/*.tsx')], {\n    ignored: [/node_modules/, /dist/, /(^|[/\\\\])\\../],\n    ignoreInitial: true,\n  });\n  const redisUrl = process.env.REDIS_URL;\n  const queue = redisUrl ? createQueue('mcp-jobs', redisUrl) : undefined;\n  const schedule = debounce(async () => {\n    if (queue) {\n      await enqueueReindex(queue, { rootDir, outDir, sqlite: sqlitePath });\n    } else {\n      await runIndexer(rootDir, outDir, sqlitePath);\n    }\n    console.log('Incremental index scheduled');\n  }, 500);\n  watcher.on('add', schedule).on('change', schedule).on('unlink', schedule);\n  return watcher;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/watcher.ts:debounce",
    "file": "packages/mcp-server/src/watcher.ts",
    "symbol": "debounce",
    "startLine": 25,
    "endLine": 31,
    "text": "function debounce(fn: () => void | Promise<void>, ms: number) {\n  let t: any;\n  return () => {\n    clearTimeout(t);\n    t = setTimeout(fn, ms);\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/weights.ts:clamp01",
    "file": "packages/mcp-server/src/weights.ts",
    "symbol": "clamp01",
    "startLine": 7,
    "endLine": 7,
    "text": "function clamp01(x: number) { return Math.max(0, Math.min(1, x)); }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/weights.ts:WeightManager",
    "file": "packages/mcp-server/src/weights.ts",
    "symbol": "WeightManager",
    "startLine": 9,
    "endLine": 34,
    "text": "export class WeightManager {\n  private file: string;\n  private w: Weights;\n  constructor(file = path.join(process.cwd(), 'weights.json')) {\n    this.file = file;\n    this.w = this.load();\n  }\n  private load(): Weights {\n    try {\n      const data = JSON.parse(fs.readFileSync(this.file, 'utf8'));\n      return { semantic: data.semantic, lexical: data.lexical, graph: data.graph } as Weights;\n    } catch { return { ...defaultWeights }; }\n  }\n  private save() { fs.writeFileSync(this.file, JSON.stringify(this.w, null, 2), 'utf8'); }\n  get(): Weights { return { ...this.w }; }\n  feedback(kind: 'up' | 'down') {\n    const delta = kind === 'up' ? 0.01 : -0.01;\n    // simple strategy: increase semantic on up, lexical on down toggles towards balance\n    this.w.semantic = clamp01(this.w.semantic + delta);\n    this.w.lexical = clamp01(this.w.lexical + (kind === 'up' ? -delta/2 : +delta/2));\n    // normalize\n    const s = this.w.semantic + this.w.lexical + this.w.graph;\n    this.w.semantic /= s; this.w.lexical /= s; this.w.graph /= s;\n    this.save();\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/weights.ts:WeightManager.load",
    "file": "packages/mcp-server/src/weights.ts",
    "symbol": "WeightManager.load",
    "startLine": 16,
    "endLine": 21,
    "text": "  private load(): Weights {\n    try {\n      const data = JSON.parse(fs.readFileSync(this.file, 'utf8'));\n      return { semantic: data.semantic, lexical: data.lexical, graph: data.graph } as Weights;\n    } catch { return { ...defaultWeights }; }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/weights.ts:WeightManager.save",
    "file": "packages/mcp-server/src/weights.ts",
    "symbol": "WeightManager.save",
    "startLine": 22,
    "endLine": 22,
    "text": "  private save() { fs.writeFileSync(this.file, JSON.stringify(this.w, null, 2), 'utf8'); }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/weights.ts:WeightManager.get",
    "file": "packages/mcp-server/src/weights.ts",
    "symbol": "WeightManager.get",
    "startLine": 23,
    "endLine": 23,
    "text": "  get(): Weights { return { ...this.w }; }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/weights.ts:WeightManager.feedback",
    "file": "packages/mcp-server/src/weights.ts",
    "symbol": "WeightManager.feedback",
    "startLine": 24,
    "endLine": 33,
    "text": "  feedback(kind: 'up' | 'down') {\n    const delta = kind === 'up' ? 0.01 : -0.01;\n    // simple strategy: increase semantic on up, lexical on down toggles towards balance\n    this.w.semantic = clamp01(this.w.semantic + delta);\n    this.w.lexical = clamp01(this.w.lexical + (kind === 'up' ? -delta/2 : +delta/2));\n    // normalize\n    const s = this.w.semantic + this.w.lexical + this.w.graph;\n    this.w.semantic /= s; this.w.lexical /= s; this.w.graph /= s;\n    this.save();\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/errors.ts:ErrorEvent",
    "file": "mcp-rag-server/node_modules/eventsource/src/errors.ts",
    "symbol": "ErrorEvent",
    "startLine": 8,
    "endLine": 78,
    "text": "export class ErrorEvent extends Event {\n  /**\n   * HTTP status code, if this was triggered by an HTTP error\n   * Note: this is not part of the spec, but is included for better error handling.\n   *\n   * @public\n   */\n  public code?: number | undefined\n\n  /**\n   * Optional message attached to the error.\n   * Note: this is not part of the spec, but is included for better error handling.\n   *\n   * @public\n   */\n  public message?: string | undefined\n\n  /**\n   * Constructs a new `ErrorEvent` instance. This is typically not called directly,\n   * but rather emitted by the `EventSource` object when an error occurs.\n   *\n   * @param type - The type of the event (should be \"error\")\n   * @param errorEventInitDict - Optional properties to include in the error event\n   */\n  constructor(\n    type: string,\n    errorEventInitDict?: {message?: string | undefined; code?: number | undefined},\n  ) {\n    super(type)\n    this.code = errorEventInitDict?.code ?? undefined\n    this.message = errorEventInitDict?.message ?? undefined\n  }\n\n  /**\n   * Node.js \"hides\" the `message` and `code` properties of the `ErrorEvent` instance,\n   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,\n   * we explicitly include the properties in the `inspect` method.\n   *\n   * This is automatically called by Node.js when you `console.log` an instance of this class.\n   *\n   * @param _depth - The current depth\n   * @param options - The options passed to `util.inspect`\n   * @param inspect - The inspect function to use (prevents having to import it from `util`)\n   * @returns A string representation of the error\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](\n    _depth: number,\n    options: {colors: boolean},\n    inspect: (obj: unknown, inspectOptions: {colors: boolean}) => string,\n  ): string {\n    return inspect(inspectableError(this), options)\n  }\n\n  /**\n   * Deno \"hides\" the `message` and `code` properties of the `ErrorEvent` instance,\n   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,\n   * we explicitly include the properties in the `inspect` method.\n   *\n   * This is automatically called by Deno when you `console.log` an instance of this class.\n   *\n   * @param inspect - The inspect function to use (prevents having to import it from `util`)\n   * @param options - The options passed to `Deno.inspect`\n   * @returns A string representation of the error\n   */\n  [Symbol.for('Deno.customInspect')](\n    inspect: (obj: unknown, inspectOptions: {colors: boolean}) => string,\n    options: {colors: boolean},\n  ): string {\n    return inspect(inspectableError(this), options)\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/errors.ts:ErrorEvent.[Symbol.for('nodejs.util.inspect.custom')]",
    "file": "mcp-rag-server/node_modules/eventsource/src/errors.ts",
    "symbol": "ErrorEvent.[Symbol.for('nodejs.util.inspect.custom')]",
    "startLine": 53,
    "endLine": 59,
    "text": "  [Symbol.for('nodejs.util.inspect.custom')](\n    _depth: number,\n    options: {colors: boolean},\n    inspect: (obj: unknown, inspectOptions: {colors: boolean}) => string,\n  ): string {\n    return inspect(inspectableError(this), options)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/errors.ts:ErrorEvent.[Symbol.for('Deno.customInspect')]",
    "file": "mcp-rag-server/node_modules/eventsource/src/errors.ts",
    "symbol": "ErrorEvent.[Symbol.for('Deno.customInspect')]",
    "startLine": 72,
    "endLine": 77,
    "text": "  [Symbol.for('Deno.customInspect')](\n    inspect: (obj: unknown, inspectOptions: {colors: boolean}) => string,\n    options: {colors: boolean},\n  ): string {\n    return inspect(inspectableError(this), options)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/errors.ts:syntaxError",
    "file": "mcp-rag-server/node_modules/eventsource/src/errors.ts",
    "symbol": "syntaxError",
    "startLine": 88,
    "endLine": 99,
    "text": "export function syntaxError(message: string): SyntaxError {\n  // If someone can figure out a way to make this work without depending on DOM/Node.js typings,\n  // and without casting to `any`, please send a PR \n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const DomException = (globalThis as any).DOMException\n  if (typeof DomException === 'function') {\n    return new DomException(message, 'SyntaxError')\n  }\n\n  return new SyntaxError(message)\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/errors.ts:flattenError",
    "file": "mcp-rag-server/node_modules/eventsource/src/errors.ts",
    "symbol": "flattenError",
    "startLine": 109,
    "endLine": 123,
    "text": "export function flattenError(err: unknown): string {\n  if (!(err instanceof Error)) {\n    return `${err}`\n  }\n\n  if ('errors' in err && Array.isArray(err.errors)) {\n    return err.errors.map(flattenError).join(', ')\n  }\n\n  if ('cause' in err && err.cause instanceof Error) {\n    return `${err}: ${flattenError(err.cause)}`\n  }\n\n  return err.message\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/errors.ts:inspectableError",
    "file": "mcp-rag-server/node_modules/eventsource/src/errors.ts",
    "symbol": "inspectableError",
    "startLine": 132,
    "endLine": 141,
    "text": "function inspectableError(err: ErrorEvent) {\n  return {\n    type: err.type,\n    message: err.message,\n    code: err.code,\n    defaultPrevented: err.defaultPrevented,\n    cancelable: err.cancelable,\n    timeStamp: err.timeStamp,\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts:EventSource",
    "file": "mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
    "symbol": "EventSource",
    "startLine": 31,
    "endLine": 578,
    "text": "export class EventSource extends EventTarget {\n  /**\n   * ReadyState representing an EventSource currently trying to connect\n   *\n   * @public\n   */\n  static CONNECTING = 0 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is open (eg connected)\n   *\n   * @public\n   */\n  static OPEN = 1 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is closed (eg disconnected)\n   *\n   * @public\n   */\n  static CLOSED = 2 as const\n\n  /**\n   * ReadyState representing an EventSource currently trying to connect\n   *\n   * @public\n   */\n  readonly CONNECTING = 0 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is open (eg connected)\n   *\n   * @public\n   */\n  readonly OPEN = 1 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is closed (eg disconnected)\n   *\n   * @public\n   */\n  readonly CLOSED = 2 as const\n\n  /**\n   * Returns the state of this EventSource object's connection. It can have the values described below.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)\n   *\n   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,\n   * defined in the TypeScript `dom` library.\n   *\n   * @public\n   */\n  public get readyState(): number {\n    return this.#readyState\n  }\n\n  /**\n   * Returns the URL providing the event stream.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)\n   *\n   * @public\n   */\n  public get url(): string {\n    return this.#url.href\n  }\n\n  /**\n   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to \"include\", and false otherwise.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)\n   */\n  public get withCredentials(): boolean {\n    return this.#withCredentials\n  }\n\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */\n  public get onerror(): ((ev: ErrorEvent) => unknown) | null {\n    return this.#onError\n  }\n  public set onerror(value: ((ev: ErrorEvent) => unknown) | null) {\n    this.#onError = value\n  }\n\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */\n  public get onmessage(): ((ev: MessageEvent) => unknown) | null {\n    return this.#onMessage\n  }\n  public set onmessage(value: ((ev: MessageEvent) => unknown) | null) {\n    this.#onMessage = value\n  }\n\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */\n  public get onopen(): ((ev: Event) => unknown) | null {\n    return this.#onOpen\n  }\n  public set onopen(value: ((ev: Event) => unknown) | null) {\n    this.#onOpen = value\n  }\n\n  override addEventListener<K extends keyof EventSourceEventMap>(\n    type: K,\n    listener: (this: EventSource, ev: EventSourceEventMap[K]) => unknown,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  override addEventListener(\n    type: string,\n    listener: (this: EventSource, event: MessageEvent) => unknown,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  override addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  override addEventListener(\n    type: string,\n    listener:\n      | ((this: EventSource, event: MessageEvent) => unknown)\n      | EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    const listen = listener as (this: EventSource, event: Event) => unknown\n    super.addEventListener(type, listen, options)\n  }\n\n  override removeEventListener<K extends keyof EventSourceEventMap>(\n    type: K,\n    listener: (this: EventSource, ev: EventSourceEventMap[K]) => unknown,\n    options?: boolean | EventListenerOptions,\n  ): void\n  override removeEventListener(\n    type: string,\n    listener: (this: EventSource, event: MessageEvent) => unknown,\n    options?: boolean | EventListenerOptions,\n  ): void\n  override removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void\n  override removeEventListener(\n    type: string,\n    listener:\n      | ((this: EventSource, event: MessageEvent) => unknown)\n      | EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void {\n    const listen = listener as (this: EventSource, event: Event) => unknown\n    super.removeEventListener(type, listen, options)\n  }\n\n  constructor(url: string | URL, eventSourceInitDict?: EventSourceInit) {\n    super()\n\n    try {\n      if (url instanceof URL) {\n        this.#url = url\n      } else if (typeof url === 'string') {\n        this.#url = new URL(url, getBaseURL())\n      } else {\n        throw new Error('Invalid URL')\n      }\n    } catch (err) {\n      throw syntaxError('An invalid or illegal string was specified')\n    }\n\n    this.#parser = createParser({\n      onEvent: this.#onEvent,\n      onRetry: this.#onRetryChange,\n    })\n\n    this.#readyState = this.CONNECTING\n    this.#reconnectInterval = 3000\n    this.#fetch = eventSourceInitDict?.fetch ?? globalThis.fetch\n    this.#withCredentials = eventSourceInitDict?.withCredentials ?? false\n\n    this.#connect()\n  }\n\n  /**\n   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)\n   *\n   * @public\n   */\n  close(): void {\n    if (this.#reconnectTimer) clearTimeout(this.#reconnectTimer)\n    if (this.#readyState === this.CLOSED) return\n    if (this.#controller) this.#controller.abort()\n    this.#readyState = this.CLOSED\n    this.#controller = undefined\n  }\n\n  // PRIVATES FOLLOW\n\n  /**\n   * Current connection state\n   *\n   * @internal\n   */\n  #readyState: number\n\n  /**\n   * Original URL used to connect.\n   *\n   * Note that this will stay the same even after a redirect.\n   *\n   * @internal\n   */\n  #url: URL\n\n  /**\n   * The destination URL after a redirect. Is reset on reconnection.\n   *\n   * @internal\n   */\n  #redirectUrl: URL | undefined\n\n  /**\n   * Whether to include credentials in the request\n   *\n   * @internal\n   */\n  #withCredentials: boolean\n\n  /**\n   * The fetch implementation to use\n   *\n   * @internal\n   */\n  #fetch: FetchLike\n\n  /**\n   * The reconnection time in milliseconds\n   *\n   * @internal\n   */\n  #reconnectInterval: number\n\n  /**\n   * Reference to an ongoing reconnect attempt, if any\n   *\n   * @internal\n   */\n  #reconnectTimer: ReturnType<typeof setTimeout> | undefined\n\n  /**\n   * The last event ID seen by the EventSource, which will be sent as `Last-Event-ID` in the\n   * request headers on a reconnection attempt.\n   *\n   * @internal\n   */\n  #lastEventId: string | null = null\n\n  /**\n   * The AbortController instance used to abort the fetch request\n   *\n   * @internal\n   */\n  #controller: AbortController | undefined\n\n  /**\n   * Instance of an EventSource parser (`eventsource-parser` npm module)\n   *\n   * @internal\n   */\n  #parser: EventSourceParser\n\n  /**\n   * Holds the current error handler, attached through `onerror` property directly.\n   * Note that `addEventListener('error', )` will not be stored here.\n   *\n   * @internal\n   */\n  #onError: ((ev: ErrorEvent) => unknown) | null = null\n\n  /**\n   * Holds the current message handler, attached through `onmessage` property directly.\n   * Note that `addEventListener('message', )` will not be stored here.\n   *\n   * @internal\n   */\n  #onMessage: ((ev: MessageEvent) => unknown) | null = null\n\n  /**\n   * Holds the current open handler, attached through `onopen` property directly.\n   * Note that `addEventListener('open', )` will not be stored here.\n   *\n   * @internal\n   */\n  #onOpen: ((ev: Event) => unknown) | null = null\n\n  /**\n   * Connect to the given URL and start receiving events\n   *\n   * @internal\n   */\n  #connect() {\n    this.#readyState = this.CONNECTING\n    this.#controller = new AbortController()\n\n    // Browser tests are failing if we directly call `this.#fetch()`, thus the indirection.\n    const fetch = this.#fetch\n    fetch(this.#url, this.#getRequestOptions())\n      .then(this.#onFetchResponse)\n      .catch(this.#onFetchError)\n  }\n\n  /**\n   * Handles the fetch response\n   *\n   * @param response - The Fetch(ish) response\n   * @internal\n   */\n  #onFetchResponse = async (response: FetchLikeResponse) => {\n    this.#parser.reset()\n\n    const {body, redirected, status, headers} = response\n\n    // [spec] a client can be told to stop reconnecting using the HTTP 204 No Content response code.\n    if (status === 204) {\n      // We still need to emit an error event - this mirrors the browser behavior,\n      // and without it there is no way to tell the user that the connection was closed.\n      this.#failConnection('Server sent HTTP 204, not reconnecting', 204)\n      this.close()\n      return\n    }\n\n    // [spec] Event stream requests can be redirected using HTTP 301 and 307 redirects as with\n    // [spec] normal HTTP requests.\n    // Spec does not say anything about other redirect codes (302, 308), but this seems an\n    // unintended omission, rather than a feature. Browsers will happily redirect on other 3xxs's.\n    if (redirected) {\n      this.#redirectUrl = new URL(response.url)\n    } else {\n      this.#redirectUrl = undefined\n    }\n\n    // [spec] if res's status is not 200, , then fail the connection.\n    if (status !== 200) {\n      this.#failConnection(`Non-200 status code (${status})`, status)\n      return\n    }\n\n    // [spec] or if res's `Content-Type` is not `text/event-stream`, then fail the connection.\n    const contentType = headers.get('content-type') || ''\n    if (!contentType.startsWith('text/event-stream')) {\n      this.#failConnection('Invalid content type, expected \"text/event-stream\"', status)\n      return\n    }\n\n    // [spec] if the readyState attribute is set to a value other than CLOSED\n    if (this.#readyState === this.CLOSED) {\n      return\n    }\n\n    // [spec] sets the readyState attribute to OPEN and fires an event\n    // [spec] named open at the EventSource object.\n    this.#readyState = this.OPEN\n\n    const openEvent = new Event('open')\n    this.#onOpen?.(openEvent)\n    this.dispatchEvent(openEvent)\n\n    // Ensure that the response stream is a web stream\n    if (typeof body !== 'object' || !body || !('getReader' in body)) {\n      this.#failConnection('Invalid response body, expected a web ReadableStream', status)\n      this.close() // This should only happen if `fetch` provided is \"faulty\" - don't reconnect\n      return\n    }\n\n    const decoder = new TextDecoder()\n\n    const reader = body.getReader()\n    let open = true\n\n    do {\n      const {done, value} = await reader.read()\n      if (value) {\n        this.#parser.feed(decoder.decode(value, {stream: !done}))\n      }\n\n      if (!done) {\n        continue\n      }\n\n      open = false\n      this.#parser.reset()\n\n      this.#scheduleReconnect()\n    } while (open)\n  }\n\n  /**\n   * Handles rejected requests for the EventSource endpoint\n   *\n   * @param err - The error from `fetch()`\n   * @internal\n   */\n  #onFetchError = (err: Error & {type?: string}) => {\n    this.#controller = undefined\n\n    // We expect abort errors when the user manually calls `close()` - ignore those\n    if (err.name === 'AbortError' || err.type === 'aborted') {\n      return\n    }\n\n    this.#scheduleReconnect(flattenError(err))\n  }\n\n  /**\n   * Get request options for the `fetch()` request\n   *\n   * @returns The request options\n   * @internal\n   */\n  #getRequestOptions(): EventSourceFetchInit {\n    const lastEvent = this.#lastEventId ? {'Last-Event-ID': this.#lastEventId} : undefined\n\n    const init: EventSourceFetchInit = {\n      // [spec] Let `corsAttributeState` be `Anonymous`\n      // [spec] will have their mode set to \"cors\"\n      mode: 'cors',\n      redirect: 'follow',\n      headers: {Accept: 'text/event-stream', ...lastEvent},\n      cache: 'no-store',\n      signal: this.#controller?.signal,\n    }\n\n    // Some environments crash if attempting to set `credentials` where it is not supported,\n    // eg on Cloudflare Workers. To avoid this, we only set it in browser-like environments.\n    if ('window' in globalThis) {\n      // [spec] and their credentials mode set to \"same-origin\"\n      // [spec] if the `withCredentials` attribute is `true`, set the credentials mode to \"include\"\n      init.credentials = this.withCredentials ? 'include' : 'same-origin'\n    }\n\n    return init\n  }\n\n  /**\n   * Called by EventSourceParser instance when an event has successfully been parsed\n   * and is ready to be processed.\n   *\n   * @param event - The parsed event\n   * @internal\n   */\n  #onEvent = (event: EventSourceMessage) => {\n    if (typeof event.id === 'string') {\n      this.#lastEventId = event.id\n    }\n\n    const messageEvent = new MessageEvent(event.event || 'message', {\n      data: event.data,\n      origin: this.#redirectUrl ? this.#redirectUrl.origin : this.#url.origin,\n      lastEventId: event.id || '',\n    })\n\n    // The `onmessage` property of the EventSource instance only triggers on messages without an\n    // `event` field, or ones that explicitly set `message`.\n    if (this.#onMessage && (!event.event || event.event === 'message')) {\n      this.#onMessage(messageEvent)\n    }\n\n    this.dispatchEvent(messageEvent)\n  }\n\n  /**\n   * Called by EventSourceParser instance when a new reconnection interval is received\n   * from the EventSource endpoint.\n   *\n   * @param value - The new reconnection interval in milliseconds\n   * @internal\n   */\n  #onRetryChange = (value: number) => {\n    this.#reconnectInterval = value\n  }\n\n  /**\n   * Handles the process referred to in the EventSource specification as \"failing a connection\".\n   *\n   * @param error - The error causing the connection to fail\n   * @param code - The HTTP status code, if available\n   * @internal\n   */\n  #failConnection(message?: string, code?: number) {\n    // [spec] if the readyState attribute is set to a value other than CLOSED,\n    // [spec] sets the readyState attribute to CLOSED\n    if (this.#readyState !== this.CLOSED) {\n      this.#readyState = this.CLOSED\n    }\n\n    // [spec] and fires an event named `error` at the `EventSource` object.\n    // [spec] Once the user agent has failed the connection, it does not attempt to reconnect.\n    // [spec] > Implementations are especially encouraged to report detailed information\n    // [spec] > to their development consoles whenever an error event is fired, since little\n    // [spec] > to no information can be made available in the events themselves.\n    // Printing to console is not very programatically helpful, though, so we emit a custom event.\n    const errorEvent = new ErrorEvent('error', {code, message})\n\n    this.#onError?.(errorEvent)\n    this.dispatchEvent(errorEvent)\n  }\n\n  /**\n   * Schedules a reconnection attempt against the EventSource endpoint.\n   *\n   * @param message - The error causing the connection to fail\n   * @param code - The HTTP status code, if available\n   * @internal\n   */\n  #scheduleReconnect(message?: string, code?: number) {\n    // [spec] If the readyState attribute is set to CLOSED, abort the task.\n    if (this.#readyState === this.CLOSED) {\n      return\n    }\n\n    // [spec] Set the readyState attribute to CONNECTING.\n    this.#readyState = this.CONNECTING\n\n    // [spec] Fire an event named `error` at the EventSource object.\n    const errorEvent = new ErrorEvent('error', {code, message})\n    this.#onError?.(errorEvent)\n    this.dispatchEvent(errorEvent)\n\n    // [spec] Wait a delay equal to the reconnection time of the event source.\n    this.#reconnectTimer = setTimeout(this.#reconnect, this.#reconnectInterval)\n  }\n\n  /**\n   * Reconnects to the EventSource endpoint after a disconnect/failure\n   *\n   * @internal\n   */\n  #reconnect = () => {\n    this.#reconnectTimer = undefined\n\n    // [spec] If the EventSource's readyState attribute is not set to CONNECTING, then return.\n    if (this.#readyState !== this.CONNECTING) {\n      return\n    }\n\n    this.#connect()\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts:EventSource.addEventListener",
    "file": "mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
    "symbol": "EventSource.addEventListener",
    "startLine": 147,
    "endLine": 156,
    "text": "  override addEventListener(\n    type: string,\n    listener:\n      | ((this: EventSource, event: MessageEvent) => unknown)\n      | EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    const listen = listener as (this: EventSource, event: Event) => unknown\n    super.addEventListener(type, listen, options)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts:EventSource.removeEventListener",
    "file": "mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
    "symbol": "EventSource.removeEventListener",
    "startLine": 173,
    "endLine": 182,
    "text": "  override removeEventListener(\n    type: string,\n    listener:\n      | ((this: EventSource, event: MessageEvent) => unknown)\n      | EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void {\n    const listen = listener as (this: EventSource, event: Event) => unknown\n    super.removeEventListener(type, listen, options)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts:EventSource.close",
    "file": "mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
    "symbol": "EventSource.close",
    "startLine": 219,
    "endLine": 225,
    "text": "  close(): void {\n    if (this.#reconnectTimer) clearTimeout(this.#reconnectTimer)\n    if (this.#readyState === this.CLOSED) return\n    if (this.#controller) this.#controller.abort()\n    this.#readyState = this.CLOSED\n    this.#controller = undefined\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts:EventSource.#connect",
    "file": "mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
    "symbol": "EventSource.#connect",
    "startLine": 331,
    "endLine": 340,
    "text": "  #connect() {\n    this.#readyState = this.CONNECTING\n    this.#controller = new AbortController()\n\n    // Browser tests are failing if we directly call `this.#fetch()`, thus the indirection.\n    const fetch = this.#fetch\n    fetch(this.#url, this.#getRequestOptions())\n      .then(this.#onFetchResponse)\n      .catch(this.#onFetchError)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts:EventSource.#getRequestOptions",
    "file": "mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
    "symbol": "EventSource.#getRequestOptions",
    "startLine": 450,
    "endLine": 472,
    "text": "  #getRequestOptions(): EventSourceFetchInit {\n    const lastEvent = this.#lastEventId ? {'Last-Event-ID': this.#lastEventId} : undefined\n\n    const init: EventSourceFetchInit = {\n      // [spec] Let `corsAttributeState` be `Anonymous`\n      // [spec] will have their mode set to \"cors\"\n      mode: 'cors',\n      redirect: 'follow',\n      headers: {Accept: 'text/event-stream', ...lastEvent},\n      cache: 'no-store',\n      signal: this.#controller?.signal,\n    }\n\n    // Some environments crash if attempting to set `credentials` where it is not supported,\n    // eg on Cloudflare Workers. To avoid this, we only set it in browser-like environments.\n    if ('window' in globalThis) {\n      // [spec] and their credentials mode set to \"same-origin\"\n      // [spec] if the `withCredentials` attribute is `true`, set the credentials mode to \"include\"\n      init.credentials = this.withCredentials ? 'include' : 'same-origin'\n    }\n\n    return init\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts:EventSource.#failConnection",
    "file": "mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
    "symbol": "EventSource.#failConnection",
    "startLine": 519,
    "endLine": 536,
    "text": "  #failConnection(message?: string, code?: number) {\n    // [spec] if the readyState attribute is set to a value other than CLOSED,\n    // [spec] sets the readyState attribute to CLOSED\n    if (this.#readyState !== this.CLOSED) {\n      this.#readyState = this.CLOSED\n    }\n\n    // [spec] and fires an event named `error` at the `EventSource` object.\n    // [spec] Once the user agent has failed the connection, it does not attempt to reconnect.\n    // [spec] > Implementations are especially encouraged to report detailed information\n    // [spec] > to their development consoles whenever an error event is fired, since little\n    // [spec] > to no information can be made available in the events themselves.\n    // Printing to console is not very programatically helpful, though, so we emit a custom event.\n    const errorEvent = new ErrorEvent('error', {code, message})\n\n    this.#onError?.(errorEvent)\n    this.dispatchEvent(errorEvent)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts:EventSource.#scheduleReconnect",
    "file": "mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
    "symbol": "EventSource.#scheduleReconnect",
    "startLine": 545,
    "endLine": 561,
    "text": "  #scheduleReconnect(message?: string, code?: number) {\n    // [spec] If the readyState attribute is set to CLOSED, abort the task.\n    if (this.#readyState === this.CLOSED) {\n      return\n    }\n\n    // [spec] Set the readyState attribute to CONNECTING.\n    this.#readyState = this.CONNECTING\n\n    // [spec] Fire an event named `error` at the EventSource object.\n    const errorEvent = new ErrorEvent('error', {code, message})\n    this.#onError?.(errorEvent)\n    this.dispatchEvent(errorEvent)\n\n    // [spec] Wait a delay equal to the reconnection time of the event source.\n    this.#reconnectTimer = setTimeout(this.#reconnect, this.#reconnectInterval)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts:getBaseURL",
    "file": "mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
    "symbol": "getBaseURL",
    "startLine": 590,
    "endLine": 596,
    "text": "function getBaseURL(): string | undefined {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const doc = 'document' in globalThis ? (globalThis as any).document : undefined\n  return doc && typeof doc === 'object' && 'baseURI' in doc && typeof doc.baseURI === 'string'\n    ? doc.baseURI\n    : undefined\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/errors.ts:ParseError",
    "file": "mcp-rag-server/node_modules/eventsource-parser/src/errors.ts",
    "symbol": "ParseError",
    "startLine": 12,
    "endLine": 44,
    "text": "export class ParseError extends Error {\n  /**\n   * The type of error that occurred.\n   */\n  type: ErrorType\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the field name.\n   */\n  field?: string | undefined\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the value of the field.\n   */\n  value?: string | undefined\n\n  /**\n   * The line that caused the error, if available.\n   */\n  line?: string | undefined\n\n  constructor(\n    message: string,\n    options: {type: ErrorType; field?: string; value?: string; line?: string},\n  ) {\n    super(message)\n    this.name = 'ParseError'\n    this.type = options.type\n    this.field = options.field\n    this.value = options.value\n    this.line = options.line\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts:noop",
    "file": "mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
    "symbol": "noop",
    "startLine": 9,
    "endLine": 11,
    "text": "function noop(_arg: unknown) {\n  // intentional noop\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts:createParser",
    "file": "mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
    "symbol": "createParser",
    "startLine": 25,
    "endLine": 172,
    "text": "export function createParser(callbacks: ParserCallbacks): EventSourceParser {\n  if (typeof callbacks === 'function') {\n    throw new TypeError(\n      '`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?',\n    )\n  }\n\n  const {onEvent = noop, onError = noop, onRetry = noop, onComment} = callbacks\n\n  let incompleteLine = ''\n\n  let isFirstChunk = true\n  let id: string | undefined\n  let data = ''\n  let eventType = ''\n\n  function feed(newChunk: string) {\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, '') : newChunk\n\n    // If there was a previous incomplete line, append it to the new chunk,\n    // so we may process it together as a new (hopefully complete) chunk.\n    const [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`)\n\n    for (const line of complete) {\n      parseLine(line)\n    }\n\n    incompleteLine = incomplete\n    isFirstChunk = false\n  }\n\n  function parseLine(line: string) {\n    // If the line is empty (a blank line), dispatch the event\n    if (line === '') {\n      dispatchEvent()\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:), ignore the line.\n    if (line.startsWith(':')) {\n      if (onComment) {\n        onComment(line.slice(line.startsWith(': ') ? 2 : 1))\n      }\n      return\n    }\n\n    // If the line contains a U+003A COLON character (:)\n    const fieldSeparatorIndex = line.indexOf(':')\n    if (fieldSeparatorIndex !== -1) {\n      // Collect the characters on the line before the first U+003A COLON character (:),\n      // and let `field` be that string.\n      const field = line.slice(0, fieldSeparatorIndex)\n\n      // Collect the characters on the line after the first U+003A COLON character (:),\n      // and let `value` be that string. If value starts with a U+0020 SPACE character,\n      // remove it from value.\n      const offset = line[fieldSeparatorIndex + 1] === ' ' ? 2 : 1\n      const value = line.slice(fieldSeparatorIndex + offset)\n\n      processField(field, value, line)\n      return\n    }\n\n    // Otherwise, the string is not empty but does not contain a U+003A COLON character (:)\n    // Process the field using the whole line as the field name, and an empty string as the field value.\n    //  This is according to spec. That means that a line that has the value `data` will result in\n    // a newline being added to the current `data` buffer, for instance.\n    processField(line, '', line)\n  }\n\n  function processField(field: string, value: string, line: string) {\n    // Field names must be compared literally, with no case folding performed.\n    switch (field) {\n      case 'event':\n        // Set the `event type` buffer to field value\n        eventType = value\n        break\n      case 'data':\n        // Append the field value to the `data` buffer, then append a single U+000A LINE FEED(LF)\n        // character to the `data` buffer.\n        data = `${data}${value}\\n`\n        break\n      case 'id':\n        // If the field value does not contain U+0000 NULL, then set the `ID` buffer to\n        // the field value. Otherwise, ignore the field.\n        id = value.includes('\\0') ? undefined : value\n        break\n      case 'retry':\n        // If the field value consists of only ASCII digits, then interpret the field value as an\n        // integer in base ten, and set the event stream's reconnection time to that integer.\n        // Otherwise, ignore the field.\n        if (/^\\d+$/.test(value)) {\n          onRetry(parseInt(value, 10))\n        } else {\n          onError(\n            new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n              type: 'invalid-retry',\n              value,\n              line,\n            }),\n          )\n        }\n        break\n      default:\n        // Otherwise, the field is ignored.\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}` : field}\"`,\n            {type: 'unknown-field', field, value, line},\n          ),\n        )\n        break\n    }\n  }\n\n  function dispatchEvent() {\n    const shouldDispatch = data.length > 0\n    if (shouldDispatch) {\n      onEvent({\n        id,\n        event: eventType || undefined,\n        // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n        // then remove the last character from the data buffer.\n        data: data.endsWith('\\n') ? data.slice(0, -1) : data,\n      })\n    }\n\n    // Reset for the next event\n    id = undefined\n    data = ''\n    eventType = ''\n  }\n\n  function reset(options: {consume?: boolean} = {}) {\n    if (incompleteLine && options.consume) {\n      parseLine(incompleteLine)\n    }\n\n    isFirstChunk = true\n    id = undefined\n    data = ''\n    eventType = ''\n    incompleteLine = ''\n  }\n\n  return {feed, reset}\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts:feed",
    "file": "mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
    "symbol": "feed",
    "startLine": 41,
    "endLine": 55,
    "text": "  function feed(newChunk: string) {\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, '') : newChunk\n\n    // If there was a previous incomplete line, append it to the new chunk,\n    // so we may process it together as a new (hopefully complete) chunk.\n    const [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`)\n\n    for (const line of complete) {\n      parseLine(line)\n    }\n\n    incompleteLine = incomplete\n    isFirstChunk = false\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts:parseLine",
    "file": "mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
    "symbol": "parseLine",
    "startLine": 57,
    "endLine": 94,
    "text": "  function parseLine(line: string) {\n    // If the line is empty (a blank line), dispatch the event\n    if (line === '') {\n      dispatchEvent()\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:), ignore the line.\n    if (line.startsWith(':')) {\n      if (onComment) {\n        onComment(line.slice(line.startsWith(': ') ? 2 : 1))\n      }\n      return\n    }\n\n    // If the line contains a U+003A COLON character (:)\n    const fieldSeparatorIndex = line.indexOf(':')\n    if (fieldSeparatorIndex !== -1) {\n      // Collect the characters on the line before the first U+003A COLON character (:),\n      // and let `field` be that string.\n      const field = line.slice(0, fieldSeparatorIndex)\n\n      // Collect the characters on the line after the first U+003A COLON character (:),\n      // and let `value` be that string. If value starts with a U+0020 SPACE character,\n      // remove it from value.\n      const offset = line[fieldSeparatorIndex + 1] === ' ' ? 2 : 1\n      const value = line.slice(fieldSeparatorIndex + offset)\n\n      processField(field, value, line)\n      return\n    }\n\n    // Otherwise, the string is not empty but does not contain a U+003A COLON character (:)\n    // Process the field using the whole line as the field name, and an empty string as the field value.\n    //  This is according to spec. That means that a line that has the value `data` will result in\n    // a newline being added to the current `data` buffer, for instance.\n    processField(line, '', line)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts:processField",
    "file": "mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
    "symbol": "processField",
    "startLine": 96,
    "endLine": 139,
    "text": "  function processField(field: string, value: string, line: string) {\n    // Field names must be compared literally, with no case folding performed.\n    switch (field) {\n      case 'event':\n        // Set the `event type` buffer to field value\n        eventType = value\n        break\n      case 'data':\n        // Append the field value to the `data` buffer, then append a single U+000A LINE FEED(LF)\n        // character to the `data` buffer.\n        data = `${data}${value}\\n`\n        break\n      case 'id':\n        // If the field value does not contain U+0000 NULL, then set the `ID` buffer to\n        // the field value. Otherwise, ignore the field.\n        id = value.includes('\\0') ? undefined : value\n        break\n      case 'retry':\n        // If the field value consists of only ASCII digits, then interpret the field value as an\n        // integer in base ten, and set the event stream's reconnection time to that integer.\n        // Otherwise, ignore the field.\n        if (/^\\d+$/.test(value)) {\n          onRetry(parseInt(value, 10))\n        } else {\n          onError(\n            new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n              type: 'invalid-retry',\n              value,\n              line,\n            }),\n          )\n        }\n        break\n      default:\n        // Otherwise, the field is ignored.\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}` : field}\"`,\n            {type: 'unknown-field', field, value, line},\n          ),\n        )\n        break\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts:dispatchEvent",
    "file": "mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
    "symbol": "dispatchEvent",
    "startLine": 141,
    "endLine": 157,
    "text": "  function dispatchEvent() {\n    const shouldDispatch = data.length > 0\n    if (shouldDispatch) {\n      onEvent({\n        id,\n        event: eventType || undefined,\n        // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n        // then remove the last character from the data buffer.\n        data: data.endsWith('\\n') ? data.slice(0, -1) : data,\n      })\n    }\n\n    // Reset for the next event\n    id = undefined\n    data = ''\n    eventType = ''\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts:reset",
    "file": "mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
    "symbol": "reset",
    "startLine": 159,
    "endLine": 169,
    "text": "  function reset(options: {consume?: boolean} = {}) {\n    if (incompleteLine && options.consume) {\n      parseLine(incompleteLine)\n    }\n\n    isFirstChunk = true\n    id = undefined\n    data = ''\n    eventType = ''\n    incompleteLine = ''\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts:splitLines",
    "file": "mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
    "symbol": "splitLines",
    "startLine": 181,
    "endLine": 232,
    "text": "function splitLines(chunk: string): [complete: Array<string>, incomplete: string] {\n  /**\n   * According to the spec, a line is terminated by either:\n   * - U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair\n   * - a single U+000A LINE FEED(LF) character not preceded by a U+000D CARRIAGE RETURN(CR) character\n   * - a single U+000D CARRIAGE RETURN(CR) character not followed by a U+000A LINE FEED(LF) character\n   */\n  const lines: Array<string> = []\n  let incompleteLine = ''\n  let searchIndex = 0\n\n  while (searchIndex < chunk.length) {\n    // Find next line terminator\n    const crIndex = chunk.indexOf('\\r', searchIndex)\n    const lfIndex = chunk.indexOf('\\n', searchIndex)\n\n    // Determine line end\n    let lineEnd = -1\n    if (crIndex !== -1 && lfIndex !== -1) {\n      // CRLF case\n      lineEnd = Math.min(crIndex, lfIndex)\n    } else if (crIndex !== -1) {\n      // CR at the end of a chunk might be part of a CRLF sequence that spans chunks,\n      // so we shouldn't treat it as a line terminator (yet)\n      if (crIndex === chunk.length - 1) {\n        lineEnd = -1\n      } else {\n        lineEnd = crIndex\n      }\n    } else if (lfIndex !== -1) {\n      lineEnd = lfIndex\n    }\n\n    // Extract line if terminator found\n    if (lineEnd === -1) {\n      // No terminator found, rest is incomplete\n      incompleteLine = chunk.slice(searchIndex)\n      break\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd)\n      lines.push(line)\n\n      // Move past line terminator\n      searchIndex = lineEnd + 1\n      if (chunk[searchIndex - 1] === '\\r' && chunk[searchIndex] === '\\n') {\n        searchIndex++\n      }\n    }\n  }\n\n  return [lines, incompleteLine]\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/stream.ts:EventSourceParserStream",
    "file": "mcp-rag-server/node_modules/eventsource-parser/src/stream.ts",
    "symbol": "EventSourceParserStream",
    "startLine": 57,
    "endLine": 85,
    "text": "export class EventSourceParserStream extends TransformStream<string, EventSourceMessage> {\n  constructor({onError, onRetry, onComment}: StreamOptions = {}) {\n    let parser!: EventSourceParser\n\n    super({\n      start(controller) {\n        parser = createParser({\n          onEvent: (event) => {\n            controller.enqueue(event)\n          },\n          onError(error) {\n            if (onError === 'terminate') {\n              controller.error(error)\n            } else if (typeof onError === 'function') {\n              onError(error)\n            }\n\n            // Ignore by default\n          },\n          onRetry,\n          onComment,\n        })\n      },\n      transform(chunk) {\n        parser.feed(chunk)\n      },\n    })\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/fastq/test/example.ts:worker",
    "file": "mcp-rag-server/node_modules/fastq/test/example.ts",
    "symbol": "worker",
    "startLine": 46,
    "endLine": 48,
    "text": "function worker(task: any, cb: fastq.done) {\n  cb(null, 'hello ' + task)\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/fastq/test/example.ts:genericsWorker",
    "file": "mcp-rag-server/node_modules/fastq/test/example.ts",
    "symbol": "genericsWorker",
    "startLine": 68,
    "endLine": 70,
    "text": "function genericsWorker(this: GenericsContext, task: number, cb: fastq.done<string>) {\n  cb(null, 'the meaning of life is ' + (this.base * task))\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/fastq/test/example.ts:asyncWorker",
    "file": "mcp-rag-server/node_modules/fastq/test/example.ts",
    "symbol": "asyncWorker",
    "startLine": 74,
    "endLine": 76,
    "text": "async function asyncWorker(task: any) {\n  return 'hello ' + task\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/fastq/test/example.ts:run",
    "file": "mcp-rag-server/node_modules/fastq/test/example.ts",
    "symbol": "run",
    "startLine": 78,
    "endLine": 81,
    "text": "async function run () {\n  await queue.push(42)\n  await queue.unshift(42)\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch",
    "startLine": 611,
    "endLine": 2060,
    "text": "export default class MiniSearch<T = any> {\n  protected _options: OptionsWithDefaults<T>\n  protected _index: SearchableMap<FieldTermData>\n  protected _documentCount: number\n  protected _documentIds: Map<number, any>\n  protected _idToShortId: Map<any, number>\n  protected _fieldIds: { [key: string]: number }\n  protected _fieldLength: Map<number, number[]>\n  protected _avgFieldLength: number[]\n  protected _nextId: number\n  protected _storedFields: Map<number, Record<string, unknown>>\n  protected _dirtCount: number\n  private _currentVacuum: Promise<void> | null\n  private _enqueuedVacuum: Promise<void> | null\n  private _enqueuedVacuumConditions: VacuumConditions | undefined\n\n  /**\n   * The special wildcard symbol that can be passed to {@link MiniSearch#search}\n   * to match all documents\n   */\n  static readonly wildcard: unique symbol = Symbol('*')\n\n  /**\n   * @param options  Configuration options\n   *\n   * ### Examples:\n   *\n   * ```javascript\n   * // Create a search engine that indexes the 'title' and 'text' fields of your\n   * // documents:\n   * const miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * ```\n   *\n   * ### ID Field:\n   *\n   * ```javascript\n   * // Your documents are assumed to include a unique 'id' field, but if you want\n   * // to use a different field for document identification, you can set the\n   * // 'idField' option:\n   * const miniSearch = new MiniSearch({ idField: 'key', fields: ['title', 'text'] })\n   * ```\n   *\n   * ### Options and defaults:\n   *\n   * ```javascript\n   * // The full set of options (here with their default value) is:\n   * const miniSearch = new MiniSearch({\n   *   // idField: field that uniquely identifies a document\n   *   idField: 'id',\n   *\n   *   // extractField: function used to get the value of a field in a document.\n   *   // By default, it assumes the document is a flat object with field names as\n   *   // property keys and field values as string property values, but custom logic\n   *   // can be implemented by setting this option to a custom extractor function.\n   *   extractField: (document, fieldName) => document[fieldName],\n   *\n   *   // tokenize: function used to split fields into individual terms. By\n   *   // default, it is also used to tokenize search queries, unless a specific\n   *   // `tokenize` search option is supplied. When tokenizing an indexed field,\n   *   // the field name is passed as the second argument.\n   *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n   *\n   *   // processTerm: function used to process each tokenized term before\n   *   // indexing. It can be used for stemming and normalization. Return a falsy\n   *   // value in order to discard a term. By default, it is also used to process\n   *   // search queries, unless a specific `processTerm` option is supplied as a\n   *   // search option. When processing a term from a indexed field, the field\n   *   // name is passed as the second argument.\n   *   processTerm: (term, _fieldName) => term.toLowerCase(),\n   *\n   *   // searchOptions: default search options, see the `search` method for\n   *   // details\n   *   searchOptions: undefined,\n   *\n   *   // fields: document fields to be indexed. Mandatory, but not set by default\n   *   fields: undefined\n   *\n   *   // storeFields: document fields to be stored and returned as part of the\n   *   // search results.\n   *   storeFields: []\n   * })\n   * ```\n   */\n  constructor (options: Options<T>) {\n    if (options?.fields == null) {\n      throw new Error('MiniSearch: option \"fields\" must be provided')\n    }\n\n    const autoVacuum = (options.autoVacuum == null || options.autoVacuum === true) ? defaultAutoVacuumOptions : options.autoVacuum\n\n    this._options = {\n      ...defaultOptions,\n      ...options,\n      autoVacuum,\n      searchOptions: { ...defaultSearchOptions, ...(options.searchOptions || {}) },\n      autoSuggestOptions: { ...defaultAutoSuggestOptions, ...(options.autoSuggestOptions || {}) }\n    }\n\n    this._index = new SearchableMap()\n\n    this._documentCount = 0\n\n    this._documentIds = new Map()\n\n    this._idToShortId = new Map()\n\n    // Fields are defined during initialization, don't change, are few in\n    // number, rarely need iterating over, and have string keys. Therefore in\n    // this case an object is a better candidate than a Map to store the mapping\n    // from field key to ID.\n    this._fieldIds = {}\n\n    this._fieldLength = new Map()\n\n    this._avgFieldLength = []\n\n    this._nextId = 0\n\n    this._storedFields = new Map()\n\n    this._dirtCount = 0\n\n    this._currentVacuum = null\n\n    this._enqueuedVacuum = null\n    this._enqueuedVacuumConditions = defaultVacuumConditions\n\n    this.addFields(this._options.fields)\n  }\n\n  /**\n   * Adds a document to the index\n   *\n   * @param document  The document to be indexed\n   */\n  add (document: T): void {\n    const { extractField, stringifyField, tokenize, processTerm, fields, idField } = this._options\n    const id = extractField(document, idField)\n    if (id == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n\n    if (this._idToShortId.has(id)) {\n      throw new Error(`MiniSearch: duplicate ID ${id}`)\n    }\n\n    const shortDocumentId = this.addDocumentId(id)\n    this.saveStoredFields(shortDocumentId, document)\n\n    for (const field of fields) {\n      const fieldValue = extractField(document, field)\n      if (fieldValue == null) continue\n\n      const tokens = tokenize(stringifyField(fieldValue, field), field)\n      const fieldId = this._fieldIds[field]\n\n      const uniqueTerms = new Set(tokens).size\n      this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms)\n\n      for (const term of tokens) {\n        const processedTerm = processTerm(term, field)\n        if (Array.isArray(processedTerm)) {\n          for (const t of processedTerm) {\n            this.addTerm(fieldId, shortDocumentId, t)\n          }\n        } else if (processedTerm) {\n          this.addTerm(fieldId, shortDocumentId, processedTerm)\n        }\n      }\n    }\n  }\n\n  /**\n   * Adds all the given documents to the index\n   *\n   * @param documents  An array of documents to be indexed\n   */\n  addAll (documents: readonly T[]): void {\n    for (const document of documents) this.add(document)\n  }\n\n  /**\n   * Adds all the given documents to the index asynchronously.\n   *\n   * Returns a promise that resolves (to `undefined`) when the indexing is done.\n   * This method is useful when index many documents, to avoid blocking the main\n   * thread. The indexing is performed asynchronously and in chunks.\n   *\n   * @param documents  An array of documents to be indexed\n   * @param options  Configuration options\n   * @return A promise resolving to `undefined` when the indexing is done\n   */\n  addAllAsync (documents: readonly T[], options: { chunkSize?: number } = {}): Promise<void> {\n    const { chunkSize = 10 } = options\n    const acc: { chunk: T[], promise: Promise<void> } = { chunk: [], promise: Promise.resolve() }\n\n    const { chunk, promise } = documents.reduce(({ chunk, promise }, document: T, i: number) => {\n      chunk.push(document)\n      if ((i + 1) % chunkSize === 0) {\n        return {\n          chunk: [],\n          promise: promise\n            .then(() => new Promise(resolve => setTimeout(resolve, 0)))\n            .then(() => this.addAll(chunk))\n        }\n      } else {\n        return { chunk, promise }\n      }\n    }, acc)\n\n    return promise.then(() => this.addAll(chunk))\n  }\n\n  /**\n   * Removes the given document from the index.\n   *\n   * The document to remove must NOT have changed between indexing and removal,\n   * otherwise the index will be corrupted.\n   *\n   * This method requires passing the full document to be removed (not just the\n   * ID), and immediately removes the document from the inverted index, allowing\n   * memory to be released. A convenient alternative is {@link\n   * MiniSearch#discard}, which needs only the document ID, and has the same\n   * visible effect, but delays cleaning up the index until the next vacuuming.\n   *\n   * @param document  The document to be removed\n   */\n  remove (document: T): void {\n    const { tokenize, processTerm, extractField, stringifyField, fields, idField } = this._options\n    const id = extractField(document, idField)\n\n    if (id == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) {\n      throw new Error(`MiniSearch: cannot remove document with ID ${id}: it is not in the index`)\n    }\n\n    for (const field of fields) {\n      const fieldValue = extractField(document, field)\n      if (fieldValue == null) continue\n\n      const tokens = tokenize(stringifyField(fieldValue, field), field)\n      const fieldId = this._fieldIds[field]\n\n      const uniqueTerms = new Set(tokens).size\n      this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms)\n\n      for (const term of tokens) {\n        const processedTerm = processTerm(term, field)\n        if (Array.isArray(processedTerm)) {\n          for (const t of processedTerm) {\n            this.removeTerm(fieldId, shortId, t)\n          }\n        } else if (processedTerm) {\n          this.removeTerm(fieldId, shortId, processedTerm)\n        }\n      }\n    }\n\n    this._storedFields.delete(shortId)\n    this._documentIds.delete(shortId)\n    this._idToShortId.delete(id)\n    this._fieldLength.delete(shortId)\n    this._documentCount -= 1\n  }\n\n  /**\n   * Removes all the given documents from the index. If called with no arguments,\n   * it removes _all_ documents from the index.\n   *\n   * @param documents  The documents to be removed. If this argument is omitted,\n   * all documents are removed. Note that, for removing all documents, it is\n   * more efficient to call this method with no arguments than to pass all\n   * documents.\n   */\n  removeAll (documents?: readonly T[]): void {\n    if (documents) {\n      for (const document of documents) this.remove(document)\n    } else if (arguments.length > 0) {\n      throw new Error('Expected documents to be present. Omit the argument to remove all documents.')\n    } else {\n      this._index = new SearchableMap()\n      this._documentCount = 0\n      this._documentIds = new Map()\n      this._idToShortId = new Map()\n      this._fieldLength = new Map()\n      this._avgFieldLength = []\n      this._storedFields = new Map()\n      this._nextId = 0\n    }\n  }\n\n  /**\n   * Discards the document with the given ID, so it won't appear in search results\n   *\n   * It has the same visible effect of {@link MiniSearch.remove} (both cause the\n   * document to stop appearing in searches), but a different effect on the\n   * internal data structures:\n   *\n   *   - {@link MiniSearch#remove} requires passing the full document to be\n   *   removed as argument, and removes it from the inverted index immediately.\n   *\n   *   - {@link MiniSearch#discard} instead only needs the document ID, and\n   *   works by marking the current version of the document as discarded, so it\n   *   is immediately ignored by searches. This is faster and more convenient\n   *   than {@link MiniSearch#remove}, but the index is not immediately\n   *   modified. To take care of that, vacuuming is performed after a certain\n   *   number of documents are discarded, cleaning up the index and allowing\n   *   memory to be released.\n   *\n   * After discarding a document, it is possible to re-add a new version, and\n   * only the new version will appear in searches. In other words, discarding\n   * and re-adding a document works exactly like removing and re-adding it. The\n   * {@link MiniSearch.replace} method can also be used to replace a document\n   * with a new version.\n   *\n   * #### Details about vacuuming\n   *\n   * Repetite calls to this method would leave obsolete document references in\n   * the index, invisible to searches. Two mechanisms take care of cleaning up:\n   * clean up during search, and vacuuming.\n   *\n   *   - Upon search, whenever a discarded ID is found (and ignored for the\n   *   results), references to the discarded document are removed from the\n   *   inverted index entries for the search terms. This ensures that subsequent\n   *   searches for the same terms do not need to skip these obsolete references\n   *   again.\n   *\n   *   - In addition, vacuuming is performed automatically by default (see the\n   *   `autoVacuum` field in {@link Options}) after a certain number of\n   *   documents are discarded. Vacuuming traverses all terms in the index,\n   *   cleaning up all references to discarded documents. Vacuuming can also be\n   *   triggered manually by calling {@link MiniSearch#vacuum}.\n   *\n   * @param id  The ID of the document to be discarded\n   */\n  discard (id: any): void {\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) {\n      throw new Error(`MiniSearch: cannot discard document with ID ${id}: it is not in the index`)\n    }\n\n    this._idToShortId.delete(id)\n    this._documentIds.delete(shortId)\n    this._storedFields.delete(shortId)\n\n    ;(this._fieldLength.get(shortId) || []).forEach((fieldLength, fieldId) => {\n      this.removeFieldLength(shortId, fieldId, this._documentCount, fieldLength)\n    })\n\n    this._fieldLength.delete(shortId)\n\n    this._documentCount -= 1\n    this._dirtCount += 1\n\n    this.maybeAutoVacuum()\n  }\n\n  private maybeAutoVacuum (): void {\n    if (this._options.autoVacuum === false) { return }\n\n    const { minDirtFactor, minDirtCount, batchSize, batchWait } = this._options.autoVacuum\n    this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor })\n  }\n\n  /**\n   * Discards the documents with the given IDs, so they won't appear in search\n   * results\n   *\n   * It is equivalent to calling {@link MiniSearch#discard} for all the given\n   * IDs, but with the optimization of triggering at most one automatic\n   * vacuuming at the end.\n   *\n   * Note: to remove all documents from the index, it is faster and more\n   * convenient to call {@link MiniSearch.removeAll} with no argument, instead\n   * of passing all IDs to this method.\n   */\n  discardAll (ids: readonly any[]): void {\n    const autoVacuum = this._options.autoVacuum\n\n    try {\n      this._options.autoVacuum = false\n\n      for (const id of ids) {\n        this.discard(id)\n      }\n    } finally {\n      this._options.autoVacuum = autoVacuum\n    }\n\n    this.maybeAutoVacuum()\n  }\n\n  /**\n   * It replaces an existing document with the given updated version\n   *\n   * It works by discarding the current version and adding the updated one, so\n   * it is functionally equivalent to calling {@link MiniSearch#discard}\n   * followed by {@link MiniSearch#add}. The ID of the updated document should\n   * be the same as the original one.\n   *\n   * Since it uses {@link MiniSearch#discard} internally, this method relies on\n   * vacuuming to clean up obsolete document references from the index, allowing\n   * memory to be released (see {@link MiniSearch#discard}).\n   *\n   * @param updatedDocument  The updated document to replace the old version\n   * with\n   */\n  replace (updatedDocument: T): void {\n    const { idField, extractField } = this._options\n    const id = extractField(updatedDocument, idField)\n\n    this.discard(id)\n    this.add(updatedDocument)\n  }\n\n  /**\n   * Triggers a manual vacuuming, cleaning up references to discarded documents\n   * from the inverted index\n   *\n   * Vacuuming is only useful for applications that use the {@link\n   * MiniSearch#discard} or {@link MiniSearch#replace} methods.\n   *\n   * By default, vacuuming is performed automatically when needed (controlled by\n   * the `autoVacuum` field in {@link Options}), so there is usually no need to\n   * call this method, unless one wants to make sure to perform vacuuming at a\n   * specific moment.\n   *\n   * Vacuuming traverses all terms in the inverted index in batches, and cleans\n   * up references to discarded documents from the posting list, allowing memory\n   * to be released.\n   *\n   * The method takes an optional object as argument with the following keys:\n   *\n   *   - `batchSize`: the size of each batch (1000 by default)\n   *\n   *   - `batchWait`: the number of milliseconds to wait between batches (10 by\n   *   default)\n   *\n   * On large indexes, vacuuming could have a non-negligible cost: batching\n   * avoids blocking the thread for long, diluting this cost so that it is not\n   * negatively affecting the application. Nonetheless, this method should only\n   * be called when necessary, and relying on automatic vacuuming is usually\n   * better.\n   *\n   * It returns a promise that resolves (to undefined) when the clean up is\n   * completed. If vacuuming is already ongoing at the time this method is\n   * called, a new one is enqueued immediately after the ongoing one, and a\n   * corresponding promise is returned. However, no more than one vacuuming is\n   * enqueued on top of the ongoing one, even if this method is called more\n   * times (enqueuing multiple ones would be useless).\n   *\n   * @param options  Configuration options for the batch size and delay. See\n   * {@link VacuumOptions}.\n   */\n  vacuum (options: VacuumOptions = {}): Promise<void> {\n    return this.conditionalVacuum(options)\n  }\n\n  private conditionalVacuum (options: VacuumOptions, conditions?: VacuumConditions): Promise<void> {\n    // If a vacuum is already ongoing, schedule another as soon as it finishes,\n    // unless there's already one enqueued. If one was already enqueued, do not\n    // enqueue another on top, but make sure that the conditions are the\n    // broadest.\n    if (this._currentVacuum) {\n      this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions\n      if (this._enqueuedVacuum != null) { return this._enqueuedVacuum }\n\n      this._enqueuedVacuum = this._currentVacuum.then(() => {\n        const conditions = this._enqueuedVacuumConditions\n        this._enqueuedVacuumConditions = defaultVacuumConditions\n        return this.performVacuuming(options, conditions)\n      })\n      return this._enqueuedVacuum\n    }\n\n    if (this.vacuumConditionsMet(conditions) === false) { return Promise.resolve() }\n\n    this._currentVacuum = this.performVacuuming(options)\n    return this._currentVacuum\n  }\n\n  private async performVacuuming (options: VacuumOptions, conditions?: VacuumConditions): Promise<void> {\n    const initialDirtCount = this._dirtCount\n\n    if (this.vacuumConditionsMet(conditions)) {\n      const batchSize = options.batchSize || defaultVacuumOptions.batchSize\n      const batchWait = options.batchWait || defaultVacuumOptions.batchWait\n      let i = 1\n\n      for (const [term, fieldsData] of this._index) {\n        for (const [fieldId, fieldIndex] of fieldsData) {\n          for (const [shortId] of fieldIndex) {\n            if (this._documentIds.has(shortId)) { continue }\n\n            if (fieldIndex.size <= 1) {\n              fieldsData.delete(fieldId)\n            } else {\n              fieldIndex.delete(shortId)\n            }\n          }\n        }\n\n        if (this._index.get(term)!.size === 0) {\n          this._index.delete(term)\n        }\n\n        if (i % batchSize === 0) {\n          await new Promise((resolve) => setTimeout(resolve, batchWait))\n        }\n\n        i += 1\n      }\n\n      this._dirtCount -= initialDirtCount\n    }\n\n    // Make the next lines always async, so they execute after this function returns\n    await null\n\n    this._currentVacuum = this._enqueuedVacuum\n    this._enqueuedVacuum = null\n  }\n\n  private vacuumConditionsMet (conditions?: VacuumConditions) {\n    if (conditions == null) { return true }\n\n    let { minDirtCount, minDirtFactor } = conditions\n    minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount\n    minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor\n\n    return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor\n  }\n\n  /**\n   * Is `true` if a vacuuming operation is ongoing, `false` otherwise\n   */\n  get isVacuuming (): boolean {\n    return this._currentVacuum != null\n  }\n\n  /**\n   * The number of documents discarded since the most recent vacuuming\n   */\n  get dirtCount (): number {\n    return this._dirtCount\n  }\n\n  /**\n   * A number between 0 and 1 giving an indication about the proportion of\n   * documents that are discarded, and can therefore be cleaned up by vacuuming.\n   * A value close to 0 means that the index is relatively clean, while a higher\n   * value means that the index is relatively dirty, and vacuuming could release\n   * memory.\n   */\n  get dirtFactor (): number {\n    return this._dirtCount / (1 + this._documentCount + this._dirtCount)\n  }\n\n  /**\n   * Returns `true` if a document with the given ID is present in the index and\n   * available for search, `false` otherwise\n   *\n   * @param id  The document ID\n   */\n  has (id: any): boolean {\n    return this._idToShortId.has(id)\n  }\n\n  /**\n   * Returns the stored fields (as configured in the `storeFields` constructor\n   * option) for the given document ID. Returns `undefined` if the document is\n   * not present in the index.\n   *\n   * @param id  The document ID\n   */\n  getStoredFields (id: any): Record<string, unknown> | undefined {\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) { return undefined }\n\n    return this._storedFields.get(shortId)\n  }\n\n  /**\n   * Search for documents matching the given search query.\n   *\n   * The result is a list of scored document IDs matching the query, sorted by\n   * descending score, and each including data about which terms were matched and\n   * in which fields.\n   *\n   * ### Basic usage:\n   *\n   * ```javascript\n   * // Search for \"zen art motorcycle\" with default options: terms have to match\n   * // exactly, and individual terms are joined with OR\n   * miniSearch.search('zen art motorcycle')\n   * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]\n   * ```\n   *\n   * ### Restrict search to specific fields:\n   *\n   * ```javascript\n   * // Search only in the 'title' field\n   * miniSearch.search('zen', { fields: ['title'] })\n   * ```\n   *\n   * ### Field boosting:\n   *\n   * ```javascript\n   * // Boost a field\n   * miniSearch.search('zen', { boost: { title: 2 } })\n   * ```\n   *\n   * ### Prefix search:\n   *\n   * ```javascript\n   * // Search for \"moto\" with prefix search (it will match documents\n   * // containing terms that start with \"moto\" or \"neuro\")\n   * miniSearch.search('moto neuro', { prefix: true })\n   * ```\n   *\n   * ### Fuzzy search:\n   *\n   * ```javascript\n   * // Search for \"ismael\" with fuzzy search (it will match documents containing\n   * // terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n   * // (rounded to nearest integer)\n   * miniSearch.search('ismael', { fuzzy: 0.2 })\n   * ```\n   *\n   * ### Combining strategies:\n   *\n   * ```javascript\n   * // Mix of exact match, prefix search, and fuzzy search\n   * miniSearch.search('ismael mob', {\n   *  prefix: true,\n   *  fuzzy: 0.2\n   * })\n   * ```\n   *\n   * ### Advanced prefix and fuzzy search:\n   *\n   * ```javascript\n   * // Perform fuzzy and prefix search depending on the search term. Here\n   * // performing prefix and fuzzy search only on terms longer than 3 characters\n   * miniSearch.search('ismael mob', {\n   *  prefix: term => term.length > 3\n   *  fuzzy: term => term.length > 3 ? 0.2 : null\n   * })\n   * ```\n   *\n   * ### Combine with AND:\n   *\n   * ```javascript\n   * // Combine search terms with AND (to match only documents that contain both\n   * // \"motorcycle\" and \"art\")\n   * miniSearch.search('motorcycle art', { combineWith: 'AND' })\n   * ```\n   *\n   * ### Combine with AND_NOT:\n   *\n   * There is also an AND_NOT combinator, that finds documents that match the\n   * first term, but do not match any of the other terms. This combinator is\n   * rarely useful with simple queries, and is meant to be used with advanced\n   * query combinations (see later for more details).\n   *\n   * ### Filtering results:\n   *\n   * ```javascript\n   * // Filter only results in the 'fiction' category (assuming that 'category'\n   * // is a stored field)\n   * miniSearch.search('motorcycle art', {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * ```\n   *\n   * ### Wildcard query\n   *\n   * Searching for an empty string (assuming the default tokenizer) returns no\n   * results. Sometimes though, one needs to match all documents, like in a\n   * \"wildcard\" search. This is possible by passing the special value\n   * {@link MiniSearch.wildcard} as the query:\n   *\n   * ```javascript\n   * // Return search results for all documents\n   * miniSearch.search(MiniSearch.wildcard)\n   * ```\n   *\n   * Note that search options such as `filter` and `boostDocument` are still\n   * applied, influencing which results are returned, and their order:\n   *\n   * ```javascript\n   * // Return search results for all documents in the 'fiction' category\n   * miniSearch.search(MiniSearch.wildcard, {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * ```\n   *\n   * ### Advanced combination of queries:\n   *\n   * It is possible to combine different subqueries with OR, AND, and AND_NOT,\n   * and even with different search options, by passing a query expression\n   * tree object as the first argument, instead of a string.\n   *\n   * ```javascript\n   * // Search for documents that contain \"zen\" and (\"motorcycle\" or \"archery\")\n   * miniSearch.search({\n   *   combineWith: 'AND',\n   *   queries: [\n   *     'zen',\n   *     {\n   *       combineWith: 'OR',\n   *       queries: ['motorcycle', 'archery']\n   *     }\n   *   ]\n   * })\n   *\n   * // Search for documents that contain (\"apple\" or \"pear\") but not \"juice\" and\n   * // not \"tree\"\n   * miniSearch.search({\n   *   combineWith: 'AND_NOT',\n   *   queries: [\n   *     {\n   *       combineWith: 'OR',\n   *       queries: ['apple', 'pear']\n   *     },\n   *     'juice',\n   *     'tree'\n   *   ]\n   * })\n   * ```\n   *\n   * Each node in the expression tree can be either a string, or an object that\n   * supports all {@link SearchOptions} fields, plus a `queries` array field for\n   * subqueries.\n   *\n   * Note that, while this can become complicated to do by hand for complex or\n   * deeply nested queries, it provides a formalized expression tree API for\n   * external libraries that implement a parser for custom query languages.\n   *\n   * @param query  Search query\n   * @param searchOptions  Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.\n   */\n  search (query: Query, searchOptions: SearchOptions = {}): SearchResult[] {\n    const { searchOptions: globalSearchOptions } = this._options\n    const searchOptionsWithDefaults: SearchOptionsWithDefaults = { ...globalSearchOptions, ...searchOptions }\n\n    const rawResults = this.executeQuery(query, searchOptions)\n    const results = []\n\n    for (const [docId, { score, terms, match }] of rawResults) {\n      // terms are the matched query terms, which will be returned to the user\n      // as queryTerms. The quality is calculated based on them, as opposed to\n      // the matched terms in the document (which can be different due to\n      // prefix and fuzzy match)\n      const quality = terms.length || 1\n\n      const result = {\n        id: this._documentIds.get(docId),\n        score: score * quality,\n        terms: Object.keys(match),\n        queryTerms: terms,\n        match\n      }\n\n      Object.assign(result, this._storedFields.get(docId))\n      if (searchOptionsWithDefaults.filter == null || searchOptionsWithDefaults.filter(result)) {\n        results.push(result)\n      }\n    }\n\n    // If it's a wildcard query, and no document boost is applied, skip sorting\n    // the results, as all results have the same score of 1\n    if (query === MiniSearch.wildcard && searchOptionsWithDefaults.boostDocument == null) {\n      return results\n    }\n\n    results.sort(byScore)\n    return results\n  }\n\n  /**\n   * Provide suggestions for the given search query\n   *\n   * The result is a list of suggested modified search queries, derived from the\n   * given search query, each with a relevance score, sorted by descending score.\n   *\n   * By default, it uses the same options used for search, except that by\n   * default it performs prefix search on the last term of the query, and\n   * combine terms with `'AND'` (requiring all query terms to match). Custom\n   * options can be passed as a second argument. Defaults can be changed upon\n   * calling the {@link MiniSearch} constructor, by passing a\n   * `autoSuggestOptions` option.\n   *\n   * ### Basic usage:\n   *\n   * ```javascript\n   * // Get suggestions for 'neuro':\n   * miniSearch.autoSuggest('neuro')\n   * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]\n   * ```\n   *\n   * ### Multiple words:\n   *\n   * ```javascript\n   * // Get suggestions for 'zen ar':\n   * miniSearch.autoSuggest('zen ar')\n   * // => [\n   * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n   * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n   * // ]\n   * ```\n   *\n   * ### Fuzzy suggestions:\n   *\n   * ```javascript\n   * // Correct spelling mistakes using fuzzy search:\n   * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n   * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n   * ```\n   *\n   * ### Filtering:\n   *\n   * ```javascript\n   * // Get suggestions for 'zen ar', but only within the 'fiction' category\n   * // (assuming that 'category' is a stored field):\n   * miniSearch.autoSuggest('zen ar', {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * // => [\n   * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n   * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n   * // ]\n   * ```\n   *\n   * @param queryString  Query string to be expanded into suggestions\n   * @param options  Search options. The supported options and default values\n   * are the same as for the {@link MiniSearch#search} method, except that by\n   * default prefix search is performed on the last term in the query, and terms\n   * are combined with `'AND'`.\n   * @return  A sorted array of suggestions sorted by relevance score.\n   */\n  autoSuggest (queryString: string, options: SearchOptions = {}): Suggestion[] {\n    options = { ...this._options.autoSuggestOptions, ...options }\n\n    const suggestions: Map<string, Omit<Suggestion, 'suggestion'> & { count: number }> = new Map()\n\n    for (const { score, terms } of this.search(queryString, options)) {\n      const phrase = terms.join(' ')\n      const suggestion = suggestions.get(phrase)\n      if (suggestion != null) {\n        suggestion.score += score\n        suggestion.count += 1\n      } else {\n        suggestions.set(phrase, { score, terms, count: 1 })\n      }\n    }\n\n    const results = []\n    for (const [suggestion, { score, terms, count }] of suggestions) {\n      results.push({ suggestion, terms, score: score / count })\n    }\n\n    results.sort(byScore)\n    return results\n  }\n\n  /**\n   * Total number of documents available to search\n   */\n  get documentCount (): number {\n    return this._documentCount\n  }\n\n  /**\n   * Number of terms in the index\n   */\n  get termCount (): number {\n    return this._index.size\n  }\n\n  /**\n   * Deserializes a JSON index (serialized with `JSON.stringify(miniSearch)`)\n   * and instantiates a MiniSearch instance. It should be given the same options\n   * originally used when serializing the index.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // If the index was serialized with:\n   * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * miniSearch.addAll(documents)\n   *\n   * const json = JSON.stringify(miniSearch)\n   * // It can later be deserialized like this:\n   * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n   * ```\n   *\n   * @param json  JSON-serialized index\n   * @param options  configuration options, same as the constructor\n   * @return An instance of MiniSearch deserialized from the given JSON.\n   */\n  static loadJSON<T = any> (json: string, options: Options<T>): MiniSearch<T> {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return this.loadJS(JSON.parse(json), options)\n  }\n\n  /**\n   * Async equivalent of {@link MiniSearch.loadJSON}\n   *\n   * This function is an alternative to {@link MiniSearch.loadJSON} that returns\n   * a promise, and loads the index in batches, leaving pauses between them to avoid\n   * blocking the main thread. It tends to be slower than the synchronous\n   * version, but does not block the main thread, so it can be a better choice\n   * when deserializing very large indexes.\n   *\n   * @param json  JSON-serialized index\n   * @param options  configuration options, same as the constructor\n   * @return A Promise that will resolve to an instance of MiniSearch deserialized from the given JSON.\n   */\n  static async loadJSONAsync<T = any> (json: string, options: Options<T>): Promise<MiniSearch<T>> {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return this.loadJSAsync(JSON.parse(json), options)\n  }\n\n  /**\n   * Returns the default value of an option. It will throw an error if no option\n   * with the given name exists.\n   *\n   * @param optionName  Name of the option\n   * @return The default value of the given option\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // Get default tokenizer\n   * MiniSearch.getDefault('tokenize')\n   *\n   * // Get default term processor\n   * MiniSearch.getDefault('processTerm')\n   *\n   * // Unknown options will throw an error\n   * MiniSearch.getDefault('notExisting')\n   * // => throws 'MiniSearch: unknown option \"notExisting\"'\n   * ```\n   */\n  static getDefault (optionName: string): any {\n    if (defaultOptions.hasOwnProperty(optionName)) {\n      return getOwnProperty(defaultOptions, optionName)\n    } else {\n      throw new Error(`MiniSearch: unknown option \"${optionName}\"`)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  static loadJS<T = any> (js: AsPlainObject, options: Options<T>): MiniSearch<T> {\n    const {\n      index,\n      documentIds,\n      fieldLength,\n      storedFields,\n      serializationVersion\n    } = js\n\n    const miniSearch = this.instantiateMiniSearch(js, options)\n\n    miniSearch._documentIds = objectToNumericMap(documentIds)\n    miniSearch._fieldLength = objectToNumericMap(fieldLength)\n    miniSearch._storedFields = objectToNumericMap(storedFields)\n\n    for (const [shortId, id] of miniSearch._documentIds) {\n      miniSearch._idToShortId.set(id, shortId)\n    }\n\n    for (const [term, data] of index) {\n      const dataMap = new Map() as FieldTermData\n\n      for (const fieldId of Object.keys(data)) {\n        let indexEntry = data[fieldId]\n\n        // Version 1 used to nest the index entry inside a field called ds\n        if (serializationVersion === 1) {\n          indexEntry = indexEntry.ds as unknown as SerializedIndexEntry\n        }\n\n        dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry) as DocumentTermFreqs)\n      }\n\n      miniSearch._index.set(term, dataMap)\n    }\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  static async loadJSAsync<T = any> (js: AsPlainObject, options: Options<T>): Promise<MiniSearch<T>> {\n    const {\n      index,\n      documentIds,\n      fieldLength,\n      storedFields,\n      serializationVersion\n    } = js\n\n    const miniSearch = this.instantiateMiniSearch(js, options)\n\n    miniSearch._documentIds = await objectToNumericMapAsync(documentIds)\n    miniSearch._fieldLength = await objectToNumericMapAsync(fieldLength)\n    miniSearch._storedFields = await objectToNumericMapAsync(storedFields)\n\n    for (const [shortId, id] of miniSearch._documentIds) {\n      miniSearch._idToShortId.set(id, shortId)\n    }\n\n    let count = 0\n    for (const [term, data] of index) {\n      const dataMap = new Map() as FieldTermData\n\n      for (const fieldId of Object.keys(data)) {\n        let indexEntry = data[fieldId]\n\n        // Version 1 used to nest the index entry inside a field called ds\n        if (serializationVersion === 1) {\n          indexEntry = indexEntry.ds as unknown as SerializedIndexEntry\n        }\n\n        dataMap.set(parseInt(fieldId, 10), await objectToNumericMapAsync(indexEntry) as DocumentTermFreqs)\n      }\n\n      if (++count % 1000 === 0) await wait(0)\n      miniSearch._index.set(term, dataMap)\n    }\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  private static instantiateMiniSearch<T = any> (js: AsPlainObject, options: Options<T>): MiniSearch<T> {\n    const {\n      documentCount,\n      nextId,\n      fieldIds,\n      averageFieldLength,\n      dirtCount,\n      serializationVersion\n    } = js\n\n    if (serializationVersion !== 1 && serializationVersion !== 2) {\n      throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version')\n    }\n\n    const miniSearch = new MiniSearch(options)\n\n    miniSearch._documentCount = documentCount\n    miniSearch._nextId = nextId\n    miniSearch._idToShortId = new Map<any, number>()\n    miniSearch._fieldIds = fieldIds\n    miniSearch._avgFieldLength = averageFieldLength\n    miniSearch._dirtCount = dirtCount || 0\n    miniSearch._index = new SearchableMap()\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  private executeQuery (query: Query, searchOptions: SearchOptions = {}): RawResult {\n    if (query === MiniSearch.wildcard) {\n      return this.executeWildcardQuery(searchOptions)\n    }\n\n    if (typeof query !== 'string') {\n      const options = { ...searchOptions, ...query, queries: undefined }\n      const results = query.queries.map((subquery) => this.executeQuery(subquery, options))\n      return this.combineResults(results, options.combineWith)\n    }\n\n    const { tokenize, processTerm, searchOptions: globalSearchOptions } = this._options\n    const options = { tokenize, processTerm, ...globalSearchOptions, ...searchOptions }\n    const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options\n    const terms = searchTokenize(query)\n      .flatMap((term: string) => searchProcessTerm(term))\n      .filter((term) => !!term) as string[]\n    const queries: QuerySpec[] = terms.map(termToQuerySpec(options))\n    const results = queries.map(query => this.executeQuerySpec(query, options))\n\n    return this.combineResults(results, options.combineWith)\n  }\n\n  /**\n   * @ignore\n   */\n  private executeQuerySpec (query: QuerySpec, searchOptions: SearchOptions): RawResult {\n    const options: SearchOptionsWithDefaults = { ...this._options.searchOptions, ...searchOptions }\n\n    const boosts = (options.fields || this._options.fields).reduce((boosts, field) =>\n      ({ ...boosts, [field]: getOwnProperty(options.boost, field) || 1 }), {})\n\n    const {\n      boostDocument,\n      weights,\n      maxFuzzy,\n      bm25: bm25params\n    } = options\n\n    const { fuzzy: fuzzyWeight, prefix: prefixWeight } = { ...defaultSearchOptions.weights, ...weights }\n\n    const data = this._index.get(query.term)\n    const results = this.termResults(query.term, query.term, 1, query.termBoost, data, boosts, boostDocument, bm25params)\n\n    let prefixMatches\n    let fuzzyMatches\n\n    if (query.prefix) {\n      prefixMatches = this._index.atPrefix(query.term)\n    }\n\n    if (query.fuzzy) {\n      const fuzzy = (query.fuzzy === true) ? 0.2 : query.fuzzy\n      const maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy\n      if (maxDistance) fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance)\n    }\n\n    if (prefixMatches) {\n      for (const [term, data] of prefixMatches) {\n        const distance = term.length - query.term.length\n        if (!distance) { continue } // Skip exact match.\n\n        // Delete the term from fuzzy results (if present) if it is also a\n        // prefix result. This entry will always be scored as a prefix result.\n        fuzzyMatches?.delete(term)\n\n        // Weight gradually approaches 0 as distance goes to infinity, with the\n        // weight for the hypothetical distance 0 being equal to prefixWeight.\n        // The rate of change is much lower than that of fuzzy matches to\n        // account for the fact that prefix matches stay more relevant than\n        // fuzzy matches for longer distances.\n        const weight = prefixWeight * term.length / (term.length + 0.3 * distance)\n        this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results)\n      }\n    }\n\n    if (fuzzyMatches) {\n      for (const term of fuzzyMatches.keys()) {\n        const [data, distance] = fuzzyMatches.get(term)!\n        if (!distance) { continue } // Skip exact match.\n\n        // Weight gradually approaches 0 as distance goes to infinity, with the\n        // weight for the hypothetical distance 0 being equal to fuzzyWeight.\n        const weight = fuzzyWeight * term.length / (term.length + distance)\n        this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results)\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private executeWildcardQuery (searchOptions: SearchOptions): RawResult {\n    const results = new Map() as RawResult\n    const options: SearchOptionsWithDefaults = { ...this._options.searchOptions, ...searchOptions }\n\n    for (const [shortId, id] of this._documentIds) {\n      const score = options.boostDocument ? options.boostDocument(id, '', this._storedFields.get(shortId)) : 1\n      results.set(shortId, {\n        score,\n        terms: [],\n        match: {}\n      })\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private combineResults (results: RawResult[], combineWith: CombinationOperator = OR): RawResult {\n    if (results.length === 0) { return new Map() }\n    const operator = combineWith.toLowerCase()\n    const combinator = (combinators as Record<string, CombinatorFunction>)[operator]\n\n    if (!combinator) {\n      throw new Error(`Invalid combination operator: ${combineWith}`)\n    }\n\n    return results.reduce(combinator) || new Map()\n  }\n\n  /**\n   * Allows serialization of the index to JSON, to possibly store it and later\n   * deserialize it with {@link MiniSearch.loadJSON}.\n   *\n   * Normally one does not directly call this method, but rather call the\n   * standard JavaScript `JSON.stringify()` passing the {@link MiniSearch}\n   * instance, and JavaScript will internally call this method. Upon\n   * deserialization, one must pass to {@link MiniSearch.loadJSON} the same\n   * options used to create the original instance that was serialized.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // Serialize the index:\n   * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * miniSearch.addAll(documents)\n   * const json = JSON.stringify(miniSearch)\n   *\n   * // Later, to deserialize it:\n   * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n   * ```\n   *\n   * @return A plain-object serializable representation of the search index.\n   */\n  toJSON (): AsPlainObject {\n    const index: [string, { [key: string]: SerializedIndexEntry }][] = []\n\n    for (const [term, fieldIndex] of this._index) {\n      const data: { [key: string]: SerializedIndexEntry } = {}\n\n      for (const [fieldId, freqs] of fieldIndex) {\n        data[fieldId] = Object.fromEntries(freqs)\n      }\n\n      index.push([term, data])\n    }\n\n    return {\n      documentCount: this._documentCount,\n      nextId: this._nextId,\n      documentIds: Object.fromEntries(this._documentIds),\n      fieldIds: this._fieldIds,\n      fieldLength: Object.fromEntries(this._fieldLength),\n      averageFieldLength: this._avgFieldLength,\n      storedFields: Object.fromEntries(this._storedFields),\n      dirtCount: this._dirtCount,\n      index,\n      serializationVersion: 2\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private termResults (\n    sourceTerm: string,\n    derivedTerm: string,\n    termWeight: number,\n    termBoost: number,\n    fieldTermData: FieldTermData | undefined,\n    fieldBoosts: { [field: string]: number },\n    boostDocumentFn: ((id: any, term: string, storedFields?: Record<string, unknown>) => number) | undefined,\n    bm25params: BM25Params,\n    results: RawResult = new Map()\n  ): RawResult {\n    if (fieldTermData == null) return results\n\n    for (const field of Object.keys(fieldBoosts)) {\n      const fieldBoost = fieldBoosts[field]\n      const fieldId = this._fieldIds[field]\n\n      const fieldTermFreqs = fieldTermData.get(fieldId)\n      if (fieldTermFreqs == null) continue\n\n      let matchingFields = fieldTermFreqs.size\n      const avgFieldLength = this._avgFieldLength[fieldId]\n\n      for (const docId of fieldTermFreqs.keys()) {\n        if (!this._documentIds.has(docId)) {\n          this.removeTerm(fieldId, docId, derivedTerm)\n          matchingFields -= 1\n          continue\n        }\n\n        const docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1\n        if (!docBoost) continue\n\n        const termFreq = fieldTermFreqs.get(docId)!\n        const fieldLength = this._fieldLength.get(docId)![fieldId]\n\n        // NOTE: The total number of fields is set to the number of documents\n        // `this._documentCount`. It could also make sense to use the number of\n        // documents where the current field is non-blank as a normalization\n        // factor. This will make a difference in scoring if the field is rarely\n        // present. This is currently not supported, and may require further\n        // analysis to see if it is a valid use case.\n        const rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params)\n        const weightedScore = termWeight * termBoost * fieldBoost * docBoost * rawScore\n\n        const result = results.get(docId)\n        if (result) {\n          result.score += weightedScore\n          assignUniqueTerm(result.terms, sourceTerm)\n          const match = getOwnProperty(result.match, derivedTerm)\n          if (match) {\n            match.push(field)\n          } else {\n            result.match[derivedTerm] = [field]\n          }\n        } else {\n          results.set(docId, {\n            score: weightedScore,\n            terms: [sourceTerm],\n            match: { [derivedTerm]: [field] }\n          })\n        }\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private addTerm (fieldId: number, documentId: number, term: string): void {\n    const indexData = this._index.fetch(term, createMap)\n\n    let fieldIndex = indexData.get(fieldId)\n    if (fieldIndex == null) {\n      fieldIndex = new Map()\n      fieldIndex.set(documentId, 1)\n      indexData.set(fieldId, fieldIndex)\n    } else {\n      const docs = fieldIndex.get(documentId)\n      fieldIndex.set(documentId, (docs || 0) + 1)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private removeTerm (fieldId: number, documentId: number, term: string): void {\n    if (!this._index.has(term)) {\n      this.warnDocumentChanged(documentId, fieldId, term)\n      return\n    }\n\n    const indexData = this._index.fetch(term, createMap)\n\n    const fieldIndex = indexData.get(fieldId)\n    if (fieldIndex == null || fieldIndex.get(documentId) == null) {\n      this.warnDocumentChanged(documentId, fieldId, term)\n    } else if (fieldIndex.get(documentId)! <= 1) {\n      if (fieldIndex.size <= 1) {\n        indexData.delete(fieldId)\n      } else {\n        fieldIndex.delete(documentId)\n      }\n    } else {\n      fieldIndex.set(documentId, fieldIndex.get(documentId)! - 1)\n    }\n\n    if (this._index.get(term)!.size === 0) {\n      this._index.delete(term)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private warnDocumentChanged (shortDocumentId: number, fieldId: number, term: string): void {\n    for (const fieldName of Object.keys(this._fieldIds)) {\n      if (this._fieldIds[fieldName] === fieldId) {\n        this._options.logger('warn', `MiniSearch: document with ID ${this._documentIds.get(shortDocumentId)} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`, 'version_conflict')\n        return\n      }\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private addDocumentId (documentId: any): number {\n    const shortDocumentId = this._nextId\n    this._idToShortId.set(documentId, shortDocumentId)\n    this._documentIds.set(shortDocumentId, documentId)\n    this._documentCount += 1\n    this._nextId += 1\n    return shortDocumentId\n  }\n\n  /**\n   * @ignore\n   */\n  private addFields (fields: string[]): void {\n    for (let i = 0; i < fields.length; i++) {\n      this._fieldIds[fields[i]] = i\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private addFieldLength (documentId: number, fieldId: number, count: number, length: number): void {\n    let fieldLengths = this._fieldLength.get(documentId)\n    if (fieldLengths == null) this._fieldLength.set(documentId, fieldLengths = [])\n    fieldLengths[fieldId] = length\n\n    const averageFieldLength = this._avgFieldLength[fieldId] || 0\n    const totalFieldLength = (averageFieldLength * count) + length\n    this._avgFieldLength[fieldId] = totalFieldLength / (count + 1)\n  }\n\n  /**\n   * @ignore\n   */\n  private removeFieldLength (documentId: number, fieldId: number, count: number, length: number): void {\n    if (count === 1) {\n      this._avgFieldLength[fieldId] = 0\n      return\n    }\n    const totalFieldLength = (this._avgFieldLength[fieldId] * count) - length\n    this._avgFieldLength[fieldId] = totalFieldLength / (count - 1)\n  }\n\n  /**\n   * @ignore\n   */\n  private saveStoredFields (documentId: number, doc: T): void {\n    const { storeFields, extractField } = this._options\n    if (storeFields == null || storeFields.length === 0) { return }\n\n    let documentFields = this._storedFields.get(documentId)\n    if (documentFields == null) this._storedFields.set(documentId, documentFields = {})\n\n    for (const fieldName of storeFields) {\n      const fieldValue = extractField(doc, fieldName)\n      if (fieldValue !== undefined) documentFields[fieldName] = fieldValue\n    }\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.add",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.add",
    "startLine": 746,
    "endLine": 781,
    "text": "  add (document: T): void {\n    const { extractField, stringifyField, tokenize, processTerm, fields, idField } = this._options\n    const id = extractField(document, idField)\n    if (id == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n\n    if (this._idToShortId.has(id)) {\n      throw new Error(`MiniSearch: duplicate ID ${id}`)\n    }\n\n    const shortDocumentId = this.addDocumentId(id)\n    this.saveStoredFields(shortDocumentId, document)\n\n    for (const field of fields) {\n      const fieldValue = extractField(document, field)\n      if (fieldValue == null) continue\n\n      const tokens = tokenize(stringifyField(fieldValue, field), field)\n      const fieldId = this._fieldIds[field]\n\n      const uniqueTerms = new Set(tokens).size\n      this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms)\n\n      for (const term of tokens) {\n        const processedTerm = processTerm(term, field)\n        if (Array.isArray(processedTerm)) {\n          for (const t of processedTerm) {\n            this.addTerm(fieldId, shortDocumentId, t)\n          }\n        } else if (processedTerm) {\n          this.addTerm(fieldId, shortDocumentId, processedTerm)\n        }\n      }\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.addAll",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.addAll",
    "startLine": 788,
    "endLine": 790,
    "text": "  addAll (documents: readonly T[]): void {\n    for (const document of documents) this.add(document)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.addAllAsync",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.addAllAsync",
    "startLine": 803,
    "endLine": 822,
    "text": "  addAllAsync (documents: readonly T[], options: { chunkSize?: number } = {}): Promise<void> {\n    const { chunkSize = 10 } = options\n    const acc: { chunk: T[], promise: Promise<void> } = { chunk: [], promise: Promise.resolve() }\n\n    const { chunk, promise } = documents.reduce(({ chunk, promise }, document: T, i: number) => {\n      chunk.push(document)\n      if ((i + 1) % chunkSize === 0) {\n        return {\n          chunk: [],\n          promise: promise\n            .then(() => new Promise(resolve => setTimeout(resolve, 0)))\n            .then(() => this.addAll(chunk))\n        }\n      } else {\n        return { chunk, promise }\n      }\n    }, acc)\n\n    return promise.then(() => this.addAll(chunk))\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.remove",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.remove",
    "startLine": 838,
    "endLine": 879,
    "text": "  remove (document: T): void {\n    const { tokenize, processTerm, extractField, stringifyField, fields, idField } = this._options\n    const id = extractField(document, idField)\n\n    if (id == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) {\n      throw new Error(`MiniSearch: cannot remove document with ID ${id}: it is not in the index`)\n    }\n\n    for (const field of fields) {\n      const fieldValue = extractField(document, field)\n      if (fieldValue == null) continue\n\n      const tokens = tokenize(stringifyField(fieldValue, field), field)\n      const fieldId = this._fieldIds[field]\n\n      const uniqueTerms = new Set(tokens).size\n      this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms)\n\n      for (const term of tokens) {\n        const processedTerm = processTerm(term, field)\n        if (Array.isArray(processedTerm)) {\n          for (const t of processedTerm) {\n            this.removeTerm(fieldId, shortId, t)\n          }\n        } else if (processedTerm) {\n          this.removeTerm(fieldId, shortId, processedTerm)\n        }\n      }\n    }\n\n    this._storedFields.delete(shortId)\n    this._documentIds.delete(shortId)\n    this._idToShortId.delete(id)\n    this._fieldLength.delete(shortId)\n    this._documentCount -= 1\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.removeAll",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.removeAll",
    "startLine": 890,
    "endLine": 905,
    "text": "  removeAll (documents?: readonly T[]): void {\n    if (documents) {\n      for (const document of documents) this.remove(document)\n    } else if (arguments.length > 0) {\n      throw new Error('Expected documents to be present. Omit the argument to remove all documents.')\n    } else {\n      this._index = new SearchableMap()\n      this._documentCount = 0\n      this._documentIds = new Map()\n      this._idToShortId = new Map()\n      this._fieldLength = new Map()\n      this._avgFieldLength = []\n      this._storedFields = new Map()\n      this._nextId = 0\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.discard",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.discard",
    "startLine": 951,
    "endLine": 972,
    "text": "  discard (id: any): void {\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) {\n      throw new Error(`MiniSearch: cannot discard document with ID ${id}: it is not in the index`)\n    }\n\n    this._idToShortId.delete(id)\n    this._documentIds.delete(shortId)\n    this._storedFields.delete(shortId)\n\n    ;(this._fieldLength.get(shortId) || []).forEach((fieldLength, fieldId) => {\n      this.removeFieldLength(shortId, fieldId, this._documentCount, fieldLength)\n    })\n\n    this._fieldLength.delete(shortId)\n\n    this._documentCount -= 1\n    this._dirtCount += 1\n\n    this.maybeAutoVacuum()\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.maybeAutoVacuum",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.maybeAutoVacuum",
    "startLine": 974,
    "endLine": 979,
    "text": "  private maybeAutoVacuum (): void {\n    if (this._options.autoVacuum === false) { return }\n\n    const { minDirtFactor, minDirtCount, batchSize, batchWait } = this._options.autoVacuum\n    this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor })\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.discardAll",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.discardAll",
    "startLine": 993,
    "endLine": 1007,
    "text": "  discardAll (ids: readonly any[]): void {\n    const autoVacuum = this._options.autoVacuum\n\n    try {\n      this._options.autoVacuum = false\n\n      for (const id of ids) {\n        this.discard(id)\n      }\n    } finally {\n      this._options.autoVacuum = autoVacuum\n    }\n\n    this.maybeAutoVacuum()\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.replace",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.replace",
    "startLine": 1024,
    "endLine": 1030,
    "text": "  replace (updatedDocument: T): void {\n    const { idField, extractField } = this._options\n    const id = extractField(updatedDocument, idField)\n\n    this.discard(id)\n    this.add(updatedDocument)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.vacuum",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.vacuum",
    "startLine": 1071,
    "endLine": 1073,
    "text": "  vacuum (options: VacuumOptions = {}): Promise<void> {\n    return this.conditionalVacuum(options)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.conditionalVacuum",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.conditionalVacuum",
    "startLine": 1075,
    "endLine": 1096,
    "text": "  private conditionalVacuum (options: VacuumOptions, conditions?: VacuumConditions): Promise<void> {\n    // If a vacuum is already ongoing, schedule another as soon as it finishes,\n    // unless there's already one enqueued. If one was already enqueued, do not\n    // enqueue another on top, but make sure that the conditions are the\n    // broadest.\n    if (this._currentVacuum) {\n      this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions\n      if (this._enqueuedVacuum != null) { return this._enqueuedVacuum }\n\n      this._enqueuedVacuum = this._currentVacuum.then(() => {\n        const conditions = this._enqueuedVacuumConditions\n        this._enqueuedVacuumConditions = defaultVacuumConditions\n        return this.performVacuuming(options, conditions)\n      })\n      return this._enqueuedVacuum\n    }\n\n    if (this.vacuumConditionsMet(conditions) === false) { return Promise.resolve() }\n\n    this._currentVacuum = this.performVacuuming(options)\n    return this._currentVacuum\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.performVacuuming",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.performVacuuming",
    "startLine": 1098,
    "endLine": 1138,
    "text": "  private async performVacuuming (options: VacuumOptions, conditions?: VacuumConditions): Promise<void> {\n    const initialDirtCount = this._dirtCount\n\n    if (this.vacuumConditionsMet(conditions)) {\n      const batchSize = options.batchSize || defaultVacuumOptions.batchSize\n      const batchWait = options.batchWait || defaultVacuumOptions.batchWait\n      let i = 1\n\n      for (const [term, fieldsData] of this._index) {\n        for (const [fieldId, fieldIndex] of fieldsData) {\n          for (const [shortId] of fieldIndex) {\n            if (this._documentIds.has(shortId)) { continue }\n\n            if (fieldIndex.size <= 1) {\n              fieldsData.delete(fieldId)\n            } else {\n              fieldIndex.delete(shortId)\n            }\n          }\n        }\n\n        if (this._index.get(term)!.size === 0) {\n          this._index.delete(term)\n        }\n\n        if (i % batchSize === 0) {\n          await new Promise((resolve) => setTimeout(resolve, batchWait))\n        }\n\n        i += 1\n      }\n\n      this._dirtCount -= initialDirtCount\n    }\n\n    // Make the next lines always async, so they execute after this function returns\n    await null\n\n    this._currentVacuum = this._enqueuedVacuum\n    this._enqueuedVacuum = null\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.vacuumConditionsMet",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.vacuumConditionsMet",
    "startLine": 1140,
    "endLine": 1148,
    "text": "  private vacuumConditionsMet (conditions?: VacuumConditions) {\n    if (conditions == null) { return true }\n\n    let { minDirtCount, minDirtFactor } = conditions\n    minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount\n    minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor\n\n    return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.has",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.has",
    "startLine": 1181,
    "endLine": 1183,
    "text": "  has (id: any): boolean {\n    return this._idToShortId.has(id)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.getStoredFields",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.getStoredFields",
    "startLine": 1192,
    "endLine": 1198,
    "text": "  getStoredFields (id: any): Record<string, unknown> | undefined {\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) { return undefined }\n\n    return this._storedFields.get(shortId)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.search",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.search",
    "startLine": 1360,
    "endLine": 1396,
    "text": "  search (query: Query, searchOptions: SearchOptions = {}): SearchResult[] {\n    const { searchOptions: globalSearchOptions } = this._options\n    const searchOptionsWithDefaults: SearchOptionsWithDefaults = { ...globalSearchOptions, ...searchOptions }\n\n    const rawResults = this.executeQuery(query, searchOptions)\n    const results = []\n\n    for (const [docId, { score, terms, match }] of rawResults) {\n      // terms are the matched query terms, which will be returned to the user\n      // as queryTerms. The quality is calculated based on them, as opposed to\n      // the matched terms in the document (which can be different due to\n      // prefix and fuzzy match)\n      const quality = terms.length || 1\n\n      const result = {\n        id: this._documentIds.get(docId),\n        score: score * quality,\n        terms: Object.keys(match),\n        queryTerms: terms,\n        match\n      }\n\n      Object.assign(result, this._storedFields.get(docId))\n      if (searchOptionsWithDefaults.filter == null || searchOptionsWithDefaults.filter(result)) {\n        results.push(result)\n      }\n    }\n\n    // If it's a wildcard query, and no document boost is applied, skip sorting\n    // the results, as all results have the same score of 1\n    if (query === MiniSearch.wildcard && searchOptionsWithDefaults.boostDocument == null) {\n      return results\n    }\n\n    results.sort(byScore)\n    return results\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.autoSuggest",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.autoSuggest",
    "startLine": 1459,
    "endLine": 1482,
    "text": "  autoSuggest (queryString: string, options: SearchOptions = {}): Suggestion[] {\n    options = { ...this._options.autoSuggestOptions, ...options }\n\n    const suggestions: Map<string, Omit<Suggestion, 'suggestion'> & { count: number }> = new Map()\n\n    for (const { score, terms } of this.search(queryString, options)) {\n      const phrase = terms.join(' ')\n      const suggestion = suggestions.get(phrase)\n      if (suggestion != null) {\n        suggestion.score += score\n        suggestion.count += 1\n      } else {\n        suggestions.set(phrase, { score, terms, count: 1 })\n      }\n    }\n\n    const results = []\n    for (const [suggestion, { score, terms, count }] of suggestions) {\n      results.push({ suggestion, terms, score: score / count })\n    }\n\n    results.sort(byScore)\n    return results\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.loadJSON",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.loadJSON",
    "startLine": 1519,
    "endLine": 1524,
    "text": "  static loadJSON<T = any> (json: string, options: Options<T>): MiniSearch<T> {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return this.loadJS(JSON.parse(json), options)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.loadJSONAsync",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.loadJSONAsync",
    "startLine": 1539,
    "endLine": 1544,
    "text": "  static async loadJSONAsync<T = any> (json: string, options: Options<T>): Promise<MiniSearch<T>> {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return this.loadJSAsync(JSON.parse(json), options)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.getDefault",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.getDefault",
    "startLine": 1567,
    "endLine": 1573,
    "text": "  static getDefault (optionName: string): any {\n    if (defaultOptions.hasOwnProperty(optionName)) {\n      return getOwnProperty(defaultOptions, optionName)\n    } else {\n      throw new Error(`MiniSearch: unknown option \"${optionName}\"`)\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.loadJS",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.loadJS",
    "startLine": 1578,
    "endLine": 1615,
    "text": "  static loadJS<T = any> (js: AsPlainObject, options: Options<T>): MiniSearch<T> {\n    const {\n      index,\n      documentIds,\n      fieldLength,\n      storedFields,\n      serializationVersion\n    } = js\n\n    const miniSearch = this.instantiateMiniSearch(js, options)\n\n    miniSearch._documentIds = objectToNumericMap(documentIds)\n    miniSearch._fieldLength = objectToNumericMap(fieldLength)\n    miniSearch._storedFields = objectToNumericMap(storedFields)\n\n    for (const [shortId, id] of miniSearch._documentIds) {\n      miniSearch._idToShortId.set(id, shortId)\n    }\n\n    for (const [term, data] of index) {\n      const dataMap = new Map() as FieldTermData\n\n      for (const fieldId of Object.keys(data)) {\n        let indexEntry = data[fieldId]\n\n        // Version 1 used to nest the index entry inside a field called ds\n        if (serializationVersion === 1) {\n          indexEntry = indexEntry.ds as unknown as SerializedIndexEntry\n        }\n\n        dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry) as DocumentTermFreqs)\n      }\n\n      miniSearch._index.set(term, dataMap)\n    }\n\n    return miniSearch\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.loadJSAsync",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.loadJSAsync",
    "startLine": 1620,
    "endLine": 1659,
    "text": "  static async loadJSAsync<T = any> (js: AsPlainObject, options: Options<T>): Promise<MiniSearch<T>> {\n    const {\n      index,\n      documentIds,\n      fieldLength,\n      storedFields,\n      serializationVersion\n    } = js\n\n    const miniSearch = this.instantiateMiniSearch(js, options)\n\n    miniSearch._documentIds = await objectToNumericMapAsync(documentIds)\n    miniSearch._fieldLength = await objectToNumericMapAsync(fieldLength)\n    miniSearch._storedFields = await objectToNumericMapAsync(storedFields)\n\n    for (const [shortId, id] of miniSearch._documentIds) {\n      miniSearch._idToShortId.set(id, shortId)\n    }\n\n    let count = 0\n    for (const [term, data] of index) {\n      const dataMap = new Map() as FieldTermData\n\n      for (const fieldId of Object.keys(data)) {\n        let indexEntry = data[fieldId]\n\n        // Version 1 used to nest the index entry inside a field called ds\n        if (serializationVersion === 1) {\n          indexEntry = indexEntry.ds as unknown as SerializedIndexEntry\n        }\n\n        dataMap.set(parseInt(fieldId, 10), await objectToNumericMapAsync(indexEntry) as DocumentTermFreqs)\n      }\n\n      if (++count % 1000 === 0) await wait(0)\n      miniSearch._index.set(term, dataMap)\n    }\n\n    return miniSearch\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.instantiateMiniSearch",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.instantiateMiniSearch",
    "startLine": 1664,
    "endLine": 1689,
    "text": "  private static instantiateMiniSearch<T = any> (js: AsPlainObject, options: Options<T>): MiniSearch<T> {\n    const {\n      documentCount,\n      nextId,\n      fieldIds,\n      averageFieldLength,\n      dirtCount,\n      serializationVersion\n    } = js\n\n    if (serializationVersion !== 1 && serializationVersion !== 2) {\n      throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version')\n    }\n\n    const miniSearch = new MiniSearch(options)\n\n    miniSearch._documentCount = documentCount\n    miniSearch._nextId = nextId\n    miniSearch._idToShortId = new Map<any, number>()\n    miniSearch._fieldIds = fieldIds\n    miniSearch._avgFieldLength = averageFieldLength\n    miniSearch._dirtCount = dirtCount || 0\n    miniSearch._index = new SearchableMap()\n\n    return miniSearch\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.executeQuery",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.executeQuery",
    "startLine": 1694,
    "endLine": 1715,
    "text": "  private executeQuery (query: Query, searchOptions: SearchOptions = {}): RawResult {\n    if (query === MiniSearch.wildcard) {\n      return this.executeWildcardQuery(searchOptions)\n    }\n\n    if (typeof query !== 'string') {\n      const options = { ...searchOptions, ...query, queries: undefined }\n      const results = query.queries.map((subquery) => this.executeQuery(subquery, options))\n      return this.combineResults(results, options.combineWith)\n    }\n\n    const { tokenize, processTerm, searchOptions: globalSearchOptions } = this._options\n    const options = { tokenize, processTerm, ...globalSearchOptions, ...searchOptions }\n    const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options\n    const terms = searchTokenize(query)\n      .flatMap((term: string) => searchProcessTerm(term))\n      .filter((term) => !!term) as string[]\n    const queries: QuerySpec[] = terms.map(termToQuerySpec(options))\n    const results = queries.map(query => this.executeQuerySpec(query, options))\n\n    return this.combineResults(results, options.combineWith)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.executeQuerySpec",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.executeQuerySpec",
    "startLine": 1720,
    "endLine": 1783,
    "text": "  private executeQuerySpec (query: QuerySpec, searchOptions: SearchOptions): RawResult {\n    const options: SearchOptionsWithDefaults = { ...this._options.searchOptions, ...searchOptions }\n\n    const boosts = (options.fields || this._options.fields).reduce((boosts, field) =>\n      ({ ...boosts, [field]: getOwnProperty(options.boost, field) || 1 }), {})\n\n    const {\n      boostDocument,\n      weights,\n      maxFuzzy,\n      bm25: bm25params\n    } = options\n\n    const { fuzzy: fuzzyWeight, prefix: prefixWeight } = { ...defaultSearchOptions.weights, ...weights }\n\n    const data = this._index.get(query.term)\n    const results = this.termResults(query.term, query.term, 1, query.termBoost, data, boosts, boostDocument, bm25params)\n\n    let prefixMatches\n    let fuzzyMatches\n\n    if (query.prefix) {\n      prefixMatches = this._index.atPrefix(query.term)\n    }\n\n    if (query.fuzzy) {\n      const fuzzy = (query.fuzzy === true) ? 0.2 : query.fuzzy\n      const maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy\n      if (maxDistance) fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance)\n    }\n\n    if (prefixMatches) {\n      for (const [term, data] of prefixMatches) {\n        const distance = term.length - query.term.length\n        if (!distance) { continue } // Skip exact match.\n\n        // Delete the term from fuzzy results (if present) if it is also a\n        // prefix result. This entry will always be scored as a prefix result.\n        fuzzyMatches?.delete(term)\n\n        // Weight gradually approaches 0 as distance goes to infinity, with the\n        // weight for the hypothetical distance 0 being equal to prefixWeight.\n        // The rate of change is much lower than that of fuzzy matches to\n        // account for the fact that prefix matches stay more relevant than\n        // fuzzy matches for longer distances.\n        const weight = prefixWeight * term.length / (term.length + 0.3 * distance)\n        this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results)\n      }\n    }\n\n    if (fuzzyMatches) {\n      for (const term of fuzzyMatches.keys()) {\n        const [data, distance] = fuzzyMatches.get(term)!\n        if (!distance) { continue } // Skip exact match.\n\n        // Weight gradually approaches 0 as distance goes to infinity, with the\n        // weight for the hypothetical distance 0 being equal to fuzzyWeight.\n        const weight = fuzzyWeight * term.length / (term.length + distance)\n        this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results)\n      }\n    }\n\n    return results\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.executeWildcardQuery",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.executeWildcardQuery",
    "startLine": 1788,
    "endLine": 1802,
    "text": "  private executeWildcardQuery (searchOptions: SearchOptions): RawResult {\n    const results = new Map() as RawResult\n    const options: SearchOptionsWithDefaults = { ...this._options.searchOptions, ...searchOptions }\n\n    for (const [shortId, id] of this._documentIds) {\n      const score = options.boostDocument ? options.boostDocument(id, '', this._storedFields.get(shortId)) : 1\n      results.set(shortId, {\n        score,\n        terms: [],\n        match: {}\n      })\n    }\n\n    return results\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.combineResults",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.combineResults",
    "startLine": 1807,
    "endLine": 1817,
    "text": "  private combineResults (results: RawResult[], combineWith: CombinationOperator = OR): RawResult {\n    if (results.length === 0) { return new Map() }\n    const operator = combineWith.toLowerCase()\n    const combinator = (combinators as Record<string, CombinatorFunction>)[operator]\n\n    if (!combinator) {\n      throw new Error(`Invalid combination operator: ${combineWith}`)\n    }\n\n    return results.reduce(combinator) || new Map()\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.toJSON",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.toJSON",
    "startLine": 1843,
    "endLine": 1868,
    "text": "  toJSON (): AsPlainObject {\n    const index: [string, { [key: string]: SerializedIndexEntry }][] = []\n\n    for (const [term, fieldIndex] of this._index) {\n      const data: { [key: string]: SerializedIndexEntry } = {}\n\n      for (const [fieldId, freqs] of fieldIndex) {\n        data[fieldId] = Object.fromEntries(freqs)\n      }\n\n      index.push([term, data])\n    }\n\n    return {\n      documentCount: this._documentCount,\n      nextId: this._nextId,\n      documentIds: Object.fromEntries(this._documentIds),\n      fieldIds: this._fieldIds,\n      fieldLength: Object.fromEntries(this._fieldLength),\n      averageFieldLength: this._avgFieldLength,\n      storedFields: Object.fromEntries(this._storedFields),\n      dirtCount: this._dirtCount,\n      index,\n      serializationVersion: 2\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.termResults",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.termResults",
    "startLine": 1873,
    "endLine": 1939,
    "text": "  private termResults (\n    sourceTerm: string,\n    derivedTerm: string,\n    termWeight: number,\n    termBoost: number,\n    fieldTermData: FieldTermData | undefined,\n    fieldBoosts: { [field: string]: number },\n    boostDocumentFn: ((id: any, term: string, storedFields?: Record<string, unknown>) => number) | undefined,\n    bm25params: BM25Params,\n    results: RawResult = new Map()\n  ): RawResult {\n    if (fieldTermData == null) return results\n\n    for (const field of Object.keys(fieldBoosts)) {\n      const fieldBoost = fieldBoosts[field]\n      const fieldId = this._fieldIds[field]\n\n      const fieldTermFreqs = fieldTermData.get(fieldId)\n      if (fieldTermFreqs == null) continue\n\n      let matchingFields = fieldTermFreqs.size\n      const avgFieldLength = this._avgFieldLength[fieldId]\n\n      for (const docId of fieldTermFreqs.keys()) {\n        if (!this._documentIds.has(docId)) {\n          this.removeTerm(fieldId, docId, derivedTerm)\n          matchingFields -= 1\n          continue\n        }\n\n        const docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1\n        if (!docBoost) continue\n\n        const termFreq = fieldTermFreqs.get(docId)!\n        const fieldLength = this._fieldLength.get(docId)![fieldId]\n\n        // NOTE: The total number of fields is set to the number of documents\n        // `this._documentCount`. It could also make sense to use the number of\n        // documents where the current field is non-blank as a normalization\n        // factor. This will make a difference in scoring if the field is rarely\n        // present. This is currently not supported, and may require further\n        // analysis to see if it is a valid use case.\n        const rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params)\n        const weightedScore = termWeight * termBoost * fieldBoost * docBoost * rawScore\n\n        const result = results.get(docId)\n        if (result) {\n          result.score += weightedScore\n          assignUniqueTerm(result.terms, sourceTerm)\n          const match = getOwnProperty(result.match, derivedTerm)\n          if (match) {\n            match.push(field)\n          } else {\n            result.match[derivedTerm] = [field]\n          }\n        } else {\n          results.set(docId, {\n            score: weightedScore,\n            terms: [sourceTerm],\n            match: { [derivedTerm]: [field] }\n          })\n        }\n      }\n    }\n\n    return results\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.addTerm",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.addTerm",
    "startLine": 1944,
    "endLine": 1956,
    "text": "  private addTerm (fieldId: number, documentId: number, term: string): void {\n    const indexData = this._index.fetch(term, createMap)\n\n    let fieldIndex = indexData.get(fieldId)\n    if (fieldIndex == null) {\n      fieldIndex = new Map()\n      fieldIndex.set(documentId, 1)\n      indexData.set(fieldId, fieldIndex)\n    } else {\n      const docs = fieldIndex.get(documentId)\n      fieldIndex.set(documentId, (docs || 0) + 1)\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.removeTerm",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.removeTerm",
    "startLine": 1961,
    "endLine": 1985,
    "text": "  private removeTerm (fieldId: number, documentId: number, term: string): void {\n    if (!this._index.has(term)) {\n      this.warnDocumentChanged(documentId, fieldId, term)\n      return\n    }\n\n    const indexData = this._index.fetch(term, createMap)\n\n    const fieldIndex = indexData.get(fieldId)\n    if (fieldIndex == null || fieldIndex.get(documentId) == null) {\n      this.warnDocumentChanged(documentId, fieldId, term)\n    } else if (fieldIndex.get(documentId)! <= 1) {\n      if (fieldIndex.size <= 1) {\n        indexData.delete(fieldId)\n      } else {\n        fieldIndex.delete(documentId)\n      }\n    } else {\n      fieldIndex.set(documentId, fieldIndex.get(documentId)! - 1)\n    }\n\n    if (this._index.get(term)!.size === 0) {\n      this._index.delete(term)\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.warnDocumentChanged",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.warnDocumentChanged",
    "startLine": 1990,
    "endLine": 1997,
    "text": "  private warnDocumentChanged (shortDocumentId: number, fieldId: number, term: string): void {\n    for (const fieldName of Object.keys(this._fieldIds)) {\n      if (this._fieldIds[fieldName] === fieldId) {\n        this._options.logger('warn', `MiniSearch: document with ID ${this._documentIds.get(shortDocumentId)} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`, 'version_conflict')\n        return\n      }\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.addDocumentId",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.addDocumentId",
    "startLine": 2002,
    "endLine": 2009,
    "text": "  private addDocumentId (documentId: any): number {\n    const shortDocumentId = this._nextId\n    this._idToShortId.set(documentId, shortDocumentId)\n    this._documentIds.set(shortDocumentId, documentId)\n    this._documentCount += 1\n    this._nextId += 1\n    return shortDocumentId\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.addFields",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.addFields",
    "startLine": 2014,
    "endLine": 2018,
    "text": "  private addFields (fields: string[]): void {\n    for (let i = 0; i < fields.length; i++) {\n      this._fieldIds[fields[i]] = i\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.addFieldLength",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.addFieldLength",
    "startLine": 2023,
    "endLine": 2031,
    "text": "  private addFieldLength (documentId: number, fieldId: number, count: number, length: number): void {\n    let fieldLengths = this._fieldLength.get(documentId)\n    if (fieldLengths == null) this._fieldLength.set(documentId, fieldLengths = [])\n    fieldLengths[fieldId] = length\n\n    const averageFieldLength = this._avgFieldLength[fieldId] || 0\n    const totalFieldLength = (averageFieldLength * count) + length\n    this._avgFieldLength[fieldId] = totalFieldLength / (count + 1)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.removeFieldLength",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.removeFieldLength",
    "startLine": 2036,
    "endLine": 2043,
    "text": "  private removeFieldLength (documentId: number, fieldId: number, count: number, length: number): void {\n    if (count === 1) {\n      this._avgFieldLength[fieldId] = 0\n      return\n    }\n    const totalFieldLength = (this._avgFieldLength[fieldId] * count) - length\n    this._avgFieldLength[fieldId] = totalFieldLength / (count - 1)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts:MiniSearch.saveStoredFields",
    "file": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "symbol": "MiniSearch.saveStoredFields",
    "startLine": 2048,
    "endLine": 2059,
    "text": "  private saveStoredFields (documentId: number, doc: T): void {\n    const { storeFields, extractField } = this._options\n    if (storeFields == null || storeFields.length === 0) { return }\n\n    let documentFields = this._storedFields.get(documentId)\n    if (documentFields == null) this._storedFields.set(documentId, documentFields = {})\n\n    for (const fieldName of storeFields) {\n      const fieldValue = extractField(doc, fieldName)\n      if (fieldValue !== undefined) documentFields[fieldName] = fieldValue\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts:decodeOriginalScopes",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "symbol": "decodeOriginalScopes",
    "startLine": 35,
    "endLine": 76,
    "text": "export function decodeOriginalScopes(input: string): OriginalScope[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes: OriginalScope[] = [];\n  const stack: OriginalScope[] = [];\n  let line = 0;\n\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop()!;\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 0b0001;\n\n    const scope: OriginalScope = (\n      hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]\n    ) as OriginalScope;\n\n    let vars: Var[] = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n\n    scopes.push(scope);\n    stack.push(scope);\n  }\n\n  return scopes;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts:encodeOriginalScopes",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "symbol": "encodeOriginalScopes",
    "startLine": 78,
    "endLine": 86,
    "text": "export function encodeOriginalScopes(scopes: OriginalScope[]): string {\n  const writer = new StringWriter();\n\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n\n  return writer.flush();\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts:_encodeOriginalScopes",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "symbol": "_encodeOriginalScopes",
    "startLine": 88,
    "endLine": 127,
    "text": "function _encodeOriginalScopes(\n  scopes: OriginalScope[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenColumn\n  ],\n): number {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n\n  if (index > 0) writer.write(comma);\n\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n\n  const fields = scope.length === 6 ? 0b0001 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n\n  return index;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts:decodeGeneratedRanges",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "symbol": "decodeGeneratedRanges",
    "startLine": 129,
    "endLine": 229,
    "text": "export function decodeGeneratedRanges(input: string): GeneratedRange[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges: GeneratedRange[] = [];\n  const stack: GeneratedRange[] = [];\n\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    let genColumn = 0;\n\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop()!;\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 0b0001;\n      const hasCallsite = fields & 0b0010;\n      const hasScope = fields & 0b0100;\n\n      let callsite: CallSite | null = null;\n      let bindings: Binding[] = EMPTY;\n      let range: GeneratedRange;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0,\n        );\n\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex] as GeneratedRange;\n      } else {\n        range = [genLine, genColumn, 0, 0] as GeneratedRange;\n      }\n\n      range.isScope = !!hasScope;\n\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0,\n        );\n\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges: BindingExpressionRange[];\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n\n      ranges.push(range);\n      stack.push(range);\n    }\n\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n\n  return ranges;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts:encodeGeneratedRanges",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "symbol": "encodeGeneratedRanges",
    "startLine": 231,
    "endLine": 241,
    "text": "export function encodeGeneratedRanges(ranges: GeneratedRange[]): string {\n  if (ranges.length === 0) return '';\n\n  const writer = new StringWriter();\n\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n\n  return writer.flush();\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts:_encodeGeneratedRanges",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "symbol": "_encodeGeneratedRanges",
    "startLine": 243,
    "endLine": 339,
    "text": "function _encodeGeneratedRanges(\n  ranges: GeneratedRange[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenLine\n    number, // GenColumn\n    number, // DefSourcesIndex\n    number, // DefScopesIndex\n    number, // CallSourcesIndex\n    number, // CallLine\n    number, // CallColumn\n  ],\n): number {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings,\n  } = range;\n\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n\n  state[1] = encodeInteger(writer, range[1], state[1]);\n\n  const fields =\n    (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\n  encodeInteger(writer, fields, 0);\n\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite!;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1]!, bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2]!, bindingStartColumn);\n        encodeInteger(writer, expRange[0]!, 0);\n      }\n    }\n  }\n\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n\n  return index;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts:catchupLine",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "symbol": "catchupLine",
    "startLine": 341,
    "endLine": 345,
    "text": "function catchupLine(writer: StringWriter, lastLine: number, line: number) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts:decode",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
    "symbol": "decode",
    "startLine": 19,
    "endLine": 68,
    "text": "export function decode(mappings: string): SourceMapMappings {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded: SourceMapMappings = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n\n    while (reader.pos < semi) {\n      let seg: SourceMapSegment;\n\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n\n      line.push(seg);\n      reader.pos++;\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n\n  return decoded;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts:sort",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
    "symbol": "sort",
    "startLine": 70,
    "endLine": 72,
    "text": "function sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts:sortComparator",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
    "symbol": "sortComparator",
    "startLine": 74,
    "endLine": 76,
    "text": "function sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts:encode",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
    "symbol": "encode",
    "startLine": 78,
    "endLine": 78,
    "text": "export function encode(decoded: SourceMapMappings): string;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts:encode",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
    "symbol": "encode",
    "startLine": 79,
    "endLine": 79,
    "text": "export function encode(decoded: Readonly<SourceMapMappings>): string;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts:encode",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
    "symbol": "encode",
    "startLine": 80,
    "endLine": 111,
    "text": "export function encode(decoded: Readonly<SourceMapMappings>): string {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n\n    let genColumn = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n\n  return writer.flush();\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/strings.ts:StringWriter",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "symbol": "StringWriter",
    "startLine": 24,
    "endLine": 42,
    "text": "export class StringWriter {\n  pos = 0;\n  private out = '';\n  private buffer = new Uint8Array(bufLength);\n\n  write(v: number): void {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n\n  flush(): string {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/strings.ts:StringWriter.write",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "symbol": "StringWriter.write",
    "startLine": 29,
    "endLine": 36,
    "text": "  write(v: number): void {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/strings.ts:StringWriter.flush",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "symbol": "StringWriter.flush",
    "startLine": 38,
    "endLine": 41,
    "text": "  flush(): string {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/strings.ts:StringReader",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "symbol": "StringReader",
    "startLine": 44,
    "endLine": 65,
    "text": "export class StringReader {\n  pos = 0;\n  declare private buffer: string;\n\n  constructor(buffer: string) {\n    this.buffer = buffer;\n  }\n\n  next(): number {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n\n  peek(): number {\n    return this.buffer.charCodeAt(this.pos);\n  }\n\n  indexOf(char: string): number {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/strings.ts:StringReader.next",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "symbol": "StringReader.next",
    "startLine": 52,
    "endLine": 54,
    "text": "  next(): number {\n    return this.buffer.charCodeAt(this.pos++);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/strings.ts:StringReader.peek",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "symbol": "StringReader.peek",
    "startLine": 56,
    "endLine": 58,
    "text": "  peek(): number {\n    return this.buffer.charCodeAt(this.pos);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/strings.ts:StringReader.indexOf",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "symbol": "StringReader.indexOf",
    "startLine": 60,
    "endLine": 64,
    "text": "  indexOf(char: string): number {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts:decodeInteger",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/vlq.ts",
    "symbol": "decodeInteger",
    "startLine": 16,
    "endLine": 36,
    "text": "export function decodeInteger(reader: StringReader, relative: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  return relative + value;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts:encodeInteger",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/vlq.ts",
    "symbol": "encodeInteger",
    "startLine": 38,
    "endLine": 50,
    "text": "export function encodeInteger(builder: StringWriter, num: number, relative: number): number {\n  let delta = num - relative;\n\n  delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\n  do {\n    let clamped = delta & 0b011111;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 0b100000;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n\n  return num;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts:hasMoreVlq",
    "file": "node_modules/@jridgewell/sourcemap-codec/src/vlq.ts",
    "symbol": "hasMoreVlq",
    "startLine": 52,
    "endLine": 55,
    "text": "export function hasMoreVlq(reader: StringReader, max: number) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/cache.ts:QueryCache",
    "file": "node_modules/@mcp/server/src/cache.ts",
    "symbol": "QueryCache",
    "startLine": 3,
    "endLine": 28,
    "text": "export class QueryCache {\n  private redis?: Redis;\n  private mem = new Map<string, { v: any; exp: number }>();\n  constructor(url?: string) {\n    if (url) {\n      try { this.redis = new Redis(url); } catch { this.redis = undefined; }\n    }\n  }\n  async get(key: string): Promise<any | undefined> {\n    if (this.redis) {\n      const v = await this.redis.get(key);\n      return v ? JSON.parse(v) : undefined;\n    }\n    const e = this.mem.get(key);\n    if (!e) return undefined;\n    if (Date.now() > e.exp) { this.mem.delete(key); return undefined; }\n    return e.v;\n  }\n  async set(key: string, value: any, ttlSec: number) {\n    if (this.redis) {\n      await this.redis.set(key, JSON.stringify(value), 'EX', ttlSec);\n      return;\n    }\n    this.mem.set(key, { v: value, exp: Date.now() + ttlSec * 1000 });\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/cache.ts:QueryCache.get",
    "file": "node_modules/@mcp/server/src/cache.ts",
    "symbol": "QueryCache.get",
    "startLine": 11,
    "endLine": 20,
    "text": "  async get(key: string): Promise<any | undefined> {\n    if (this.redis) {\n      const v = await this.redis.get(key);\n      return v ? JSON.parse(v) : undefined;\n    }\n    const e = this.mem.get(key);\n    if (!e) return undefined;\n    if (Date.now() > e.exp) { this.mem.delete(key); return undefined; }\n    return e.v;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/cache.ts:QueryCache.set",
    "file": "node_modules/@mcp/server/src/cache.ts",
    "symbol": "QueryCache.set",
    "startLine": 21,
    "endLine": 27,
    "text": "  async set(key: string, value: any, ttlSec: number) {\n    if (this.redis) {\n      await this.redis.set(key, JSON.stringify(value), 'EX', ttlSec);\n      return;\n    }\n    this.mem.set(key, { v: value, exp: Date.now() + ttlSec * 1000 });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/context_profiler.ts:profileContext",
    "file": "node_modules/@mcp/server/src/context_profiler.ts",
    "symbol": "profileContext",
    "startLine": 49,
    "endLine": 69,
    "text": "export function profileContext(query: string, requestedTopK: number): ContextProfile {\n  const trimmed = query.trim();\n  for (const candidate of KEYWORDS) {\n    if (candidate.words.some(re => re.test(trimmed))) {\n      return {\n        intent: candidate.intent,\n        tokenBudget: candidate.budget,\n        requestedTopK,\n        effectiveTopK: Math.max(1, Math.min(candidate.topK, requestedTopK || candidate.topK)),\n        notes: [candidate.note],\n      };\n    }\n  }\n  return {\n    intent: 'general',\n    tokenBudget: 600,\n    requestedTopK,\n    effectiveTopK: Math.max(1, Math.min(requestedTopK || 5, 5)),\n    notes: ['General search; apply balanced context selection.'],\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/generate_telemetry.ts:parseArgs",
    "file": "node_modules/@mcp/server/src/generate_telemetry.ts",
    "symbol": "parseArgs",
    "startLine": 5,
    "endLine": 20,
    "text": "function parseArgs(argv: string[]): { root?: string; output?: string } {\n  const result: { root?: string; output?: string } = {};\n  for (let i = 0; i < argv.length; i++) {\n    const arg = argv[i];\n    if (arg.startsWith('--root=')) {\n      result.root = arg.slice('--root='.length);\n    } else if (arg === '--root' && argv[i + 1]) {\n      result.root = argv[++i];\n    } else if (arg.startsWith('--output=')) {\n      result.output = arg.slice('--output='.length);\n    } else if (arg === '--output' && argv[i + 1]) {\n      result.output = argv[++i];\n    }\n  }\n  return result;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/generate_telemetry.ts:main",
    "file": "node_modules/@mcp/server/src/generate_telemetry.ts",
    "symbol": "main",
    "startLine": 22,
    "endLine": 28,
    "text": "function main() {\n  const args = parseArgs(process.argv.slice(2));\n  const repoRoot = args.root ? path.resolve(args.root) : process.cwd();\n  const result = generate_telemetry_panel(repoRoot, args.output);\n  // eslint-disable-next-line no-console\n  console.log(JSON.stringify(result, null, 2));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/graph_store.ts:GraphStore",
    "file": "node_modules/@mcp/server/src/graph_store.ts",
    "symbol": "GraphStore",
    "startLine": 4,
    "endLine": 74,
    "text": "export class GraphStore {\n  private db: Database.Database;\n  constructor(dbPath: string) {\n    const resolved = path.resolve(dbPath);\n    this.db = new Database(resolved);\n    this.bootstrap();\n  }\n  private bootstrap() {\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS files (\n        id INTEGER PRIMARY KEY,\n        path TEXT UNIQUE\n      );\n      CREATE TABLE IF NOT EXISTS symbols (\n        id INTEGER PRIMARY KEY,\n        file_id INTEGER,\n        name TEXT,\n        kind TEXT,\n        start_line INTEGER,\n        end_line INTEGER,\n        FOREIGN KEY(file_id) REFERENCES files(id)\n      );\n      CREATE TABLE IF NOT EXISTS edges (\n        from_file INTEGER,\n        to_file INTEGER,\n        kind TEXT,\n        UNIQUE(from_file, to_file, kind)\n      );\n    `);\n  }\n  listSymbols(file?: string) {\n    if (file) {\n      const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(file) as any;\n      if (!row) return [] as any[];\n      return this.db.prepare('SELECT name, kind, start_line AS startLine, end_line AS endLine FROM symbols WHERE file_id=?').all(row.id) as any[];\n    }\n    return this.db.prepare('SELECT f.path AS file, s.name, s.kind, s.start_line AS startLine, s.end_line AS endLine FROM symbols s JOIN files f ON s.file_id=f.id').all() as any[];\n  }\n  listImports(filePath: string): string[] {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return [];\n    const rows = this.db\n      .prepare('SELECT f.path AS path FROM edges e JOIN files f ON e.to_file=f.id WHERE e.from_file=?')\n      .all(row.id) as Array<{ path: string }>;\n    return rows.map(r => r.path);\n  }\n  listDependents(filePath: string): string[] {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return [];\n    const rows = this.db\n      .prepare('SELECT f.path AS path FROM edges e JOIN files f ON e.from_file=f.id WHERE e.to_file=?')\n      .all(row.id) as Array<{ path: string }>;\n    return rows.map(r => r.path);\n  }\n  findRefs(symbol: string) {\n    // Simple heuristic: return files that import the file containing the symbol\n    const fileRows = this.db.prepare('SELECT f.id, f.path, s.name FROM symbols s JOIN files f ON s.file_id=f.id WHERE s.name LIKE ?').all(`%${symbol}%`);\n    if (fileRows.length === 0) return [];\n    const fileIds = fileRows.map((r: any) => r.id);\n    const placeholders = fileIds.map(() => '?').join(',');\n    const refRows = this.db.prepare(`SELECT DISTINCT f2.path AS file FROM edges e JOIN files f1 ON e.to_file=f1.id JOIN files f2 ON e.from_file=f2.id WHERE e.kind='import' AND e.to_file IN (${placeholders})`).all(...fileIds) as any[];\n    return refRows as any[];\n  }\n  degree(filePath: string) {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return 0;\n    const out = this.db.prepare('SELECT COUNT(*) AS c FROM edges WHERE from_file=?').get(row.id) as any;\n    const inn = this.db.prepare('SELECT COUNT(*) AS c FROM edges WHERE to_file=?').get(row.id) as any;\n    return (out?.c || 0) + (inn?.c || 0);\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/graph_store.ts:GraphStore.bootstrap",
    "file": "node_modules/@mcp/server/src/graph_store.ts",
    "symbol": "GraphStore.bootstrap",
    "startLine": 11,
    "endLine": 33,
    "text": "  private bootstrap() {\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS files (\n        id INTEGER PRIMARY KEY,\n        path TEXT UNIQUE\n      );\n      CREATE TABLE IF NOT EXISTS symbols (\n        id INTEGER PRIMARY KEY,\n        file_id INTEGER,\n        name TEXT,\n        kind TEXT,\n        start_line INTEGER,\n        end_line INTEGER,\n        FOREIGN KEY(file_id) REFERENCES files(id)\n      );\n      CREATE TABLE IF NOT EXISTS edges (\n        from_file INTEGER,\n        to_file INTEGER,\n        kind TEXT,\n        UNIQUE(from_file, to_file, kind)\n      );\n    `);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/graph_store.ts:GraphStore.listSymbols",
    "file": "node_modules/@mcp/server/src/graph_store.ts",
    "symbol": "GraphStore.listSymbols",
    "startLine": 34,
    "endLine": 41,
    "text": "  listSymbols(file?: string) {\n    if (file) {\n      const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(file) as any;\n      if (!row) return [] as any[];\n      return this.db.prepare('SELECT name, kind, start_line AS startLine, end_line AS endLine FROM symbols WHERE file_id=?').all(row.id) as any[];\n    }\n    return this.db.prepare('SELECT f.path AS file, s.name, s.kind, s.start_line AS startLine, s.end_line AS endLine FROM symbols s JOIN files f ON s.file_id=f.id').all() as any[];\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/graph_store.ts:GraphStore.listImports",
    "file": "node_modules/@mcp/server/src/graph_store.ts",
    "symbol": "GraphStore.listImports",
    "startLine": 42,
    "endLine": 49,
    "text": "  listImports(filePath: string): string[] {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return [];\n    const rows = this.db\n      .prepare('SELECT f.path AS path FROM edges e JOIN files f ON e.to_file=f.id WHERE e.from_file=?')\n      .all(row.id) as Array<{ path: string }>;\n    return rows.map(r => r.path);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/graph_store.ts:GraphStore.listDependents",
    "file": "node_modules/@mcp/server/src/graph_store.ts",
    "symbol": "GraphStore.listDependents",
    "startLine": 50,
    "endLine": 57,
    "text": "  listDependents(filePath: string): string[] {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return [];\n    const rows = this.db\n      .prepare('SELECT f.path AS path FROM edges e JOIN files f ON e.from_file=f.id WHERE e.to_file=?')\n      .all(row.id) as Array<{ path: string }>;\n    return rows.map(r => r.path);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/graph_store.ts:GraphStore.findRefs",
    "file": "node_modules/@mcp/server/src/graph_store.ts",
    "symbol": "GraphStore.findRefs",
    "startLine": 58,
    "endLine": 66,
    "text": "  findRefs(symbol: string) {\n    // Simple heuristic: return files that import the file containing the symbol\n    const fileRows = this.db.prepare('SELECT f.id, f.path, s.name FROM symbols s JOIN files f ON s.file_id=f.id WHERE s.name LIKE ?').all(`%${symbol}%`);\n    if (fileRows.length === 0) return [];\n    const fileIds = fileRows.map((r: any) => r.id);\n    const placeholders = fileIds.map(() => '?').join(',');\n    const refRows = this.db.prepare(`SELECT DISTINCT f2.path AS file FROM edges e JOIN files f1 ON e.to_file=f1.id JOIN files f2 ON e.from_file=f2.id WHERE e.kind='import' AND e.to_file IN (${placeholders})`).all(...fileIds) as any[];\n    return refRows as any[];\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/graph_store.ts:GraphStore.degree",
    "file": "node_modules/@mcp/server/src/graph_store.ts",
    "symbol": "GraphStore.degree",
    "startLine": 67,
    "endLine": 73,
    "text": "  degree(filePath: string) {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return 0;\n    const out = this.db.prepare('SELECT COUNT(*) AS c FROM edges WHERE from_file=?').get(row.id) as any;\n    const inn = this.db.prepare('SELECT COUNT(*) AS c FROM edges WHERE to_file=?').get(row.id) as any;\n    return (out?.c || 0) + (inn?.c || 0);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/indexer.ts:writeSQLite",
    "file": "node_modules/@mcp/server/src/indexer.ts",
    "symbol": "writeSQLite",
    "startLine": 8,
    "endLine": 58,
    "text": "function writeSQLite(dbPath: string, files: FileMeta[], imports: Array<{ from: string; to: string }>) {\n  // Ensure directory and file exist\n  try {\n    const dir = path.dirname(dbPath);\n    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n    if (!fs.existsSync(dbPath)) {\n      const fd = fs.openSync(dbPath, 'a');\n      fs.closeSync(fd);\n    }\n  } catch {}\n  const db = new Database(dbPath);\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS files (\n      id INTEGER PRIMARY KEY,\n      path TEXT UNIQUE\n    );\n    CREATE TABLE IF NOT EXISTS symbols (\n      id INTEGER PRIMARY KEY,\n      file_id INTEGER,\n      name TEXT,\n      kind TEXT,\n      start_line INTEGER,\n      end_line INTEGER,\n      FOREIGN KEY(file_id) REFERENCES files(id)\n    );\n    CREATE TABLE IF NOT EXISTS edges (\n      from_file INTEGER,\n      to_file INTEGER,\n      kind TEXT,\n      UNIQUE(from_file, to_file, kind)\n    );\n  `);\n  db.exec('BEGIN');\n  db.exec('DELETE FROM edges; DELETE FROM symbols; DELETE FROM files;');\n  const insertFile = db.prepare('INSERT OR IGNORE INTO files(path) VALUES (?)');\n  const getFileId = db.prepare('SELECT id FROM files WHERE path=?');\n  const insertSym = db.prepare('INSERT INTO symbols(file_id,name,kind,start_line,end_line) VALUES (?,?,?,?,?)');\n  for (const f of files) {\n    insertFile.run(f.path);\n    const row = getFileId.get(f.path) as any;\n    for (const s of f.symbols) insertSym.run(row.id, s.name, s.kind, s.startLine, s.endLine);\n  }\n  const insertEdge = db.prepare('INSERT OR IGNORE INTO edges(from_file,to_file,kind) VALUES (?,?,?)');\n  for (const e of imports) {\n    const fromRow = getFileId.get(e.from) as any;\n    const toRow = getFileId.get(e.to) as any;\n    if (fromRow && toRow) insertEdge.run(fromRow.id, toRow.id, 'import');\n  }\n  db.exec('COMMIT');\n  db.close();\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/indexer.ts:buildEdgesWithTsMorph",
    "file": "node_modules/@mcp/server/src/indexer.ts",
    "symbol": "buildEdgesWithTsMorph",
    "startLine": 60,
    "endLine": 97,
    "text": "function buildEdgesWithTsMorph(project: Project, rootDir: string): Array<{ from: string; to: string }> {\n  const edges: Array<{ from: string; to: string }> = [];\n  const files = project.getSourceFiles();\n  // Debug root info if needed\n  try {\n    const info = `rootDir=${rootDir}\\nfirstFile=${files[0]?.getFilePath()}`;\n    const out = path.join(process.cwd(), 'data', 'edges_info.txt');\n    fs.mkdirSync(path.dirname(out), { recursive: true });\n    fs.writeFileSync(out, info, 'utf8');\n  } catch {}\n  for (const sf of files) {\n    const fromAbs = sf.getFilePath();\n    const fromRel = path.relative(rootDir, fromAbs).replace(/\\\\/g, '/');\n    // import declarations\n    for (const imp of sf.getImportDeclarations()) {\n      const target = imp.getModuleSpecifierSourceFile();\n      if (!target) continue;\n      const toAbs = target.getFilePath();\n      if (!toAbs.startsWith(rootDir)) continue;\n      const toRel = path.relative(rootDir, toAbs).replace(/\\\\/g, '/');\n      if (fromRel !== toRel) edges.push({ from: fromRel, to: toRel });\n    }\n    // export declarations (re-exports)\n    for (const exp of sf.getExportDeclarations()) {\n      const target = exp.getModuleSpecifierSourceFile();\n      if (!target) continue;\n      const toAbs = target.getFilePath();\n      if (!toAbs.startsWith(rootDir)) continue;\n      const toRel = path.relative(rootDir, toAbs).replace(/\\\\/g, '/');\n      if (fromRel !== toRel) edges.push({ from: fromRel, to: toRel });\n    }\n  }\n  // de-duplicate\n  const key = (e: { from: string; to: string }) => `${e.from}=>${e.to}`;\n  const map = new Map<string, { from: string; to: string }>();\n  for (const e of edges) map.set(key(e), e);\n  return Array.from(map.values());\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/indexer.ts:resolveTsConfig",
    "file": "node_modules/@mcp/server/src/indexer.ts",
    "symbol": "resolveTsConfig",
    "startLine": 99,
    "endLine": 112,
    "text": "function resolveTsConfig(): string | undefined {\n  const envPath = process.env.TS_CONFIG_PATH;\n  if (envPath && fs.existsSync(envPath)) return envPath;\n  // Prefer the package-local tsconfig to avoid relying on process.cwd()\n  const pkgTs = path.resolve(__dirname, '..', 'tsconfig.json');\n  if (fs.existsSync(pkgTs)) return pkgTs;\n  // Next, try repository root tsconfig relative to this file\n  const repoRootTs = path.resolve(__dirname, '..', '..', '..', 'tsconfig.json');\n  if (fs.existsSync(repoRootTs)) return repoRootTs;\n  // Finally, try current working directory only if it actually exists\n  const cwdTs = path.resolve(process.cwd(), 'tsconfig.json');\n  if (fs.existsSync(cwdTs)) return cwdTs;\n  return undefined;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/indexer.ts:runIndexer",
    "file": "node_modules/@mcp/server/src/indexer.ts",
    "symbol": "runIndexer",
    "startLine": 114,
    "endLine": 201,
    "text": "export async function runIndexer(rootDir: string, outDir: string, sqlitePath?: string) {\n  const tsConfigPath = resolveTsConfig();\n  let project: Project;\n  try {\n    project = tsConfigPath\n      ? new Project({ tsConfigFilePath: tsConfigPath })\n      : new Project({ skipAddingFilesFromTsConfig: true });\n  } catch {\n    // Fall back to a minimal config that avoids reading any tsconfig\n    project = new Project({ skipAddingFilesFromTsConfig: true });\n  }\n  const tsFiles = project.addSourceFilesAtPaths([path.join(rootDir, '**/*.ts'), '!' + path.join(rootDir, '**/*.d.ts')]);\n  const fileMetas: FileMeta[] = [];\n  const semanticEntries: SemanticEntry[] = [];\n  for (const sf of tsFiles) {\n    const fullPath = sf.getFilePath();\n    const content = sf.getFullText();\n    const symbols: SymbolMeta[] = [];\n    sf.forEachDescendant(node => {\n      if (node.getKind() === SyntaxKind.FunctionDeclaration) {\n        const fn = node.asKind(SyntaxKind.FunctionDeclaration)!;\n        const name = fn.getName();\n        if (name) {\n          const start = fn.getStartLineNumber();\n          const end = fn.getEndLineNumber();\n          symbols.push({ name, kind: 'function', file: fullPath, startLine: start, endLine: end });\n        }\n      } else if (node.getKind() === SyntaxKind.ClassDeclaration) {\n        const cls = node.asKind(SyntaxKind.ClassDeclaration)!;\n        const name = cls.getName();\n        if (name) {\n          const start = cls.getStartLineNumber();\n          const end = cls.getEndLineNumber();\n          symbols.push({ name, kind: 'class', file: fullPath, startLine: start, endLine: end });\n          for (const m of cls.getMethods()) {\n            symbols.push({ name: `${name}.${m.getName()}`, kind: 'method', file: fullPath, startLine: m.getStartLineNumber(), endLine: m.getEndLineNumber() });\n          }\n        }\n      }\n    });\n    const relativePath = path.relative(rootDir, fullPath).replace(/\\\\/g, '/');\n    const fm: FileMeta = { path: relativePath, content, symbols };\n    fileMetas.push(fm);\n    const lines = content.split(/\\r?\\n/);\n    for (const s of symbols) {\n      const snippet = lines.slice(s.startLine - 1, s.endLine).join('\\n');\n      semanticEntries.push({ id: `${s.file}:${s.name}`, file: relativePath, symbol: s.name, startLine: s.startLine, endLine: s.endLine, text: snippet });\n    }\n  }\n  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });\n  fs.writeFileSync(path.join(outDir, 'index.json'), JSON.stringify(fileMetas, null, 2), 'utf8');\n  fs.writeFileSync(path.join(outDir, 'semantic_entries.json'), JSON.stringify(semanticEntries, null, 2), 'utf8');\n\n  // Build edges via madge (best-effort)\n  let edges: Array<{ from: string; to: string }> = [];\n  try {\n    const result = await madge(rootDir, {\n      fileExtensions: ['ts', 'tsx', 'js', 'jsx'],\n      // Provide a stable tsconfig path that actually exists\n      tsConfig: (tsConfigPath && fs.existsSync(tsConfigPath))\n        ? tsConfigPath\n        : path.resolve(__dirname, '..', 'tsconfig.json'),\n      detectiveOptions: { ts: { skipTypeImports: true } } as any,\n      includeNpm: false,\n      baseDir: rootDir,\n    } as any);\n    const graph = await result.obj();\n    for (const [from, tos] of Object.entries(graph)) {\n      const fromAbs = path.isAbsolute(from) ? from : path.resolve(rootDir, from);\n      const fromRel = path.relative(rootDir, fromAbs).replace(/\\\\/g, '/');\n      for (const to of tos as string[]) {\n        const toAbs = path.isAbsolute(to) ? to : path.resolve(rootDir, to);\n        const toRel = path.relative(rootDir, toAbs).replace(/\\\\/g, '/');\n        if (fromRel && toRel && fromRel !== toRel) edges.push({ from: fromRel, to: toRel });\n      }\n    }\n  } catch {\n    // ignore madge errors; fallback to ts-morph\n  }\n\n  // Fallback/union with ts-morph derived edges\n  const morphEdges = buildEdgesWithTsMorph(project, rootDir);\n  const existing = new Set(edges.map(e => `${e.from}=>${e.to}`));\n  for (const e of morphEdges) if (!existing.has(`${e.from}=>${e.to}`)) edges.push(e);\n  // Debug: dump edges\n  try { fs.writeFileSync(path.join(outDir, 'edges.json'), JSON.stringify(edges, null, 2), 'utf8'); } catch {}\n  if (sqlitePath) writeSQLite(sqlitePath, fileMetas, edges);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/index_cli.ts:main",
    "file": "node_modules/@mcp/server/src/index_cli.ts",
    "symbol": "main",
    "startLine": 5,
    "endLine": 16,
    "text": "async function main() {\n  const envRoot = process.env.INDEX_ROOT || process.env.MCP_INDEX_ROOT || process.env.WORKSPACE_ROOT;\n  const envData = process.env.DATA_DIR || process.env.MCP_DATA_DIR;\n  const rootDir = envRoot ? path.resolve(envRoot) : process.cwd();\n  const outDir = envData ? path.resolve(envData) : path.join(process.cwd(), 'data');\n  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });\n  const sqlite = path.join(outDir, 'graph.db');\n  await runIndexer(rootDir, outDir, sqlite);\n  // Also set env so any subsequent child tools could reuse\n  process.env.DATA_DIR = outDir;\n  process.env.SQLITE_DB = sqlite;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/job_queue.ts:createQueue",
    "file": "node_modules/@mcp/server/src/job_queue.ts",
    "symbol": "createQueue",
    "startLine": 5,
    "endLine": 9,
    "text": "export function createQueue(name = 'mcp-jobs', connection?: string) {\n  const conn = connection ? new IORedis(connection) : undefined;\n  const queue = new Queue(name, { connection: conn as any });\n  return queue;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/job_queue.ts:startWorker",
    "file": "node_modules/@mcp/server/src/job_queue.ts",
    "symbol": "startWorker",
    "startLine": 11,
    "endLine": 20,
    "text": "export function startWorker(name = 'mcp-jobs', connection?: string) {\n  const conn = connection ? new IORedis(connection) : undefined;\n  const worker = new Worker(name, async job => {\n    if (job.name === 'reindex') {\n      const { rootDir, outDir, sqlite } = job.data as { rootDir: string; outDir: string; sqlite: string };\n      await runIndexer(rootDir, outDir, sqlite);\n    }\n  }, { connection: conn as any });\n  return worker;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/job_queue.ts:enqueueReindex",
    "file": "node_modules/@mcp/server/src/job_queue.ts",
    "symbol": "enqueueReindex",
    "startLine": 22,
    "endLine": 24,
    "text": "export async function enqueueReindex(queue: Queue, payload: { rootDir: string; outDir: string; sqlite: string }, opts?: JobsOptions) {\n  await queue.add('reindex', payload, opts);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/langchain_bridge.ts:LangChainBridge",
    "file": "node_modules/@mcp/server/src/langchain_bridge.ts",
    "symbol": "LangChainBridge",
    "startLine": 19,
    "endLine": 109,
    "text": "export class LangChainBridge {\n  private entries: SemanticEntry[] = [];\n  private available = false;\n  private reason = 'langchain package not detected';\n\n  constructor(private dataDir: string) {\n    this.loadEntries();\n    this.detectLangChain();\n  }\n\n  private loadEntries() {\n    const semanticPath = path.join(this.dataDir, 'semantic_entries.json');\n    if (!fs.existsSync(semanticPath)) return;\n    try {\n      const parsed = JSON.parse(fs.readFileSync(semanticPath, 'utf8')) as Array<any>;\n      this.entries = parsed.map(e => ({\n        id: String(e.id ?? `${e.file}:${e.symbol}`),\n        file: String(e.file),\n        symbol: String(e.symbol),\n        text: String(e.text ?? ''),\n      }));\n    } catch {\n      this.entries = [];\n    }\n  }\n\n  private detectLangChain() {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      require.resolve('langchain');\n      this.available = true;\n      this.reason = '';\n    } catch {\n      this.available = false;\n    }\n  }\n\n  private lexicalQuery(query: string, topK: number): BridgeResult[] {\n    const tokens = query\n      .toLowerCase()\n      .split(/\\W+/)\n      .filter(Boolean);\n    const scored = this.entries.map(entry => {\n      const text = entry.text.toLowerCase();\n      let hits = 0;\n      for (const token of tokens) {\n        if (text.includes(token)) hits += 1;\n      }\n      const score = tokens.length ? hits / tokens.length : 0;\n      return {\n        id: entry.id,\n        file: entry.file,\n        symbol: entry.symbol,\n        score,\n        snippet: entry.text.slice(0, 200),\n      };\n    });\n    return scored\n      .sort((a, b) => b.score - a.score)\n      .slice(0, Math.max(1, Math.min(topK, scored.length)));\n  }\n\n  async query(query: string, topK: number): Promise<{ available: boolean; provider: 'langchain' | 'fallback'; reason?: string; results: BridgeResult[] }> {\n    if (!this.entries.length) {\n      return {\n        available: this.available,\n        provider: this.available ? 'langchain' : 'fallback',\n        reason: this.entries.length ? undefined : 'semantic_entries.json not found or empty',\n        results: [],\n      };\n    }\n\n    if (!this.available) {\n      return {\n        available: false,\n        provider: 'fallback',\n        reason: this.reason,\n        results: this.lexicalQuery(query, topK),\n      };\n    }\n\n    // Placeholder for real LangChain integration. Until dependencies are present,\n    // fall back to lexical scoring while reporting availability.\n    return {\n      available: true,\n      provider: 'langchain',\n      reason: 'LangChain detected but no vector store configured; using lexical fallback.',\n      results: this.lexicalQuery(query, topK),\n    };\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/langchain_bridge.ts:LangChainBridge.loadEntries",
    "file": "node_modules/@mcp/server/src/langchain_bridge.ts",
    "symbol": "LangChainBridge.loadEntries",
    "startLine": 29,
    "endLine": 43,
    "text": "  private loadEntries() {\n    const semanticPath = path.join(this.dataDir, 'semantic_entries.json');\n    if (!fs.existsSync(semanticPath)) return;\n    try {\n      const parsed = JSON.parse(fs.readFileSync(semanticPath, 'utf8')) as Array<any>;\n      this.entries = parsed.map(e => ({\n        id: String(e.id ?? `${e.file}:${e.symbol}`),\n        file: String(e.file),\n        symbol: String(e.symbol),\n        text: String(e.text ?? ''),\n      }));\n    } catch {\n      this.entries = [];\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/langchain_bridge.ts:LangChainBridge.detectLangChain",
    "file": "node_modules/@mcp/server/src/langchain_bridge.ts",
    "symbol": "LangChainBridge.detectLangChain",
    "startLine": 45,
    "endLine": 54,
    "text": "  private detectLangChain() {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      require.resolve('langchain');\n      this.available = true;\n      this.reason = '';\n    } catch {\n      this.available = false;\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/langchain_bridge.ts:LangChainBridge.lexicalQuery",
    "file": "node_modules/@mcp/server/src/langchain_bridge.ts",
    "symbol": "LangChainBridge.lexicalQuery",
    "startLine": 56,
    "endLine": 79,
    "text": "  private lexicalQuery(query: string, topK: number): BridgeResult[] {\n    const tokens = query\n      .toLowerCase()\n      .split(/\\W+/)\n      .filter(Boolean);\n    const scored = this.entries.map(entry => {\n      const text = entry.text.toLowerCase();\n      let hits = 0;\n      for (const token of tokens) {\n        if (text.includes(token)) hits += 1;\n      }\n      const score = tokens.length ? hits / tokens.length : 0;\n      return {\n        id: entry.id,\n        file: entry.file,\n        symbol: entry.symbol,\n        score,\n        snippet: entry.text.slice(0, 200),\n      };\n    });\n    return scored\n      .sort((a, b) => b.score - a.score)\n      .slice(0, Math.max(1, Math.min(topK, scored.length)));\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/langchain_bridge.ts:LangChainBridge.query",
    "file": "node_modules/@mcp/server/src/langchain_bridge.ts",
    "symbol": "LangChainBridge.query",
    "startLine": 81,
    "endLine": 108,
    "text": "  async query(query: string, topK: number): Promise<{ available: boolean; provider: 'langchain' | 'fallback'; reason?: string; results: BridgeResult[] }> {\n    if (!this.entries.length) {\n      return {\n        available: this.available,\n        provider: this.available ? 'langchain' : 'fallback',\n        reason: this.entries.length ? undefined : 'semantic_entries.json not found or empty',\n        results: [],\n      };\n    }\n\n    if (!this.available) {\n      return {\n        available: false,\n        provider: 'fallback',\n        reason: this.reason,\n        results: this.lexicalQuery(query, topK),\n      };\n    }\n\n    // Placeholder for real LangChain integration. Until dependencies are present,\n    // fall back to lexical scoring while reporting availability.\n    return {\n      available: true,\n      provider: 'langchain',\n      reason: 'LangChain detected but no vector store configured; using lexical fallback.',\n      results: this.lexicalQuery(query, topK),\n    };\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp.ts:ensureIndex",
    "file": "node_modules/@mcp/server/src/launch_mcp.ts",
    "symbol": "ensureIndex",
    "startLine": 10,
    "endLine": 12,
    "text": "async function ensureIndex(rootDir: string, outDir: string, sqlite: string) {\n  await runIndexer(rootDir, outDir, sqlite);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp.ts:tryStartMemurai",
    "file": "node_modules/@mcp/server/src/launch_mcp.ts",
    "symbol": "tryStartMemurai",
    "startLine": 14,
    "endLine": 21,
    "text": "function tryStartMemurai() {\n  try {\n    // Start Memurai service if installed; ignore failures.\n    if (process.platform === 'win32') {\n      execSync('powershell -NoProfile -Command \"$s=Get-Service -Name Memurai* -ErrorAction SilentlyContinue | Select-Object -First 1; if ($s -and $s.Status -ne \\\"Running\\\") { Start-Service -InputObject $s }\"', { stdio: 'ignore' });\n    }\n  } catch {}\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp.ts:checkPortFree",
    "file": "node_modules/@mcp/server/src/launch_mcp.ts",
    "symbol": "checkPortFree",
    "startLine": 23,
    "endLine": 30,
    "text": "function checkPortFree(port: number): Promise<boolean> {\n  return new Promise(resolve => {\n    const srv = net.createServer();\n    srv.once('error', () => resolve(false));\n    srv.once('listening', () => { srv.close(() => resolve(true)); });\n    srv.listen(port, '127.0.0.1');\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp.ts:findFreePort",
    "file": "node_modules/@mcp/server/src/launch_mcp.ts",
    "symbol": "findFreePort",
    "startLine": 32,
    "endLine": 38,
    "text": "async function findFreePort(start: number, max: number): Promise<number> {\n  for (let p = start; p <= max; p++) {\n    // eslint-disable-next-line no-await-in-loop\n    if (await checkPortFree(p)) return p;\n  }\n  return start;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp.ts:waitForHealth",
    "file": "node_modules/@mcp/server/src/launch_mcp.ts",
    "symbol": "waitForHealth",
    "startLine": 40,
    "endLine": 58,
    "text": "function waitForHealth(url: string, attempts = 30, delayMs = 500): Promise<void> {\n  return new Promise((resolve, reject) => {\n    let tries = 0;\n    const tick = () => {\n      tries++;\n      const req = http.get(url, res => {\n        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\n          res.resume();\n          resolve();\n        } else {\n          res.resume();\n          if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health timeout'));\n        }\n      });\n      req.on('error', () => { if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health error')); });\n    };\n    tick();\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp.ts:startFastApi",
    "file": "node_modules/@mcp/server/src/launch_mcp.ts",
    "symbol": "startFastApi",
    "startLine": 60,
    "endLine": 73,
    "text": "async function startFastApi(dataDir: string, port: number) {\n  const script = path.join(process.cwd(), 'packages', 'semantic-engine', 'semantic_engine_fastapi.py');\n  const env = { ...process.env, DATA_DIR: dataDir, ENGINE_PORT: String(port) };\n  // Quick preflight to ensure python + fastapi are usable; if not, throw and fallback\n  try {\n    execSync('python -V', { stdio: 'ignore' });\n    execSync('python -c \"import fastapi,uvicorn\"', { stdio: 'ignore' });\n  } catch {\n    throw new Error('python or fastapi/uvicorn not available');\n  }\n  const proc = spawn('python', [script], { env, stdio: 'ignore', windowsHide: true });\n  await waitForHealth(`http://127.0.0.1:${port}/health`, 40, 500);\n  return proc;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp.ts:startLocalNodeEngine",
    "file": "node_modules/@mcp/server/src/launch_mcp.ts",
    "symbol": "startLocalNodeEngine",
    "startLine": 75,
    "endLine": 123,
    "text": "function startLocalNodeEngine(dataDir: string, port: number) {\n  // Minimal in-process engine with /health and /search using naive scoring\n  const entriesPath = path.join(dataDir, 'semantic_entries.json');\n  let entries: Array<{ id: string; file: string; symbol: string; startLine: number; endLine: number; text: string }> = [];\n  try {\n    const raw = fs.readFileSync(entriesPath, 'utf8');\n    entries = JSON.parse(raw);\n  } catch {\n    entries = [];\n  }\n  const server = http.createServer((req, res) => {\n    try {\n      const url = new URL(req.url || '/', `http://127.0.0.1:${port}`);\n      if (url.pathname === '/health') {\n        res.writeHead(200, { 'content-type': 'application/json' });\n        res.end(JSON.stringify({ ok: true }));\n        return;\n      }\n      if (url.pathname === '/search') {\n        const q = (url.searchParams.get('q') || '').toLowerCase();\n        const topK = Math.max(1, Math.min(50, Number(url.searchParams.get('top_k') || '5')));\n        const scored = entries.map(e => {\n          const text = (e.text || '').toLowerCase();\n          let score = 0;\n          if (q) {\n            // naive: frequency of query tokens present\n            const tokens = q.split(/\\s+/).filter(Boolean);\n            for (const t of tokens) {\n              if (!t) continue;\n              const matches = text.split(t).length - 1;\n              score += matches;\n            }\n          }\n          return { file: e.file, symbol: e.symbol, startLine: e.startLine, endLine: e.endLine, score, snippet: e.text?.slice(0, 200) || '' };\n        }).sort((a, b) => b.score - a.score).slice(0, topK);\n        res.writeHead(200, { 'content-type': 'application/json' });\n        res.end(JSON.stringify({ query: q, results: scored }));\n        return;\n      }\n      res.writeHead(404);\n      res.end();\n    } catch (e) {\n      res.writeHead(500);\n      res.end();\n    }\n  });\n  server.listen(port, '127.0.0.1');\n  return server;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp_http.ts:ensureIndex",
    "file": "node_modules/@mcp/server/src/launch_mcp_http.ts",
    "symbol": "ensureIndex",
    "startLine": 7,
    "endLine": 14,
    "text": "async function ensureIndex() {\n  const envRoot = process.env.INDEX_ROOT || process.env.MCP_INDEX_ROOT;\n  const envData = process.env.DATA_DIR;\n  const rootDir = envRoot ? path.resolve(envRoot) : path.join(__dirname, '..', 'src');\n  const outDir = envData ? path.resolve(envData) : path.join(__dirname, '..', 'data');\n  const sqlite = path.join(outDir, 'graph.db');\n  await runIndexer(rootDir, outDir, sqlite);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp_http.ts:waitForHealth",
    "file": "node_modules/@mcp/server/src/launch_mcp_http.ts",
    "symbol": "waitForHealth",
    "startLine": 16,
    "endLine": 30,
    "text": "function waitForHealth(url: string, attempts = 30, delayMs = 500): Promise<void> {\n  return new Promise((resolve, reject) => {\n    let tries = 0;\n    const tick = () => {\n      tries++;\n      const req = http.get(url, res => {\n        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\n          res.resume(); resolve();\n        } else { res.resume(); if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health timeout')); }\n      });\n      req.on('error', () => { if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health error')); });\n    };\n    tick();\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp_http.ts:startFastApi",
    "file": "node_modules/@mcp/server/src/launch_mcp_http.ts",
    "symbol": "startFastApi",
    "startLine": 32,
    "endLine": 40,
    "text": "async function startFastApi(dataDir: string, port: number) {\n  const script = path.join(process.cwd(), 'packages', 'semantic-engine', 'semantic_engine_fastapi.py');\n  const env = { ...process.env, DATA_DIR: dataDir, ENGINE_PORT: String(port) };\n  try { execSync('python -V', { stdio: 'ignore' }); execSync('python -c \"import fastapi,uvicorn\"', { stdio: 'ignore' }); }\n  catch { throw new Error('python or fastapi/uvicorn not available'); }\n  const proc = spawn('python', [script], { env, stdio: 'ignore', windowsHide: true });\n  await waitForHealth(`http://127.0.0.1:${port}/health`, 40, 500);\n  return proc;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp.ts:respond",
    "file": "node_modules/@mcp/server/src/mcp.ts",
    "symbol": "respond",
    "startLine": 48,
    "endLine": 52,
    "text": "function respond(id: RpcRequest['id'], result?: Json, error?: { code: number; message: string }) {\n  const payload: any = { jsonrpc: '2.0', id };\n  if (error) payload.error = error; else payload.result = result ?? null;\n  process.stdout.write(JSON.stringify(payload) + '\\n');\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp.ts:handle",
    "file": "node_modules/@mcp/server/src/mcp.ts",
    "symbol": "handle",
    "startLine": 54,
    "endLine": 196,
    "text": "async function handle(req: RpcRequest) {\n  try {\n    switch (req.method) {\n      case 'search_code': {\n        const stop = startTimer('search_code', { source: 'mcp:tools' });\n        const q = String(req.params?.q ?? '');\n        const topK = Number(req.params?.top_k ?? 5);\n        const results = await orchestrator.searchCode(q, topK);\n        const profile = orchestrator.getLastProfile();\n        respond(req.id, { query: q, profile, results });\n        stop({ query_length: q.length, result_count: results.length, top_k: topK, intent: profile?.intent });\n        return;\n      }\n      case 'get_file': {\n        const stop = startTimer('get_file', { source: 'mcp:tools' });\n        const filePath = String(req.params?.path ?? '');\n        const content = orchestrator.getFile(filePath);\n        respond(req.id, { path: filePath, content });\n        stop({ path: filePath, content_length: content.length });\n        return;\n      }\n      case 'list_symbols': {\n        const file = req.params?.file ? String(req.params.file) : undefined;\n        const symbols = graph.listSymbols(file);\n        respond(req.id, symbols);\n        return;\n      }\n      case 'find_refs': {\n        const symbol = String(req.params?.symbol ?? '');\n        const refs = graph.findRefs(symbol);\n        respond(req.id, refs);\n        return;\n      }\n      case 'plan_refactor': {\n        const file = req.params?.file ? String(req.params.file) : undefined;\n        const symbol = req.params?.symbol ? String(req.params.symbol) : undefined;\n        const goal = req.params?.goal ? String(req.params.goal) : undefined;\n        const plan = plan_refactor(orchestrator, graph, process.cwd(), { file, symbol, goal });\n        respond(req.id, plan);\n        return;\n      }\n      case 'gen_patch': {\n        const file = String(req.params?.path ?? '');\n        const operations = Array.isArray(req.params?.operations) ? (req.params.operations as any[]) : [];\n        const patch = generate_patch(process.cwd(), file, operations);\n        respond(req.id, patch);\n        return;\n      }\n      case 'apply_patch': {\n        const file = String(req.params?.path ?? '');\n        const operations = Array.isArray(req.params?.operations) ? (req.params.operations as any[]) : [];\n        const result = applyPatchOperations(process.cwd(), file, operations);\n        respond(req.id, result);\n        return;\n      }\n      case 'analyze_performance': {\n        const file = String(req.params?.path ?? '');\n        const insight = analyze_performance(process.cwd(), file);\n        respond(req.id, insight);\n        return;\n      }\n      case 'compare_versions': {\n        const pathA = String(req.params?.pathA ?? '');\n        const pathB = String(req.params?.pathB ?? '');\n        const diff = compare_versions(process.cwd(), pathA, pathB);\n        respond(req.id, diff);\n        return;\n      }\n      case 'auto_docs': {\n        const file = String(req.params?.path ?? '');\n        const docs = auto_docs(orchestrator, graph, process.cwd(), file);\n        respond(req.id, docs);\n        return;\n      }\n      case 'run_tests': {\n        const command = req.params?.command ? String(req.params.command) : 'npm test';\n        const outcome = run_tests(process.cwd(), command);\n        respond(req.id, outcome);\n        return;\n      }\n      case 'run_task': {\n        const script = String(req.params?.script ?? '');\n        const outcome = run_task(process.cwd(), script);\n        respond(req.id, outcome);\n        return;\n      }\n      case 'generate_telemetry_panel': {\n        const output = req.params?.output ? String(req.params.output) : undefined;\n        const panel = generate_telemetry_panel(process.cwd(), output);\n        respond(req.id, panel);\n        return;\n      }\n      case 'open_telemetry_webview': {\n        const regenerate = req.params?.regenerate === true;\n        const output = req.params?.output ? String(req.params.output) : undefined;\n        const webview = open_telemetry_webview(process.cwd(), { regenerate, output });\n        respond(req.id, webview);\n        return;\n      }\n      case 'langchain_query': {\n        const query = String(req.params?.q ?? '');\n        const topK = Number(req.params?.top_k ?? 5);\n        const dataDir = process.env.DATA_DIR || path.join(process.cwd(), 'data');\n        langchain_query(dataDir, query, topK)\n          .then(result => respond(req.id, result))\n          .catch(err => respond(req.id, undefined, { code: -32000, message: err?.message || 'LangChain query failed' }));\n        return;\n      }\n      case 'summarize_architecture': {\n        const summary = summarize_architecture(graph);\n        respond(req.id, summary);\n        return;\n      }\n      case 'detect_smells': {\n        const repo = String(req.params?.root ?? process.cwd());\n        const res = detect_smells(repo);\n        respond(req.id, res);\n        return;\n      }\n      case 'suggest_tests': {\n        const symbols = (req.params?.symbols ?? []) as Array<{ file: string; name: string }>;\n        const suggestions = suggest_tests(symbols);\n        respond(req.id, suggestions);\n        return;\n      }\n      case 'submit_feedback': {\n        const kind = String(req.params?.kind ?? 'up');\n        wm.feedback(kind === 'down' ? 'down' : 'up');\n        set_weights(wm.get());\n        respond(req.id, { ok: true, weights: wm.get() });\n        return;\n      }\n      case 'get_weights': {\n        respond(req.id, wm.get());\n        return;\n      }\n      default:\n        respond(req.id, undefined, { code: -32601, message: 'Method not found' });\n    }\n  } catch (e: any) {\n    respond(req.id, undefined, { code: -32000, message: e?.message || 'Internal error' });\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:getOrchestrator",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "getOrchestrator",
    "startLine": 39,
    "endLine": 46,
    "text": "function getOrchestrator(): Orchestrator {\n  if (!orchestrator) {\n    const dir = process.env.DATA_DIR || DATA_DIR;\n    const url = process.env.ENGINE_URL || ENGINE_URL;\n    orchestrator = new Orchestrator(dir, url);\n  }\n  return orchestrator;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:getGraph",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "getGraph",
    "startLine": 48,
    "endLine": 54,
    "text": "function getGraph(): GraphStore {\n  if (!graph) {\n    const db = process.env.SQLITE_DB || SQLITE_DB;\n    graph = new GraphStore(db);\n  }\n  return graph;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:write",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "write",
    "startLine": 69,
    "endLine": 69,
    "text": "function write(obj: any) { process.stdout.write(JSON.stringify(obj) + '\\n'); }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:ok",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "ok",
    "startLine": 70,
    "endLine": 70,
    "text": "function ok(id: RpcRequest['id'], result: any) { write({ jsonrpc: '2.0', id, result }); }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:err",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "err",
    "startLine": 71,
    "endLine": 75,
    "text": "function err(id: RpcRequest['id'], code: number, message: string, data?: any) {\n  const e: any = { code, message };\n  if (data) e.data = data;\n  write({ jsonrpc: '2.0', id, error: e });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:toFileUri",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "toFileUri",
    "startLine": 84,
    "endLine": 92,
    "text": "function toFileUri(p: string): string {\n  const abs = path.resolve(p);\n  const withSlashes = abs.replace(/\\\\/g, '/');\n  // Ensure file:/// prefix with Windows drive support\n  if (/^[A-Za-z]:\\//.test(withSlashes)) {\n    return `file:///${withSlashes}`;\n  }\n  return `file://${withSlashes.startsWith('/') ? '' : '/'}${withSlashes}`;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:fromFileUri",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "fromFileUri",
    "startLine": 94,
    "endLine": 107,
    "text": "function fromFileUri(u: string): string {\n  try {\n    if (!u.startsWith('file://')) return u;\n    const url = new URL(u);\n    let p = decodeURIComponent(url.pathname);\n    // Windows path like /C:/...\n    if (process.platform === 'win32' && /^\\/[A-Za-z]:\\//.test(p)) {\n      p = p.slice(1);\n    }\n    return path.normalize(p);\n  } catch {\n    return u;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:safeJoin",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "safeJoin",
    "startLine": 109,
    "endLine": 113,
    "text": "function safeJoin(root: string, rel: string): string | null {\n  const p = path.resolve(root, rel);\n  if (!p.startsWith(path.resolve(root))) return null;\n  return p;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:listFiles",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "listFiles",
    "startLine": 115,
    "endLine": 136,
    "text": "function listFiles(root: string, max = 200): string[] {\n  const out: string[] = [];\n  const stack: string[] = [root];\n  while (stack.length && out.length < max) {\n    const cur = stack.pop()!;\n    try {\n      const st = fs.statSync(cur);\n      if (st.isDirectory()) {\n        for (const name of fs.readdirSync(cur)) {\n          const full = path.join(cur, name);\n          try {\n            const s2 = fs.statSync(full);\n            if (s2.isDirectory()) stack.push(full);\n            else if (s2.isFile() && allowPath(full)) out.push(full);\n          } catch { }\n          if (out.length >= max) break;\n        }\n      } else if (st.isFile() && allowPath(cur)) out.push(cur);\n    } catch { }\n  }\n  return out;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:normalizeRepoPath",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "normalizeRepoPath",
    "startLine": 140,
    "endLine": 142,
    "text": "function normalizeRepoPath(p: string): string {\n  return p.replace(/\\\\/g, '/');\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:uniqueList",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "uniqueList",
    "startLine": 144,
    "endLine": 155,
    "text": "function uniqueList(values: string[]): string[] {\n  const seen = new Set<string>();\n  const result: string[] = [];\n  for (const value of values) {\n    const normalized = normalizeRepoPath(value);\n    if (!seen.has(normalized)) {\n      seen.add(normalized);\n      result.push(normalized);\n    }\n  }\n  return result;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:filePreview",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "filePreview",
    "startLine": 157,
    "endLine": 165,
    "text": "function filePreview(file: string, maxLines = MAX_PROMPT_SNIPPET_LINES): string {\n  try {\n    const content = getOrchestrator().getFile(file);\n    const lines = content.split(/\\r?\\n/).slice(0, maxLines);\n    return lines.join('\\n').trimEnd();\n  } catch {\n    return '';\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:formatList",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "formatList",
    "startLine": 167,
    "endLine": 171,
    "text": "function formatList(label: string, items: string[]): string {\n  const list = uniqueList(items).slice(0, 8);\n  if (!list.length) return '';\n  return `${label}:\\n${list.map(item => `- ${item}`).join('\\n')}`;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:buildPromptContext",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "buildPromptContext",
    "startLine": 173,
    "endLine": 208,
    "text": "function buildPromptContext(args: { file?: string; symbol?: string; extraNote?: string }): string {\n  const segments: string[] = [];\n  const graph = getGraph();\n  const file = args.file ? normalizeRepoPath(String(args.file)) : undefined;\n  const symbol = args.symbol ? String(args.symbol) : undefined;\n\n  if (file) {\n    segments.push(`File Scope: ${file}`);\n    const symbols = graph.listSymbols(file).slice(0, 8).map((s: any) => `${s.kind}:${s.name} (L${s.startLine}-${s.endLine})`);\n    const imports = graph.listImports(file);\n    const dependents = graph.listDependents(file);\n    const preview = filePreview(file);\n    if (symbols.length) segments.push(formatList('Local symbols', symbols));\n    const importBlock = formatList('Imports', imports);\n    if (importBlock) segments.push(importBlock);\n    const dependentsBlock = formatList('Referenced by', dependents);\n    if (dependentsBlock) segments.push(dependentsBlock);\n    if (preview) {\n      const previewLines = preview.split(/\\r?\\n/).length;\n      segments.push(`File preview (first ${Math.min(previewLines, MAX_PROMPT_SNIPPET_LINES)} lines):\\n${preview}`);\n    }\n  }\n\n  if (symbol) {\n    segments.push(`Focus symbol: ${symbol}`);\n    const refs = (graph.findRefs(symbol) as Array<{ file?: string }> | undefined) ?? [];\n    const refList = uniqueList(refs.map(r => r.file || '').filter(Boolean));\n    if (refList.length) segments.push(formatList('Referenced in', refList));\n  }\n\n  if (args.extraNote) {\n    segments.push(`Additional notes: ${args.extraNote}`);\n  }\n\n  return segments.filter(Boolean).join('\\n\\n');\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:buildPromptText",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "buildPromptText",
    "startLine": 210,
    "endLine": 246,
    "text": "function buildPromptText(name: string, args: Record<string, unknown>): string | null {\n  const fileArg = typeof args.file === 'string' ? args.file : undefined;\n  const symbolArg = typeof args.symbol === 'string' ? args.symbol : undefined;\n  const userContext = typeof args.context === 'string' ? args.context : undefined;\n  const extra = typeof args.notes === 'string' ? args.notes : undefined;\n  const baseContext = buildPromptContext({ file: fileArg, symbol: symbolArg, extraNote: extra });\n\n  const sections: string[] = [];\n  switch (name) {\n    case 'refactor': {\n      sections.push('Goal: Refactor the target code to improve readability and maintainability without altering behaviour.');\n      if (baseContext) sections.push(`Context:\\n${baseContext}`);\n      if (userContext) sections.push(`Caller notes:\\n${userContext}`);\n      sections.push('Guidelines:\\n- Preserve public contracts and side-effects.\\n- Identify technical debt hotspots and propose concise fixes.\\n- Provide updated code excerpts with rationale for each change.');\n      break;\n    }\n    case 'test': {\n      const subject = symbolArg || fileArg || 'the specified module';\n      sections.push(`Goal: Design a focused test strategy for ${subject}.`);\n      if (baseContext) sections.push(`Context:\\n${baseContext}`);\n      if (userContext) sections.push(`Caller notes:\\n${userContext}`);\n      sections.push('Checklist:\\n- Enumerate critical behaviours and edge cases.\\n- Recommend unit/integration test boundaries.\\n- Suggest fixtures or mocks and expected assertions.');\n      break;\n    }\n    case 'perf': {\n      const scope = fileArg || symbolArg || 'the target codebase';\n      sections.push(`Goal: Investigate potential performance issues in ${scope}.`);\n      if (baseContext) sections.push(`Context:\\n${baseContext}`);\n      if (userContext) sections.push(`Caller notes:\\n${userContext}`);\n      sections.push('Focus:\\n- Highlight expensive code paths or dependency hot spots.\\n- Suggest measurement approaches (profilers, metrics).\\n- Recommend optimisation tactics while keeping clarity.');\n      break;\n    }\n    default:\n      return null;\n  }\n  return sections.filter(Boolean).join('\\n\\n');\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:handle",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "handle",
    "startLine": 512,
    "endLine": 754,
    "text": "async function handle(req: RpcRequest) {\n  try {\n    // Ignore notifications (JSON-RPC without id). MCP may send sessionConfigured, etc.\n    if (req.id === null || typeof req.id === 'undefined') {\n      // Known MCP notifications we can safely ignore\n      if (req.method === 'sessionConfigured' || req.method === 'ping' || req.method === 'initialized') {\n        return; // no response for notifications\n      }\n      return; // silently ignore unknown notifications per JSON-RPC\n    }\n    if (req.method === 'initialize') {\n      return ok(req.id, {\n        protocolVersion: '2024-11-05',\n        capabilities: { tools: {}, resources: {}, prompts: {} },\n        serverInfo: { name: 'mcp-local', version: '1.0.0' }\n      });\n    }\n    if (req.method === 'ping') {\n      return ok(req.id, { ok: true });\n    }\n    if (req.method === 'shutdown') {\n      ok(req.id, { ok: true });\n      process.exit(0);\n      return;\n    }\n    if (req.method === 'tools/list') {\n      return ok(req.id, { tools });\n    }\n    if (req.method === 'tools/call') {\n      const name = String(req.params?.name || '');\n      const args = (req.params?.arguments as any) || {};\n      switch (name) {\n        case 'search_code': {\n          const orchestrator = getOrchestrator();\n          const q = String(args.q || '');\n          const topK = Number.isFinite(args.top_k) ? Number(args.top_k) : 5;\n          const results = await orchestrator.searchCode(q, topK);\n          const profile = orchestrator.getLastProfile();\n          return ok(req.id, {\n            content: [{\n              type: 'text',\n              text: JSON.stringify({ query: q, profile, results }),\n            }],\n          });\n        }\n        case 'get_file': {\n          const p = String(args.path || '');\n          const content = getOrchestrator().getFile(p);\n          return ok(req.id, { content: [{ type: 'text', text: content }] });\n        }\n        case 'list_symbols': {\n          const file = args.file ? String(args.file) : undefined;\n          const syms = getGraph().listSymbols(file);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(syms) }] });\n        }\n        case 'find_refs': {\n          const sym = String(args.symbol || '');\n          const refs = getGraph().findRefs(sym);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(refs) }] });\n        }\n        case 'plan_refactor': {\n          const file = args.file ? String(args.file) : undefined;\n          const symbol = args.symbol ? String(args.symbol) : undefined;\n          const goal = args.goal ? String(args.goal) : undefined;\n          const plan = plan_refactor(getOrchestrator(), getGraph(), process.cwd(), { file, symbol, goal });\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(plan) }] });\n        }\n        case 'gen_patch': {\n          const file = String(args.path || '');\n          const operations = Array.isArray(args.operations) ? args.operations as any[] : [];\n          const patch = generate_patch(process.cwd(), file, operations);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(patch) }] });\n        }\n        case 'apply_patch': {\n          const file = String(args.path || '');\n          const operations = Array.isArray(args.operations) ? args.operations as any[] : [];\n          const res = applyPatchOperations(process.cwd(), file, operations);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(res) }] });\n        }\n        case 'analyze_performance': {\n          const file = String(args.path || '');\n          const insight = analyze_performance(process.cwd(), file);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(insight) }] });\n        }\n        case 'compare_versions': {\n          const pathA = String(args.pathA || '');\n          const pathB = String(args.pathB || '');\n          const cmp = compare_versions(process.cwd(), pathA, pathB);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(cmp) }] });\n        }\n        case 'auto_docs': {\n          const file = String(args.path || '');\n          const docs = auto_docs(getOrchestrator(), getGraph(), process.cwd(), file);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(docs) }] });\n        }\n        case 'run_tests': {\n          const command = args.command ? String(args.command) : 'npm test';\n          const outcome = run_tests(process.cwd(), command);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(outcome) }] });\n        }\n        case 'run_task': {\n          const script = String(args.script || '');\n          const outcome = run_task(process.cwd(), script);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(outcome) }] });\n        }\n        case 'generate_telemetry_panel': {\n          const output = args.output ? String(args.output) : undefined;\n          const panel = generate_telemetry_panel(process.cwd(), output);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(panel) }] });\n        }\n        case 'open_telemetry_webview': {\n          const regenerate = args.regenerate === true;\n          const output = args.output ? String(args.output) : undefined;\n          const webview = open_telemetry_webview(process.cwd(), { regenerate, output });\n          return ok(req.id, {\n            content: [{\n              type: 'text',\n              text: webview.html,\n              mimeType: 'text/html',\n              metadata: { path: webview.path },\n            }],\n          });\n        }\n        case 'langchain_query': {\n          const q = String(args.q || '');\n          const topK = Number.isFinite(args.top_k) ? Number(args.top_k) : 5;\n          const dataDir = process.env.DATA_DIR || DATA_DIR;\n          const result = await langchain_query(dataDir, q, topK);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(result) }] });\n        }\n        case 'summarize_architecture': {\n          const s = summarize_architecture(getGraph());\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(s) }] });\n        }\n        case 'detect_smells': {\n          const root = String(args.root || process.cwd());\n          const res = detect_smells(root);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(res) }] });\n        }\n        case 'suggest_tests': {\n          const symbols = (args.symbols as Array<{ file: string; name: string }>) || [];\n          const sugg = suggest_tests(symbols);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(sugg) }] });\n        }\n        case 'submit_feedback': {\n          const kind = String(args.kind || 'up');\n          wm.feedback(kind === 'down' ? 'down' : 'up');\n          set_weights(wm.get());\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify({ ok: true, weights: wm.get() }) }] });\n        }\n        case 'get_weights': {\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(wm.get()) }] });\n        }\n        case 'resources-list': {\n          const root = args.root ? String(args.root) : ROOTS[0];\n          const max = Number.isFinite(args.max) ? Number(args.max) : 200;\n          if (!ROOTS.some(r => path.resolve(root).startsWith(path.resolve(r)))) {\n            return err(req.id, -32001, 'Root not allowed', { root, allowed: ROOTS });\n          }\n          const files = listFiles(root, max).map(f => path.normalize(f));\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(files) }] });\n        }\n        case 'resources-read': {\n          const p = String(args.path || '');\n          const maxChars = Number.isFinite(args.maxChars) ? Number(args.maxChars) : 200_000;\n          if (!ROOTS.some(r => path.resolve(p).startsWith(path.resolve(r)))) {\n            return err(req.id, -32001, 'Path not under allowed roots', { path: p, allowed: ROOTS });\n          }\n          if (!allowPath(p)) return err(req.id, -32002, 'Path not allowed by policy', { path: p });\n          try {\n            const buf = fs.readFileSync(p, 'utf8');\n            const text = buf.slice(0, maxChars);\n            return ok(req.id, { content: [{ type: 'text', text }] });\n          } catch (e: any) {\n            return err(req.id, -32003, 'Failed to read file', { path: p, error: e?.message });\n          }\n        }\n        case 'roots-list': {\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(ROOTS) }] });\n        }\n        case 'prompts-list': {\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(PROMPT_DESCRIPTORS) }] });\n        }\n        case 'prompts-call': {\n          const pname = String(args.name || '');\n          const a = (args.args || {}) as Record<string, unknown>;\n          const text = buildPromptText(pname, a);\n          if (!text) return err(req.id, -32601, 'Prompt not found', { name: pname });\n          return ok(req.id, { content: [{ type: 'text', text }] });\n        }\n        default:\n          return err(req.id, -32601, 'Tool not found');\n      }\n    }\n    // Expose top-level MCP resource/prompt methods for IDE panels\n    if (req.method === 'resources/list') {\n      const args = (req.params as any) || {};\n      const rootArg = String(args.root || args.uri || ROOTS[0]);\n      const root = rootArg.startsWith('file://') ? fromFileUri(rootArg) : rootArg;\n      const max = Number.isFinite(args.max) ? Number(args.max) : 200;\n      if (!ROOTS.some(r => path.resolve(root).startsWith(path.resolve(r)))) {\n        return err(req.id, -32001, 'Root not allowed', { root, allowed: ROOTS });\n      }\n      const files = listFiles(root, max).map(f => path.normalize(f));\n      return ok(req.id, { resources: files.map(f => ({ uri: toFileUri(f), name: path.basename(f) })) });\n    }\n    if (req.method === 'resources/read') {\n      const args = (req.params as any) || {};\n      const raw = String(args.path || args.uri || '');\n      const p = raw.startsWith('file://') ? fromFileUri(raw) : raw;\n      const maxChars = Number.isFinite(args.maxChars) ? Number(args.maxChars) : 200_000;\n      if (!ROOTS.some(r => path.resolve(p).startsWith(path.resolve(r)))) {\n        return err(req.id, -32001, 'Path not under allowed roots', { path: p, allowed: ROOTS });\n      }\n      if (!allowPath(p)) return err(req.id, -32002, 'Path not allowed by policy', { path: p });\n      try {\n        const buf = fs.readFileSync(p, 'utf8');\n        const text = buf.slice(0, maxChars);\n        const mimeType = p.endsWith('.html') ? 'text/html' : 'text/plain';\n        return ok(req.id, { contents: [{ uri: toFileUri(p), mimeType, text }] });\n      } catch (e: any) {\n        return err(req.id, -32003, 'Failed to read file', { path: p, error: e?.message });\n      }\n    }\n    if (req.method === 'roots/list') {\n      return ok(req.id, { roots: ROOTS.map(r => ({ uri: toFileUri(r), name: r })) });\n    }\n    if (req.method === 'prompts/list') {\n      return ok(req.id, { prompts: PROMPT_DESCRIPTORS });\n    }\n    if (req.method === 'prompts/call') {\n      const args = (req.params as any) || {};\n      const pname = String(args.name || '');\n      const a = (args.args || {}) as Record<string, unknown>;\n      const text = buildPromptText(pname, a);\n      if (!text) return err(req.id, -32601, 'Prompt not found', { name: pname });\n      return ok(req.id, { content: [{ type: 'text', text }] });\n    }\n    return err(req.id, -32601, 'Method not found');\n  } catch (e: any) {\n    return err(req.id, -32000, e?.message || 'Internal error');\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts:parseEnvironmentContext",
    "file": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "symbol": "parseEnvironmentContext",
    "startLine": 781,
    "endLine": 788,
    "text": "function parseEnvironmentContext(xmlStr: string): any {\n  const matches = {\n    cwd: xmlStr.match(/<cwd>(.*?)<\\/cwd>/)?.[1] || '',\n    approval_policy: xmlStr.match(/<approval_policy>(.*?)<\\/approval_policy>/)?.[1] || 'on-request',\n    sandbox_mode: xmlStr.match(/<sandbox_mode>(.*?)<\\/sandbox_mode>/)?.[1] || 'workspace-write'\n  };\n  return matches;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_http_bridge.ts:startMcpHttpBridge",
    "file": "node_modules/@mcp/server/src/mcp_http_bridge.ts",
    "symbol": "startMcpHttpBridge",
    "startLine": 10,
    "endLine": 81,
    "text": "export function startMcpHttpBridge(port: number) {\n  const adapterPath = path.join(__dirname, 'mcp_adapter.js');\n  const child: ChildProcessByStdio<Writable, Readable, Readable> = spawn(process.execPath, [adapterPath], {\n    stdio: ['pipe', 'pipe', 'pipe'],\n    env: process.env,\n  });\n\n  const rl = readline.createInterface({ input: child.stdout });\n  const pending = new Map<string, (resp: any) => void>();\n\n  rl.on('line', line => {\n    try {\n      const obj = JSON.parse(line);\n      const id = String(obj.id);\n      const resolve = pending.get(id);\n      if (resolve) {\n        pending.delete(id);\n        resolve(obj);\n      }\n    } catch { /* ignore non-JSON lines */ }\n  });\n\n  const server = http.createServer(async (req, res) => {\n    try {\n      if (req.method !== 'POST' || !req.url) { res.writeHead(405); return res.end(); }\n      const url = new URL(req.url, `http://${req.headers.host}`);\n      if (url.pathname !== '/mcp') { res.writeHead(404); return res.end(); }\n      const chunks: Buffer[] = [];\n      req.on('data', c => chunks.push(c));\n      req.on('end', async () => {\n        try {\n          const body = Buffer.concat(chunks).toString('utf8');\n          const payload = JSON.parse(body);\n          const handleOne = (p: RpcRequest) => new Promise<any>((resolveOne, rejectOne) => {\n            if (p.id === null || typeof p.id === 'undefined') {\n              // notification: just forward and return 204 later\n              child.stdin.write(JSON.stringify(p) + '\\n');\n              resolveOne(undefined);\n              return;\n            }\n            const key = String(p.id);\n            pending.set(key, resp => resolveOne(resp));\n            child.stdin.write(JSON.stringify(p) + '\\n');\n            // Optionally add a timeout\n            setTimeout(() => {\n              if (pending.has(key)) { pending.delete(key); rejectOne(new Error('timeout')); }\n            }, 30000);\n          });\n\n          if (Array.isArray(payload)) {\n            const responses = await Promise.all(payload.map(p => handleOne(p)));\n            const filtered = responses.filter(r => r !== undefined);\n            res.writeHead(200, { 'content-type': 'application/json' });\n            res.end(JSON.stringify(filtered));\n          } else {\n            const response = await handleOne(payload);\n            if (response === undefined) { res.writeHead(204); res.end(); }\n            else { res.writeHead(200, { 'content-type': 'application/json' }); res.end(JSON.stringify(response)); }\n          }\n        } catch (e: any) {\n          res.writeHead(400, { 'content-type': 'application/json' });\n          res.end(JSON.stringify({ error: e?.message || 'bad request' }));\n        }\n      });\n    } catch {\n      res.writeHead(500); res.end();\n    }\n  });\n\n  server.listen(port, '127.0.0.1');\n  return { server, child };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/orchestrator.ts:Orchestrator",
    "file": "node_modules/@mcp/server/src/orchestrator.ts",
    "symbol": "Orchestrator",
    "startLine": 18,
    "endLine": 81,
    "text": "export class Orchestrator {\n  private fileIndex: Map<string, FileMeta> = new Map();\n  private engineUrl: string;\n  private graph?: GraphStore;\n  private lastProfile: ContextProfile | null = null;\n\n  constructor(dataDir: string, engineUrl: string = 'http://localhost:8000', graph?: GraphStore) {\n    this.engineUrl = engineUrl;\n    this.loadIndex(dataDir);\n    this.graph = graph;\n  }\n\n  private loadIndex(dataDir: string) {\n    const idxPath = path.join(dataDir, 'index.json');\n    const json = fs.readFileSync(idxPath, 'utf8');\n    const files: FileMeta[] = JSON.parse(json);\n    for (const file of files) {\n      this.fileIndex.set(file.path, file);\n    }\n  }\n\n  public getFile(filePath: string): string {\n    const fileMeta = this.fileIndex.get(filePath);\n    if (!fileMeta) throw new Error(`File not found in index: ${filePath}`);\n    return fileMeta.content;\n  }\n\n  public getLastProfile(): ContextProfile | null {\n    return this.lastProfile ? { ...this.lastProfile } : null;\n  }\n\n  public async searchCode(query: string, topK = 5): Promise<SearchResult[]> {\n    const url = new URL('/search', this.engineUrl);\n    url.searchParams.set('q', query);\n    url.searchParams.set('top_k', topK.toString());\n    const engineResults: EngineSearchResult[] = await new Promise((resolve, reject) => {\n      const req = http.get(url.toString(), res => {\n        const chunks: Buffer[] = [];\n        res.on('data', c => chunks.push(c));\n        res.on('end', () => {\n          try {\n            const parsed = JSON.parse(Buffer.concat(chunks).toString('utf8'));\n            resolve(parsed.results as EngineSearchResult[]);\n          } catch (err) {\n            reject(err);\n          }\n        });\n      });\n      req.on('error', err => reject(err));\n    });\n    const initial: SearchResult[] = engineResults.map(er => ({ ...er } as SearchResult));\n    const profile = profileContext(query, topK);\n    const ranked = rank_hybrid(initial, query, this.graph ? (f => this.graph!.degree(f)) : undefined);\n    let curated = pack_tokens(ranked, profile.tokenBudget);\n    if (!curated.length) {\n      curated = ranked.slice(0, Math.max(1, profile.effectiveTopK));\n    }\n    if (curated.length > profile.effectiveTopK) {\n      curated = curated.slice(0, profile.effectiveTopK);\n    }\n    this.lastProfile = profile;\n    return curated;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/orchestrator.ts:Orchestrator.loadIndex",
    "file": "node_modules/@mcp/server/src/orchestrator.ts",
    "symbol": "Orchestrator.loadIndex",
    "startLine": 30,
    "endLine": 37,
    "text": "  private loadIndex(dataDir: string) {\n    const idxPath = path.join(dataDir, 'index.json');\n    const json = fs.readFileSync(idxPath, 'utf8');\n    const files: FileMeta[] = JSON.parse(json);\n    for (const file of files) {\n      this.fileIndex.set(file.path, file);\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/orchestrator.ts:Orchestrator.getFile",
    "file": "node_modules/@mcp/server/src/orchestrator.ts",
    "symbol": "Orchestrator.getFile",
    "startLine": 39,
    "endLine": 43,
    "text": "  public getFile(filePath: string): string {\n    const fileMeta = this.fileIndex.get(filePath);\n    if (!fileMeta) throw new Error(`File not found in index: ${filePath}`);\n    return fileMeta.content;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/orchestrator.ts:Orchestrator.getLastProfile",
    "file": "node_modules/@mcp/server/src/orchestrator.ts",
    "symbol": "Orchestrator.getLastProfile",
    "startLine": 45,
    "endLine": 47,
    "text": "  public getLastProfile(): ContextProfile | null {\n    return this.lastProfile ? { ...this.lastProfile } : null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/orchestrator.ts:Orchestrator.searchCode",
    "file": "node_modules/@mcp/server/src/orchestrator.ts",
    "symbol": "Orchestrator.searchCode",
    "startLine": 49,
    "endLine": 80,
    "text": "  public async searchCode(query: string, topK = 5): Promise<SearchResult[]> {\n    const url = new URL('/search', this.engineUrl);\n    url.searchParams.set('q', query);\n    url.searchParams.set('top_k', topK.toString());\n    const engineResults: EngineSearchResult[] = await new Promise((resolve, reject) => {\n      const req = http.get(url.toString(), res => {\n        const chunks: Buffer[] = [];\n        res.on('data', c => chunks.push(c));\n        res.on('end', () => {\n          try {\n            const parsed = JSON.parse(Buffer.concat(chunks).toString('utf8'));\n            resolve(parsed.results as EngineSearchResult[]);\n          } catch (err) {\n            reject(err);\n          }\n        });\n      });\n      req.on('error', err => reject(err));\n    });\n    const initial: SearchResult[] = engineResults.map(er => ({ ...er } as SearchResult));\n    const profile = profileContext(query, topK);\n    const ranked = rank_hybrid(initial, query, this.graph ? (f => this.graph!.degree(f)) : undefined);\n    let curated = pack_tokens(ranked, profile.tokenBudget);\n    if (!curated.length) {\n      curated = ranked.slice(0, Math.max(1, profile.effectiveTopK));\n    }\n    if (curated.length > profile.effectiveTopK) {\n      curated = curated.slice(0, profile.effectiveTopK);\n    }\n    this.lastProfile = profile;\n    return curated;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/policy.ts:allowPath",
    "file": "node_modules/@mcp/server/src/policy.ts",
    "symbol": "allowPath",
    "startLine": 4,
    "endLine": 14,
    "text": "export function allowPath(p: string): boolean {\n  const basename = path.basename(p).toLowerCase();\n  if (basename.endsWith('.env') || basename.endsWith('.key') || basename.endsWith('.pem')) return false;\n  try {\n    const stat = fs.statSync(p);\n    if (stat.size > 50 * 1024 * 1024) return false;\n  } catch {\n    // ignore\n  }\n  return true;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/policy.ts:filterPaths",
    "file": "node_modules/@mcp/server/src/policy.ts",
    "symbol": "filterPaths",
    "startLine": 16,
    "endLine": 18,
    "text": "export function filterPaths(paths: string[]): string[] {\n  return paths.filter(allowPath);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/ranker.ts:set_weights",
    "file": "node_modules/@mcp/server/src/ranker.ts",
    "symbol": "set_weights",
    "startLine": 10,
    "endLine": 13,
    "text": "export function set_weights(w: { semantic: number; lexical: number; graph: number }) {\n  const s = w.semantic + w.lexical + w.graph;\n  weights = { semantic: w.semantic / s, lexical: w.lexical / s, graph: w.graph / s };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/ranker.ts:rank_hybrid",
    "file": "node_modules/@mcp/server/src/ranker.ts",
    "symbol": "rank_hybrid",
    "startLine": 15,
    "endLine": 36,
    "text": "export function rank_hybrid(results: SearchResult[], query: string, fileDegree?: (file: string) => number): SearchResult[] {\n  const tokens = query.toLowerCase().split(/\\W+/).filter(Boolean);\n  const degrees = new Map<string, number>();\n  let maxDeg = 1;\n  if (fileDegree) {\n    for (const r of results) {\n      const d = fileDegree(r.file) || 0;\n      degrees.set(r.file, d);\n      if (d > maxDeg) maxDeg = d;\n    }\n  }\n  return results.map(r => {\n    const snippetLower = r.snippet.toLowerCase();\n    let hits = 0;\n    for (const t of tokens) if (snippetLower.includes(t)) hits++;\n    const lexical = tokens.length ? hits / tokens.length : 0;\n    const graph = degrees.has(r.file) ? (degrees.get(r.file)! / maxDeg) : 0;\n    const semantic = r.score; // assume engine score in [0..1]\n    const score = semantic * weights.semantic + lexical * weights.lexical + graph * weights.graph;\n    return { ...r, score };\n  }).sort((a, b) => b.score - a.score);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/ranker.ts:pack_tokens",
    "file": "node_modules/@mcp/server/src/ranker.ts",
    "symbol": "pack_tokens",
    "startLine": 38,
    "endLine": 64,
    "text": "export function pack_tokens(results: SearchResult[], budgetTokens: number): SearchResult[] {\n  // naive token estimate: ~1 token per 4 chars\n  const estimate = (s: string) => Math.ceil(s.length / 4);\n  const selected: SearchResult[] = [];\n  let used = 0;\n  // MMR-like greedy selection with diversity by file\n  const usedFiles = new Set<string>();\n  for (const r of results) {\n    const cost = estimate(r.snippet);\n    if (used + cost > budgetTokens) continue;\n    if (usedFiles.has(r.file)) continue; // diversity: one per file first\n    selected.push(r);\n    used += cost;\n    usedFiles.add(r.file);\n  }\n  // fill remaining budget regardless of file if space left\n  if (used < budgetTokens) {\n    for (const r of results) {\n      if (selected.includes(r)) continue;\n      const cost = estimate(r.snippet);\n      if (used + cost > budgetTokens) continue;\n      selected.push(r);\n      used += cost;\n    }\n  }\n  return selected;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts:configureTelemetry",
    "file": "node_modules/@mcp/server/src/telemetry.ts",
    "symbol": "configureTelemetry",
    "startLine": 25,
    "endLine": 34,
    "text": "export function configureTelemetry(options: { promFile?: string; jsonSnapshotFile?: string; disableProm?: boolean; disableSnapshot?: boolean } = {}) {\n  if (options.promFile) {\n    promFile = path.resolve(process.cwd(), options.promFile);\n  }\n  if (options.jsonSnapshotFile) {\n    jsonSnapshotFile = path.resolve(process.cwd(), options.jsonSnapshotFile);\n  }\n  if (typeof options.disableProm === 'boolean') promEnabled = !options.disableProm;\n  if (typeof options.disableSnapshot === 'boolean') jsonSnapshotEnabled = !options.disableSnapshot;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts:startTimer",
    "file": "node_modules/@mcp/server/src/telemetry.ts",
    "symbol": "startTimer",
    "startLine": 36,
    "endLine": 49,
    "text": "export function startTimer(name: string, attributes: Record<string, unknown> = {}) {\n  const start = Date.now();\n  return (extra: Record<string, unknown> = {}) => {\n    const dur = Date.now() - start;\n    const payload: MetricPayload = {\n      name,\n      duration_ms: dur,\n      ts: new Date().toISOString(),\n      ...attributes,\n      ...extra,\n    };\n    writeMetric(payload);\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts:ensureDir",
    "file": "node_modules/@mcp/server/src/telemetry.ts",
    "symbol": "ensureDir",
    "startLine": 51,
    "endLine": 53,
    "text": "function ensureDir(filePath: string) {\n  fs.mkdirSync(path.dirname(filePath), { recursive: true });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts:writeMetric",
    "file": "node_modules/@mcp/server/src/telemetry.ts",
    "symbol": "writeMetric",
    "startLine": 55,
    "endLine": 68,
    "text": "function writeMetric(m: MetricPayload) {\n  try {\n    ensureDir(JSON_LOG_FILE);\n    fs.appendFileSync(JSON_LOG_FILE, JSON.stringify(m) + '\\n', 'utf8');\n  } catch (err) {\n    if (process.env.DEBUG_TELEMETRY) {\n      // eslint-disable-next-line no-console\n      console.warn('[telemetry] failed to write JSON log', err);\n    }\n  }\n  updateAggregates(m);\n  if (promEnabled) emitPrometheus();\n  if (jsonSnapshotEnabled) emitJsonSnapshot();\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts:aggregateKey",
    "file": "node_modules/@mcp/server/src/telemetry.ts",
    "symbol": "aggregateKey",
    "startLine": 70,
    "endLine": 72,
    "text": "function aggregateKey(m: MetricPayload): AggregateKey {\n  return `${m.name}:${m.source ?? 'unknown'}`;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts:updateAggregates",
    "file": "node_modules/@mcp/server/src/telemetry.ts",
    "symbol": "updateAggregates",
    "startLine": 74,
    "endLine": 82,
    "text": "function updateAggregates(m: MetricPayload) {\n  const key = aggregateKey(m);\n  const entry = aggregates.get(key) ?? { count: 0, total: 0, max: Number.MIN_SAFE_INTEGER, min: Number.MAX_SAFE_INTEGER };\n  entry.count += 1;\n  entry.total += m.duration_ms;\n  entry.max = Math.max(entry.max, m.duration_ms);\n  entry.min = Math.min(entry.min, m.duration_ms);\n  aggregates.set(key, entry);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts:emitPrometheus",
    "file": "node_modules/@mcp/server/src/telemetry.ts",
    "symbol": "emitPrometheus",
    "startLine": 84,
    "endLine": 107,
    "text": "function emitPrometheus() {\n  try {\n    ensureDir(promFile);\n    const lines: string[] = [\n      '# HELP mcp_request_duration_ms MCP request durations in milliseconds.',\n      '# TYPE mcp_request_duration_ms summary',\n    ];\n    for (const [key, stats] of aggregates.entries()) {\n      const [name, source] = key.split(':');\n      const avg = stats.count ? stats.total / stats.count : 0;\n      lines.push(`mcp_request_duration_ms_count{name=\"${name}\",source=\"${source}\"} ${stats.count}`);\n      lines.push(`mcp_request_duration_ms_sum{name=\"${name}\",source=\"${source}\"} ${stats.total}`);\n      lines.push(`mcp_request_duration_ms_avg{name=\"${name}\",source=\"${source}\"} ${avg.toFixed(2)}`);\n      lines.push(`mcp_request_duration_ms_max{name=\"${name}\",source=\"${source}\"} ${stats.max}`);\n      lines.push(`mcp_request_duration_ms_min{name=\"${name}\",source=\"${source}\"} ${stats.min}`);\n    }\n    fs.writeFileSync(promFile, lines.join('\\n') + '\\n', 'utf8');\n  } catch (err) {\n    if (process.env.DEBUG_TELEMETRY) {\n      // eslint-disable-next-line no-console\n      console.warn('[telemetry] failed to write Prometheus output', err);\n    }\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts:emitJsonSnapshot",
    "file": "node_modules/@mcp/server/src/telemetry.ts",
    "symbol": "emitJsonSnapshot",
    "startLine": 109,
    "endLine": 124,
    "text": "function emitJsonSnapshot() {\n  try {\n    ensureDir(jsonSnapshotFile);\n    const snapshot = Array.from(aggregates.entries()).map(([key, stats]) => {\n      const [name, source] = key.split(':');\n      const avg = stats.count ? stats.total / stats.count : 0;\n      return { name, source, count: stats.count, total: stats.total, avg, max: stats.max, min: stats.min };\n    });\n    fs.writeFileSync(jsonSnapshotFile, JSON.stringify(snapshot, null, 2), 'utf8');\n  } catch (err) {\n    if (process.env.DEBUG_TELEMETRY) {\n      // eslint-disable-next-line no-console\n      console.warn('[telemetry] failed to write JSON snapshot', err);\n    }\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:safeRelative",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "safeRelative",
    "startLine": 104,
    "endLine": 106,
    "text": "function safeRelative(root: string, target: string) {\n  return path.relative(root, target).replace(/\\\\/g, '/');\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:slicePreview",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "slicePreview",
    "startLine": 108,
    "endLine": 112,
    "text": "function slicePreview(lines: string[], startLine: number, endLine: number): string[] {\n  const start = Math.max(0, startLine - 1);\n  const end = Math.min(lines.length, endLine);\n  return lines.slice(start, Math.min(end, start + MAX_PREVIEW_LINES));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:applyOperations",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "applyOperations",
    "startLine": 114,
    "endLine": 129,
    "text": "function applyOperations(content: string, operations: PatchOperation[]): { updated: string; applied: number } {\n  let current = content;\n  let applied = 0;\n  for (const op of operations) {\n    const occurrences = typeof op.occurrences === 'number' && op.occurrences > 0 ? op.occurrences : 1;\n    let count = 0;\n    let idx = current.indexOf(op.find);\n    while (idx !== -1 && count < occurrences) {\n      current = current.slice(0, idx) + op.replace + current.slice(idx + op.find.length);\n      applied += 1;\n      count += 1;\n      idx = current.indexOf(op.find, idx + op.replace.length);\n    }\n  }\n  return { updated: current, applied };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:plan_refactor",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "plan_refactor",
    "startLine": 131,
    "endLine": 201,
    "text": "export function plan_refactor(orchestrator: Orchestrator, graph: GraphStore, repoRoot: string, input: RefactorPlanInput): RefactorPlan {\n  const targetFile = input.file ?? '';\n  let summary = 'High level refactor plan for the repository';\n  const steps: string[] = [];\n  const risks: string[] = [];\n  let imports: string[] = [];\n  let dependents: string[] = [];\n\n  if (targetFile) {\n    try {\n      const content = orchestrator.getFile(targetFile);\n      const lines = content.split(/\\r?\\n/);\n      const symbols = graph.listSymbols(targetFile) as Array<{ name: string; kind: string; startLine: number; endLine: number }> | [];\n\n      if (input.symbol) {\n        const sym = symbols.find(s => s.name === input.symbol);\n        if (sym) {\n          summary = `Targeted refactor plan for ${input.symbol}`;\n          const preview = slicePreview(lines, sym.startLine, sym.endLine);\n          steps.push(`Review ${input.symbol} (${sym.kind}) lines ${sym.startLine}-${sym.endLine}`);\n          steps.push(`Update dependent tests and call sites for ${input.symbol}`);\n          if (input.goal) steps.push(`Apply requested goal: ${input.goal}`);\n          risks.push('Run existing tests to catch regressions');\n          risks.push('Update documentation if the public API changes');\n          if (preview.length) {\n            steps.push(`Current snippet:\\n${preview.join('\\n')}`);\n          }\n        } else {\n          summary = `${input.symbol} symbol not found in GraphStore`;\n          steps.push(`Inspect ${targetFile} and verify symbol naming`);\n        }\n      } else {\n        summary = `High level refactor plan for ${targetFile}`;\n        const topSymbols = symbols.slice(0, 5).map(s => `${s.name} (${s.kind})`);\n        if (topSymbols.length) steps.push(`Review structure: ${topSymbols.join(', ')}`);\n        if (input.goal) steps.push(`Focus goal: ${input.goal}`);\n        steps.push('Simplify dependencies and deduplicate logic');\n      }\n\n      imports = graph.listImports(targetFile);\n      dependents = graph.listDependents(targetFile);\n\n      if (!imports.length && !dependents.length) {\n        risks.push('File is isolated in the dependency graph; check downstream impact manually');\n      } else {\n        if (imports.length) risks.push(`${imports.length} imports must remain coherent`);\n        if (dependents.length) risks.push(`${dependents.length} files depend on this module; plan regression tests`);\n      }\n    } catch (err: any) {\n      summary = `Failed to produce refactor plan for ${targetFile} (${err?.message ?? 'unknown error'})`;\n      steps.push('Verify that the file is indexed (run build and index tasks)');\n    }\n  } else {\n    steps.push('No target file or symbol supplied; outline global refactor goals');\n    steps.push('Use GraphStore metadata to pick high-impact modules');\n  }\n\n  if (!steps.length) steps.push('Additional context required to craft actionable steps');\n  if (!risks.length) risks.push('Follow standard code review and regression testing workflow');\n\n  return {\n    intent: input.goal ?? (input.symbol ? 'targeted-refactor' : 'structural-refactor'),\n    summary,\n    steps,\n    risks,\n    impact: {\n      imports,\n      dependents,\n    },\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:generate_patch",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "generate_patch",
    "startLine": 203,
    "endLine": 217,
    "text": "export function generate_patch(repoRoot: string, filePath: string, operations: PatchOperation[]): GeneratedPatch {\n  const abs = path.resolve(repoRoot, filePath);\n  const content = fs.readFileSync(abs, 'utf8');\n  const { updated } = applyOperations(content, operations);\n  const originalPreview = slicePreview(content.split(/\\r?\\n/), 1, MAX_PREVIEW_LINES);\n  const updatedPreview = slicePreview(updated.split(/\\r?\\n/), 1, MAX_PREVIEW_LINES);\n  return {\n    path: safeRelative(repoRoot, abs),\n    operations,\n    preview: {\n      before: originalPreview,\n      after: updatedPreview,\n    },\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:apply_patch",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "apply_patch",
    "startLine": 219,
    "endLine": 229,
    "text": "export function apply_patch(repoRoot: string, filePath: string, operations: PatchOperation[]): PatchResult {\n  const abs = path.resolve(repoRoot, filePath);\n  const content = fs.readFileSync(abs, 'utf8');\n  const { updated, applied } = applyOperations(content, operations);\n  fs.writeFileSync(abs, updated, 'utf8');\n  return {\n    path: safeRelative(repoRoot, abs),\n    applied,\n    total: operations.length,\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:analyze_performance",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "analyze_performance",
    "startLine": 231,
    "endLine": 257,
    "text": "export function analyze_performance(repoRoot: string, filePath: string): PerformanceInsight {\n  const abs = path.resolve(repoRoot, filePath);\n  const content = fs.readFileSync(abs, 'utf8');\n  const issues: string[] = [];\n  const suggestions: string[] = [];\n\n  if (/for\\s*\\([^)]*\\)[\\s\\S]*for\\s*\\(/.test(content) || /for\\s*\\([^)]*\\)[\\s\\S]*while\\s*\\(/.test(content)) {\n    issues.push('Nested loops detected');\n    suggestions.push('Flatten or refactor nested loops to reduce complexity');\n  }\n  if (/JSON\\.stringify\\(.{400,}\\)/.test(content)) {\n    issues.push('Large JSON.stringify usage may impact performance');\n    suggestions.push('Stream or chunk large JSON payloads');\n  }\n  if (/fs\\.(readFileSync|writeFileSync|readdirSync)/.test(content)) {\n    issues.push('Synchronous fs calls detected');\n    suggestions.push('Prefer async fs APIs to avoid blocking the event loop');\n  }\n  if (/await\\s+.*\\.map\\(/.test(content) && !/await\\s+Promise\\.all\\([^)]*map\\(/.test(content)) {\n    issues.push('Await inside Array.map without Promise.all');\n    suggestions.push('Wrap async map calls with Promise.all for parallel execution');\n  }\n  if (!issues.length) {\n    suggestions.push('No obvious performance smells detected; capture runtime metrics to confirm');\n  }\n  return { file: safeRelative(repoRoot, abs), issues, suggestions };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:diffLines",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "diffLines",
    "startLine": 259,
    "endLine": 276,
    "text": "function diffLines(a: string[], b: string[]) {\n  const removed: string[] = [];\n  const added: string[] = [];\n  const changed: string[] = [];\n  const len = Math.max(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    const left = a[i];\n    const right = b[i];\n    if (left === undefined) {\n      added.push(`${i + 1}: ${right}`);\n    } else if (right === undefined) {\n      removed.push(`${i + 1}: ${left}`);\n    } else if (left !== right) {\n      changed.push(`${i + 1}: ${left} -> ${right}`);\n    }\n  }\n  return { added, removed, changed };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:compare_versions",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "compare_versions",
    "startLine": 278,
    "endLine": 291,
    "text": "export function compare_versions(repoRoot: string, fileA: string, fileB: string): VersionComparison {\n  const absA = path.resolve(repoRoot, fileA);\n  const absB = path.resolve(repoRoot, fileB);\n  const contentA = fs.readFileSync(absA, 'utf8').split(/\\r?\\n/);\n  const contentB = fs.readFileSync(absB, 'utf8').split(/\\r?\\n/);\n  const diff = diffLines(contentA, contentB);\n  return {\n    fileA: safeRelative(repoRoot, absA),\n    fileB: safeRelative(repoRoot, absB),\n    added: diff.added,\n    removed: diff.removed,\n    changed: diff.changed,\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:auto_docs",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "auto_docs",
    "startLine": 293,
    "endLine": 314,
    "text": "export function auto_docs(orchestrator: Orchestrator, graph: GraphStore, repoRoot: string, filePath: string): AutoDoc {\n  const abs = path.resolve(repoRoot, filePath);\n  const rel = safeRelative(repoRoot, abs);\n  const content = orchestrator.getFile(rel);\n  const lines = content.split(/\\r?\\n/);\n  const symbols = graph.listSymbols(rel) as Array<{ name: string; kind: string; startLine: number; endLine: number }>;\n  const exports = symbols.map(s => ({\n    name: s.name,\n    kind: s.kind,\n    range: `${s.startLine}-${s.endLine}`,\n  }));\n  const summary = `${rel} contains ${symbols.length} symbols across ${lines.length} lines.`;\n  return {\n    file: rel,\n    summary,\n    exports,\n    deps: {\n      imports: graph.listImports(rel),\n      dependents: graph.listDependents(rel),\n    },\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:run_tests",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "run_tests",
    "startLine": 316,
    "endLine": 329,
    "text": "export function run_tests(repoRoot: string, testCommand = 'npm test'): TestRunResult {\n  const [cmd, ...args] = testCommand.split(/\\s+/).filter(Boolean);\n  const binary = process.platform === 'win32' && cmd === 'npm' ? 'npm.cmd' : cmd;\n  const result = spawnSync(binary, args, {\n    cwd: repoRoot,\n    encoding: 'utf8',\n  });\n  return {\n    command: testCommand,\n    status: result.status,\n    stdout: result.stdout ?? '',\n    stderr: result.stderr ?? '',\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:run_task",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "run_task",
    "startLine": 331,
    "endLine": 377,
    "text": "export function run_task(repoRoot: string, scriptName: string): TestRunResult {\n  const pkgPath = path.join(repoRoot, 'package.json');\n  if (!fs.existsSync(pkgPath)) {\n    throw new Error(`package.json not found under ${repoRoot}`);\n  }\n  const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));\n  const scripts = pkg.scripts || {};\n  if (!scripts[scriptName]) {\n    throw new Error(`Script \"${scriptName}\" is not defined in package.json`);\n  }\n  const scriptCommand = String(scripts[scriptName]);\n  const bin = process.platform === 'win32' ? 'npm.cmd' : 'npm';\n  const result = spawnSync(bin, ['run', scriptName], {\n    cwd: repoRoot,\n    encoding: 'utf8',\n  });\n  const status =\n    typeof result.status === 'number'\n      ? result.status\n      : result.error\n      ? -1\n      : 0;\n  let finalStatus = status;\n  let stdout = result.stdout ?? '';\n  let stderr = result.stderr ?? '';\n  if (finalStatus !== 0) {\n    const fallback = spawnSync(scriptCommand, {\n      cwd: repoRoot,\n      encoding: 'utf8',\n      shell: true,\n    });\n    finalStatus =\n      typeof fallback.status === 'number'\n        ? fallback.status\n        : fallback.error\n        ? -1\n        : 0;\n    stdout += fallback.stdout ?? '';\n    stderr += fallback.stderr ?? '';\n  }\n  return {\n    command: `npm run ${scriptName}`,\n    status: finalStatus,\n    stdout,\n    stderr,\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:summarize_architecture",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "summarize_architecture",
    "startLine": 379,
    "endLine": 384,
    "text": "export function summarize_architecture(graph: GraphStore) {\n  const files = graph['db'].prepare('SELECT COUNT(*) AS c FROM files').get() as any;\n  const symbols = graph['db'].prepare('SELECT COUNT(*) AS c FROM symbols').get() as any;\n  const edges = graph['db'].prepare('SELECT COUNT(*) AS c FROM edges').get() as any;\n  return { files: files?.c || 0, symbols: symbols?.c || 0, edges: edges?.c || 0 };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:detect_smells",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "detect_smells",
    "startLine": 386,
    "endLine": 405,
    "text": "export function detect_smells(repoRoot: string) {\n  const smells: Array<{ file: string; issue: string }> = [];\n  const walk = (dir: string) => {\n    for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {\n      const full = path.join(dir, entry.name);\n      if (entry.isDirectory()) {\n        if (entry.name === 'node_modules' || entry.name === 'dist' || entry.name.startsWith('.')) continue;\n        walk(full);\n      } else if (entry.isFile() && (entry.name.endsWith('.ts') || entry.name.endsWith('.tsx'))) {\n        const content = fs.readFileSync(full, 'utf8');\n        if (/TODO|FIXME/.test(content)) smells.push({ file: safeRelative(repoRoot, full), issue: 'TODO/FIXME marker present' });\n        if (content.split(/\\r?\\n/).some(line => line.length > 200)) {\n          smells.push({ file: safeRelative(repoRoot, full), issue: 'Line longer than 200 chars' });\n        }\n      }\n    }\n  };\n  walk(repoRoot);\n  return smells;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:suggest_tests",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "suggest_tests",
    "startLine": 407,
    "endLine": 409,
    "text": "export function suggest_tests(symbols: Array<{ file: string; name: string }>) {\n  return symbols.map(s => ({ symbol: s.name, suggestion: `Add unit test for ${s.name} in ${s.file}` }));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:langchain_query",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "langchain_query",
    "startLine": 411,
    "endLine": 414,
    "text": "export async function langchain_query(dataDir: string, query: string, topK = 5): Promise<LangChainQueryResult> {\n  const bridge = new LangChainBridge(dataDir);\n  return bridge.query(query, topK);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:generate_telemetry_panel",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "generate_telemetry_panel",
    "startLine": 416,
    "endLine": 473,
    "text": "export function generate_telemetry_panel(repoRoot: string, outputPath?: string): TelemetryPanelResult {\n  const logsDir = path.join(repoRoot, 'logs');\n  const snapshotPath = path.join(logsDir, 'telemetry_latest.json');\n  let entries: Array<{ name: string; source: string; count: number; total: number; avg: number; max: number; min: number }> = [];\n  if (fs.existsSync(snapshotPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(snapshotPath, 'utf8'));\n    } catch {\n      entries = [];\n    }\n  }\n  const outFile = outputPath ? path.resolve(repoRoot, outputPath) : path.join(logsDir, 'telemetry_panel.html');\n  fs.mkdirSync(path.dirname(outFile), { recursive: true });\n  const rows = entries\n    .map(\n      entry =>\n        `<tr><td>${entry.name}</td><td>${entry.source}</td><td>${entry.count}</td><td>${entry.total}</td><td>${entry.avg.toFixed(\n          2\n        )}</td><td>${entry.max}</td><td>${entry.min}</td></tr>`\n    )\n    .join('');\n  const html = `<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\" />\n  <title>MCP Telemetry Panel</title>\n  <style>\n    body { font-family: Arial, sans-serif; margin: 2rem; background: #111; color: #eee; }\n    table { border-collapse: collapse; width: 100%; }\n    th, td { border: 1px solid #444; padding: 0.5rem; text-align: left; }\n    th { background: #222; }\n    tbody tr:nth-child(even) { background: #1a1a1a; }\n  </style>\n</head>\n<body>\n  <h1>Telemetry Metrics</h1>\n  <p>Generated at ${new Date().toISOString()}</p>\n  <table>\n    <thead>\n      <tr>\n        <th>Name</th>\n        <th>Source</th>\n        <th>Count</th>\n        <th>Total (ms)</th>\n        <th>Avg (ms)</th>\n        <th>Max (ms)</th>\n        <th>Min (ms)</th>\n      </tr>\n    </thead>\n    <tbody>\n      ${rows || '<tr><td colspan=\"7\">No telemetry entries recorded.</td></tr>'}\n    </tbody>\n  </table>\n</body>\n</html>`;\n  fs.writeFileSync(outFile, html, 'utf8');\n  return { output: safeRelative(repoRoot, outFile), entries: entries.length };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:open_telemetry_webview",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "open_telemetry_webview",
    "startLine": 475,
    "endLine": 489,
    "text": "export function open_telemetry_webview(repoRoot: string, options: { regenerate?: boolean; output?: string } = {}): TelemetryWebview {\n  const shouldRegenerate = options.regenerate ?? false;\n  const preferredPath = options.output\n    ? path.resolve(repoRoot, options.output)\n    : path.join(repoRoot, 'logs', 'telemetry_panel.html');\n\n  let htmlPath = preferredPath;\n  if (shouldRegenerate || !fs.existsSync(preferredPath)) {\n    const generated = generate_telemetry_panel(repoRoot, options.output);\n    htmlPath = path.resolve(repoRoot, generated.output);\n  }\n\n  const html = fs.readFileSync(htmlPath, 'utf8');\n  return { path: safeRelative(repoRoot, htmlPath), html };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts:select_context",
    "file": "node_modules/@mcp/server/src/tools.ts",
    "symbol": "select_context",
    "startLine": 491,
    "endLine": 504,
    "text": "export function select_context(results: SearchResult[], budgetTokens: number) {\n  if (!results.length) return results;\n  if (budgetTokens <= 0) return results;\n  const approxTokens = (snippet: string) => Math.ceil(snippet.length / 4);\n  const selected: SearchResult[] = [];\n  let used = 0;\n  for (const res of results) {\n    const cost = approxTokens(res.snippet);\n    if (used + cost > budgetTokens) continue;\n    selected.push(res);\n    used += cost;\n  }\n  return selected.length ? selected : results.slice(0, Math.max(1, Math.min(results.length, 3)));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/watcher.ts:startWatcher",
    "file": "node_modules/@mcp/server/src/watcher.ts",
    "symbol": "startWatcher",
    "startLine": 6,
    "endLine": 23,
    "text": "export function startWatcher(rootDir: string, outDir: string, sqlitePath: string) {\n  const watcher = chokidar.watch([path.join(rootDir, '**/*.ts'), path.join(rootDir, '**/*.tsx')], {\n    ignored: [/node_modules/, /dist/, /(^|[/\\\\])\\../],\n    ignoreInitial: true,\n  });\n  const redisUrl = process.env.REDIS_URL;\n  const queue = redisUrl ? createQueue('mcp-jobs', redisUrl) : undefined;\n  const schedule = debounce(async () => {\n    if (queue) {\n      await enqueueReindex(queue, { rootDir, outDir, sqlite: sqlitePath });\n    } else {\n      await runIndexer(rootDir, outDir, sqlitePath);\n    }\n    console.log('Incremental index scheduled');\n  }, 500);\n  watcher.on('add', schedule).on('change', schedule).on('unlink', schedule);\n  return watcher;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/watcher.ts:debounce",
    "file": "node_modules/@mcp/server/src/watcher.ts",
    "symbol": "debounce",
    "startLine": 25,
    "endLine": 31,
    "text": "function debounce(fn: () => void | Promise<void>, ms: number) {\n  let t: any;\n  return () => {\n    clearTimeout(t);\n    t = setTimeout(fn, ms);\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/weights.ts:clamp01",
    "file": "node_modules/@mcp/server/src/weights.ts",
    "symbol": "clamp01",
    "startLine": 7,
    "endLine": 7,
    "text": "function clamp01(x: number) { return Math.max(0, Math.min(1, x)); }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/weights.ts:WeightManager",
    "file": "node_modules/@mcp/server/src/weights.ts",
    "symbol": "WeightManager",
    "startLine": 9,
    "endLine": 34,
    "text": "export class WeightManager {\n  private file: string;\n  private w: Weights;\n  constructor(file = path.join(process.cwd(), 'weights.json')) {\n    this.file = file;\n    this.w = this.load();\n  }\n  private load(): Weights {\n    try {\n      const data = JSON.parse(fs.readFileSync(this.file, 'utf8'));\n      return { semantic: data.semantic, lexical: data.lexical, graph: data.graph } as Weights;\n    } catch { return { ...defaultWeights }; }\n  }\n  private save() { fs.writeFileSync(this.file, JSON.stringify(this.w, null, 2), 'utf8'); }\n  get(): Weights { return { ...this.w }; }\n  feedback(kind: 'up' | 'down') {\n    const delta = kind === 'up' ? 0.01 : -0.01;\n    // simple strategy: increase semantic on up, lexical on down toggles towards balance\n    this.w.semantic = clamp01(this.w.semantic + delta);\n    this.w.lexical = clamp01(this.w.lexical + (kind === 'up' ? -delta/2 : +delta/2));\n    // normalize\n    const s = this.w.semantic + this.w.lexical + this.w.graph;\n    this.w.semantic /= s; this.w.lexical /= s; this.w.graph /= s;\n    this.save();\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/weights.ts:WeightManager.load",
    "file": "node_modules/@mcp/server/src/weights.ts",
    "symbol": "WeightManager.load",
    "startLine": 16,
    "endLine": 21,
    "text": "  private load(): Weights {\n    try {\n      const data = JSON.parse(fs.readFileSync(this.file, 'utf8'));\n      return { semantic: data.semantic, lexical: data.lexical, graph: data.graph } as Weights;\n    } catch { return { ...defaultWeights }; }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/weights.ts:WeightManager.save",
    "file": "node_modules/@mcp/server/src/weights.ts",
    "symbol": "WeightManager.save",
    "startLine": 22,
    "endLine": 22,
    "text": "  private save() { fs.writeFileSync(this.file, JSON.stringify(this.w, null, 2), 'utf8'); }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/weights.ts:WeightManager.get",
    "file": "node_modules/@mcp/server/src/weights.ts",
    "symbol": "WeightManager.get",
    "startLine": 23,
    "endLine": 23,
    "text": "  get(): Weights { return { ...this.w }; }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/weights.ts:WeightManager.feedback",
    "file": "node_modules/@mcp/server/src/weights.ts",
    "symbol": "WeightManager.feedback",
    "startLine": 24,
    "endLine": 33,
    "text": "  feedback(kind: 'up' | 'down') {\n    const delta = kind === 'up' ? 0.01 : -0.01;\n    // simple strategy: increase semantic on up, lexical on down toggles towards balance\n    this.w.semantic = clamp01(this.w.semantic + delta);\n    this.w.lexical = clamp01(this.w.lexical + (kind === 'up' ? -delta/2 : +delta/2));\n    // normalize\n    const s = this.w.semantic + this.w.lexical + this.w.graph;\n    this.w.semantic /= s; this.w.lexical /= s; this.w.graph /= s;\n    this.save();\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/export.ts:ExportClass",
    "file": "node_modules/madge/test/typescript/export.ts",
    "symbol": "ExportClass",
    "startLine": 1,
    "endLine": 5,
    "text": "class ExportClass {\n\tstringLength(s: string) {\n\t\treturn s.length;\n\t}\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/export.ts:ExportClass.stringLength",
    "file": "node_modules/madge/test/typescript/export.ts",
    "symbol": "ExportClass.stringLength",
    "startLine": 2,
    "endLine": 4,
    "text": "\tstringLength(s: string) {\n\t\treturn s.length;\n\t}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/import.ts:ImportClass",
    "file": "node_modules/madge/test/typescript/import.ts",
    "symbol": "ImportClass",
    "startLine": 4,
    "endLine": 9,
    "text": "class ImportClass {\n\tconstructor(public greeting: string) { }\n\tgreet() {\n\t\treturn \"<h1>\" + this.greeting + \"</h1>\";\n\t}\n};"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/import.ts:ImportClass.greet",
    "file": "node_modules/madge/test/typescript/import.ts",
    "symbol": "ImportClass.greet",
    "startLine": 6,
    "endLine": 8,
    "text": "\tgreet() {\n\t\treturn \"<h1>\" + this.greeting + \"</h1>\";\n\t}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/require.ts:RequireClass",
    "file": "node_modules/madge/test/typescript/require.ts",
    "symbol": "RequireClass",
    "startLine": 3,
    "endLine": 7,
    "text": "export default class RequireClass  {\n\tstringLength(s: string) {\n\t\treturn s.length;\n\t}\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/require.ts:RequireClass.stringLength",
    "file": "node_modules/madge/test/typescript/require.ts",
    "symbol": "RequireClass.stringLength",
    "startLine": 4,
    "endLine": 6,
    "text": "\tstringLength(s: string) {\n\t\treturn s.length;\n\t}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/array_queue.ts:ArrayTaskQueue",
    "file": "node_modules/piscina/src/task_queue/array_queue.ts",
    "symbol": "ArrayTaskQueue",
    "startLine": 5,
    "endLine": 25,
    "text": "export class ArrayTaskQueue implements TaskQueue {\n  tasks: Task[] = []\n\n  get size () {\n    return this.tasks.length;\n  }\n\n  shift (): Task | null {\n    return this.tasks.shift() ?? null;\n  }\n\n  push (task: Task): void {\n    this.tasks.push(task);\n  }\n\n  remove (task: Task): void {\n    const index = this.tasks.indexOf(task);\n    assert.notStrictEqual(index, -1);\n    this.tasks.splice(index, 1);\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/array_queue.ts:ArrayTaskQueue.shift",
    "file": "node_modules/piscina/src/task_queue/array_queue.ts",
    "symbol": "ArrayTaskQueue.shift",
    "startLine": 12,
    "endLine": 14,
    "text": "  shift (): Task | null {\n    return this.tasks.shift() ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/array_queue.ts:ArrayTaskQueue.push",
    "file": "node_modules/piscina/src/task_queue/array_queue.ts",
    "symbol": "ArrayTaskQueue.push",
    "startLine": 16,
    "endLine": 18,
    "text": "  push (task: Task): void {\n    this.tasks.push(task);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/array_queue.ts:ArrayTaskQueue.remove",
    "file": "node_modules/piscina/src/task_queue/array_queue.ts",
    "symbol": "ArrayTaskQueue.remove",
    "startLine": 20,
    "endLine": 24,
    "text": "  remove (task: Task): void {\n    const index = this.tasks.indexOf(task);\n    assert.notStrictEqual(index, -1);\n    this.tasks.splice(index, 1);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts:FixedCircularBuffer",
    "file": "node_modules/piscina/src/task_queue/fixed_queue.ts",
    "symbol": "FixedCircularBuffer",
    "startLine": 61,
    "endLine": 114,
    "text": "class FixedCircularBuffer {\n  bottom: number\n  top: number\n  list: Array<Task | undefined>\n  next: FixedCircularBuffer | null\n\n  constructor () {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty () {\n    return this.top === this.bottom;\n  }\n\n  isFull () {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push (data:Task) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift () {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined) { return null; }\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n\n  remove (task: Task) {\n    const indexToRemove = this.list.indexOf(task);\n\n    assert.notStrictEqual(indexToRemove, -1);\n    let curr = indexToRemove;\n    while (true) {\n      const next = (curr + 1) & kMask;\n      this.list[curr] = this.list[next];\n      if (this.list[curr] === undefined) {\n        break;\n      }\n      if (next === indexToRemove) {\n        this.list[curr] = undefined;\n        break;\n      }\n      curr = next;\n    }\n    this.top = (this.top - 1) & kMask;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts:FixedCircularBuffer.isEmpty",
    "file": "node_modules/piscina/src/task_queue/fixed_queue.ts",
    "symbol": "FixedCircularBuffer.isEmpty",
    "startLine": 74,
    "endLine": 76,
    "text": "  isEmpty () {\n    return this.top === this.bottom;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts:FixedCircularBuffer.isFull",
    "file": "node_modules/piscina/src/task_queue/fixed_queue.ts",
    "symbol": "FixedCircularBuffer.isFull",
    "startLine": 78,
    "endLine": 80,
    "text": "  isFull () {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts:FixedCircularBuffer.push",
    "file": "node_modules/piscina/src/task_queue/fixed_queue.ts",
    "symbol": "FixedCircularBuffer.push",
    "startLine": 82,
    "endLine": 85,
    "text": "  push (data:Task) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts:FixedCircularBuffer.shift",
    "file": "node_modules/piscina/src/task_queue/fixed_queue.ts",
    "symbol": "FixedCircularBuffer.shift",
    "startLine": 87,
    "endLine": 93,
    "text": "  shift () {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined) { return null; }\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts:FixedCircularBuffer.remove",
    "file": "node_modules/piscina/src/task_queue/fixed_queue.ts",
    "symbol": "FixedCircularBuffer.remove",
    "startLine": 95,
    "endLine": 113,
    "text": "  remove (task: Task) {\n    const indexToRemove = this.list.indexOf(task);\n\n    assert.notStrictEqual(indexToRemove, -1);\n    let curr = indexToRemove;\n    while (true) {\n      const next = (curr + 1) & kMask;\n      this.list[curr] = this.list[next];\n      if (this.list[curr] === undefined) {\n        break;\n      }\n      if (next === indexToRemove) {\n        this.list[curr] = undefined;\n        break;\n      }\n      curr = next;\n    }\n    this.top = (this.top - 1) & kMask;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts:FixedQueue",
    "file": "node_modules/piscina/src/task_queue/fixed_queue.ts",
    "symbol": "FixedQueue",
    "startLine": 116,
    "endLine": 184,
    "text": "export class FixedQueue implements TaskQueue {\n  head: FixedCircularBuffer\n  tail: FixedCircularBuffer\n  _size: number = 0\n\n  constructor () {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty () {\n    return this.head.isEmpty();\n  }\n\n  push (data:Task) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n    this._size++;\n  }\n\n  shift (): Task | null {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (next !== null) this._size--;\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n      tail.next = null;\n    }\n    return next;\n  }\n\n  remove (task: Task) {\n    let prev: FixedCircularBuffer | null = null;\n    let buffer = this.tail;\n    while (true) {\n      if (buffer.list.includes(task)) {\n        buffer.remove(task);\n        this._size--;\n        break;\n      }\n      if (buffer.next === null) break;\n      prev = buffer;\n      buffer = buffer.next;\n    }\n    if (buffer.isEmpty()) {\n      // removing tail\n      if (prev === null) {\n        // if tail is not the last buffer\n        if (buffer.next !== null) this.tail = buffer.next;\n      } else {\n        // removing head\n        if (buffer.next === null) {\n          this.head = prev;\n        } else {\n          // removing buffer from middle\n          prev.next = buffer.next;\n        }\n      }\n    }\n  }\n\n  get size () {\n    return this._size;\n  }\n};"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts:FixedQueue.isEmpty",
    "file": "node_modules/piscina/src/task_queue/fixed_queue.ts",
    "symbol": "FixedQueue.isEmpty",
    "startLine": 125,
    "endLine": 127,
    "text": "  isEmpty () {\n    return this.head.isEmpty();\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts:FixedQueue.push",
    "file": "node_modules/piscina/src/task_queue/fixed_queue.ts",
    "symbol": "FixedQueue.push",
    "startLine": 129,
    "endLine": 137,
    "text": "  push (data:Task) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n    this._size++;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts:FixedQueue.shift",
    "file": "node_modules/piscina/src/task_queue/fixed_queue.ts",
    "symbol": "FixedQueue.shift",
    "startLine": 139,
    "endLine": 149,
    "text": "  shift (): Task | null {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (next !== null) this._size--;\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n      tail.next = null;\n    }\n    return next;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts:FixedQueue.remove",
    "file": "node_modules/piscina/src/task_queue/fixed_queue.ts",
    "symbol": "FixedQueue.remove",
    "startLine": 151,
    "endLine": 179,
    "text": "  remove (task: Task) {\n    let prev: FixedCircularBuffer | null = null;\n    let buffer = this.tail;\n    while (true) {\n      if (buffer.list.includes(task)) {\n        buffer.remove(task);\n        this._size--;\n        break;\n      }\n      if (buffer.next === null) break;\n      prev = buffer;\n      buffer = buffer.next;\n    }\n    if (buffer.isEmpty()) {\n      // removing tail\n      if (prev === null) {\n        // if tail is not the last buffer\n        if (buffer.next !== null) this.tail = buffer.next;\n      } else {\n        // removing head\n        if (buffer.next === null) {\n          this.head = prev;\n        } else {\n          // removing buffer from middle\n          prev.next = buffer.next;\n        }\n      }\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/index.ts:isTaskQueue",
    "file": "node_modules/piscina/src/task_queue/index.ts",
    "symbol": "isTaskQueue",
    "startLine": 33,
    "endLine": 42,
    "text": "export function isTaskQueue (value: TaskQueue): boolean {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'size' in value &&\n    typeof value.shift === 'function' &&\n    typeof value.remove === 'function' &&\n    typeof value.push === 'function'\n  );\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/index.ts:TaskInfo",
    "file": "node_modules/piscina/src/task_queue/index.ts",
    "symbol": "TaskInfo",
    "startLine": 47,
    "endLine": 131,
    "text": "export class TaskInfo extends AsyncResource implements Task {\n    callback : TaskCallback;\n    task : any;\n    transferList : TransferList;\n    filename : string;\n    name : string;\n    taskId : number;\n    abortSignal : AbortSignalAny | null;\n    abortListener : (() => void) | null = null;\n    workerInfo : WorkerInfo | null = null;\n    created : number;\n    started : number;\n\n    constructor (\n      task : any,\n      transferList : TransferList,\n      filename : string,\n      name : string,\n      callback : TaskCallback,\n      abortSignal : AbortSignalAny | null,\n      triggerAsyncId : number) {\n      super('Piscina.Task', { requireManualDestroy: true, triggerAsyncId });\n      this.callback = callback;\n      this.task = task;\n      this.transferList = transferList;\n\n      // If the task is a Transferable returned by\n      // Piscina.move(), then add it to the transferList\n      // automatically\n      if (isMovable(task)) {\n        // This condition should never be hit but typescript\n        // complains if we dont do the check.\n        /* istanbul ignore if */\n        if (this.transferList == null) {\n          this.transferList = [];\n        }\n        this.transferList =\n          this.transferList.concat(task[kTransferable]);\n        this.task = task[kValue];\n      }\n\n      this.filename = filename;\n      this.name = name;\n      this.taskId = taskIdCounter++;\n      this.abortSignal = abortSignal;\n      this.created = performance.now();\n      this.started = 0;\n    }\n\n    releaseTask () : any {\n      const ret = this.task;\n      this.task = null;\n      return ret;\n    }\n\n    done (err : Error | null, result? : any) : void {\n      this.runInAsyncScope(this.callback, null, err, result);\n      this.emitDestroy(); // `TaskInfo`s are used only once.\n      // If an abort signal was used, remove the listener from it when\n      // done to make sure we do not accidentally leak.\n      if (this.abortSignal && this.abortListener) {\n        if ('removeEventListener' in this.abortSignal && this.abortListener) {\n          this.abortSignal.removeEventListener('abort', this.abortListener);\n        } else {\n          (this.abortSignal as AbortSignalEventEmitter).off(\n            'abort', this.abortListener);\n        }\n      }\n    }\n\n    get [kQueueOptions] () : object | null {\n      return kQueueOptions in this.task ? this.task[kQueueOptions] : null;\n    }\n\n    get interface (): PiscinaTask {\n      return {\n        taskId: this.taskId,\n        filename: this.filename,\n        name: this.name,\n        created: this.created,\n        isAbortable: this.abortSignal !== null,\n        [kQueueOptions]: this[kQueueOptions]\n      };\n    }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/index.ts:TaskInfo.releaseTask",
    "file": "node_modules/piscina/src/task_queue/index.ts",
    "symbol": "TaskInfo.releaseTask",
    "startLine": 96,
    "endLine": 100,
    "text": "    releaseTask () : any {\n      const ret = this.task;\n      this.task = null;\n      return ret;\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/index.ts:TaskInfo.done",
    "file": "node_modules/piscina/src/task_queue/index.ts",
    "symbol": "TaskInfo.done",
    "startLine": 102,
    "endLine": 115,
    "text": "    done (err : Error | null, result? : any) : void {\n      this.runInAsyncScope(this.callback, null, err, result);\n      this.emitDestroy(); // `TaskInfo`s are used only once.\n      // If an abort signal was used, remove the listener from it when\n      // done to make sure we do not accidentally leak.\n      if (this.abortSignal && this.abortListener) {\n        if ('removeEventListener' in this.abortSignal && this.abortListener) {\n          this.abortSignal.removeEventListener('abort', this.abortListener);\n        } else {\n          (this.abortSignal as AbortSignalEventEmitter).off(\n            'abort', this.abortListener);\n        }\n      }\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:AsynchronouslyCreatedResource",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "AsynchronouslyCreatedResource",
    "startLine": 12,
    "endLine": 37,
    "text": "abstract class AsynchronouslyCreatedResource {\n    onreadyListeners : (() => void)[] | null = [];\n\n    markAsReady () : void {\n      const listeners = this.onreadyListeners;\n      assert(listeners !== null);\n      this.onreadyListeners = null;\n      for (const listener of listeners) {\n        listener();\n      }\n    }\n\n    isReady () : boolean {\n      return this.onreadyListeners === null;\n    }\n\n    onReady (fn : () => void) {\n      if (this.onreadyListeners === null) {\n        fn(); // Zalgo is okay here.\n        return;\n      }\n      this.onreadyListeners.push(fn);\n    }\n\n    abstract currentUsage() : number;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:AsynchronouslyCreatedResource.markAsReady",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "AsynchronouslyCreatedResource.markAsReady",
    "startLine": 15,
    "endLine": 22,
    "text": "    markAsReady () : void {\n      const listeners = this.onreadyListeners;\n      assert(listeners !== null);\n      this.onreadyListeners = null;\n      for (const listener of listeners) {\n        listener();\n      }\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:AsynchronouslyCreatedResource.isReady",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "AsynchronouslyCreatedResource.isReady",
    "startLine": 24,
    "endLine": 26,
    "text": "    isReady () : boolean {\n      return this.onreadyListeners === null;\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:AsynchronouslyCreatedResource.onReady",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "AsynchronouslyCreatedResource.onReady",
    "startLine": 28,
    "endLine": 34,
    "text": "    onReady (fn : () => void) {\n      if (this.onreadyListeners === null) {\n        fn(); // Zalgo is okay here.\n        return;\n      }\n      this.onreadyListeners.push(fn);\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:AsynchronouslyCreatedResource.currentUsage",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "AsynchronouslyCreatedResource.currentUsage",
    "startLine": 36,
    "endLine": 36,
    "text": "    abstract currentUsage() : number;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:AsynchronouslyCreatedResourcePool",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "AsynchronouslyCreatedResourcePool",
    "startLine": 39,
    "endLine": 103,
    "text": "export class AsynchronouslyCreatedResourcePool<\n  T extends AsynchronouslyCreatedResource> {\n  pendingItems = new Set<T>();\n  readyItems = new Set<T>();\n  maximumUsage : number;\n  onAvailableListeners : ((item : T) => void)[];\n\n  constructor (maximumUsage : number) {\n    this.maximumUsage = maximumUsage;\n    this.onAvailableListeners = [];\n  }\n\n  add (item : T) {\n    this.pendingItems.add(item);\n    item.onReady(() => {\n      /* istanbul ignore else */\n      if (this.pendingItems.has(item)) {\n        this.pendingItems.delete(item);\n        this.readyItems.add(item);\n        this.maybeAvailable(item);\n      }\n    });\n  }\n\n  delete (item : T) {\n    this.pendingItems.delete(item);\n    this.readyItems.delete(item);\n  }\n\n  findAvailable () : T | null {\n    let minUsage = this.maximumUsage;\n    let candidate = null;\n    for (const item of this.readyItems) {\n      const usage = item.currentUsage();\n      if (usage === 0) return item;\n      if (usage < minUsage) {\n        candidate = item;\n        minUsage = usage;\n      }\n    }\n    return candidate;\n  }\n\n  * [Symbol.iterator] () {\n    yield * this.pendingItems;\n    yield * this.readyItems;\n  }\n\n  get size () {\n    return this.pendingItems.size + this.readyItems.size;\n  }\n\n  maybeAvailable (item : T) {\n    /* istanbul ignore else */\n    if (item.currentUsage() < this.maximumUsage) {\n      for (const listener of this.onAvailableListeners) {\n        listener(item);\n      }\n    }\n  }\n\n  onAvailable (fn : (item : T) => void) {\n    this.onAvailableListeners.push(fn);\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:AsynchronouslyCreatedResourcePool.add",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "AsynchronouslyCreatedResourcePool.add",
    "startLine": 51,
    "endLine": 61,
    "text": "  add (item : T) {\n    this.pendingItems.add(item);\n    item.onReady(() => {\n      /* istanbul ignore else */\n      if (this.pendingItems.has(item)) {\n        this.pendingItems.delete(item);\n        this.readyItems.add(item);\n        this.maybeAvailable(item);\n      }\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:AsynchronouslyCreatedResourcePool.delete",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "AsynchronouslyCreatedResourcePool.delete",
    "startLine": 63,
    "endLine": 66,
    "text": "  delete (item : T) {\n    this.pendingItems.delete(item);\n    this.readyItems.delete(item);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:AsynchronouslyCreatedResourcePool.findAvailable",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "AsynchronouslyCreatedResourcePool.findAvailable",
    "startLine": 68,
    "endLine": 80,
    "text": "  findAvailable () : T | null {\n    let minUsage = this.maximumUsage;\n    let candidate = null;\n    for (const item of this.readyItems) {\n      const usage = item.currentUsage();\n      if (usage === 0) return item;\n      if (usage < minUsage) {\n        candidate = item;\n        minUsage = usage;\n      }\n    }\n    return candidate;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:AsynchronouslyCreatedResourcePool.[Symbol.iterator]",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "AsynchronouslyCreatedResourcePool.[Symbol.iterator]",
    "startLine": 82,
    "endLine": 85,
    "text": "  * [Symbol.iterator] () {\n    yield * this.pendingItems;\n    yield * this.readyItems;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:AsynchronouslyCreatedResourcePool.maybeAvailable",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "AsynchronouslyCreatedResourcePool.maybeAvailable",
    "startLine": 91,
    "endLine": 98,
    "text": "  maybeAvailable (item : T) {\n    /* istanbul ignore else */\n    if (item.currentUsage() < this.maximumUsage) {\n      for (const listener of this.onAvailableListeners) {\n        listener(item);\n      }\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:AsynchronouslyCreatedResourcePool.onAvailable",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "AsynchronouslyCreatedResourcePool.onAvailable",
    "startLine": 100,
    "endLine": 102,
    "text": "  onAvailable (fn : (item : T) => void) {\n    this.onAvailableListeners.push(fn);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:WorkerInfo",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "WorkerInfo",
    "startLine": 105,
    "endLine": 226,
    "text": "export class WorkerInfo extends AsynchronouslyCreatedResource {\n    worker : Worker;\n    taskInfos : Map<number, TaskInfo>;\n    idleTimeout : NodeJS.Timeout | null = null; // eslint-disable-line no-undef\n    port : MessagePort;\n    sharedBuffer : Int32Array;\n    lastSeenResponseCount : number = 0;\n    onMessage : ResponseCallback;\n\n    constructor (\n      worker : Worker,\n      port : MessagePort,\n      onMessage : ResponseCallback) {\n      super();\n      this.worker = worker;\n      this.port = port;\n      this.port.on('message',\n        (message : ResponseMessage) => this._handleResponse(message));\n      this.onMessage = onMessage;\n      this.taskInfos = new Map();\n      this.sharedBuffer = new Int32Array(\n        new SharedArrayBuffer(kFieldCount * Int32Array.BYTES_PER_ELEMENT));\n    }\n\n    destroy () : void {\n      this.worker.terminate();\n      this.port.close();\n      this.clearIdleTimeout();\n      for (const taskInfo of this.taskInfos.values()) {\n        taskInfo.done(Errors.ThreadTermination());\n      }\n      this.taskInfos.clear();\n    }\n\n    clearIdleTimeout () : void {\n      if (this.idleTimeout !== null) {\n        clearTimeout(this.idleTimeout);\n        this.idleTimeout = null;\n      }\n    }\n\n    ref () : WorkerInfo {\n      this.port.ref();\n      return this;\n    }\n\n    unref () : WorkerInfo {\n      // Note: Do not call ref()/unref() on the Worker itself since that may cause\n      // a hard crash, see https://github.com/nodejs/node/pull/33394.\n      this.port.unref();\n      return this;\n    }\n\n    _handleResponse (message : ResponseMessage) : void {\n      this.onMessage(message);\n\n      if (this.taskInfos.size === 0) {\n        // No more tasks running on this Worker means it should not keep the\n        // process running.\n        this.unref();\n      }\n    }\n\n    postTask (taskInfo : TaskInfo) {\n      assert(!this.taskInfos.has(taskInfo.taskId));\n      const message : RequestMessage = {\n        task: taskInfo.releaseTask(),\n        taskId: taskInfo.taskId,\n        filename: taskInfo.filename,\n        name: taskInfo.name\n      };\n\n      try {\n        this.port.postMessage(message, taskInfo.transferList);\n      } catch (err) {\n        // This would mostly happen if e.g. message contains unserializable data\n        // or transferList is invalid.\n        taskInfo.done(<Error>err);\n        return;\n      }\n\n      taskInfo.workerInfo = this;\n      this.taskInfos.set(taskInfo.taskId, taskInfo);\n      this.ref();\n      this.clearIdleTimeout();\n\n      // Inform the worker that there are new messages posted, and wake it up\n      // if it is waiting for one.\n      Atomics.add(this.sharedBuffer, kRequestCountField, 1);\n      Atomics.notify(this.sharedBuffer, kRequestCountField, 1);\n    }\n\n    processPendingMessages () {\n      // If we *know* that there are more messages than we have received using\n      // 'message' events yet, then try to load and handle them synchronously,\n      // without the need to wait for more expensive events on the event loop.\n      // This would usually break async tracking, but in our case, we already have\n      // the extra TaskInfo/AsyncResource layer that rectifies that situation.\n      const actualResponseCount =\n        Atomics.load(this.sharedBuffer, kResponseCountField);\n      if (actualResponseCount !== this.lastSeenResponseCount) {\n        this.lastSeenResponseCount = actualResponseCount;\n\n        let entry;\n        while ((entry = receiveMessageOnPort(this.port)) !== undefined) {\n          this._handleResponse(entry.message);\n        }\n      }\n    }\n\n    isRunningAbortableTask () : boolean {\n      // If there are abortable tasks, we are running one at most per Worker.\n      if (this.taskInfos.size !== 1) return false;\n      const [[, task]] = this.taskInfos;\n      return task.abortSignal !== null;\n    }\n\n    currentUsage () : number {\n      if (this.isRunningAbortableTask()) return Infinity;\n      return this.taskInfos.size;\n    }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:WorkerInfo.destroy",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "WorkerInfo.destroy",
    "startLine": 129,
    "endLine": 137,
    "text": "    destroy () : void {\n      this.worker.terminate();\n      this.port.close();\n      this.clearIdleTimeout();\n      for (const taskInfo of this.taskInfos.values()) {\n        taskInfo.done(Errors.ThreadTermination());\n      }\n      this.taskInfos.clear();\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:WorkerInfo.clearIdleTimeout",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "WorkerInfo.clearIdleTimeout",
    "startLine": 139,
    "endLine": 144,
    "text": "    clearIdleTimeout () : void {\n      if (this.idleTimeout !== null) {\n        clearTimeout(this.idleTimeout);\n        this.idleTimeout = null;\n      }\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:WorkerInfo.ref",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "WorkerInfo.ref",
    "startLine": 146,
    "endLine": 149,
    "text": "    ref () : WorkerInfo {\n      this.port.ref();\n      return this;\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:WorkerInfo.unref",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "WorkerInfo.unref",
    "startLine": 151,
    "endLine": 156,
    "text": "    unref () : WorkerInfo {\n      // Note: Do not call ref()/unref() on the Worker itself since that may cause\n      // a hard crash, see https://github.com/nodejs/node/pull/33394.\n      this.port.unref();\n      return this;\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:WorkerInfo._handleResponse",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "WorkerInfo._handleResponse",
    "startLine": 158,
    "endLine": 166,
    "text": "    _handleResponse (message : ResponseMessage) : void {\n      this.onMessage(message);\n\n      if (this.taskInfos.size === 0) {\n        // No more tasks running on this Worker means it should not keep the\n        // process running.\n        this.unref();\n      }\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:WorkerInfo.postTask",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "WorkerInfo.postTask",
    "startLine": 168,
    "endLine": 195,
    "text": "    postTask (taskInfo : TaskInfo) {\n      assert(!this.taskInfos.has(taskInfo.taskId));\n      const message : RequestMessage = {\n        task: taskInfo.releaseTask(),\n        taskId: taskInfo.taskId,\n        filename: taskInfo.filename,\n        name: taskInfo.name\n      };\n\n      try {\n        this.port.postMessage(message, taskInfo.transferList);\n      } catch (err) {\n        // This would mostly happen if e.g. message contains unserializable data\n        // or transferList is invalid.\n        taskInfo.done(<Error>err);\n        return;\n      }\n\n      taskInfo.workerInfo = this;\n      this.taskInfos.set(taskInfo.taskId, taskInfo);\n      this.ref();\n      this.clearIdleTimeout();\n\n      // Inform the worker that there are new messages posted, and wake it up\n      // if it is waiting for one.\n      Atomics.add(this.sharedBuffer, kRequestCountField, 1);\n      Atomics.notify(this.sharedBuffer, kRequestCountField, 1);\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:WorkerInfo.processPendingMessages",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "WorkerInfo.processPendingMessages",
    "startLine": 197,
    "endLine": 213,
    "text": "    processPendingMessages () {\n      // If we *know* that there are more messages than we have received using\n      // 'message' events yet, then try to load and handle them synchronously,\n      // without the need to wait for more expensive events on the event loop.\n      // This would usually break async tracking, but in our case, we already have\n      // the extra TaskInfo/AsyncResource layer that rectifies that situation.\n      const actualResponseCount =\n        Atomics.load(this.sharedBuffer, kResponseCountField);\n      if (actualResponseCount !== this.lastSeenResponseCount) {\n        this.lastSeenResponseCount = actualResponseCount;\n\n        let entry;\n        while ((entry = receiveMessageOnPort(this.port)) !== undefined) {\n          this._handleResponse(entry.message);\n        }\n      }\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:WorkerInfo.isRunningAbortableTask",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "WorkerInfo.isRunningAbortableTask",
    "startLine": 215,
    "endLine": 220,
    "text": "    isRunningAbortableTask () : boolean {\n      // If there are abortable tasks, we are running one at most per Worker.\n      if (this.taskInfos.size !== 1) return false;\n      const [[, task]] = this.taskInfos;\n      return task.abortSignal !== null;\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts:WorkerInfo.currentUsage",
    "file": "node_modules/piscina/src/worker_pool/index.ts",
    "symbol": "WorkerInfo.currentUsage",
    "startLine": 222,
    "endLine": 225,
    "text": "    currentUsage () : number {\n      if (this.isRunningAbortableTask()) return Infinity;\n      return this.taskInfos.size;\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/tests/sample_src/src/orders/order.service.ts:OrderService",
    "file": "tests/sample_src/src/orders/order.service.ts",
    "symbol": "OrderService",
    "startLine": 1,
    "endLine": 13,
    "text": "export class OrderService {\n  /**\n   * Create a new order with the given items.\n   */\n  createOrder(items: string[]): number {\n    // compute total\n    let total = 0;\n    for (const item of items) {\n      total += item.length;\n    }\n    return total;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/tests/sample_src/src/orders/order.service.ts:OrderService.createOrder",
    "file": "tests/sample_src/src/orders/order.service.ts",
    "symbol": "OrderService.createOrder",
    "startLine": 5,
    "endLine": 12,
    "text": "  createOrder(items: string[]): number {\n    // compute total\n    let total = 0;\n    for (const item of items) {\n      total += item.length;\n    }\n    return total;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/tests/sample_src/src/utils/math.ts:add",
    "file": "tests/sample_src/src/utils/math.ts",
    "symbol": "add",
    "startLine": 1,
    "endLine": 3,
    "text": "export function add(a: number, b: number): number {\n  return a + b;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts:decodeOriginalScopes",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "symbol": "decodeOriginalScopes",
    "startLine": 35,
    "endLine": 76,
    "text": "export function decodeOriginalScopes(input: string): OriginalScope[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes: OriginalScope[] = [];\n  const stack: OriginalScope[] = [];\n  let line = 0;\n\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop()!;\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 0b0001;\n\n    const scope: OriginalScope = (\n      hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]\n    ) as OriginalScope;\n\n    let vars: Var[] = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n\n    scopes.push(scope);\n    stack.push(scope);\n  }\n\n  return scopes;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts:encodeOriginalScopes",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "symbol": "encodeOriginalScopes",
    "startLine": 78,
    "endLine": 86,
    "text": "export function encodeOriginalScopes(scopes: OriginalScope[]): string {\n  const writer = new StringWriter();\n\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n\n  return writer.flush();\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts:_encodeOriginalScopes",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "symbol": "_encodeOriginalScopes",
    "startLine": 88,
    "endLine": 127,
    "text": "function _encodeOriginalScopes(\n  scopes: OriginalScope[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenColumn\n  ],\n): number {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n\n  if (index > 0) writer.write(comma);\n\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n\n  const fields = scope.length === 6 ? 0b0001 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n\n  return index;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts:decodeGeneratedRanges",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "symbol": "decodeGeneratedRanges",
    "startLine": 129,
    "endLine": 229,
    "text": "export function decodeGeneratedRanges(input: string): GeneratedRange[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges: GeneratedRange[] = [];\n  const stack: GeneratedRange[] = [];\n\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    let genColumn = 0;\n\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop()!;\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 0b0001;\n      const hasCallsite = fields & 0b0010;\n      const hasScope = fields & 0b0100;\n\n      let callsite: CallSite | null = null;\n      let bindings: Binding[] = EMPTY;\n      let range: GeneratedRange;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0,\n        );\n\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex] as GeneratedRange;\n      } else {\n        range = [genLine, genColumn, 0, 0] as GeneratedRange;\n      }\n\n      range.isScope = !!hasScope;\n\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0,\n        );\n\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges: BindingExpressionRange[];\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n\n      ranges.push(range);\n      stack.push(range);\n    }\n\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n\n  return ranges;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts:encodeGeneratedRanges",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "symbol": "encodeGeneratedRanges",
    "startLine": 231,
    "endLine": 241,
    "text": "export function encodeGeneratedRanges(ranges: GeneratedRange[]): string {\n  if (ranges.length === 0) return '';\n\n  const writer = new StringWriter();\n\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n\n  return writer.flush();\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts:_encodeGeneratedRanges",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "symbol": "_encodeGeneratedRanges",
    "startLine": 243,
    "endLine": 339,
    "text": "function _encodeGeneratedRanges(\n  ranges: GeneratedRange[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenLine\n    number, // GenColumn\n    number, // DefSourcesIndex\n    number, // DefScopesIndex\n    number, // CallSourcesIndex\n    number, // CallLine\n    number, // CallColumn\n  ],\n): number {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings,\n  } = range;\n\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n\n  state[1] = encodeInteger(writer, range[1], state[1]);\n\n  const fields =\n    (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\n  encodeInteger(writer, fields, 0);\n\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite!;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1]!, bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2]!, bindingStartColumn);\n        encodeInteger(writer, expRange[0]!, 0);\n      }\n    }\n  }\n\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n\n  return index;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts:catchupLine",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "symbol": "catchupLine",
    "startLine": 341,
    "endLine": 345,
    "text": "function catchupLine(writer: StringWriter, lastLine: number, line: number) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts:decode",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
    "symbol": "decode",
    "startLine": 19,
    "endLine": 68,
    "text": "export function decode(mappings: string): SourceMapMappings {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded: SourceMapMappings = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n\n    while (reader.pos < semi) {\n      let seg: SourceMapSegment;\n\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n\n      line.push(seg);\n      reader.pos++;\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n\n  return decoded;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts:sort",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
    "symbol": "sort",
    "startLine": 70,
    "endLine": 72,
    "text": "function sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts:sortComparator",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
    "symbol": "sortComparator",
    "startLine": 74,
    "endLine": 76,
    "text": "function sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts:encode",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
    "symbol": "encode",
    "startLine": 78,
    "endLine": 78,
    "text": "export function encode(decoded: SourceMapMappings): string;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts:encode",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
    "symbol": "encode",
    "startLine": 79,
    "endLine": 79,
    "text": "export function encode(decoded: Readonly<SourceMapMappings>): string;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts:encode",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
    "symbol": "encode",
    "startLine": 80,
    "endLine": 111,
    "text": "export function encode(decoded: Readonly<SourceMapMappings>): string {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n\n    let genColumn = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n\n  return writer.flush();\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts:StringWriter",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "symbol": "StringWriter",
    "startLine": 24,
    "endLine": 42,
    "text": "export class StringWriter {\n  pos = 0;\n  private out = '';\n  private buffer = new Uint8Array(bufLength);\n\n  write(v: number): void {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n\n  flush(): string {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts:StringWriter.write",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "symbol": "StringWriter.write",
    "startLine": 29,
    "endLine": 36,
    "text": "  write(v: number): void {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts:StringWriter.flush",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "symbol": "StringWriter.flush",
    "startLine": 38,
    "endLine": 41,
    "text": "  flush(): string {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts:StringReader",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "symbol": "StringReader",
    "startLine": 44,
    "endLine": 65,
    "text": "export class StringReader {\n  pos = 0;\n  declare private buffer: string;\n\n  constructor(buffer: string) {\n    this.buffer = buffer;\n  }\n\n  next(): number {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n\n  peek(): number {\n    return this.buffer.charCodeAt(this.pos);\n  }\n\n  indexOf(char: string): number {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts:StringReader.next",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "symbol": "StringReader.next",
    "startLine": 52,
    "endLine": 54,
    "text": "  next(): number {\n    return this.buffer.charCodeAt(this.pos++);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts:StringReader.peek",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "symbol": "StringReader.peek",
    "startLine": 56,
    "endLine": 58,
    "text": "  peek(): number {\n    return this.buffer.charCodeAt(this.pos);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts:StringReader.indexOf",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "symbol": "StringReader.indexOf",
    "startLine": 60,
    "endLine": 64,
    "text": "  indexOf(char: string): number {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts:decodeInteger",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts",
    "symbol": "decodeInteger",
    "startLine": 16,
    "endLine": 36,
    "text": "export function decodeInteger(reader: StringReader, relative: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  return relative + value;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts:encodeInteger",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts",
    "symbol": "encodeInteger",
    "startLine": 38,
    "endLine": 50,
    "text": "export function encodeInteger(builder: StringWriter, num: number, relative: number): number {\n  let delta = num - relative;\n\n  delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\n  do {\n    let clamped = delta & 0b011111;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 0b100000;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n\n  return num;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts:hasMoreVlq",
    "file": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts",
    "symbol": "hasMoreVlq",
    "startLine": 52,
    "endLine": 55,
    "text": "export function hasMoreVlq(reader: StringReader, max: number) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap",
    "startLine": 20,
    "endLine": 315,
    "text": "export default class SearchableMap<T = any> {\n  /**\n   * @internal\n   */\n  _tree: RadixTree<T>\n\n  /**\n   * @internal\n   */\n  _prefix: string\n\n  private _size: number | undefined = undefined\n\n  /**\n   * The constructor is normally called without arguments, creating an empty\n   * map. In order to create a {@link SearchableMap} from an iterable or from an\n   * object, check {@link SearchableMap.from} and {@link\n   * SearchableMap.fromObject}.\n   *\n   * The constructor arguments are for internal use, when creating derived\n   * mutable views of a map at a prefix.\n   */\n  constructor (tree: RadixTree<T> = new Map(), prefix = '') {\n    this._tree = tree\n    this._prefix = prefix\n  }\n\n  /**\n   * Creates and returns a mutable view of this {@link SearchableMap},\n   * containing only entries that share the given prefix.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * let map = new SearchableMap()\n   * map.set(\"unicorn\", 1)\n   * map.set(\"universe\", 2)\n   * map.set(\"university\", 3)\n   * map.set(\"unique\", 4)\n   * map.set(\"hello\", 5)\n   *\n   * let uni = map.atPrefix(\"uni\")\n   * uni.get(\"unique\") // => 4\n   * uni.get(\"unicorn\") // => 1\n   * uni.get(\"hello\") // => undefined\n   *\n   * let univer = map.atPrefix(\"univer\")\n   * univer.get(\"unique\") // => undefined\n   * univer.get(\"universe\") // => 2\n   * univer.get(\"university\") // => 3\n   * ```\n   *\n   * @param prefix  The prefix\n   * @return A {@link SearchableMap} representing a mutable view of the original\n   * Map at the given prefix\n   */\n  atPrefix (prefix: string): SearchableMap<T> {\n    if (!prefix.startsWith(this._prefix)) { throw new Error('Mismatched prefix') }\n\n    const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length))\n\n    if (node === undefined) {\n      const [parentNode, key] = last(path)\n\n      for (const k of parentNode!.keys()) {\n        if (k !== LEAF && k.startsWith(key)) {\n          const node = new Map()\n          node.set(k.slice(key.length), parentNode!.get(k)!)\n          return new SearchableMap(node, prefix)\n        }\n      }\n    }\n\n    return new SearchableMap<T>(node, prefix)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\n   */\n  clear (): void {\n    this._size = undefined\n    this._tree.clear()\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\n   * @param key  Key to delete\n   */\n  delete (key: string): void {\n    this._size = undefined\n    return remove(this._tree, key)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\n   * @return An iterator iterating through `[key, value]` entries.\n   */\n  entries () {\n    return new TreeIterator(this, ENTRIES)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\n   * @param fn  Iteration function\n   */\n  forEach (fn: (key: string, value: T, map: SearchableMap) => void): void {\n    for (const [key, value] of this) {\n      fn(key, value, this)\n    }\n  }\n\n  /**\n   * Returns a Map of all the entries that have a key within the given edit\n   * distance from the search key. The keys of the returned Map are the matching\n   * keys, while the values are two-element arrays where the first element is\n   * the value associated to the key, and the second is the edit distance of the\n   * key to the search key.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * let map = new SearchableMap()\n   * map.set('hello', 'world')\n   * map.set('hell', 'yeah')\n   * map.set('ciao', 'mondo')\n   *\n   * // Get all entries that match the key 'hallo' with a maximum edit distance of 2\n   * map.fuzzyGet('hallo', 2)\n   * // => Map(2) { 'hello' => ['world', 1], 'hell' => ['yeah', 2] }\n   *\n   * // In the example, the \"hello\" key has value \"world\" and edit distance of 1\n   * // (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n   * // (change \"e\" to \"a\", delete \"o\")\n   * ```\n   *\n   * @param key  The search key\n   * @param maxEditDistance  The maximum edit distance (Levenshtein)\n   * @return A Map of the matching keys to their value and edit distance\n   */\n  fuzzyGet (key: string, maxEditDistance: number): FuzzyResults<T> {\n    return fuzzySearch<T>(this._tree, key, maxEditDistance)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\n   * @param key  Key to get\n   * @return Value associated to the key, or `undefined` if the key is not\n   * found.\n   */\n  get (key: string): T | undefined {\n    const node = lookup<T>(this._tree, key)\n    return node !== undefined ? node.get(LEAF) : undefined\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\n   * @param key  Key\n   * @return True if the key is in the map, false otherwise\n   */\n  has (key: string): boolean {\n    const node = lookup(this._tree, key)\n    return node !== undefined && node.has(LEAF)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\n   * @return An `Iterable` iterating through keys\n   */\n  keys () {\n    return new TreeIterator(this, KEYS)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\n   * @param key  Key to set\n   * @param value  Value to associate to the key\n   * @return The {@link SearchableMap} itself, to allow chaining\n   */\n  set (key: string, value: T): SearchableMap<T> {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n    node.set(LEAF, value)\n    return this\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\n   */\n  get size (): number {\n    if (this._size) { return this._size }\n    /** @ignore */\n    this._size = 0\n\n    const iter = this.entries()\n    while (!iter.next().done) this._size! += 1\n\n    return this._size\n  }\n\n  /**\n   * Updates the value at the given key using the provided function. The function\n   * is called with the current value at the key, and its return value is used as\n   * the new value to be set.\n   *\n   * ### Example:\n   *\n   * ```javascript\n   * // Increment the current value by one\n   * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)\n   * ```\n   *\n   * If the value at the given key is or will be an object, it might not require\n   * re-assignment. In that case it is better to use `fetch()`, because it is\n   * faster.\n   *\n   * @param key  The key to update\n   * @param fn  The function used to compute the new value from the current one\n   * @return The {@link SearchableMap} itself, to allow chaining\n   */\n  update (key: string, fn: (value: T | undefined) => T): SearchableMap<T> {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n    node.set(LEAF, fn(node.get(LEAF)))\n    return this\n  }\n\n  /**\n   * Fetches the value of the given key. If the value does not exist, calls the\n   * given function to create a new value, which is inserted at the given key\n   * and subsequently returned.\n   *\n   * ### Example:\n   *\n   * ```javascript\n   * const map = searchableMap.fetch('somekey', () => new Map())\n   * map.set('foo', 'bar')\n   * ```\n   *\n   * @param key  The key to update\n   * @param initial  A function that creates a new value if the key does not exist\n   * @return The existing or new value at the given key\n   */\n  fetch (key: string, initial: () => T): T {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n\n    let value = node.get(LEAF)\n    if (value === undefined) {\n      node.set(LEAF, value = initial())\n    }\n\n    return value\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\n   * @return An `Iterable` iterating through values.\n   */\n  values () {\n    return new TreeIterator(this, VALUES)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Creates a {@link SearchableMap} from an `Iterable` of entries\n   *\n   * @param entries  Entries to be inserted in the {@link SearchableMap}\n   * @return A new {@link SearchableMap} with the given entries\n   */\n  static from<T = any> (entries: Iterable<Entry<T>> | Entry<T>[]) {\n    const tree = new SearchableMap()\n    for (const [key, value] of entries) {\n      tree.set(key, value)\n    }\n    return tree\n  }\n\n  /**\n   * Creates a {@link SearchableMap} from the iterable properties of a JavaScript object\n   *\n   * @param object  Object of entries for the {@link SearchableMap}\n   * @return A new {@link SearchableMap} with the given entries\n   */\n  static fromObject<T = any> (object: { [key: string]: T }) {\n    return SearchableMap.from<T>(Object.entries(object))\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.atPrefix",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.atPrefix",
    "startLine": 76,
    "endLine": 94,
    "text": "  atPrefix (prefix: string): SearchableMap<T> {\n    if (!prefix.startsWith(this._prefix)) { throw new Error('Mismatched prefix') }\n\n    const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length))\n\n    if (node === undefined) {\n      const [parentNode, key] = last(path)\n\n      for (const k of parentNode!.keys()) {\n        if (k !== LEAF && k.startsWith(key)) {\n          const node = new Map()\n          node.set(k.slice(key.length), parentNode!.get(k)!)\n          return new SearchableMap(node, prefix)\n        }\n      }\n    }\n\n    return new SearchableMap<T>(node, prefix)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.clear",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.clear",
    "startLine": 99,
    "endLine": 102,
    "text": "  clear (): void {\n    this._size = undefined\n    this._tree.clear()\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.delete",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.delete",
    "startLine": 108,
    "endLine": 111,
    "text": "  delete (key: string): void {\n    this._size = undefined\n    return remove(this._tree, key)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.entries",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.entries",
    "startLine": 117,
    "endLine": 119,
    "text": "  entries () {\n    return new TreeIterator(this, ENTRIES)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.forEach",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.forEach",
    "startLine": 125,
    "endLine": 129,
    "text": "  forEach (fn: (key: string, value: T, map: SearchableMap) => void): void {\n    for (const [key, value] of this) {\n      fn(key, value, this)\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.fuzzyGet",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.fuzzyGet",
    "startLine": 159,
    "endLine": 161,
    "text": "  fuzzyGet (key: string, maxEditDistance: number): FuzzyResults<T> {\n    return fuzzySearch<T>(this._tree, key, maxEditDistance)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.get",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.get",
    "startLine": 169,
    "endLine": 172,
    "text": "  get (key: string): T | undefined {\n    const node = lookup<T>(this._tree, key)\n    return node !== undefined ? node.get(LEAF) : undefined\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.has",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.has",
    "startLine": 179,
    "endLine": 182,
    "text": "  has (key: string): boolean {\n    const node = lookup(this._tree, key)\n    return node !== undefined && node.has(LEAF)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.keys",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.keys",
    "startLine": 188,
    "endLine": 190,
    "text": "  keys () {\n    return new TreeIterator(this, KEYS)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.set",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.set",
    "startLine": 198,
    "endLine": 204,
    "text": "  set (key: string, value: T): SearchableMap<T> {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n    node.set(LEAF, value)\n    return this\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.update",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.update",
    "startLine": 240,
    "endLine": 246,
    "text": "  update (key: string, fn: (value: T | undefined) => T): SearchableMap<T> {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n    node.set(LEAF, fn(node.get(LEAF)))\n    return this\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.fetch",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.fetch",
    "startLine": 264,
    "endLine": 275,
    "text": "  fetch (key: string, initial: () => T): T {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n\n    let value = node.get(LEAF)\n    if (value === undefined) {\n      node.set(LEAF, value = initial())\n    }\n\n    return value\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.values",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.values",
    "startLine": 281,
    "endLine": 283,
    "text": "  values () {\n    return new TreeIterator(this, VALUES)\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.[Symbol.iterator]",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.[Symbol.iterator]",
    "startLine": 288,
    "endLine": 290,
    "text": "  [Symbol.iterator] () {\n    return this.entries()\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.from",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.from",
    "startLine": 298,
    "endLine": 304,
    "text": "  static from<T = any> (entries: Iterable<Entry<T>> | Entry<T>[]) {\n    const tree = new SearchableMap()\n    for (const [key, value] of entries) {\n      tree.set(key, value)\n    }\n    return tree\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts:SearchableMap.fromObject",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "symbol": "SearchableMap.fromObject",
    "startLine": 312,
    "endLine": 314,
    "text": "  static fromObject<T = any> (object: { [key: string]: T }) {\n    return SearchableMap.from<T>(Object.entries(object))\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts:TreeIterator",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
    "symbol": "TreeIterator",
    "startLine": 37,
    "endLine": 97,
    "text": "class TreeIterator<T, K extends Kind<T>> implements Iterator<Result<T, K>> {\n  set: IterableSet<T>\n  _type: K\n  _path: IteratorPath<T>\n\n  constructor (set: IterableSet<T>, type: K) {\n    const node = set._tree\n    const keys = Array.from(node.keys())\n    this.set = set\n    this._type = type\n    this._path = keys.length > 0 ? [{ node, keys }] : []\n  }\n\n  next (): IteratorResult<Result<T, K>> {\n    const value = this.dive()\n    this.backtrack()\n    return value\n  }\n\n  dive (): IteratorResult<Result<T, K>> {\n    if (this._path.length === 0) { return { done: true, value: undefined } }\n    const { node, keys } = last(this._path)!\n    if (last(keys) === LEAF) { return { done: false, value: this.result() } }\n\n    const child = node.get(last(keys)!)!\n    this._path.push({ node: child, keys: Array.from(child.keys()) })\n    return this.dive()\n  }\n\n  backtrack (): void {\n    if (this._path.length === 0) { return }\n    const keys = last(this._path)!.keys\n    keys.pop()\n    if (keys.length > 0) { return }\n    this._path.pop()\n    this.backtrack()\n  }\n\n  key (): string {\n    return this.set._prefix + this._path\n      .map(({ keys }) => last(keys))\n      .filter(key => key !== LEAF)\n      .join('')\n  }\n\n  value (): T {\n    return last(this._path)!.node.get(LEAF)!\n  }\n\n  result (): Result<T, K> {\n    switch (this._type) {\n      case VALUES: return this.value() as Result<T, K>\n      case KEYS: return this.key() as Result<T, K>\n      default: return [this.key(), this.value()] as Result<T, K>\n    }\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts:TreeIterator.next",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
    "symbol": "TreeIterator.next",
    "startLine": 50,
    "endLine": 54,
    "text": "  next (): IteratorResult<Result<T, K>> {\n    const value = this.dive()\n    this.backtrack()\n    return value\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts:TreeIterator.dive",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
    "symbol": "TreeIterator.dive",
    "startLine": 56,
    "endLine": 64,
    "text": "  dive (): IteratorResult<Result<T, K>> {\n    if (this._path.length === 0) { return { done: true, value: undefined } }\n    const { node, keys } = last(this._path)!\n    if (last(keys) === LEAF) { return { done: false, value: this.result() } }\n\n    const child = node.get(last(keys)!)!\n    this._path.push({ node: child, keys: Array.from(child.keys()) })\n    return this.dive()\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts:TreeIterator.backtrack",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
    "symbol": "TreeIterator.backtrack",
    "startLine": 66,
    "endLine": 73,
    "text": "  backtrack (): void {\n    if (this._path.length === 0) { return }\n    const keys = last(this._path)!.keys\n    keys.pop()\n    if (keys.length > 0) { return }\n    this._path.pop()\n    this.backtrack()\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts:TreeIterator.key",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
    "symbol": "TreeIterator.key",
    "startLine": 75,
    "endLine": 80,
    "text": "  key (): string {\n    return this.set._prefix + this._path\n      .map(({ keys }) => last(keys))\n      .filter(key => key !== LEAF)\n      .join('')\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts:TreeIterator.value",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
    "symbol": "TreeIterator.value",
    "startLine": 82,
    "endLine": 84,
    "text": "  value (): T {\n    return last(this._path)!.node.get(LEAF)!\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts:TreeIterator.result",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
    "symbol": "TreeIterator.result",
    "startLine": 86,
    "endLine": 92,
    "text": "  result (): Result<T, K> {\n    switch (this._type) {\n      case VALUES: return this.value() as Result<T, K>\n      case KEYS: return this.key() as Result<T, K>\n      default: return [this.key(), this.value()] as Result<T, K>\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts:TreeIterator.[Symbol.iterator]",
    "file": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
    "symbol": "TreeIterator.[Symbol.iterator]",
    "startLine": 94,
    "endLine": 96,
    "text": "  [Symbol.iterator] () {\n    return this\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/errors.ts:setErrorMap",
    "file": "mcp-rag-server/node_modules/zod/src/v3/errors.ts",
    "symbol": "setErrorMap",
    "startLine": 7,
    "endLine": 9,
    "text": "export function setErrorMap(map: ZodErrorMap) {\n  overrideErrorMap = map;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/errors.ts:getErrorMap",
    "file": "mcp-rag-server/node_modules/zod/src/v3/errors.ts",
    "symbol": "getErrorMap",
    "startLine": 11,
    "endLine": 13,
    "text": "export function getErrorMap() {\n  return overrideErrorMap;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ParseInputLazyPath",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ParseInputLazyPath",
    "startLine": 62,
    "endLine": 85,
    "text": "class ParseInputLazyPath implements ParseInput {\n  parent: ParseContext;\n  data: any;\n  _path: ParsePath;\n  _key: string | number | (string | number)[];\n  _cachedPath: ParsePath = [];\n  constructor(parent: ParseContext, value: any, path: ParsePath, key: string | number | (string | number)[]) {\n    this.parent = parent;\n    this.data = value;\n    this._path = path;\n    this._key = key;\n  }\n  get path() {\n    if (!this._cachedPath.length) {\n      if (Array.isArray(this._key)) {\n        this._cachedPath.push(...this._path, ...this._key);\n      } else {\n        this._cachedPath.push(...this._path, this._key);\n      }\n    }\n\n    return this._cachedPath;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:processCreateParams",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "processCreateParams",
    "startLine": 123,
    "endLine": 143,
    "text": "function processCreateParams(params: RawCreateParams): ProcessedCreateParams {\n  if (!params) return {};\n  const { errorMap, invalid_type_error, required_error, description } = params;\n  if (errorMap && (invalid_type_error || required_error)) {\n    throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  }\n  if (errorMap) return { errorMap: errorMap, description };\n  const customMap: ZodErrorMap = (iss, ctx) => {\n    const { message } = params;\n\n    if (iss.code === \"invalid_enum_value\") {\n      return { message: message ?? ctx.defaultError };\n    }\n    if (typeof ctx.data === \"undefined\") {\n      return { message: message ?? required_error ?? ctx.defaultError };\n    }\n    if (iss.code !== \"invalid_type\") return { message: ctx.defaultError };\n    return { message: message ?? invalid_type_error ?? ctx.defaultError };\n  };\n  return { errorMap: customMap, description };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType",
    "startLine": 158,
    "endLine": 535,
    "text": "export abstract class ZodType<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> {\n  readonly _type!: Output;\n  readonly _output!: Output;\n  readonly _input!: Input;\n  readonly _def!: Def;\n\n  get description(): string | undefined {\n    return this._def.description;\n  }\n\n  \"~standard\": StandardSchemaV1.Props<Input, Output>;\n\n  abstract _parse(input: ParseInput): ParseReturnType<Output>;\n\n  _getType(input: ParseInput): string {\n    return getParsedType(input.data);\n  }\n\n  _getOrReturnCtx(input: ParseInput, ctx?: ParseContext | undefined): ParseContext {\n    return (\n      ctx || {\n        common: input.parent.common,\n        data: input.data,\n\n        parsedType: getParsedType(input.data),\n\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent,\n      }\n    );\n  }\n\n  _processInputParams(input: ParseInput): {\n    status: ParseStatus;\n    ctx: ParseContext;\n  } {\n    return {\n      status: new ParseStatus(),\n      ctx: {\n        common: input.parent.common,\n        data: input.data,\n\n        parsedType: getParsedType(input.data),\n\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent,\n      },\n    };\n  }\n\n  _parseSync(input: ParseInput): SyncParseReturnType<Output> {\n    const result = this._parse(input);\n    if (isAsync(result)) {\n      throw new Error(\"Synchronous parse encountered promise.\");\n    }\n    return result;\n  }\n\n  _parseAsync(input: ParseInput): AsyncParseReturnType<Output> {\n    const result = this._parse(input);\n    return Promise.resolve(result);\n  }\n\n  parse(data: unknown, params?: util.InexactPartial<ParseParams>): Output {\n    const result = this.safeParse(data, params);\n    if (result.success) return result.data;\n    throw result.error;\n  }\n\n  safeParse(data: unknown, params?: util.InexactPartial<ParseParams>): SafeParseReturnType<Input, Output> {\n    const ctx: ParseContext = {\n      common: {\n        issues: [],\n        async: params?.async ?? false,\n        contextualErrorMap: params?.errorMap,\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data),\n    };\n    const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n\n    return handleResult(ctx, result);\n  }\n\n  \"~validate\"(data: unknown): StandardSchemaV1.Result<Output> | Promise<StandardSchemaV1.Result<Output>> {\n    const ctx: ParseContext = {\n      common: {\n        issues: [],\n        async: !!(this[\"~standard\"] as any).async,\n      },\n      path: [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data),\n    };\n\n    if (!(this[\"~standard\"] as any).async) {\n      try {\n        const result = this._parseSync({ data, path: [], parent: ctx });\n        return isValid(result)\n          ? {\n              value: result.value,\n            }\n          : {\n              issues: ctx.common.issues,\n            };\n      } catch (err: any) {\n        if ((err as Error)?.message?.toLowerCase()?.includes(\"encountered\")) {\n          (this[\"~standard\"] as any).async = true;\n        }\n        (ctx as any).common = {\n          issues: [],\n          async: true,\n        };\n      }\n    }\n\n    return this._parseAsync({ data, path: [], parent: ctx }).then((result) =>\n      isValid(result)\n        ? {\n            value: result.value,\n          }\n        : {\n            issues: ctx.common.issues,\n          }\n    );\n  }\n\n  async parseAsync(data: unknown, params?: util.InexactPartial<ParseParams>): Promise<Output> {\n    const result = await this.safeParseAsync(data, params);\n    if (result.success) return result.data;\n    throw result.error;\n  }\n\n  async safeParseAsync(\n    data: unknown,\n    params?: util.InexactPartial<ParseParams>\n  ): Promise<SafeParseReturnType<Input, Output>> {\n    const ctx: ParseContext = {\n      common: {\n        issues: [],\n        contextualErrorMap: params?.errorMap,\n        async: true,\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data),\n    };\n\n    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n    return handleResult(ctx, result);\n  }\n\n  /** Alias of safeParseAsync */\n  spa = this.safeParseAsync;\n\n  refine<RefinedOutput extends Output>(\n    check: (arg: Output) => arg is RefinedOutput,\n    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)\n  ): ZodEffects<this, RefinedOutput, Input>;\n  refine(\n    check: (arg: Output) => unknown | Promise<unknown>,\n    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)\n  ): ZodEffects<this, Output, Input>;\n  refine(\n    check: (arg: Output) => unknown,\n    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)\n  ): ZodEffects<this, Output, Input> {\n    const getIssueProperties = (val: Output) => {\n      if (typeof message === \"string\" || typeof message === \"undefined\") {\n        return { message };\n      } else if (typeof message === \"function\") {\n        return message(val);\n      } else {\n        return message;\n      }\n    };\n    return this._refinement((val, ctx) => {\n      const result = check(val);\n      const setError = () =>\n        ctx.addIssue({\n          code: ZodIssueCode.custom,\n          ...getIssueProperties(val),\n        });\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then((data) => {\n          if (!data) {\n            setError();\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      if (!result) {\n        setError();\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n\n  refinement<RefinedOutput extends Output>(\n    check: (arg: Output) => arg is RefinedOutput,\n    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)\n  ): ZodEffects<this, RefinedOutput, Input>;\n  refinement(\n    check: (arg: Output) => boolean,\n    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)\n  ): ZodEffects<this, Output, Input>;\n  refinement(\n    check: (arg: Output) => unknown,\n    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)\n  ): ZodEffects<this, Output, Input> {\n    return this._refinement((val, ctx) => {\n      if (!check(val)) {\n        ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n\n  _refinement(refinement: RefinementEffect<Output>[\"refinement\"]): ZodEffects<this, Output, Input> {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"refinement\", refinement },\n    });\n  }\n\n  superRefine<RefinedOutput extends Output>(\n    refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput\n  ): ZodEffects<this, RefinedOutput, Input>;\n  superRefine(refinement: (arg: Output, ctx: RefinementCtx) => void): ZodEffects<this, Output, Input>;\n  superRefine(refinement: (arg: Output, ctx: RefinementCtx) => Promise<void>): ZodEffects<this, Output, Input>;\n  superRefine(\n    refinement: (arg: Output, ctx: RefinementCtx) => unknown | Promise<unknown>\n  ): ZodEffects<this, Output, Input> {\n    return this._refinement(refinement);\n  }\n\n  constructor(def: Def) {\n    this._def = def;\n    this.parse = this.parse.bind(this);\n    this.safeParse = this.safeParse.bind(this);\n    this.parseAsync = this.parseAsync.bind(this);\n    this.safeParseAsync = this.safeParseAsync.bind(this);\n    this.spa = this.spa.bind(this);\n    this.refine = this.refine.bind(this);\n    this.refinement = this.refinement.bind(this);\n    this.superRefine = this.superRefine.bind(this);\n    this.optional = this.optional.bind(this);\n    this.nullable = this.nullable.bind(this);\n    this.nullish = this.nullish.bind(this);\n    this.array = this.array.bind(this);\n    this.promise = this.promise.bind(this);\n    this.or = this.or.bind(this);\n    this.and = this.and.bind(this);\n    this.transform = this.transform.bind(this);\n    this.brand = this.brand.bind(this);\n    this.default = this.default.bind(this);\n    this.catch = this.catch.bind(this);\n    this.describe = this.describe.bind(this);\n    this.pipe = this.pipe.bind(this);\n    this.readonly = this.readonly.bind(this);\n    this.isNullable = this.isNullable.bind(this);\n    this.isOptional = this.isOptional.bind(this);\n    this[\"~standard\"] = {\n      version: 1,\n      vendor: \"zod\",\n      validate: (data) => this[\"~validate\"](data),\n    };\n  }\n\n  optional(): ZodOptional<this> {\n    return ZodOptional.create(this, this._def) as any;\n  }\n  nullable(): ZodNullable<this> {\n    return ZodNullable.create(this, this._def) as any;\n  }\n  nullish(): ZodOptional<ZodNullable<this>> {\n    return this.nullable().optional();\n  }\n  array(): ZodArray<this> {\n    return ZodArray.create(this);\n  }\n  promise(): ZodPromise<this> {\n    return ZodPromise.create(this, this._def);\n  }\n\n  or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {\n    return ZodUnion.create([this, option], this._def) as any;\n  }\n\n  and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T> {\n    return ZodIntersection.create(this, incoming, this._def);\n  }\n\n  transform<NewOut>(\n    transform: (arg: Output, ctx: RefinementCtx) => NewOut | Promise<NewOut>\n  ): ZodEffects<this, NewOut> {\n    return new ZodEffects({\n      ...processCreateParams(this._def),\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"transform\", transform },\n    }) as any;\n  }\n\n  default(def: util.noUndefined<Input>): ZodDefault<this>;\n  default(def: () => util.noUndefined<Input>): ZodDefault<this>;\n  default(def: any) {\n    const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n\n    return new ZodDefault({\n      ...processCreateParams(this._def),\n      innerType: this,\n      defaultValue: defaultValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodDefault,\n    }) as any;\n  }\n\n  brand<B extends string | number | symbol>(brand?: B): ZodBranded<this, B>;\n  brand<B extends string | number | symbol>(): ZodBranded<this, B> {\n    return new ZodBranded({\n      typeName: ZodFirstPartyTypeKind.ZodBranded,\n      type: this,\n      ...processCreateParams(this._def),\n    });\n  }\n\n  catch(def: Output): ZodCatch<this>;\n  catch(def: (ctx: { error: ZodError; input: Input }) => Output): ZodCatch<this>;\n  catch(def: any) {\n    const catchValueFunc = typeof def === \"function\" ? def : () => def;\n\n    return new ZodCatch({\n      ...processCreateParams(this._def),\n      innerType: this,\n      catchValue: catchValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodCatch,\n    }) as any;\n  }\n\n  describe(description: string): this {\n    const This = (this as any).constructor;\n    return new This({\n      ...this._def,\n      description,\n    });\n  }\n\n  pipe<T extends ZodTypeAny>(target: T): ZodPipeline<this, T> {\n    return ZodPipeline.create(this, target);\n  }\n  readonly(): ZodReadonly<this> {\n    return ZodReadonly.create(this);\n  }\n\n  isOptional(): boolean {\n    return this.safeParse(undefined).success;\n  }\n  isNullable(): boolean {\n    return this.safeParse(null).success;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType._parse",
    "startLine": 170,
    "endLine": 170,
    "text": "  abstract _parse(input: ParseInput): ParseReturnType<Output>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType._getType",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType._getType",
    "startLine": 172,
    "endLine": 174,
    "text": "  _getType(input: ParseInput): string {\n    return getParsedType(input.data);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType._getOrReturnCtx",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType._getOrReturnCtx",
    "startLine": 176,
    "endLine": 189,
    "text": "  _getOrReturnCtx(input: ParseInput, ctx?: ParseContext | undefined): ParseContext {\n    return (\n      ctx || {\n        common: input.parent.common,\n        data: input.data,\n\n        parsedType: getParsedType(input.data),\n\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent,\n      }\n    );\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType._processInputParams",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType._processInputParams",
    "startLine": 191,
    "endLine": 208,
    "text": "  _processInputParams(input: ParseInput): {\n    status: ParseStatus;\n    ctx: ParseContext;\n  } {\n    return {\n      status: new ParseStatus(),\n      ctx: {\n        common: input.parent.common,\n        data: input.data,\n\n        parsedType: getParsedType(input.data),\n\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent,\n      },\n    };\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType._parseSync",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType._parseSync",
    "startLine": 210,
    "endLine": 216,
    "text": "  _parseSync(input: ParseInput): SyncParseReturnType<Output> {\n    const result = this._parse(input);\n    if (isAsync(result)) {\n      throw new Error(\"Synchronous parse encountered promise.\");\n    }\n    return result;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType._parseAsync",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType._parseAsync",
    "startLine": 218,
    "endLine": 221,
    "text": "  _parseAsync(input: ParseInput): AsyncParseReturnType<Output> {\n    const result = this._parse(input);\n    return Promise.resolve(result);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.parse",
    "startLine": 223,
    "endLine": 227,
    "text": "  parse(data: unknown, params?: util.InexactPartial<ParseParams>): Output {\n    const result = this.safeParse(data, params);\n    if (result.success) return result.data;\n    throw result.error;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.safeParse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.safeParse",
    "startLine": 229,
    "endLine": 245,
    "text": "  safeParse(data: unknown, params?: util.InexactPartial<ParseParams>): SafeParseReturnType<Input, Output> {\n    const ctx: ParseContext = {\n      common: {\n        issues: [],\n        async: params?.async ?? false,\n        contextualErrorMap: params?.errorMap,\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data),\n    };\n    const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n\n    return handleResult(ctx, result);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.\"~validate\"",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.\"~validate\"",
    "startLine": 247,
    "endLine": 290,
    "text": "  \"~validate\"(data: unknown): StandardSchemaV1.Result<Output> | Promise<StandardSchemaV1.Result<Output>> {\n    const ctx: ParseContext = {\n      common: {\n        issues: [],\n        async: !!(this[\"~standard\"] as any).async,\n      },\n      path: [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data),\n    };\n\n    if (!(this[\"~standard\"] as any).async) {\n      try {\n        const result = this._parseSync({ data, path: [], parent: ctx });\n        return isValid(result)\n          ? {\n              value: result.value,\n            }\n          : {\n              issues: ctx.common.issues,\n            };\n      } catch (err: any) {\n        if ((err as Error)?.message?.toLowerCase()?.includes(\"encountered\")) {\n          (this[\"~standard\"] as any).async = true;\n        }\n        (ctx as any).common = {\n          issues: [],\n          async: true,\n        };\n      }\n    }\n\n    return this._parseAsync({ data, path: [], parent: ctx }).then((result) =>\n      isValid(result)\n        ? {\n            value: result.value,\n          }\n        : {\n            issues: ctx.common.issues,\n          }\n    );\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.parseAsync",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.parseAsync",
    "startLine": 292,
    "endLine": 296,
    "text": "  async parseAsync(data: unknown, params?: util.InexactPartial<ParseParams>): Promise<Output> {\n    const result = await this.safeParseAsync(data, params);\n    if (result.success) return result.data;\n    throw result.error;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.safeParseAsync",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.safeParseAsync",
    "startLine": 298,
    "endLine": 318,
    "text": "  async safeParseAsync(\n    data: unknown,\n    params?: util.InexactPartial<ParseParams>\n  ): Promise<SafeParseReturnType<Input, Output>> {\n    const ctx: ParseContext = {\n      common: {\n        issues: [],\n        contextualErrorMap: params?.errorMap,\n        async: true,\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data),\n    };\n\n    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n    return handleResult(ctx, result);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.refine",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.refine",
    "startLine": 331,
    "endLine": 368,
    "text": "  refine(\n    check: (arg: Output) => unknown,\n    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)\n  ): ZodEffects<this, Output, Input> {\n    const getIssueProperties = (val: Output) => {\n      if (typeof message === \"string\" || typeof message === \"undefined\") {\n        return { message };\n      } else if (typeof message === \"function\") {\n        return message(val);\n      } else {\n        return message;\n      }\n    };\n    return this._refinement((val, ctx) => {\n      const result = check(val);\n      const setError = () =>\n        ctx.addIssue({\n          code: ZodIssueCode.custom,\n          ...getIssueProperties(val),\n        });\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then((data) => {\n          if (!data) {\n            setError();\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      if (!result) {\n        setError();\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.refinement",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.refinement",
    "startLine": 378,
    "endLine": 390,
    "text": "  refinement(\n    check: (arg: Output) => unknown,\n    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)\n  ): ZodEffects<this, Output, Input> {\n    return this._refinement((val, ctx) => {\n      if (!check(val)) {\n        ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType._refinement",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType._refinement",
    "startLine": 392,
    "endLine": 398,
    "text": "  _refinement(refinement: RefinementEffect<Output>[\"refinement\"]): ZodEffects<this, Output, Input> {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"refinement\", refinement },\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.superRefine",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.superRefine",
    "startLine": 405,
    "endLine": 409,
    "text": "  superRefine(\n    refinement: (arg: Output, ctx: RefinementCtx) => unknown | Promise<unknown>\n  ): ZodEffects<this, Output, Input> {\n    return this._refinement(refinement);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.optional",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.optional",
    "startLine": 444,
    "endLine": 446,
    "text": "  optional(): ZodOptional<this> {\n    return ZodOptional.create(this, this._def) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.nullable",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.nullable",
    "startLine": 447,
    "endLine": 449,
    "text": "  nullable(): ZodNullable<this> {\n    return ZodNullable.create(this, this._def) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.nullish",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.nullish",
    "startLine": 450,
    "endLine": 452,
    "text": "  nullish(): ZodOptional<ZodNullable<this>> {\n    return this.nullable().optional();\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.array",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.array",
    "startLine": 453,
    "endLine": 455,
    "text": "  array(): ZodArray<this> {\n    return ZodArray.create(this);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.promise",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.promise",
    "startLine": 456,
    "endLine": 458,
    "text": "  promise(): ZodPromise<this> {\n    return ZodPromise.create(this, this._def);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.or",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.or",
    "startLine": 460,
    "endLine": 462,
    "text": "  or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {\n    return ZodUnion.create([this, option], this._def) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.and",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.and",
    "startLine": 464,
    "endLine": 466,
    "text": "  and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T> {\n    return ZodIntersection.create(this, incoming, this._def);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.transform",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.transform",
    "startLine": 468,
    "endLine": 477,
    "text": "  transform<NewOut>(\n    transform: (arg: Output, ctx: RefinementCtx) => NewOut | Promise<NewOut>\n  ): ZodEffects<this, NewOut> {\n    return new ZodEffects({\n      ...processCreateParams(this._def),\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"transform\", transform },\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.default",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.default",
    "startLine": 481,
    "endLine": 490,
    "text": "  default(def: any) {\n    const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n\n    return new ZodDefault({\n      ...processCreateParams(this._def),\n      innerType: this,\n      defaultValue: defaultValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodDefault,\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.brand",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.brand",
    "startLine": 493,
    "endLine": 499,
    "text": "  brand<B extends string | number | symbol>(): ZodBranded<this, B> {\n    return new ZodBranded({\n      typeName: ZodFirstPartyTypeKind.ZodBranded,\n      type: this,\n      ...processCreateParams(this._def),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.catch",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.catch",
    "startLine": 503,
    "endLine": 512,
    "text": "  catch(def: any) {\n    const catchValueFunc = typeof def === \"function\" ? def : () => def;\n\n    return new ZodCatch({\n      ...processCreateParams(this._def),\n      innerType: this,\n      catchValue: catchValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodCatch,\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.describe",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.describe",
    "startLine": 514,
    "endLine": 520,
    "text": "  describe(description: string): this {\n    const This = (this as any).constructor;\n    return new This({\n      ...this._def,\n      description,\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.pipe",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.pipe",
    "startLine": 522,
    "endLine": 524,
    "text": "  pipe<T extends ZodTypeAny>(target: T): ZodPipeline<this, T> {\n    return ZodPipeline.create(this, target);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.readonly",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.readonly",
    "startLine": 525,
    "endLine": 527,
    "text": "  readonly(): ZodReadonly<this> {\n    return ZodReadonly.create(this);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.isOptional",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.isOptional",
    "startLine": 529,
    "endLine": 531,
    "text": "  isOptional(): boolean {\n    return this.safeParse(undefined).success;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodType.isNullable",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodType.isNullable",
    "startLine": 532,
    "endLine": 534,
    "text": "  isNullable(): boolean {\n    return this.safeParse(null).success;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:timeRegexSource",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "timeRegexSource",
    "startLine": 652,
    "endLine": 662,
    "text": "function timeRegexSource(args: { precision?: number | null }) {\n  let secondsRegexSource = `[0-5]\\\\d`;\n  if (args.precision) {\n    secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n  } else if (args.precision == null) {\n    secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n  }\n\n  const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n  return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:timeRegex",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "timeRegex",
    "startLine": 664,
    "endLine": 670,
    "text": "function timeRegex(args: {\n  offset?: boolean;\n  local?: boolean;\n  precision?: number | null;\n}) {\n  return new RegExp(`^${timeRegexSource(args)}$`);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:datetimeRegex",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "datetimeRegex",
    "startLine": 673,
    "endLine": 685,
    "text": "export function datetimeRegex(args: {\n  precision?: number | null;\n  offset?: boolean;\n  local?: boolean;\n}) {\n  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n\n  const opts: string[] = [];\n  opts.push(args.local ? `Z?` : `Z`);\n  if (args.offset) opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n  regex = `${regex}(${opts.join(\"|\")})`;\n  return new RegExp(`^${regex}$`);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:isValidIP",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "isValidIP",
    "startLine": 687,
    "endLine": 696,
    "text": "function isValidIP(ip: string, version?: IpVersion) {\n  if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n    return true;\n  }\n  if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n    return true;\n  }\n\n  return false;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:isValidJWT",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "isValidJWT",
    "startLine": 698,
    "endLine": 717,
    "text": "function isValidJWT(jwt: string, alg?: string): boolean {\n  if (!jwtRegex.test(jwt)) return false;\n  try {\n    const [header] = jwt.split(\".\");\n    if (!header) return false;\n    // Convert base64url to base64\n    const base64 = header\n      .replace(/-/g, \"+\")\n      .replace(/_/g, \"/\")\n      .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n    const decoded = JSON.parse(atob(base64));\n    if (typeof decoded !== \"object\" || decoded === null) return false;\n    if (\"typ\" in decoded && decoded?.typ !== \"JWT\") return false;\n    if (!decoded.alg) return false;\n    if (alg && decoded.alg !== alg) return false;\n    return true;\n  } catch {\n    return false;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:isValidCidr",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "isValidCidr",
    "startLine": 719,
    "endLine": 728,
    "text": "function isValidCidr(ip: string, version?: IpVersion) {\n  if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n    return true;\n  }\n  if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n    return true;\n  }\n\n  return false;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString",
    "startLine": 730,
    "endLine": 1335,
    "text": "export class ZodString extends ZodType<string, ZodStringDef, string> {\n  _parse(input: ParseInput): ParseReturnType<string> {\n    if (this._def.coerce) {\n      input.data = String(input.data);\n    }\n    const parsedType = this._getType(input);\n\n    if (parsedType !== ZodParsedType.string) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.string,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const status = new ParseStatus();\n    let ctx: undefined | ParseContext = undefined;\n\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.length < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.length > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"length\") {\n        const tooBig = input.data.length > check.value;\n        const tooSmall = input.data.length < check.value;\n        if (tooBig || tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          if (tooBig) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_big,\n              maximum: check.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check.message,\n            });\n          } else if (tooSmall) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_small,\n              minimum: check.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check.message,\n            });\n          }\n          status.dirty();\n        }\n      } else if (check.kind === \"email\") {\n        if (!emailRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"email\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"emoji\") {\n        if (!emojiRegex) {\n          emojiRegex = new RegExp(_emojiRegex, \"u\");\n        }\n        if (!emojiRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"emoji\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"uuid\") {\n        if (!uuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"uuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"nanoid\") {\n        if (!nanoidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"nanoid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid\") {\n        if (!cuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid2\") {\n        if (!cuid2Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid2\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"ulid\") {\n        if (!ulidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ulid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"url\") {\n        try {\n          new URL(input.data);\n        } catch {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"url\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"regex\") {\n        check.regex.lastIndex = 0;\n        const testResult = check.regex.test(input.data);\n        if (!testResult) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"regex\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"trim\") {\n        input.data = input.data.trim();\n      } else if (check.kind === \"includes\") {\n        if (!(input.data as string).includes(check.value, check.position)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { includes: check.value, position: check.position },\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"toLowerCase\") {\n        input.data = input.data.toLowerCase();\n      } else if (check.kind === \"toUpperCase\") {\n        input.data = input.data.toUpperCase();\n      } else if (check.kind === \"startsWith\") {\n        if (!(input.data as string).startsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { startsWith: check.value },\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"endsWith\") {\n        if (!(input.data as string).endsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { endsWith: check.value },\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"datetime\") {\n        const regex = datetimeRegex(check);\n\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"datetime\",\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"date\") {\n        const regex = dateRegex;\n\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"date\",\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"time\") {\n        const regex = timeRegex(check);\n\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"time\",\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"duration\") {\n        if (!durationRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"duration\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"ip\") {\n        if (!isValidIP(input.data, check.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ip\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"jwt\") {\n        if (!isValidJWT(input.data, check.alg)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"jwt\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cidr\") {\n        if (!isValidCidr(input.data, check.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cidr\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"base64\") {\n        if (!base64Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"base64\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"base64url\") {\n        if (!base64urlRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"base64url\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n\n    return { status: status.value, value: input.data };\n  }\n\n  protected _regex(regex: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage) {\n    return this.refinement((data) => regex.test(data), {\n      validation,\n      code: ZodIssueCode.invalid_string,\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  _addCheck(check: ZodStringCheck) {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, check],\n    });\n  }\n\n  email(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n  }\n\n  url(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n  }\n\n  emoji(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n  }\n\n  uuid(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n  }\n  nanoid(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n  }\n  cuid(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n  }\n\n  cuid2(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n  }\n  ulid(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n  }\n  base64(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n  }\n  base64url(message?: errorUtil.ErrMessage) {\n    // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n    return this._addCheck({\n      kind: \"base64url\",\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  jwt(options?: { alg?: string; message?: string | undefined }) {\n    return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n  }\n\n  ip(options?: string | { version?: IpVersion; message?: string | undefined }) {\n    return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n  }\n\n  cidr(options?: string | { version?: IpVersion; message?: string | undefined }) {\n    return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n  }\n\n  datetime(\n    options?:\n      | string\n      | {\n          message?: string | undefined;\n          precision?: number | null;\n          offset?: boolean;\n          local?: boolean;\n        }\n  ) {\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"datetime\",\n        precision: null,\n        offset: false,\n        local: false,\n        message: options,\n      });\n    }\n    return this._addCheck({\n      kind: \"datetime\",\n\n      precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n      offset: options?.offset ?? false,\n      local: options?.local ?? false,\n      ...errorUtil.errToObj(options?.message),\n    });\n  }\n\n  date(message?: string) {\n    return this._addCheck({ kind: \"date\", message });\n  }\n\n  time(\n    options?:\n      | string\n      | {\n          message?: string | undefined;\n          precision?: number | null;\n        }\n  ) {\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"time\",\n        precision: null,\n        message: options,\n      });\n    }\n    return this._addCheck({\n      kind: \"time\",\n      precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n      ...errorUtil.errToObj(options?.message),\n    });\n  }\n\n  duration(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n  }\n\n  regex(regex: RegExp, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"regex\",\n      regex: regex,\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  includes(value: string, options?: { message?: string; position?: number }) {\n    return this._addCheck({\n      kind: \"includes\",\n      value: value,\n      position: options?.position,\n      ...errorUtil.errToObj(options?.message),\n    });\n  }\n\n  startsWith(value: string, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"startsWith\",\n      value: value,\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  endsWith(value: string, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"endsWith\",\n      value: value,\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  min(minLength: number, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minLength,\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  max(maxLength: number, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxLength,\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  length(len: number, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"length\",\n      value: len,\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  /**\n   * Equivalent to `.min(1)`\n   */\n  nonempty(message?: errorUtil.ErrMessage) {\n    return this.min(1, errorUtil.errToObj(message));\n  }\n\n  trim() {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"trim\" }],\n    });\n  }\n\n  toLowerCase() {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n    });\n  }\n\n  toUpperCase() {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n    });\n  }\n\n  get isDatetime() {\n    return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n  }\n\n  get isDate() {\n    return !!this._def.checks.find((ch) => ch.kind === \"date\");\n  }\n\n  get isTime() {\n    return !!this._def.checks.find((ch) => ch.kind === \"time\");\n  }\n  get isDuration() {\n    return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n  }\n\n  get isEmail() {\n    return !!this._def.checks.find((ch) => ch.kind === \"email\");\n  }\n\n  get isURL() {\n    return !!this._def.checks.find((ch) => ch.kind === \"url\");\n  }\n\n  get isEmoji() {\n    return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n  }\n\n  get isUUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n  }\n  get isNANOID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n  }\n\n  get isCUID2() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n  }\n  get isULID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n  }\n  get isIP() {\n    return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n  }\n  get isCIDR() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n  }\n  get isBase64() {\n    return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n  }\n  get isBase64url() {\n    // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n    return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n  }\n\n  get minLength() {\n    let min: number | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      }\n    }\n    return min;\n  }\n\n  get maxLength() {\n    let max: number | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n    return max;\n  }\n\n  static create = (params?: RawCreateParams & { coerce?: true }): ZodString => {\n    return new ZodString({\n      checks: [],\n      typeName: ZodFirstPartyTypeKind.ZodString,\n      coerce: params?.coerce ?? false,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString._parse",
    "startLine": 731,
    "endLine": 1038,
    "text": "  _parse(input: ParseInput): ParseReturnType<string> {\n    if (this._def.coerce) {\n      input.data = String(input.data);\n    }\n    const parsedType = this._getType(input);\n\n    if (parsedType !== ZodParsedType.string) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.string,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const status = new ParseStatus();\n    let ctx: undefined | ParseContext = undefined;\n\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.length < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.length > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"length\") {\n        const tooBig = input.data.length > check.value;\n        const tooSmall = input.data.length < check.value;\n        if (tooBig || tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          if (tooBig) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_big,\n              maximum: check.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check.message,\n            });\n          } else if (tooSmall) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_small,\n              minimum: check.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check.message,\n            });\n          }\n          status.dirty();\n        }\n      } else if (check.kind === \"email\") {\n        if (!emailRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"email\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"emoji\") {\n        if (!emojiRegex) {\n          emojiRegex = new RegExp(_emojiRegex, \"u\");\n        }\n        if (!emojiRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"emoji\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"uuid\") {\n        if (!uuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"uuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"nanoid\") {\n        if (!nanoidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"nanoid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid\") {\n        if (!cuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid2\") {\n        if (!cuid2Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid2\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"ulid\") {\n        if (!ulidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ulid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"url\") {\n        try {\n          new URL(input.data);\n        } catch {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"url\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"regex\") {\n        check.regex.lastIndex = 0;\n        const testResult = check.regex.test(input.data);\n        if (!testResult) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"regex\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"trim\") {\n        input.data = input.data.trim();\n      } else if (check.kind === \"includes\") {\n        if (!(input.data as string).includes(check.value, check.position)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { includes: check.value, position: check.position },\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"toLowerCase\") {\n        input.data = input.data.toLowerCase();\n      } else if (check.kind === \"toUpperCase\") {\n        input.data = input.data.toUpperCase();\n      } else if (check.kind === \"startsWith\") {\n        if (!(input.data as string).startsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { startsWith: check.value },\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"endsWith\") {\n        if (!(input.data as string).endsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { endsWith: check.value },\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"datetime\") {\n        const regex = datetimeRegex(check);\n\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"datetime\",\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"date\") {\n        const regex = dateRegex;\n\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"date\",\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"time\") {\n        const regex = timeRegex(check);\n\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"time\",\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"duration\") {\n        if (!durationRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"duration\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"ip\") {\n        if (!isValidIP(input.data, check.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ip\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"jwt\") {\n        if (!isValidJWT(input.data, check.alg)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"jwt\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cidr\") {\n        if (!isValidCidr(input.data, check.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cidr\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"base64\") {\n        if (!base64Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"base64\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"base64url\") {\n        if (!base64urlRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"base64url\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n\n    return { status: status.value, value: input.data };\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString._regex",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString._regex",
    "startLine": 1040,
    "endLine": 1046,
    "text": "  protected _regex(regex: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage) {\n    return this.refinement((data) => regex.test(data), {\n      validation,\n      code: ZodIssueCode.invalid_string,\n      ...errorUtil.errToObj(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString._addCheck",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString._addCheck",
    "startLine": 1048,
    "endLine": 1053,
    "text": "  _addCheck(check: ZodStringCheck) {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, check],\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.email",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.email",
    "startLine": 1055,
    "endLine": 1057,
    "text": "  email(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.url",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.url",
    "startLine": 1059,
    "endLine": 1061,
    "text": "  url(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.emoji",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.emoji",
    "startLine": 1063,
    "endLine": 1065,
    "text": "  emoji(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.uuid",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.uuid",
    "startLine": 1067,
    "endLine": 1069,
    "text": "  uuid(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.nanoid",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.nanoid",
    "startLine": 1070,
    "endLine": 1072,
    "text": "  nanoid(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.cuid",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.cuid",
    "startLine": 1073,
    "endLine": 1075,
    "text": "  cuid(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.cuid2",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.cuid2",
    "startLine": 1077,
    "endLine": 1079,
    "text": "  cuid2(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.ulid",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.ulid",
    "startLine": 1080,
    "endLine": 1082,
    "text": "  ulid(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.base64",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.base64",
    "startLine": 1083,
    "endLine": 1085,
    "text": "  base64(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.base64url",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.base64url",
    "startLine": 1086,
    "endLine": 1092,
    "text": "  base64url(message?: errorUtil.ErrMessage) {\n    // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n    return this._addCheck({\n      kind: \"base64url\",\n      ...errorUtil.errToObj(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.jwt",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.jwt",
    "startLine": 1094,
    "endLine": 1096,
    "text": "  jwt(options?: { alg?: string; message?: string | undefined }) {\n    return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.ip",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.ip",
    "startLine": 1098,
    "endLine": 1100,
    "text": "  ip(options?: string | { version?: IpVersion; message?: string | undefined }) {\n    return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.cidr",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.cidr",
    "startLine": 1102,
    "endLine": 1104,
    "text": "  cidr(options?: string | { version?: IpVersion; message?: string | undefined }) {\n    return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.datetime",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.datetime",
    "startLine": 1106,
    "endLine": 1133,
    "text": "  datetime(\n    options?:\n      | string\n      | {\n          message?: string | undefined;\n          precision?: number | null;\n          offset?: boolean;\n          local?: boolean;\n        }\n  ) {\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"datetime\",\n        precision: null,\n        offset: false,\n        local: false,\n        message: options,\n      });\n    }\n    return this._addCheck({\n      kind: \"datetime\",\n\n      precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n      offset: options?.offset ?? false,\n      local: options?.local ?? false,\n      ...errorUtil.errToObj(options?.message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.date",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.date",
    "startLine": 1135,
    "endLine": 1137,
    "text": "  date(message?: string) {\n    return this._addCheck({ kind: \"date\", message });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.time",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.time",
    "startLine": 1139,
    "endLine": 1159,
    "text": "  time(\n    options?:\n      | string\n      | {\n          message?: string | undefined;\n          precision?: number | null;\n        }\n  ) {\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"time\",\n        precision: null,\n        message: options,\n      });\n    }\n    return this._addCheck({\n      kind: \"time\",\n      precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n      ...errorUtil.errToObj(options?.message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.duration",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.duration",
    "startLine": 1161,
    "endLine": 1163,
    "text": "  duration(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.regex",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.regex",
    "startLine": 1165,
    "endLine": 1171,
    "text": "  regex(regex: RegExp, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"regex\",\n      regex: regex,\n      ...errorUtil.errToObj(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.includes",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.includes",
    "startLine": 1173,
    "endLine": 1180,
    "text": "  includes(value: string, options?: { message?: string; position?: number }) {\n    return this._addCheck({\n      kind: \"includes\",\n      value: value,\n      position: options?.position,\n      ...errorUtil.errToObj(options?.message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.startsWith",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.startsWith",
    "startLine": 1182,
    "endLine": 1188,
    "text": "  startsWith(value: string, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"startsWith\",\n      value: value,\n      ...errorUtil.errToObj(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.endsWith",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.endsWith",
    "startLine": 1190,
    "endLine": 1196,
    "text": "  endsWith(value: string, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"endsWith\",\n      value: value,\n      ...errorUtil.errToObj(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.min",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.min",
    "startLine": 1198,
    "endLine": 1204,
    "text": "  min(minLength: number, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minLength,\n      ...errorUtil.errToObj(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.max",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.max",
    "startLine": 1206,
    "endLine": 1212,
    "text": "  max(maxLength: number, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxLength,\n      ...errorUtil.errToObj(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.length",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.length",
    "startLine": 1214,
    "endLine": 1220,
    "text": "  length(len: number, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"length\",\n      value: len,\n      ...errorUtil.errToObj(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.nonempty",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.nonempty",
    "startLine": 1225,
    "endLine": 1227,
    "text": "  nonempty(message?: errorUtil.ErrMessage) {\n    return this.min(1, errorUtil.errToObj(message));\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.trim",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.trim",
    "startLine": 1229,
    "endLine": 1234,
    "text": "  trim() {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"trim\" }],\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.toLowerCase",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.toLowerCase",
    "startLine": 1236,
    "endLine": 1241,
    "text": "  toLowerCase() {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodString.toUpperCase",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodString.toUpperCase",
    "startLine": 1243,
    "endLine": 1248,
    "text": "  toUpperCase() {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:floatSafeRemainder",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "floatSafeRemainder",
    "startLine": 1352,
    "endLine": 1359,
    "text": "function floatSafeRemainder(val: number, step: number) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return (valInt % stepInt) / 10 ** decCount;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber",
    "startLine": 1367,
    "endLine": 1613,
    "text": "export class ZodNumber extends ZodType<number, ZodNumberDef, number> {\n  _parse(input: ParseInput): ParseReturnType<number> {\n    if (this._def.coerce) {\n      input.data = Number(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.number) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.number,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    let ctx: undefined | ParseContext = undefined;\n    const status = new ParseStatus();\n\n    for (const check of this._def.checks) {\n      if (check.kind === \"int\") {\n        if (!util.isInteger(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: \"integer\",\n            received: \"float\",\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (floatSafeRemainder(input.data, check.value) !== 0) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"finite\") {\n        if (!Number.isFinite(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_finite,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n\n    return { status: status.value, value: input.data };\n  }\n\n  static create = (params?: RawCreateParams & { coerce?: boolean }): ZodNumber => {\n    return new ZodNumber({\n      checks: [],\n      typeName: ZodFirstPartyTypeKind.ZodNumber,\n      coerce: params?.coerce || false,\n      ...processCreateParams(params),\n    });\n  };\n\n  gte(value: number, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n  }\n  min = this.gte;\n\n  gt(value: number, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n  }\n\n  lte(value: number, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n  }\n  max = this.lte;\n\n  lt(value: number, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n  }\n\n  protected setLimit(kind: \"min\" | \"max\", value: number, inclusive: boolean, message?: string) {\n    return new ZodNumber({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message),\n        },\n      ],\n    });\n  }\n\n  _addCheck(check: ZodNumberCheck) {\n    return new ZodNumber({\n      ...this._def,\n      checks: [...this._def.checks, check],\n    });\n  }\n\n  int(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"int\",\n      message: errorUtil.toString(message),\n    });\n  }\n\n  positive(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  negative(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  nonpositive(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  nonnegative(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  multipleOf(value: number, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value: value,\n      message: errorUtil.toString(message),\n    });\n  }\n  step = this.multipleOf;\n\n  finite(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"finite\",\n      message: errorUtil.toString(message),\n    });\n  }\n\n  safe(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      inclusive: true,\n      value: Number.MIN_SAFE_INTEGER,\n      message: errorUtil.toString(message),\n    })._addCheck({\n      kind: \"max\",\n      inclusive: true,\n      value: Number.MAX_SAFE_INTEGER,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  get minValue() {\n    let min: number | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      }\n    }\n    return min;\n  }\n\n  get maxValue() {\n    let max: number | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n    return max;\n  }\n\n  get isInt() {\n    return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n  }\n\n  get isFinite() {\n    let max: number | null = null;\n    let min: number | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n        return true;\n      } else if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      } else if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n    return Number.isFinite(min) && Number.isFinite(max);\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber._parse",
    "startLine": 1368,
    "endLine": 1451,
    "text": "  _parse(input: ParseInput): ParseReturnType<number> {\n    if (this._def.coerce) {\n      input.data = Number(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.number) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.number,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    let ctx: undefined | ParseContext = undefined;\n    const status = new ParseStatus();\n\n    for (const check of this._def.checks) {\n      if (check.kind === \"int\") {\n        if (!util.isInteger(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: \"integer\",\n            received: \"float\",\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (floatSafeRemainder(input.data, check.value) !== 0) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"finite\") {\n        if (!Number.isFinite(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_finite,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n\n    return { status: status.value, value: input.data };\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber.gte",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber.gte",
    "startLine": 1462,
    "endLine": 1464,
    "text": "  gte(value: number, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber.gt",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber.gt",
    "startLine": 1467,
    "endLine": 1469,
    "text": "  gt(value: number, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber.lte",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber.lte",
    "startLine": 1471,
    "endLine": 1473,
    "text": "  lte(value: number, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber.lt",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber.lt",
    "startLine": 1476,
    "endLine": 1478,
    "text": "  lt(value: number, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber.setLimit",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber.setLimit",
    "startLine": 1480,
    "endLine": 1493,
    "text": "  protected setLimit(kind: \"min\" | \"max\", value: number, inclusive: boolean, message?: string) {\n    return new ZodNumber({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message),\n        },\n      ],\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber._addCheck",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber._addCheck",
    "startLine": 1495,
    "endLine": 1500,
    "text": "  _addCheck(check: ZodNumberCheck) {\n    return new ZodNumber({\n      ...this._def,\n      checks: [...this._def.checks, check],\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber.int",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber.int",
    "startLine": 1502,
    "endLine": 1507,
    "text": "  int(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"int\",\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber.positive",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber.positive",
    "startLine": 1509,
    "endLine": 1516,
    "text": "  positive(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber.negative",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber.negative",
    "startLine": 1518,
    "endLine": 1525,
    "text": "  negative(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber.nonpositive",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber.nonpositive",
    "startLine": 1527,
    "endLine": 1534,
    "text": "  nonpositive(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber.nonnegative",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber.nonnegative",
    "startLine": 1536,
    "endLine": 1543,
    "text": "  nonnegative(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber.multipleOf",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber.multipleOf",
    "startLine": 1545,
    "endLine": 1551,
    "text": "  multipleOf(value: number, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value: value,\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber.finite",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber.finite",
    "startLine": 1554,
    "endLine": 1559,
    "text": "  finite(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"finite\",\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNumber.safe",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNumber.safe",
    "startLine": 1561,
    "endLine": 1573,
    "text": "  safe(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      inclusive: true,\n      value: Number.MIN_SAFE_INTEGER,\n      message: errorUtil.toString(message),\n    })._addCheck({\n      kind: \"max\",\n      inclusive: true,\n      value: Number.MAX_SAFE_INTEGER,\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBigInt",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBigInt",
    "startLine": 1633,
    "endLine": 1817,
    "text": "export class ZodBigInt extends ZodType<bigint, ZodBigIntDef, bigint> {\n  _parse(input: ParseInput): ParseReturnType<bigint> {\n    if (this._def.coerce) {\n      try {\n        input.data = BigInt(input.data);\n      } catch {\n        return this._getInvalidInput(input);\n      }\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.bigint) {\n      return this._getInvalidInput(input);\n    }\n\n    let ctx: undefined | ParseContext = undefined;\n    const status = new ParseStatus();\n\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            type: \"bigint\",\n            minimum: check.value,\n            inclusive: check.inclusive,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            type: \"bigint\",\n            maximum: check.value,\n            inclusive: check.inclusive,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (input.data % check.value !== BigInt(0)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n\n    return { status: status.value, value: input.data };\n  }\n\n  _getInvalidInput(input: ParseInput) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.bigint,\n      received: ctx.parsedType,\n    });\n    return INVALID;\n  }\n\n  static create = (params?: RawCreateParams & { coerce?: boolean }): ZodBigInt => {\n    return new ZodBigInt({\n      checks: [],\n      typeName: ZodFirstPartyTypeKind.ZodBigInt,\n      coerce: params?.coerce ?? false,\n      ...processCreateParams(params),\n    });\n  };\n\n  gte(value: bigint, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n  }\n  min = this.gte;\n\n  gt(value: bigint, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n  }\n\n  lte(value: bigint, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n  }\n  max = this.lte;\n\n  lt(value: bigint, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n  }\n\n  protected setLimit(kind: \"min\" | \"max\", value: bigint, inclusive: boolean, message?: string) {\n    return new ZodBigInt({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message),\n        },\n      ],\n    });\n  }\n\n  _addCheck(check: ZodBigIntCheck) {\n    return new ZodBigInt({\n      ...this._def,\n      checks: [...this._def.checks, check],\n    });\n  }\n\n  positive(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  negative(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  nonpositive(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  nonnegative(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  multipleOf(value: bigint, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  get minValue() {\n    let min: bigint | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      }\n    }\n    return min;\n  }\n\n  get maxValue() {\n    let max: bigint | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n    return max;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBigInt._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBigInt._parse",
    "startLine": 1634,
    "endLine": 1693,
    "text": "  _parse(input: ParseInput): ParseReturnType<bigint> {\n    if (this._def.coerce) {\n      try {\n        input.data = BigInt(input.data);\n      } catch {\n        return this._getInvalidInput(input);\n      }\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.bigint) {\n      return this._getInvalidInput(input);\n    }\n\n    let ctx: undefined | ParseContext = undefined;\n    const status = new ParseStatus();\n\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            type: \"bigint\",\n            minimum: check.value,\n            inclusive: check.inclusive,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            type: \"bigint\",\n            maximum: check.value,\n            inclusive: check.inclusive,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (input.data % check.value !== BigInt(0)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n\n    return { status: status.value, value: input.data };\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBigInt._getInvalidInput",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBigInt._getInvalidInput",
    "startLine": 1695,
    "endLine": 1703,
    "text": "  _getInvalidInput(input: ParseInput) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.bigint,\n      received: ctx.parsedType,\n    });\n    return INVALID;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBigInt.gte",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBigInt.gte",
    "startLine": 1714,
    "endLine": 1716,
    "text": "  gte(value: bigint, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBigInt.gt",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBigInt.gt",
    "startLine": 1719,
    "endLine": 1721,
    "text": "  gt(value: bigint, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBigInt.lte",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBigInt.lte",
    "startLine": 1723,
    "endLine": 1725,
    "text": "  lte(value: bigint, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBigInt.lt",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBigInt.lt",
    "startLine": 1728,
    "endLine": 1730,
    "text": "  lt(value: bigint, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBigInt.setLimit",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBigInt.setLimit",
    "startLine": 1732,
    "endLine": 1745,
    "text": "  protected setLimit(kind: \"min\" | \"max\", value: bigint, inclusive: boolean, message?: string) {\n    return new ZodBigInt({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message),\n        },\n      ],\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBigInt._addCheck",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBigInt._addCheck",
    "startLine": 1747,
    "endLine": 1752,
    "text": "  _addCheck(check: ZodBigIntCheck) {\n    return new ZodBigInt({\n      ...this._def,\n      checks: [...this._def.checks, check],\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBigInt.positive",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBigInt.positive",
    "startLine": 1754,
    "endLine": 1761,
    "text": "  positive(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBigInt.negative",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBigInt.negative",
    "startLine": 1763,
    "endLine": 1770,
    "text": "  negative(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBigInt.nonpositive",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBigInt.nonpositive",
    "startLine": 1772,
    "endLine": 1779,
    "text": "  nonpositive(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBigInt.nonnegative",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBigInt.nonnegative",
    "startLine": 1781,
    "endLine": 1788,
    "text": "  nonnegative(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBigInt.multipleOf",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBigInt.multipleOf",
    "startLine": 1790,
    "endLine": 1796,
    "text": "  multipleOf(value: bigint, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBoolean",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBoolean",
    "startLine": 1831,
    "endLine": 1857,
    "text": "export class ZodBoolean extends ZodType<boolean, ZodBooleanDef, boolean> {\n  _parse(input: ParseInput): ParseReturnType<boolean> {\n    if (this._def.coerce) {\n      input.data = Boolean(input.data);\n    }\n    const parsedType = this._getType(input);\n\n    if (parsedType !== ZodParsedType.boolean) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.boolean,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n\n  static create = (params?: RawCreateParams & { coerce?: boolean }): ZodBoolean => {\n    return new ZodBoolean({\n      typeName: ZodFirstPartyTypeKind.ZodBoolean,\n      coerce: params?.coerce || false,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBoolean._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBoolean._parse",
    "startLine": 1832,
    "endLine": 1848,
    "text": "  _parse(input: ParseInput): ParseReturnType<boolean> {\n    if (this._def.coerce) {\n      input.data = Boolean(input.data);\n    }\n    const parsedType = this._getType(input);\n\n    if (parsedType !== ZodParsedType.boolean) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.boolean,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodDate",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodDate",
    "startLine": 1875,
    "endLine": 1994,
    "text": "export class ZodDate extends ZodType<Date, ZodDateDef, Date> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    if (this._def.coerce) {\n      input.data = new Date(input.data);\n    }\n    const parsedType = this._getType(input);\n\n    if (parsedType !== ZodParsedType.date) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.date,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    if (Number.isNaN(input.data.getTime())) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_date,\n      });\n      return INVALID;\n    }\n\n    const status = new ParseStatus();\n    let ctx: undefined | ParseContext = undefined;\n\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.getTime() < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            minimum: check.value,\n            type: \"date\",\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.getTime() > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            maximum: check.value,\n            type: \"date\",\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n\n    return {\n      status: status.value,\n      value: new Date((input.data as Date).getTime()),\n    };\n  }\n\n  _addCheck(check: ZodDateCheck) {\n    return new ZodDate({\n      ...this._def,\n      checks: [...this._def.checks, check],\n    });\n  }\n\n  min(minDate: Date, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minDate.getTime(),\n      message: errorUtil.toString(message),\n    });\n  }\n\n  max(maxDate: Date, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxDate.getTime(),\n      message: errorUtil.toString(message),\n    });\n  }\n\n  get minDate() {\n    let min: number | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      }\n    }\n\n    return min != null ? new Date(min) : null;\n  }\n\n  get maxDate() {\n    let max: number | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n\n    return max != null ? new Date(max) : null;\n  }\n\n  static create = (params?: RawCreateParams & { coerce?: boolean }): ZodDate => {\n    return new ZodDate({\n      checks: [],\n      coerce: params?.coerce || false,\n      typeName: ZodFirstPartyTypeKind.ZodDate,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodDate._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodDate._parse",
    "startLine": 1876,
    "endLine": 1939,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    if (this._def.coerce) {\n      input.data = new Date(input.data);\n    }\n    const parsedType = this._getType(input);\n\n    if (parsedType !== ZodParsedType.date) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.date,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    if (Number.isNaN(input.data.getTime())) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_date,\n      });\n      return INVALID;\n    }\n\n    const status = new ParseStatus();\n    let ctx: undefined | ParseContext = undefined;\n\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.getTime() < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            minimum: check.value,\n            type: \"date\",\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.getTime() > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            maximum: check.value,\n            type: \"date\",\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n\n    return {\n      status: status.value,\n      value: new Date((input.data as Date).getTime()),\n    };\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodDate._addCheck",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodDate._addCheck",
    "startLine": 1941,
    "endLine": 1946,
    "text": "  _addCheck(check: ZodDateCheck) {\n    return new ZodDate({\n      ...this._def,\n      checks: [...this._def.checks, check],\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodDate.min",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodDate.min",
    "startLine": 1948,
    "endLine": 1954,
    "text": "  min(minDate: Date, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minDate.getTime(),\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodDate.max",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodDate.max",
    "startLine": 1956,
    "endLine": 1962,
    "text": "  max(maxDate: Date, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxDate.getTime(),\n      message: errorUtil.toString(message),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodSymbol",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodSymbol",
    "startLine": 2007,
    "endLine": 2029,
    "text": "export class ZodSymbol extends ZodType<symbol, ZodSymbolDef, symbol> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.symbol) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.symbol,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    return OK(input.data);\n  }\n\n  static create = (params?: RawCreateParams): ZodSymbol => {\n    return new ZodSymbol({\n      typeName: ZodFirstPartyTypeKind.ZodSymbol,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodSymbol._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodSymbol._parse",
    "startLine": 2008,
    "endLine": 2021,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.symbol) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.symbol,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    return OK(input.data);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodUndefined",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodUndefined",
    "startLine": 2042,
    "endLine": 2064,
    "text": "export class ZodUndefined extends ZodType<undefined, ZodUndefinedDef, undefined> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.undefined,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  params?: RawCreateParams;\n\n  static create = (params?: RawCreateParams): ZodUndefined => {\n    return new ZodUndefined({\n      typeName: ZodFirstPartyTypeKind.ZodUndefined,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodUndefined._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodUndefined._parse",
    "startLine": 2043,
    "endLine": 2055,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.undefined,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNull",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNull",
    "startLine": 2077,
    "endLine": 2097,
    "text": "export class ZodNull extends ZodType<null, ZodNullDef, null> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.null) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.null,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  static create = (params?: RawCreateParams): ZodNull => {\n    return new ZodNull({\n      typeName: ZodFirstPartyTypeKind.ZodNull,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNull._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNull._parse",
    "startLine": 2078,
    "endLine": 2090,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.null) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.null,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodAny",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodAny",
    "startLine": 2110,
    "endLine": 2122,
    "text": "export class ZodAny extends ZodType<any, ZodAnyDef, any> {\n  // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n  _any = true as const;\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    return OK(input.data);\n  }\n  static create = (params?: RawCreateParams): ZodAny => {\n    return new ZodAny({\n      typeName: ZodFirstPartyTypeKind.ZodAny,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodAny._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodAny._parse",
    "startLine": 2113,
    "endLine": 2115,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    return OK(input.data);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodUnknown",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodUnknown",
    "startLine": 2135,
    "endLine": 2148,
    "text": "export class ZodUnknown extends ZodType<unknown, ZodUnknownDef, unknown> {\n  // required\n  _unknown = true as const;\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    return OK(input.data);\n  }\n\n  static create = (params?: RawCreateParams): ZodUnknown => {\n    return new ZodUnknown({\n      typeName: ZodFirstPartyTypeKind.ZodUnknown,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodUnknown._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodUnknown._parse",
    "startLine": 2138,
    "endLine": 2140,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    return OK(input.data);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNever",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNever",
    "startLine": 2161,
    "endLine": 2177,
    "text": "export class ZodNever extends ZodType<never, ZodNeverDef, never> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.never,\n      received: ctx.parsedType,\n    });\n    return INVALID;\n  }\n  static create = (params?: RawCreateParams): ZodNever => {\n    return new ZodNever({\n      typeName: ZodFirstPartyTypeKind.ZodNever,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNever._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNever._parse",
    "startLine": 2162,
    "endLine": 2170,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.never,\n      received: ctx.parsedType,\n    });\n    return INVALID;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodVoid",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodVoid",
    "startLine": 2190,
    "endLine": 2211,
    "text": "export class ZodVoid extends ZodType<void, ZodVoidDef, void> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.void,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n\n  static create = (params?: RawCreateParams): ZodVoid => {\n    return new ZodVoid({\n      typeName: ZodFirstPartyTypeKind.ZodVoid,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodVoid._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodVoid._parse",
    "startLine": 2191,
    "endLine": 2203,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.void,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodArray",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodArray",
    "startLine": 2234,
    "endLine": 2354,
    "text": "export class ZodArray<T extends ZodTypeAny, Cardinality extends ArrayCardinality = \"many\"> extends ZodType<\n  arrayOutputType<T, Cardinality>,\n  ZodArrayDef<T>,\n  Cardinality extends \"atleastone\" ? [T[\"_input\"], ...T[\"_input\"][]] : T[\"_input\"][]\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx, status } = this._processInputParams(input);\n\n    const def = this._def;\n\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    if (def.exactLength !== null) {\n      const tooBig = ctx.data.length > def.exactLength.value;\n      const tooSmall = ctx.data.length < def.exactLength.value;\n      if (tooBig || tooSmall) {\n        addIssueToContext(ctx, {\n          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n          minimum: (tooSmall ? def.exactLength.value : undefined) as number,\n          maximum: (tooBig ? def.exactLength.value : undefined) as number,\n          type: \"array\",\n          inclusive: true,\n          exact: true,\n          message: def.exactLength.message,\n        });\n        status.dirty();\n      }\n    }\n\n    if (def.minLength !== null) {\n      if (ctx.data.length < def.minLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.minLength.message,\n        });\n        status.dirty();\n      }\n    }\n\n    if (def.maxLength !== null) {\n      if (ctx.data.length > def.maxLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.maxLength.message,\n        });\n        status.dirty();\n      }\n    }\n\n    if (ctx.common.async) {\n      return Promise.all(\n        ([...ctx.data] as any[]).map((item, i) => {\n          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        })\n      ).then((result) => {\n        return ParseStatus.mergeArray(status, result);\n      });\n    }\n\n    const result = ([...ctx.data] as any[]).map((item, i) => {\n      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n    });\n\n    return ParseStatus.mergeArray(status, result);\n  }\n\n  get element() {\n    return this._def.type;\n  }\n\n  min(minLength: number, message?: errorUtil.ErrMessage): this {\n    return new ZodArray({\n      ...this._def,\n      minLength: { value: minLength, message: errorUtil.toString(message) },\n    }) as any;\n  }\n\n  max(maxLength: number, message?: errorUtil.ErrMessage): this {\n    return new ZodArray({\n      ...this._def,\n      maxLength: { value: maxLength, message: errorUtil.toString(message) },\n    }) as any;\n  }\n\n  length(len: number, message?: errorUtil.ErrMessage): this {\n    return new ZodArray({\n      ...this._def,\n      exactLength: { value: len, message: errorUtil.toString(message) },\n    }) as any;\n  }\n\n  nonempty(message?: errorUtil.ErrMessage): ZodArray<T, \"atleastone\"> {\n    return this.min(1, message) as any;\n  }\n\n  static create = <El extends ZodTypeAny>(schema: El, params?: RawCreateParams): ZodArray<El> => {\n    return new ZodArray({\n      type: schema,\n      minLength: null,\n      maxLength: null,\n      exactLength: null,\n      typeName: ZodFirstPartyTypeKind.ZodArray,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodArray._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodArray._parse",
    "startLine": 2239,
    "endLine": 2313,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx, status } = this._processInputParams(input);\n\n    const def = this._def;\n\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    if (def.exactLength !== null) {\n      const tooBig = ctx.data.length > def.exactLength.value;\n      const tooSmall = ctx.data.length < def.exactLength.value;\n      if (tooBig || tooSmall) {\n        addIssueToContext(ctx, {\n          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n          minimum: (tooSmall ? def.exactLength.value : undefined) as number,\n          maximum: (tooBig ? def.exactLength.value : undefined) as number,\n          type: \"array\",\n          inclusive: true,\n          exact: true,\n          message: def.exactLength.message,\n        });\n        status.dirty();\n      }\n    }\n\n    if (def.minLength !== null) {\n      if (ctx.data.length < def.minLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.minLength.message,\n        });\n        status.dirty();\n      }\n    }\n\n    if (def.maxLength !== null) {\n      if (ctx.data.length > def.maxLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.maxLength.message,\n        });\n        status.dirty();\n      }\n    }\n\n    if (ctx.common.async) {\n      return Promise.all(\n        ([...ctx.data] as any[]).map((item, i) => {\n          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        })\n      ).then((result) => {\n        return ParseStatus.mergeArray(status, result);\n      });\n    }\n\n    const result = ([...ctx.data] as any[]).map((item, i) => {\n      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n    });\n\n    return ParseStatus.mergeArray(status, result);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodArray.min",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodArray.min",
    "startLine": 2319,
    "endLine": 2324,
    "text": "  min(minLength: number, message?: errorUtil.ErrMessage): this {\n    return new ZodArray({\n      ...this._def,\n      minLength: { value: minLength, message: errorUtil.toString(message) },\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodArray.max",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodArray.max",
    "startLine": 2326,
    "endLine": 2331,
    "text": "  max(maxLength: number, message?: errorUtil.ErrMessage): this {\n    return new ZodArray({\n      ...this._def,\n      maxLength: { value: maxLength, message: errorUtil.toString(message) },\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodArray.length",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodArray.length",
    "startLine": 2333,
    "endLine": 2338,
    "text": "  length(len: number, message?: errorUtil.ErrMessage): this {\n    return new ZodArray({\n      ...this._def,\n      exactLength: { value: len, message: errorUtil.toString(message) },\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodArray.nonempty",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodArray.nonempty",
    "startLine": 2340,
    "endLine": 2342,
    "text": "  nonempty(message?: errorUtil.ErrMessage): ZodArray<T, \"atleastone\"> {\n    return this.min(1, message) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:deepPartialify",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "deepPartialify",
    "startLine": 2422,
    "endLine": 2448,
    "text": "function deepPartialify(schema: ZodTypeAny): any {\n  if (schema instanceof ZodObject) {\n    const newShape: any = {};\n\n    for (const key in schema.shape) {\n      const fieldSchema = schema.shape[key];\n      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n    }\n    return new ZodObject({\n      ...schema._def,\n      shape: () => newShape,\n    }) as any;\n  } else if (schema instanceof ZodArray) {\n    return new ZodArray({\n      ...schema._def,\n      type: deepPartialify(schema.element),\n    });\n  } else if (schema instanceof ZodOptional) {\n    return ZodOptional.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodNullable) {\n    return ZodNullable.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodTuple) {\n    return ZodTuple.create(schema.items.map((item: any) => deepPartialify(item)));\n  } else {\n    return schema;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject",
    "startLine": 2450,
    "endLine": 2922,
    "text": "export class ZodObject<\n  T extends ZodRawShape,\n  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,\n  Catchall extends ZodTypeAny = ZodTypeAny,\n  Output = objectOutputType<T, Catchall, UnknownKeys>,\n  Input = objectInputType<T, Catchall, UnknownKeys>,\n> extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {\n  private _cached: { shape: T; keys: string[] } | null = null;\n\n  _getCached(): { shape: T; keys: string[] } {\n    if (this._cached !== null) return this._cached;\n    const shape = this._def.shape();\n    const keys = util.objectKeys(shape);\n    this._cached = { shape, keys };\n    return this._cached;\n  }\n\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.object) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const { status, ctx } = this._processInputParams(input);\n\n    const { shape, keys: shapeKeys } = this._getCached();\n    const extraKeys: string[] = [];\n\n    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n      for (const key in ctx.data) {\n        if (!shapeKeys.includes(key)) {\n          extraKeys.push(key);\n        }\n      }\n    }\n\n    const pairs: {\n      key: ParseReturnType<any>;\n      value: ParseReturnType<any>;\n      alwaysSet?: boolean;\n    }[] = [];\n    for (const key of shapeKeys) {\n      const keyValidator = shape[key]!;\n      const value = ctx.data[key];\n      pairs.push({\n        key: { status: \"valid\", value: key },\n        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n        alwaysSet: key in ctx.data,\n      });\n    }\n\n    if (this._def.catchall instanceof ZodNever) {\n      const unknownKeys = this._def.unknownKeys;\n\n      if (unknownKeys === \"passthrough\") {\n        for (const key of extraKeys) {\n          pairs.push({\n            key: { status: \"valid\", value: key },\n            value: { status: \"valid\", value: ctx.data[key] },\n          });\n        }\n      } else if (unknownKeys === \"strict\") {\n        if (extraKeys.length > 0) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.unrecognized_keys,\n            keys: extraKeys,\n          });\n          status.dirty();\n        }\n      } else if (unknownKeys === \"strip\") {\n      } else {\n        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n      }\n    } else {\n      // run catchall validation\n      const catchall = this._def.catchall;\n\n      for (const key of extraKeys) {\n        const value = ctx.data[key];\n        pairs.push({\n          key: { status: \"valid\", value: key },\n          value: catchall._parse(\n            new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n          ),\n          alwaysSet: key in ctx.data,\n        });\n      }\n    }\n\n    if (ctx.common.async) {\n      return Promise.resolve()\n        .then(async () => {\n          const syncPairs: any[] = [];\n          for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n              key,\n              value,\n              alwaysSet: pair.alwaysSet,\n            });\n          }\n          return syncPairs;\n        })\n        .then((syncPairs) => {\n          return ParseStatus.mergeObjectSync(status, syncPairs);\n        });\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs as any);\n    }\n  }\n\n  get shape() {\n    return this._def.shape();\n  }\n\n  strict(message?: errorUtil.ErrMessage): ZodObject<T, \"strict\", Catchall> {\n    errorUtil.errToObj;\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"strict\",\n      ...(message !== undefined\n        ? {\n            errorMap: (issue, ctx) => {\n              const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n              if (issue.code === \"unrecognized_keys\")\n                return {\n                  message: errorUtil.errToObj(message).message ?? defaultError,\n                };\n              return {\n                message: defaultError,\n              };\n            },\n          }\n        : {}),\n    }) as any;\n  }\n\n  strip(): ZodObject<T, \"strip\", Catchall> {\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"strip\",\n    }) as any;\n  }\n\n  passthrough(): ZodObject<T, \"passthrough\", Catchall> {\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"passthrough\",\n    }) as any;\n  }\n\n  /**\n   * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n   * If you want to pass through unknown properties, use `.passthrough()` instead.\n   */\n  nonstrict = this.passthrough;\n\n  // const AugmentFactory =\n  //   <Def extends ZodObjectDef>(def: Def) =>\n  //   <Augmentation extends ZodRawShape>(\n  //     augmentation: Augmentation\n  //   ): ZodObject<\n  //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n  //     Def[\"unknownKeys\"],\n  //     Def[\"catchall\"]\n  //   > => {\n  //     return new ZodObject({\n  //       ...def,\n  //       shape: () => ({\n  //         ...def.shape(),\n  //         ...augmentation,\n  //       }),\n  //     }) as any;\n  //   };\n  extend<Augmentation extends ZodRawShape>(\n    augmentation: Augmentation\n  ): ZodObject<objectUtil.extendShape<T, Augmentation>, UnknownKeys, Catchall> {\n    return new ZodObject({\n      ...this._def,\n      shape: () => ({\n        ...this._def.shape(),\n        ...augmentation,\n      }),\n    }) as any;\n  }\n  // extend<\n  //   Augmentation extends ZodRawShape,\n  //   NewOutput extends util.flatten<{\n  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_output\"]\n  //       : k extends keyof Output\n  //       ? Output[k]\n  //       : never;\n  //   }>,\n  //   NewInput extends util.flatten<{\n  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_input\"]\n  //       : k extends keyof Input\n  //       ? Input[k]\n  //       : never;\n  //   }>\n  // >(\n  //   augmentation: Augmentation\n  // ): ZodObject<\n  //   extendShape<T, Augmentation>,\n  //   UnknownKeys,\n  //   Catchall,\n  //   NewOutput,\n  //   NewInput\n  // > {\n  //   return new ZodObject({\n  //     ...this._def,\n  //     shape: () => ({\n  //       ...this._def.shape(),\n  //       ...augmentation,\n  //     }),\n  //   }) as any;\n  // }\n  /**\n   * @deprecated Use `.extend` instead\n   *  */\n  augment = this.extend;\n\n  /**\n   * Prior to zod@1.0.12 there was a bug in the\n   * inferred type of merged objects. Please\n   * upgrade if you are experiencing issues.\n   */\n  merge<Incoming extends AnyZodObject, Augmentation extends Incoming[\"shape\"]>(\n    merging: Incoming\n  ): ZodObject<objectUtil.extendShape<T, Augmentation>, Incoming[\"_def\"][\"unknownKeys\"], Incoming[\"_def\"][\"catchall\"]> {\n    const merged: any = new ZodObject({\n      unknownKeys: merging._def.unknownKeys,\n      catchall: merging._def.catchall,\n      shape: () => ({\n        ...this._def.shape(),\n        ...merging._def.shape(),\n      }),\n      typeName: ZodFirstPartyTypeKind.ZodObject,\n    }) as any;\n    return merged;\n  }\n  // merge<\n  //   Incoming extends AnyZodObject,\n  //   Augmentation extends Incoming[\"shape\"],\n  //   NewOutput extends {\n  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_output\"]\n  //       : k extends keyof Output\n  //       ? Output[k]\n  //       : never;\n  //   },\n  //   NewInput extends {\n  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_input\"]\n  //       : k extends keyof Input\n  //       ? Input[k]\n  //       : never;\n  //   }\n  // >(\n  //   merging: Incoming\n  // ): ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"],\n  //   NewOutput,\n  //   NewInput\n  // > {\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n\n  setKey<Key extends string, Schema extends ZodTypeAny>(\n    key: Key,\n    schema: Schema\n  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> {\n    return this.augment({ [key]: schema }) as any;\n  }\n  // merge<Incoming extends AnyZodObject>(\n  //   merging: Incoming\n  // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n  // ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"]\n  // > {\n  //   // const mergedShape = objectUtil.mergeShapes(\n  //   //   this._def.shape(),\n  //   //   merging._def.shape()\n  //   // );\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n\n  catchall<Index extends ZodTypeAny>(index: Index): ZodObject<T, UnknownKeys, Index> {\n    return new ZodObject({\n      ...this._def,\n      catchall: index,\n    }) as any;\n  }\n\n  pick<Mask extends util.Exactly<{ [k in keyof T]?: true }, Mask>>(\n    mask: Mask\n  ): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall> {\n    const shape: any = {};\n\n    for (const key of util.objectKeys(mask)) {\n      if (mask[key] && this.shape[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n\n    return new ZodObject({\n      ...this._def,\n      shape: () => shape,\n    }) as any;\n  }\n\n  omit<Mask extends util.Exactly<{ [k in keyof T]?: true }, Mask>>(\n    mask: Mask\n  ): ZodObject<Omit<T, keyof Mask>, UnknownKeys, Catchall> {\n    const shape: any = {};\n\n    for (const key of util.objectKeys(this.shape)) {\n      if (!mask[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n\n    return new ZodObject({\n      ...this._def,\n      shape: () => shape,\n    }) as any;\n  }\n\n  /**\n   * @deprecated\n   */\n  deepPartial(): partialUtil.DeepPartial<this> {\n    return deepPartialify(this);\n  }\n\n  partial(): ZodObject<{ [k in keyof T]: ZodOptional<T[k]> }, UnknownKeys, Catchall>;\n  partial<Mask extends util.Exactly<{ [k in keyof T]?: true }, Mask>>(\n    mask: Mask\n  ): ZodObject<\n    objectUtil.noNever<{\n      [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];\n    }>,\n    UnknownKeys,\n    Catchall\n  >;\n  partial(mask?: any) {\n    const newShape: any = {};\n\n    for (const key of util.objectKeys(this.shape)) {\n      const fieldSchema = this.shape[key]!;\n\n      if (mask && !mask[key]) {\n        newShape[key] = fieldSchema;\n      } else {\n        newShape[key] = fieldSchema.optional();\n      }\n    }\n\n    return new ZodObject({\n      ...this._def,\n      shape: () => newShape,\n    }) as any;\n  }\n\n  required(): ZodObject<{ [k in keyof T]: deoptional<T[k]> }, UnknownKeys, Catchall>;\n  required<Mask extends util.Exactly<{ [k in keyof T]?: true }, Mask>>(\n    mask: Mask\n  ): ZodObject<\n    objectUtil.noNever<{\n      [k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];\n    }>,\n    UnknownKeys,\n    Catchall\n  >;\n  required(mask?: any) {\n    const newShape: any = {};\n\n    for (const key of util.objectKeys(this.shape)) {\n      if (mask && !mask[key]) {\n        newShape[key] = this.shape[key];\n      } else {\n        const fieldSchema = this.shape[key];\n        let newField = fieldSchema;\n\n        while (newField instanceof ZodOptional) {\n          newField = (newField as ZodOptional<any>)._def.innerType;\n        }\n\n        newShape[key] = newField;\n      }\n    }\n\n    return new ZodObject({\n      ...this._def,\n      shape: () => newShape,\n    }) as any;\n  }\n\n  keyof(): ZodEnum<enumUtil.UnionToTupleString<keyof T>> {\n    return createZodEnum(util.objectKeys(this.shape) as [string, ...string[]]) as any;\n  }\n\n  static create = <Shape extends ZodRawShape>(\n    shape: Shape,\n    params?: RawCreateParams\n  ): ZodObject<\n    Shape,\n    \"strip\",\n    ZodTypeAny,\n    objectOutputType<Shape, ZodTypeAny, \"strip\">,\n    objectInputType<Shape, ZodTypeAny, \"strip\">\n  > => {\n    return new ZodObject({\n      shape: () => shape,\n      unknownKeys: \"strip\",\n      catchall: ZodNever.create(),\n      typeName: ZodFirstPartyTypeKind.ZodObject,\n      ...processCreateParams(params),\n    }) as any;\n  };\n\n  static strictCreate = <Shape extends ZodRawShape>(\n    shape: Shape,\n    params?: RawCreateParams\n  ): ZodObject<Shape, \"strict\"> => {\n    return new ZodObject({\n      shape: () => shape,\n      unknownKeys: \"strict\",\n      catchall: ZodNever.create(),\n      typeName: ZodFirstPartyTypeKind.ZodObject,\n      ...processCreateParams(params),\n    }) as any;\n  };\n\n  static lazycreate = <Shape extends ZodRawShape>(\n    shape: () => Shape,\n    params?: RawCreateParams\n  ): ZodObject<Shape, \"strip\"> => {\n    return new ZodObject({\n      shape,\n      unknownKeys: \"strip\",\n      catchall: ZodNever.create(),\n      typeName: ZodFirstPartyTypeKind.ZodObject,\n      ...processCreateParams(params),\n    }) as any;\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject._getCached",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject._getCached",
    "startLine": 2459,
    "endLine": 2465,
    "text": "  _getCached(): { shape: T; keys: string[] } {\n    if (this._cached !== null) return this._cached;\n    const shape = this._def.shape();\n    const keys = util.objectKeys(shape);\n    this._cached = { shape, keys };\n    return this._cached;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject._parse",
    "startLine": 2467,
    "endLine": 2566,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.object) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const { status, ctx } = this._processInputParams(input);\n\n    const { shape, keys: shapeKeys } = this._getCached();\n    const extraKeys: string[] = [];\n\n    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n      for (const key in ctx.data) {\n        if (!shapeKeys.includes(key)) {\n          extraKeys.push(key);\n        }\n      }\n    }\n\n    const pairs: {\n      key: ParseReturnType<any>;\n      value: ParseReturnType<any>;\n      alwaysSet?: boolean;\n    }[] = [];\n    for (const key of shapeKeys) {\n      const keyValidator = shape[key]!;\n      const value = ctx.data[key];\n      pairs.push({\n        key: { status: \"valid\", value: key },\n        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n        alwaysSet: key in ctx.data,\n      });\n    }\n\n    if (this._def.catchall instanceof ZodNever) {\n      const unknownKeys = this._def.unknownKeys;\n\n      if (unknownKeys === \"passthrough\") {\n        for (const key of extraKeys) {\n          pairs.push({\n            key: { status: \"valid\", value: key },\n            value: { status: \"valid\", value: ctx.data[key] },\n          });\n        }\n      } else if (unknownKeys === \"strict\") {\n        if (extraKeys.length > 0) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.unrecognized_keys,\n            keys: extraKeys,\n          });\n          status.dirty();\n        }\n      } else if (unknownKeys === \"strip\") {\n      } else {\n        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n      }\n    } else {\n      // run catchall validation\n      const catchall = this._def.catchall;\n\n      for (const key of extraKeys) {\n        const value = ctx.data[key];\n        pairs.push({\n          key: { status: \"valid\", value: key },\n          value: catchall._parse(\n            new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n          ),\n          alwaysSet: key in ctx.data,\n        });\n      }\n    }\n\n    if (ctx.common.async) {\n      return Promise.resolve()\n        .then(async () => {\n          const syncPairs: any[] = [];\n          for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n              key,\n              value,\n              alwaysSet: pair.alwaysSet,\n            });\n          }\n          return syncPairs;\n        })\n        .then((syncPairs) => {\n          return ParseStatus.mergeObjectSync(status, syncPairs);\n        });\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs as any);\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject.strict",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject.strict",
    "startLine": 2572,
    "endLine": 2592,
    "text": "  strict(message?: errorUtil.ErrMessage): ZodObject<T, \"strict\", Catchall> {\n    errorUtil.errToObj;\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"strict\",\n      ...(message !== undefined\n        ? {\n            errorMap: (issue, ctx) => {\n              const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n              if (issue.code === \"unrecognized_keys\")\n                return {\n                  message: errorUtil.errToObj(message).message ?? defaultError,\n                };\n              return {\n                message: defaultError,\n              };\n            },\n          }\n        : {}),\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject.strip",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject.strip",
    "startLine": 2594,
    "endLine": 2599,
    "text": "  strip(): ZodObject<T, \"strip\", Catchall> {\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"strip\",\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject.passthrough",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject.passthrough",
    "startLine": 2601,
    "endLine": 2606,
    "text": "  passthrough(): ZodObject<T, \"passthrough\", Catchall> {\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"passthrough\",\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject.extend",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject.extend",
    "startLine": 2631,
    "endLine": 2641,
    "text": "  extend<Augmentation extends ZodRawShape>(\n    augmentation: Augmentation\n  ): ZodObject<objectUtil.extendShape<T, Augmentation>, UnknownKeys, Catchall> {\n    return new ZodObject({\n      ...this._def,\n      shape: () => ({\n        ...this._def.shape(),\n        ...augmentation,\n      }),\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject.merge",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject.merge",
    "startLine": 2685,
    "endLine": 2698,
    "text": "  merge<Incoming extends AnyZodObject, Augmentation extends Incoming[\"shape\"]>(\n    merging: Incoming\n  ): ZodObject<objectUtil.extendShape<T, Augmentation>, Incoming[\"_def\"][\"unknownKeys\"], Incoming[\"_def\"][\"catchall\"]> {\n    const merged: any = new ZodObject({\n      unknownKeys: merging._def.unknownKeys,\n      catchall: merging._def.catchall,\n      shape: () => ({\n        ...this._def.shape(),\n        ...merging._def.shape(),\n      }),\n      typeName: ZodFirstPartyTypeKind.ZodObject,\n    }) as any;\n    return merged;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject.setKey",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject.setKey",
    "startLine": 2735,
    "endLine": 2740,
    "text": "  setKey<Key extends string, Schema extends ZodTypeAny>(\n    key: Key,\n    schema: Schema\n  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> {\n    return this.augment({ [key]: schema }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject.catchall",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject.catchall",
    "startLine": 2763,
    "endLine": 2768,
    "text": "  catchall<Index extends ZodTypeAny>(index: Index): ZodObject<T, UnknownKeys, Index> {\n    return new ZodObject({\n      ...this._def,\n      catchall: index,\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject.pick",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject.pick",
    "startLine": 2770,
    "endLine": 2785,
    "text": "  pick<Mask extends util.Exactly<{ [k in keyof T]?: true }, Mask>>(\n    mask: Mask\n  ): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall> {\n    const shape: any = {};\n\n    for (const key of util.objectKeys(mask)) {\n      if (mask[key] && this.shape[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n\n    return new ZodObject({\n      ...this._def,\n      shape: () => shape,\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject.omit",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject.omit",
    "startLine": 2787,
    "endLine": 2802,
    "text": "  omit<Mask extends util.Exactly<{ [k in keyof T]?: true }, Mask>>(\n    mask: Mask\n  ): ZodObject<Omit<T, keyof Mask>, UnknownKeys, Catchall> {\n    const shape: any = {};\n\n    for (const key of util.objectKeys(this.shape)) {\n      if (!mask[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n\n    return new ZodObject({\n      ...this._def,\n      shape: () => shape,\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject.deepPartial",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject.deepPartial",
    "startLine": 2807,
    "endLine": 2809,
    "text": "  deepPartial(): partialUtil.DeepPartial<this> {\n    return deepPartialify(this);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject.partial",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject.partial",
    "startLine": 2821,
    "endLine": 2838,
    "text": "  partial(mask?: any) {\n    const newShape: any = {};\n\n    for (const key of util.objectKeys(this.shape)) {\n      const fieldSchema = this.shape[key]!;\n\n      if (mask && !mask[key]) {\n        newShape[key] = fieldSchema;\n      } else {\n        newShape[key] = fieldSchema.optional();\n      }\n    }\n\n    return new ZodObject({\n      ...this._def,\n      shape: () => newShape,\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject.required",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject.required",
    "startLine": 2850,
    "endLine": 2872,
    "text": "  required(mask?: any) {\n    const newShape: any = {};\n\n    for (const key of util.objectKeys(this.shape)) {\n      if (mask && !mask[key]) {\n        newShape[key] = this.shape[key];\n      } else {\n        const fieldSchema = this.shape[key];\n        let newField = fieldSchema;\n\n        while (newField instanceof ZodOptional) {\n          newField = (newField as ZodOptional<any>)._def.innerType;\n        }\n\n        newShape[key] = newField;\n      }\n    }\n\n    return new ZodObject({\n      ...this._def,\n      shape: () => newShape,\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodObject.keyof",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodObject.keyof",
    "startLine": 2874,
    "endLine": 2876,
    "text": "  keyof(): ZodEnum<enumUtil.UnionToTupleString<keyof T>> {\n    return createZodEnum(util.objectKeys(this.shape) as [string, ...string[]]) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodUnion",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodUnion",
    "startLine": 2940,
    "endLine": 3055,
    "text": "export class ZodUnion<T extends ZodUnionOptions> extends ZodType<\n  T[number][\"_output\"],\n  ZodUnionDef<T>,\n  T[number][\"_input\"]\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n    const options = this._def.options;\n\n    function handleResults(results: { ctx: ParseContext; result: SyncParseReturnType<any> }[]) {\n      // return first issue-free validation if it exists\n      for (const result of results) {\n        if (result.result.status === \"valid\") {\n          return result.result;\n        }\n      }\n\n      for (const result of results) {\n        if (result.result.status === \"dirty\") {\n          // add issues from dirty option\n\n          ctx.common.issues.push(...result.ctx.common.issues);\n          return result.result;\n        }\n      }\n\n      // return invalid\n      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors,\n      });\n      return INVALID;\n    }\n\n    if (ctx.common.async) {\n      return Promise.all(\n        options.map(async (option) => {\n          const childCtx: ParseContext = {\n            ...ctx,\n            common: {\n              ...ctx.common,\n              issues: [],\n            },\n            parent: null,\n          };\n          return {\n            result: await option._parseAsync({\n              data: ctx.data,\n              path: ctx.path,\n              parent: childCtx,\n            }),\n            ctx: childCtx,\n          };\n        })\n      ).then(handleResults);\n    } else {\n      let dirty: undefined | { result: DIRTY<any>; ctx: ParseContext } = undefined;\n      const issues: ZodIssue[][] = [];\n      for (const option of options) {\n        const childCtx: ParseContext = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: [],\n          },\n          parent: null,\n        };\n        const result = option._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: childCtx,\n        });\n\n        if (result.status === \"valid\") {\n          return result;\n        } else if (result.status === \"dirty\" && !dirty) {\n          dirty = { result, ctx: childCtx };\n        }\n\n        if (childCtx.common.issues.length) {\n          issues.push(childCtx.common.issues);\n        }\n      }\n\n      if (dirty) {\n        ctx.common.issues.push(...dirty.ctx.common.issues);\n        return dirty.result;\n      }\n\n      const unionErrors = issues.map((issues) => new ZodError(issues));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors,\n      });\n\n      return INVALID;\n    }\n  }\n\n  get options() {\n    return this._def.options;\n  }\n\n  static create = <Options extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>>(\n    types: Options,\n    params?: RawCreateParams\n  ): ZodUnion<Options> => {\n    return new ZodUnion({\n      options: types,\n      typeName: ZodFirstPartyTypeKind.ZodUnion,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodUnion._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodUnion._parse",
    "startLine": 2945,
    "endLine": 3039,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n    const options = this._def.options;\n\n    function handleResults(results: { ctx: ParseContext; result: SyncParseReturnType<any> }[]) {\n      // return first issue-free validation if it exists\n      for (const result of results) {\n        if (result.result.status === \"valid\") {\n          return result.result;\n        }\n      }\n\n      for (const result of results) {\n        if (result.result.status === \"dirty\") {\n          // add issues from dirty option\n\n          ctx.common.issues.push(...result.ctx.common.issues);\n          return result.result;\n        }\n      }\n\n      // return invalid\n      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors,\n      });\n      return INVALID;\n    }\n\n    if (ctx.common.async) {\n      return Promise.all(\n        options.map(async (option) => {\n          const childCtx: ParseContext = {\n            ...ctx,\n            common: {\n              ...ctx.common,\n              issues: [],\n            },\n            parent: null,\n          };\n          return {\n            result: await option._parseAsync({\n              data: ctx.data,\n              path: ctx.path,\n              parent: childCtx,\n            }),\n            ctx: childCtx,\n          };\n        })\n      ).then(handleResults);\n    } else {\n      let dirty: undefined | { result: DIRTY<any>; ctx: ParseContext } = undefined;\n      const issues: ZodIssue[][] = [];\n      for (const option of options) {\n        const childCtx: ParseContext = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: [],\n          },\n          parent: null,\n        };\n        const result = option._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: childCtx,\n        });\n\n        if (result.status === \"valid\") {\n          return result;\n        } else if (result.status === \"dirty\" && !dirty) {\n          dirty = { result, ctx: childCtx };\n        }\n\n        if (childCtx.common.issues.length) {\n          issues.push(childCtx.common.issues);\n        }\n      }\n\n      if (dirty) {\n        ctx.common.issues.push(...dirty.ctx.common.issues);\n        return dirty.result;\n      }\n\n      const unionErrors = issues.map((issues) => new ZodError(issues));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors,\n      });\n\n      return INVALID;\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:handleResults",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "handleResults",
    "startLine": 2949,
    "endLine": 2974,
    "text": "    function handleResults(results: { ctx: ParseContext; result: SyncParseReturnType<any> }[]) {\n      // return first issue-free validation if it exists\n      for (const result of results) {\n        if (result.result.status === \"valid\") {\n          return result.result;\n        }\n      }\n\n      for (const result of results) {\n        if (result.result.status === \"dirty\") {\n          // add issues from dirty option\n\n          ctx.common.issues.push(...result.ctx.common.issues);\n          return result.result;\n        }\n      }\n\n      // return invalid\n      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors,\n      });\n      return INVALID;\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodDiscriminatedUnion",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodDiscriminatedUnion",
    "startLine": 3114,
    "endLine": 3223,
    "text": "export class ZodDiscriminatedUnion<\n  Discriminator extends string,\n  Options extends readonly ZodDiscriminatedUnionOption<Discriminator>[],\n> extends ZodType<output<Options[number]>, ZodDiscriminatedUnionDef<Discriminator, Options>, input<Options[number]>> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const discriminator = this.discriminator;\n\n    const discriminatorValue: string = ctx.data[discriminator];\n\n    const option = this.optionsMap.get(discriminatorValue);\n\n    if (!option) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union_discriminator,\n        options: Array.from(this.optionsMap.keys()),\n        path: [discriminator],\n      });\n      return INVALID;\n    }\n\n    if (ctx.common.async) {\n      return option._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx,\n      }) as any;\n    } else {\n      return option._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx,\n      }) as any;\n    }\n  }\n\n  get discriminator() {\n    return this._def.discriminator;\n  }\n\n  get options() {\n    return this._def.options;\n  }\n\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n\n  /**\n   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n   * have a different value for each object in the union.\n   * @param discriminator the name of the discriminator property\n   * @param types an array of object schemas\n   * @param params\n   */\n  static create<\n    Discriminator extends string,\n    Types extends readonly [\n      ZodDiscriminatedUnionOption<Discriminator>,\n      ...ZodDiscriminatedUnionOption<Discriminator>[],\n    ],\n  >(\n    discriminator: Discriminator,\n    options: Types,\n    params?: RawCreateParams\n  ): ZodDiscriminatedUnion<Discriminator, Types> {\n    // Get all the valid discriminator values\n    const optionsMap: Map<Primitive, Types[number]> = new Map();\n\n    // try {\n    for (const type of options) {\n      const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n      if (!discriminatorValues.length) {\n        throw new Error(\n          `A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`\n        );\n      }\n      for (const value of discriminatorValues) {\n        if (optionsMap.has(value)) {\n          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n        }\n\n        optionsMap.set(value, type);\n      }\n    }\n\n    return new ZodDiscriminatedUnion<\n      Discriminator,\n      // DiscriminatorValue,\n      Types\n    >({\n      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n      discriminator,\n      options,\n      optionsMap,\n      ...processCreateParams(params),\n    });\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodDiscriminatedUnion._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodDiscriminatedUnion._parse",
    "startLine": 3118,
    "endLine": 3158,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const discriminator = this.discriminator;\n\n    const discriminatorValue: string = ctx.data[discriminator];\n\n    const option = this.optionsMap.get(discriminatorValue);\n\n    if (!option) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union_discriminator,\n        options: Array.from(this.optionsMap.keys()),\n        path: [discriminator],\n      });\n      return INVALID;\n    }\n\n    if (ctx.common.async) {\n      return option._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx,\n      }) as any;\n    } else {\n      return option._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx,\n      }) as any;\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodDiscriminatedUnion.create",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodDiscriminatedUnion.create",
    "startLine": 3180,
    "endLine": 3222,
    "text": "  static create<\n    Discriminator extends string,\n    Types extends readonly [\n      ZodDiscriminatedUnionOption<Discriminator>,\n      ...ZodDiscriminatedUnionOption<Discriminator>[],\n    ],\n  >(\n    discriminator: Discriminator,\n    options: Types,\n    params?: RawCreateParams\n  ): ZodDiscriminatedUnion<Discriminator, Types> {\n    // Get all the valid discriminator values\n    const optionsMap: Map<Primitive, Types[number]> = new Map();\n\n    // try {\n    for (const type of options) {\n      const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n      if (!discriminatorValues.length) {\n        throw new Error(\n          `A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`\n        );\n      }\n      for (const value of discriminatorValues) {\n        if (optionsMap.has(value)) {\n          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n        }\n\n        optionsMap.set(value, type);\n      }\n    }\n\n    return new ZodDiscriminatedUnion<\n      Discriminator,\n      // DiscriminatorValue,\n      Types\n    >({\n      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n      discriminator,\n      options,\n      optionsMap,\n      ...processCreateParams(params),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:mergeValues",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "mergeValues",
    "startLine": 3239,
    "endLine": 3283,
    "text": "function mergeValues(a: any, b: any): { valid: true; data: any } | { valid: false } {\n  const aType = getParsedType(a);\n  const bType = getParsedType(b);\n\n  if (a === b) {\n    return { valid: true, data: a };\n  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n    const bKeys = util.objectKeys(b);\n    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n\n    const newObj: any = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newObj[key] = sharedValue.data;\n    }\n\n    return { valid: true, data: newObj };\n  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n    if (a.length !== b.length) {\n      return { valid: false };\n    }\n\n    const newArray: unknown[] = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n\n      newArray.push(sharedValue.data);\n    }\n\n    return { valid: true, data: newArray };\n  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n    return { valid: true, data: a };\n  } else {\n    return { valid: false };\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodIntersection",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodIntersection",
    "startLine": 3285,
    "endLine": 3357,
    "text": "export class ZodIntersection<T extends ZodTypeAny, U extends ZodTypeAny> extends ZodType<\n  T[\"_output\"] & U[\"_output\"],\n  ZodIntersectionDef<T, U>,\n  T[\"_input\"] & U[\"_input\"]\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    const handleParsed = (\n      parsedLeft: SyncParseReturnType,\n      parsedRight: SyncParseReturnType\n    ): SyncParseReturnType<T & U> => {\n      if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n        return INVALID;\n      }\n\n      const merged = mergeValues(parsedLeft.value, parsedRight.value);\n\n      if (!merged.valid) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.invalid_intersection_types,\n        });\n        return INVALID;\n      }\n\n      if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n        status.dirty();\n      }\n\n      return { status: status.value, value: merged.data };\n    };\n\n    if (ctx.common.async) {\n      return Promise.all([\n        this._def.left._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        }),\n        this._def.right._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        }),\n      ]).then(([left, right]: any) => handleParsed(left, right));\n    } else {\n      return handleParsed(\n        this._def.left._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        }),\n        this._def.right._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        })\n      );\n    }\n  }\n\n  static create = <TSchema extends ZodTypeAny, USchema extends ZodTypeAny>(\n    left: TSchema,\n    right: USchema,\n    params?: RawCreateParams\n  ): ZodIntersection<TSchema, USchema> => {\n    return new ZodIntersection({\n      left: left,\n      right: right,\n      typeName: ZodFirstPartyTypeKind.ZodIntersection,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodIntersection._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodIntersection._parse",
    "startLine": 3290,
    "endLine": 3343,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    const handleParsed = (\n      parsedLeft: SyncParseReturnType,\n      parsedRight: SyncParseReturnType\n    ): SyncParseReturnType<T & U> => {\n      if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n        return INVALID;\n      }\n\n      const merged = mergeValues(parsedLeft.value, parsedRight.value);\n\n      if (!merged.valid) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.invalid_intersection_types,\n        });\n        return INVALID;\n      }\n\n      if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n        status.dirty();\n      }\n\n      return { status: status.value, value: merged.data };\n    };\n\n    if (ctx.common.async) {\n      return Promise.all([\n        this._def.left._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        }),\n        this._def.right._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        }),\n      ]).then(([left, right]: any) => handleParsed(left, right));\n    } else {\n      return handleParsed(\n        this._def.left._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        }),\n        this._def.right._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        })\n      );\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodTuple",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodTuple",
    "startLine": 3393,
    "endLine": 3475,
    "text": "export class ZodTuple<\n  T extends ZodTupleItems | [] = ZodTupleItems,\n  Rest extends ZodTypeAny | null = null,\n> extends ZodType<OutputTypeOfTupleWithRest<T, Rest>, ZodTupleDef<T, Rest>, InputTypeOfTupleWithRest<T, Rest>> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    if (ctx.data.length < this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        minimum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\",\n      });\n\n      return INVALID;\n    }\n\n    const rest = this._def.rest;\n\n    if (!rest && ctx.data.length > this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_big,\n        maximum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\",\n      });\n      status.dirty();\n    }\n\n    const items = ([...ctx.data] as any[])\n      .map((item, itemIndex) => {\n        const schema = this._def.items[itemIndex] || this._def.rest;\n        if (!schema) return null as any as SyncParseReturnType<any>;\n        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n      })\n      .filter((x) => !!x); // filter nulls\n\n    if (ctx.common.async) {\n      return Promise.all(items).then((results) => {\n        return ParseStatus.mergeArray(status, results);\n      });\n    } else {\n      return ParseStatus.mergeArray(status, items as SyncParseReturnType[]);\n    }\n  }\n\n  get items() {\n    return this._def.items;\n  }\n\n  rest<RestSchema extends ZodTypeAny>(rest: RestSchema): ZodTuple<T, RestSchema> {\n    return new ZodTuple({\n      ...this._def,\n      rest,\n    });\n  }\n\n  static create = <Items extends [ZodTypeAny, ...ZodTypeAny[]] | []>(\n    schemas: Items,\n    params?: RawCreateParams\n  ): ZodTuple<Items, null> => {\n    if (!Array.isArray(schemas)) {\n      throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n      items: schemas,\n      typeName: ZodFirstPartyTypeKind.ZodTuple,\n      rest: null,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodTuple._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodTuple._parse",
    "startLine": 3397,
    "endLine": 3448,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    if (ctx.data.length < this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        minimum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\",\n      });\n\n      return INVALID;\n    }\n\n    const rest = this._def.rest;\n\n    if (!rest && ctx.data.length > this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_big,\n        maximum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\",\n      });\n      status.dirty();\n    }\n\n    const items = ([...ctx.data] as any[])\n      .map((item, itemIndex) => {\n        const schema = this._def.items[itemIndex] || this._def.rest;\n        if (!schema) return null as any as SyncParseReturnType<any>;\n        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n      })\n      .filter((x) => !!x); // filter nulls\n\n    if (ctx.common.async) {\n      return Promise.all(items).then((results) => {\n        return ParseStatus.mergeArray(status, results);\n      });\n    } else {\n      return ParseStatus.mergeArray(status, items as SyncParseReturnType[]);\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodTuple.rest",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodTuple.rest",
    "startLine": 3454,
    "endLine": 3459,
    "text": "  rest<RestSchema extends ZodTypeAny>(rest: RestSchema): ZodTuple<T, RestSchema> {\n    return new ZodTuple({\n      ...this._def,\n      rest,\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodRecord",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodRecord",
    "startLine": 3501,
    "endLine": 3574,
    "text": "export class ZodRecord<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<\n  RecordType<Key[\"_output\"], Value[\"_output\"]>,\n  ZodRecordDef<Key, Value>,\n  RecordType<Key[\"_input\"], Value[\"_input\"]>\n> {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const pairs: {\n      key: ParseReturnType<any>;\n      value: ParseReturnType<any>;\n      alwaysSet: boolean;\n    }[] = [];\n\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n\n    for (const key in ctx.data) {\n      pairs.push({\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n        alwaysSet: key in ctx.data,\n      });\n    }\n\n    if (ctx.common.async) {\n      return ParseStatus.mergeObjectAsync(status, pairs);\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs as any);\n    }\n  }\n\n  get element() {\n    return this._def.valueType;\n  }\n\n  static create<Value extends ZodTypeAny>(valueType: Value, params?: RawCreateParams): ZodRecord<ZodString, Value>;\n  static create<Keys extends KeySchema, Value extends ZodTypeAny>(\n    keySchema: Keys,\n    valueType: Value,\n    params?: RawCreateParams\n  ): ZodRecord<Keys, Value>;\n  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {\n    if (second instanceof ZodType) {\n      return new ZodRecord({\n        keyType: first,\n        valueType: second,\n        typeName: ZodFirstPartyTypeKind.ZodRecord,\n        ...processCreateParams(third),\n      });\n    }\n\n    return new ZodRecord({\n      keyType: ZodString.create(),\n      valueType: first,\n      typeName: ZodFirstPartyTypeKind.ZodRecord,\n      ...processCreateParams(second),\n    });\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodRecord._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodRecord._parse",
    "startLine": 3512,
    "endLine": 3545,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const pairs: {\n      key: ParseReturnType<any>;\n      value: ParseReturnType<any>;\n      alwaysSet: boolean;\n    }[] = [];\n\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n\n    for (const key in ctx.data) {\n      pairs.push({\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n        alwaysSet: key in ctx.data,\n      });\n    }\n\n    if (ctx.common.async) {\n      return ParseStatus.mergeObjectAsync(status, pairs);\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs as any);\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodRecord.create",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodRecord.create",
    "startLine": 3557,
    "endLine": 3573,
    "text": "  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {\n    if (second instanceof ZodType) {\n      return new ZodRecord({\n        keyType: first,\n        valueType: second,\n        typeName: ZodFirstPartyTypeKind.ZodRecord,\n        ...processCreateParams(third),\n      });\n    }\n\n    return new ZodRecord({\n      keyType: ZodString.create(),\n      valueType: first,\n      typeName: ZodFirstPartyTypeKind.ZodRecord,\n      ...processCreateParams(second),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodMap",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodMap",
    "startLine": 3590,
    "endLine": 3668,
    "text": "export class ZodMap<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<\n  Map<Key[\"_output\"], Value[\"_output\"]>,\n  ZodMapDef<Key, Value>,\n  Map<Key[\"_input\"], Value[\"_input\"]>\n> {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.map) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.map,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n\n    const pairs = [...(ctx.data as Map<unknown, unknown>).entries()].map(([key, value], index) => {\n      return {\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n      };\n    });\n\n    if (ctx.common.async) {\n      const finalMap = new Map();\n      return Promise.resolve().then(async () => {\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          if (key.status === \"aborted\" || value.status === \"aborted\") {\n            return INVALID;\n          }\n          if (key.status === \"dirty\" || value.status === \"dirty\") {\n            status.dirty();\n          }\n\n          finalMap.set(key.value, value.value);\n        }\n        return { status: status.value, value: finalMap };\n      });\n    } else {\n      const finalMap = new Map();\n      for (const pair of pairs) {\n        const key = pair.key as SyncParseReturnType;\n        const value = pair.value as SyncParseReturnType;\n        if (key.status === \"aborted\" || value.status === \"aborted\") {\n          return INVALID;\n        }\n        if (key.status === \"dirty\" || value.status === \"dirty\") {\n          status.dirty();\n        }\n\n        finalMap.set(key.value, value.value);\n      }\n      return { status: status.value, value: finalMap };\n    }\n  }\n  static create = <KeySchema extends ZodTypeAny = ZodTypeAny, ValueSchema extends ZodTypeAny = ZodTypeAny>(\n    keyType: KeySchema,\n    valueType: ValueSchema,\n    params?: RawCreateParams\n  ): ZodMap<KeySchema, ValueSchema> => {\n    return new ZodMap({\n      valueType,\n      keyType,\n      typeName: ZodFirstPartyTypeKind.ZodMap,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodMap._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodMap._parse",
    "startLine": 3601,
    "endLine": 3655,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.map) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.map,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n\n    const pairs = [...(ctx.data as Map<unknown, unknown>).entries()].map(([key, value], index) => {\n      return {\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n      };\n    });\n\n    if (ctx.common.async) {\n      const finalMap = new Map();\n      return Promise.resolve().then(async () => {\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          if (key.status === \"aborted\" || value.status === \"aborted\") {\n            return INVALID;\n          }\n          if (key.status === \"dirty\" || value.status === \"dirty\") {\n            status.dirty();\n          }\n\n          finalMap.set(key.value, value.value);\n        }\n        return { status: status.value, value: finalMap };\n      });\n    } else {\n      const finalMap = new Map();\n      for (const pair of pairs) {\n        const key = pair.key as SyncParseReturnType;\n        const value = pair.value as SyncParseReturnType;\n        if (key.status === \"aborted\" || value.status === \"aborted\") {\n          return INVALID;\n        }\n        if (key.status === \"dirty\" || value.status === \"dirty\") {\n          status.dirty();\n        }\n\n        finalMap.set(key.value, value.value);\n      }\n      return { status: status.value, value: finalMap };\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodSet",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodSet",
    "startLine": 3684,
    "endLine": 3787,
    "text": "export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<\n  Set<Value[\"_output\"]>,\n  ZodSetDef<Value>,\n  Set<Value[\"_input\"]>\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.set) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.set,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const def = this._def;\n\n    if (def.minSize !== null) {\n      if (ctx.data.size < def.minSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.minSize.message,\n        });\n        status.dirty();\n      }\n    }\n\n    if (def.maxSize !== null) {\n      if (ctx.data.size > def.maxSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.maxSize.message,\n        });\n        status.dirty();\n      }\n    }\n\n    const valueType = this._def.valueType;\n\n    function finalizeSet(elements: SyncParseReturnType<any>[]) {\n      const parsedSet = new Set();\n      for (const element of elements) {\n        if (element.status === \"aborted\") return INVALID;\n        if (element.status === \"dirty\") status.dirty();\n        parsedSet.add(element.value);\n      }\n      return { status: status.value, value: parsedSet };\n    }\n\n    const elements = [...(ctx.data as Set<unknown>).values()].map((item, i) =>\n      valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i))\n    );\n\n    if (ctx.common.async) {\n      return Promise.all(elements).then((elements) => finalizeSet(elements));\n    } else {\n      return finalizeSet(elements as SyncParseReturnType[]);\n    }\n  }\n\n  min(minSize: number, message?: errorUtil.ErrMessage): this {\n    return new ZodSet({\n      ...this._def,\n      minSize: { value: minSize, message: errorUtil.toString(message) },\n    }) as any;\n  }\n\n  max(maxSize: number, message?: errorUtil.ErrMessage): this {\n    return new ZodSet({\n      ...this._def,\n      maxSize: { value: maxSize, message: errorUtil.toString(message) },\n    }) as any;\n  }\n\n  size(size: number, message?: errorUtil.ErrMessage): this {\n    return this.min(size, message).max(size, message) as any;\n  }\n\n  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {\n    return this.min(1, message) as any;\n  }\n\n  static create = <ValueSchema extends ZodTypeAny = ZodTypeAny>(\n    valueType: ValueSchema,\n    params?: RawCreateParams\n  ): ZodSet<ValueSchema> => {\n    return new ZodSet({\n      valueType,\n      minSize: null,\n      maxSize: null,\n      typeName: ZodFirstPartyTypeKind.ZodSet,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodSet._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodSet._parse",
    "startLine": 3689,
    "endLine": 3751,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.set) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.set,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const def = this._def;\n\n    if (def.minSize !== null) {\n      if (ctx.data.size < def.minSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.minSize.message,\n        });\n        status.dirty();\n      }\n    }\n\n    if (def.maxSize !== null) {\n      if (ctx.data.size > def.maxSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.maxSize.message,\n        });\n        status.dirty();\n      }\n    }\n\n    const valueType = this._def.valueType;\n\n    function finalizeSet(elements: SyncParseReturnType<any>[]) {\n      const parsedSet = new Set();\n      for (const element of elements) {\n        if (element.status === \"aborted\") return INVALID;\n        if (element.status === \"dirty\") status.dirty();\n        parsedSet.add(element.value);\n      }\n      return { status: status.value, value: parsedSet };\n    }\n\n    const elements = [...(ctx.data as Set<unknown>).values()].map((item, i) =>\n      valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i))\n    );\n\n    if (ctx.common.async) {\n      return Promise.all(elements).then((elements) => finalizeSet(elements));\n    } else {\n      return finalizeSet(elements as SyncParseReturnType[]);\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodSet.min",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodSet.min",
    "startLine": 3753,
    "endLine": 3758,
    "text": "  min(minSize: number, message?: errorUtil.ErrMessage): this {\n    return new ZodSet({\n      ...this._def,\n      minSize: { value: minSize, message: errorUtil.toString(message) },\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodSet.max",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodSet.max",
    "startLine": 3760,
    "endLine": 3765,
    "text": "  max(maxSize: number, message?: errorUtil.ErrMessage): this {\n    return new ZodSet({\n      ...this._def,\n      maxSize: { value: maxSize, message: errorUtil.toString(message) },\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodSet.size",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodSet.size",
    "startLine": 3767,
    "endLine": 3769,
    "text": "  size(size: number, message?: errorUtil.ErrMessage): this {\n    return this.min(size, message).max(size, message) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodSet.nonempty",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodSet.nonempty",
    "startLine": 3771,
    "endLine": 3773,
    "text": "  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {\n    return this.min(1, message) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:finalizeSet",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "finalizeSet",
    "startLine": 3732,
    "endLine": 3740,
    "text": "    function finalizeSet(elements: SyncParseReturnType<any>[]) {\n      const parsedSet = new Set();\n      for (const element of elements) {\n        if (element.status === \"aborted\") return INVALID;\n        if (element.status === \"dirty\") status.dirty();\n        parsedSet.add(element.value);\n      }\n      return { status: status.value, value: parsedSet };\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodFunction",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodFunction",
    "startLine": 3815,
    "endLine": 3958,
    "text": "export class ZodFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> extends ZodType<\n  OuterTypeOfFunction<Args, Returns>,\n  ZodFunctionDef<Args, Returns>,\n  InnerTypeOfFunction<Args, Returns>\n> {\n  _parse(input: ParseInput): ParseReturnType<any> {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.function) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.function,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    function makeArgsIssue(args: any, error: ZodError): ZodIssue {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter(\n          (x) => !!x\n        ),\n        issueData: {\n          code: ZodIssueCode.invalid_arguments,\n          argumentsError: error,\n        },\n      });\n    }\n\n    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter(\n          (x) => !!x\n        ),\n        issueData: {\n          code: ZodIssueCode.invalid_return_type,\n          returnTypeError: error,\n        },\n      });\n    }\n\n    const params = { errorMap: ctx.common.contextualErrorMap };\n    const fn = ctx.data;\n\n    if (this._def.returns instanceof ZodPromise) {\n      // Would love a way to avoid disabling this rule, but we need\n      // an alias (using an arrow function was what caused 2651).\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const me = this;\n      return OK(async function (this: any, ...args: any[]) {\n        const error = new ZodError([]);\n        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n          error.addIssue(makeArgsIssue(args, e));\n          throw error;\n        });\n        const result = await Reflect.apply(fn, this, parsedArgs as any);\n        const parsedReturns = await (me._def.returns as unknown as ZodPromise<ZodTypeAny>)._def.type\n          .parseAsync(result, params)\n          .catch((e) => {\n            error.addIssue(makeReturnsIssue(result, e));\n            throw error;\n          });\n        return parsedReturns;\n      });\n    } else {\n      // Would love a way to avoid disabling this rule, but we need\n      // an alias (using an arrow function was what caused 2651).\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const me = this;\n      return OK(function (this: any, ...args: any[]) {\n        const parsedArgs = me._def.args.safeParse(args, params);\n        if (!parsedArgs.success) {\n          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n        }\n        const result = Reflect.apply(fn, this, parsedArgs.data);\n        const parsedReturns = me._def.returns.safeParse(result, params);\n        if (!parsedReturns.success) {\n          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n        }\n        return parsedReturns.data;\n      }) as any;\n    }\n  }\n\n  parameters() {\n    return this._def.args;\n  }\n\n  returnType() {\n    return this._def.returns;\n  }\n\n  args<Items extends Parameters<(typeof ZodTuple)[\"create\"]>[0]>(\n    ...items: Items\n  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> {\n    return new ZodFunction({\n      ...this._def,\n      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,\n    });\n  }\n\n  returns<NewReturnType extends ZodType<any, any, any>>(returnType: NewReturnType): ZodFunction<Args, NewReturnType> {\n    return new ZodFunction({\n      ...this._def,\n      returns: returnType,\n    });\n  }\n\n  implement<F extends InnerTypeOfFunction<Args, Returns>>(\n    func: F\n  ): ReturnType<F> extends Returns[\"_output\"]\n    ? (...args: Args[\"_input\"]) => ReturnType<F>\n    : OuterTypeOfFunction<Args, Returns> {\n    const validatedFunc = this.parse(func);\n    return validatedFunc as any;\n  }\n\n  strictImplement(func: InnerTypeOfFunction<Args, Returns>): InnerTypeOfFunction<Args, Returns> {\n    const validatedFunc = this.parse(func);\n    return validatedFunc as any;\n  }\n\n  validate = this.implement;\n\n  static create(): ZodFunction<ZodTuple<[], ZodUnknown>, ZodUnknown>;\n  static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>>(args: T): ZodFunction<T, ZodUnknown>;\n  static create<T extends AnyZodTuple, U extends ZodTypeAny>(args: T, returns: U): ZodFunction<T, U>;\n  static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>, U extends ZodTypeAny = ZodUnknown>(\n    args: T,\n    returns: U,\n    params?: RawCreateParams\n  ): ZodFunction<T, U>;\n  static create(args?: AnyZodTuple, returns?: ZodTypeAny, params?: RawCreateParams) {\n    return new ZodFunction({\n      args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())) as any,\n      returns: returns || ZodUnknown.create(),\n      typeName: ZodFirstPartyTypeKind.ZodFunction,\n      ...processCreateParams(params),\n    }) as any;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodFunction._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodFunction._parse",
    "startLine": 3820,
    "endLine": 3900,
    "text": "  _parse(input: ParseInput): ParseReturnType<any> {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.function) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.function,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    function makeArgsIssue(args: any, error: ZodError): ZodIssue {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter(\n          (x) => !!x\n        ),\n        issueData: {\n          code: ZodIssueCode.invalid_arguments,\n          argumentsError: error,\n        },\n      });\n    }\n\n    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter(\n          (x) => !!x\n        ),\n        issueData: {\n          code: ZodIssueCode.invalid_return_type,\n          returnTypeError: error,\n        },\n      });\n    }\n\n    const params = { errorMap: ctx.common.contextualErrorMap };\n    const fn = ctx.data;\n\n    if (this._def.returns instanceof ZodPromise) {\n      // Would love a way to avoid disabling this rule, but we need\n      // an alias (using an arrow function was what caused 2651).\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const me = this;\n      return OK(async function (this: any, ...args: any[]) {\n        const error = new ZodError([]);\n        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n          error.addIssue(makeArgsIssue(args, e));\n          throw error;\n        });\n        const result = await Reflect.apply(fn, this, parsedArgs as any);\n        const parsedReturns = await (me._def.returns as unknown as ZodPromise<ZodTypeAny>)._def.type\n          .parseAsync(result, params)\n          .catch((e) => {\n            error.addIssue(makeReturnsIssue(result, e));\n            throw error;\n          });\n        return parsedReturns;\n      });\n    } else {\n      // Would love a way to avoid disabling this rule, but we need\n      // an alias (using an arrow function was what caused 2651).\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const me = this;\n      return OK(function (this: any, ...args: any[]) {\n        const parsedArgs = me._def.args.safeParse(args, params);\n        if (!parsedArgs.success) {\n          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n        }\n        const result = Reflect.apply(fn, this, parsedArgs.data);\n        const parsedReturns = me._def.returns.safeParse(result, params);\n        if (!parsedReturns.success) {\n          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n        }\n        return parsedReturns.data;\n      }) as any;\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodFunction.parameters",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodFunction.parameters",
    "startLine": 3902,
    "endLine": 3904,
    "text": "  parameters() {\n    return this._def.args;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodFunction.returnType",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodFunction.returnType",
    "startLine": 3906,
    "endLine": 3908,
    "text": "  returnType() {\n    return this._def.returns;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodFunction.args",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodFunction.args",
    "startLine": 3910,
    "endLine": 3917,
    "text": "  args<Items extends Parameters<(typeof ZodTuple)[\"create\"]>[0]>(\n    ...items: Items\n  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> {\n    return new ZodFunction({\n      ...this._def,\n      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodFunction.returns",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodFunction.returns",
    "startLine": 3919,
    "endLine": 3924,
    "text": "  returns<NewReturnType extends ZodType<any, any, any>>(returnType: NewReturnType): ZodFunction<Args, NewReturnType> {\n    return new ZodFunction({\n      ...this._def,\n      returns: returnType,\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodFunction.implement",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodFunction.implement",
    "startLine": 3926,
    "endLine": 3933,
    "text": "  implement<F extends InnerTypeOfFunction<Args, Returns>>(\n    func: F\n  ): ReturnType<F> extends Returns[\"_output\"]\n    ? (...args: Args[\"_input\"]) => ReturnType<F>\n    : OuterTypeOfFunction<Args, Returns> {\n    const validatedFunc = this.parse(func);\n    return validatedFunc as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodFunction.strictImplement",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodFunction.strictImplement",
    "startLine": 3935,
    "endLine": 3938,
    "text": "  strictImplement(func: InnerTypeOfFunction<Args, Returns>): InnerTypeOfFunction<Args, Returns> {\n    const validatedFunc = this.parse(func);\n    return validatedFunc as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodFunction.create",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodFunction.create",
    "startLine": 3950,
    "endLine": 3957,
    "text": "  static create(args?: AnyZodTuple, returns?: ZodTypeAny, params?: RawCreateParams) {\n    return new ZodFunction({\n      args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())) as any,\n      returns: returns || ZodUnknown.create(),\n      typeName: ZodFirstPartyTypeKind.ZodFunction,\n      ...processCreateParams(params),\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:makeArgsIssue",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "makeArgsIssue",
    "startLine": 3831,
    "endLine": 3843,
    "text": "    function makeArgsIssue(args: any, error: ZodError): ZodIssue {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter(\n          (x) => !!x\n        ),\n        issueData: {\n          code: ZodIssueCode.invalid_arguments,\n          argumentsError: error,\n        },\n      });\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:makeReturnsIssue",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "makeReturnsIssue",
    "startLine": 3845,
    "endLine": 3857,
    "text": "    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter(\n          (x) => !!x\n        ),\n        issueData: {\n          code: ZodIssueCode.invalid_return_type,\n          returnTypeError: error,\n        },\n      });\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodLazy",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodLazy",
    "startLine": 3972,
    "endLine": 3990,
    "text": "export class ZodLazy<T extends ZodTypeAny> extends ZodType<output<T>, ZodLazyDef<T>, input<T>> {\n  get schema(): T {\n    return this._def.getter();\n  }\n\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n    const lazySchema = this._def.getter();\n    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n  }\n\n  static create = <Inner extends ZodTypeAny>(getter: () => Inner, params?: RawCreateParams): ZodLazy<Inner> => {\n    return new ZodLazy({\n      getter: getter,\n      typeName: ZodFirstPartyTypeKind.ZodLazy,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodLazy._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodLazy._parse",
    "startLine": 3977,
    "endLine": 3981,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n    const lazySchema = this._def.getter();\n    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodLiteral",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodLiteral",
    "startLine": 4004,
    "endLine": 4029,
    "text": "export class ZodLiteral<T> extends ZodType<T, ZodLiteralDef<T>, T> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    if (input.data !== this._def.value) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_literal,\n        expected: this._def.value,\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n\n  get value() {\n    return this._def.value;\n  }\n\n  static create = <Value extends Primitive>(value: Value, params?: RawCreateParams): ZodLiteral<Value> => {\n    return new ZodLiteral({\n      value: value,\n      typeName: ZodFirstPartyTypeKind.ZodLiteral,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodLiteral._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodLiteral._parse",
    "startLine": 4005,
    "endLine": 4016,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    if (input.data !== this._def.value) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_literal,\n        expected: this._def.value,\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:createZodEnum",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "createZodEnum",
    "startLine": 4064,
    "endLine": 4067,
    "text": "function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(\n  values: T,\n  params?: RawCreateParams\n): ZodEnum<Writeable<T>>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:createZodEnum",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "createZodEnum",
    "startLine": 4068,
    "endLine": 4068,
    "text": "function createZodEnum<U extends string, T extends [U, ...U[]]>(values: T, params?: RawCreateParams): ZodEnum<T>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:createZodEnum",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "createZodEnum",
    "startLine": 4069,
    "endLine": 4075,
    "text": "function createZodEnum(values: [string, ...string[]], params?: RawCreateParams) {\n  return new ZodEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodEnum,\n    ...processCreateParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodEnum",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodEnum",
    "startLine": 4077,
    "endLine": 4159,
    "text": "export class ZodEnum<T extends [string, ...string[]]> extends ZodType<T[number], ZodEnumDef<T>, T[number]> {\n  _cache: Set<T[number]> | undefined;\n\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    if (typeof input.data !== \"string\") {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues) as \"string\",\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type,\n      });\n      return INVALID;\n    }\n\n    if (!this._cache) {\n      this._cache = new Set(this._def.values);\n    }\n\n    if (!this._cache.has(input.data)) {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n\n  get options() {\n    return this._def.values;\n  }\n\n  get enum(): Values<T> {\n    const enumValues: any = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n\n  get Values(): Values<T> {\n    const enumValues: any = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n\n  get Enum(): Values<T> {\n    const enumValues: any = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n\n  extract<ToExtract extends readonly [T[number], ...T[number][]]>(\n    values: ToExtract,\n    newDef: RawCreateParams = this._def\n  ): ZodEnum<Writeable<ToExtract>> {\n    return ZodEnum.create(values, {\n      ...this._def,\n      ...newDef,\n    }) as any;\n  }\n\n  exclude<ToExclude extends readonly [T[number], ...T[number][]]>(\n    values: ToExclude,\n    newDef: RawCreateParams = this._def\n  ): ZodEnum<typecast<Writeable<FilterEnum<T, ToExclude[number]>>, [string, ...string[]]>> {\n    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)) as FilterEnum<T, ToExclude[number]>, {\n      ...this._def,\n      ...newDef,\n    }) as any;\n  }\n\n  static create = createZodEnum;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodEnum._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodEnum._parse",
    "startLine": 4080,
    "endLine": 4108,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    if (typeof input.data !== \"string\") {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues) as \"string\",\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type,\n      });\n      return INVALID;\n    }\n\n    if (!this._cache) {\n      this._cache = new Set(this._def.values);\n    }\n\n    if (!this._cache.has(input.data)) {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodEnum.extract",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodEnum.extract",
    "startLine": 4138,
    "endLine": 4146,
    "text": "  extract<ToExtract extends readonly [T[number], ...T[number][]]>(\n    values: ToExtract,\n    newDef: RawCreateParams = this._def\n  ): ZodEnum<Writeable<ToExtract>> {\n    return ZodEnum.create(values, {\n      ...this._def,\n      ...newDef,\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodEnum.exclude",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodEnum.exclude",
    "startLine": 4148,
    "endLine": 4156,
    "text": "  exclude<ToExclude extends readonly [T[number], ...T[number][]]>(\n    values: ToExclude,\n    newDef: RawCreateParams = this._def\n  ): ZodEnum<typecast<Writeable<FilterEnum<T, ToExclude[number]>>, [string, ...string[]]>> {\n    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)) as FilterEnum<T, ToExclude[number]>, {\n      ...this._def,\n      ...newDef,\n    }) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNativeEnum",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNativeEnum",
    "startLine": 4175,
    "endLine": 4219,
    "text": "export class ZodNativeEnum<T extends EnumLike> extends ZodType<T[keyof T], ZodNativeEnumDef<T>, T[keyof T]> {\n  _cache: Set<T[keyof T]> | undefined;\n  _parse(input: ParseInput): ParseReturnType<T[keyof T]> {\n    const nativeEnumValues = util.getValidEnumValues(this._def.values);\n\n    const ctx = this._getOrReturnCtx(input);\n    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues) as \"string\",\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type,\n      });\n      return INVALID;\n    }\n\n    if (!this._cache) {\n      this._cache = new Set(util.getValidEnumValues(this._def.values));\n    }\n\n    if (!this._cache.has(input.data)) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n\n  get enum() {\n    return this._def.values;\n  }\n\n  static create = <Elements extends EnumLike>(values: Elements, params?: RawCreateParams): ZodNativeEnum<Elements> => {\n    return new ZodNativeEnum({\n      values: values,\n      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNativeEnum._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNativeEnum._parse",
    "startLine": 4177,
    "endLine": 4206,
    "text": "  _parse(input: ParseInput): ParseReturnType<T[keyof T]> {\n    const nativeEnumValues = util.getValidEnumValues(this._def.values);\n\n    const ctx = this._getOrReturnCtx(input);\n    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues) as \"string\",\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type,\n      });\n      return INVALID;\n    }\n\n    if (!this._cache) {\n      this._cache = new Set(util.getValidEnumValues(this._def.values));\n    }\n\n    if (!this._cache.has(input.data)) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodPromise",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodPromise",
    "startLine": 4233,
    "endLine": 4272,
    "text": "export class ZodPromise<T extends ZodTypeAny> extends ZodType<\n  Promise<T[\"_output\"]>,\n  ZodPromiseDef<T>,\n  Promise<T[\"_input\"]>\n> {\n  unwrap() {\n    return this._def.type;\n  }\n\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.promise,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n\n    return OK(\n      promisified.then((data: any) => {\n        return this._def.type.parseAsync(data, {\n          path: ctx.path,\n          errorMap: ctx.common.contextualErrorMap,\n        });\n      })\n    );\n  }\n\n  static create = <Inner extends ZodTypeAny>(schema: Inner, params?: RawCreateParams): ZodPromise<Inner> => {\n    return new ZodPromise({\n      type: schema,\n      typeName: ZodFirstPartyTypeKind.ZodPromise,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodPromise.unwrap",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodPromise.unwrap",
    "startLine": 4238,
    "endLine": 4240,
    "text": "  unwrap() {\n    return this._def.type;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodPromise._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodPromise._parse",
    "startLine": 4242,
    "endLine": 4263,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.promise,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n\n    return OK(\n      promisified.then((data: any) => {\n        return this._def.type.parseAsync(data, {\n          path: ctx.path,\n          errorMap: ctx.common.contextualErrorMap,\n        });\n      })\n    );\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodEffects",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodEffects",
    "startLine": 4305,
    "endLine": 4465,
    "text": "export class ZodEffects<T extends ZodTypeAny, Output = output<T>, Input = input<T>> extends ZodType<\n  Output,\n  ZodEffectsDef<T>,\n  Input\n> {\n  innerType() {\n    return this._def.schema;\n  }\n\n  sourceType(): T {\n    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n      ? (this._def.schema as unknown as ZodEffects<T>).sourceType()\n      : (this._def.schema as T);\n  }\n\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n\n    const effect = this._def.effect || null;\n\n    const checkCtx: RefinementCtx = {\n      addIssue: (arg: IssueData) => {\n        addIssueToContext(ctx, arg);\n        if (arg.fatal) {\n          status.abort();\n        } else {\n          status.dirty();\n        }\n      },\n      get path() {\n        return ctx.path;\n      },\n    };\n\n    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n\n    if (effect.type === \"preprocess\") {\n      const processed = effect.transform(ctx.data, checkCtx);\n\n      if (ctx.common.async) {\n        return Promise.resolve(processed).then(async (processed) => {\n          if (status.value === \"aborted\") return INVALID;\n\n          const result = await this._def.schema._parseAsync({\n            data: processed,\n            path: ctx.path,\n            parent: ctx,\n          });\n          if (result.status === \"aborted\") return INVALID;\n          if (result.status === \"dirty\") return DIRTY(result.value);\n          if (status.value === \"dirty\") return DIRTY(result.value);\n          return result;\n        });\n      } else {\n        if (status.value === \"aborted\") return INVALID;\n        const result = this._def.schema._parseSync({\n          data: processed,\n          path: ctx.path,\n          parent: ctx,\n        });\n        if (result.status === \"aborted\") return INVALID;\n        if (result.status === \"dirty\") return DIRTY(result.value);\n        if (status.value === \"dirty\") return DIRTY(result.value);\n        return result;\n      }\n    }\n    if (effect.type === \"refinement\") {\n      const executeRefinement = (acc: unknown): any => {\n        const result = effect.refinement(acc, checkCtx);\n        if (ctx.common.async) {\n          return Promise.resolve(result);\n        }\n        if (result instanceof Promise) {\n          throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        }\n        return acc;\n      };\n\n      if (ctx.common.async === false) {\n        const inner = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        });\n        if (inner.status === \"aborted\") return INVALID;\n        if (inner.status === \"dirty\") status.dirty();\n\n        // return value is ignored\n        executeRefinement(inner.value);\n        return { status: status.value, value: inner.value };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n          if (inner.status === \"aborted\") return INVALID;\n          if (inner.status === \"dirty\") status.dirty();\n\n          return executeRefinement(inner.value).then(() => {\n            return { status: status.value, value: inner.value };\n          });\n        });\n      }\n    }\n\n    if (effect.type === \"transform\") {\n      if (ctx.common.async === false) {\n        const base = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        });\n\n        if (!isValid(base)) return INVALID;\n\n        const result = effect.transform(base.value, checkCtx);\n        if (result instanceof Promise) {\n          throw new Error(\n            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`\n          );\n        }\n\n        return { status: status.value, value: result };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n          if (!isValid(base)) return INVALID;\n\n          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n            status: status.value,\n            value: result,\n          }));\n        });\n      }\n    }\n\n    util.assertNever(effect);\n  }\n\n  static create = <I extends ZodTypeAny>(\n    schema: I,\n    effect: Effect<I[\"_output\"]>,\n    params?: RawCreateParams\n  ): ZodEffects<I, I[\"_output\"]> => {\n    return new ZodEffects({\n      schema,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect,\n      ...processCreateParams(params),\n    });\n  };\n\n  static createWithPreprocess = <I extends ZodTypeAny>(\n    preprocess: (arg: unknown, ctx: RefinementCtx) => unknown,\n    schema: I,\n    params?: RawCreateParams\n  ): ZodEffects<I, I[\"_output\"], unknown> => {\n    return new ZodEffects({\n      schema,\n      effect: { type: \"preprocess\", transform: preprocess },\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodEffects.innerType",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodEffects.innerType",
    "startLine": 4310,
    "endLine": 4312,
    "text": "  innerType() {\n    return this._def.schema;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodEffects.sourceType",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodEffects.sourceType",
    "startLine": 4314,
    "endLine": 4318,
    "text": "  sourceType(): T {\n    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n      ? (this._def.schema as unknown as ZodEffects<T>).sourceType()\n      : (this._def.schema as T);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodEffects._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodEffects._parse",
    "startLine": 4320,
    "endLine": 4438,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n\n    const effect = this._def.effect || null;\n\n    const checkCtx: RefinementCtx = {\n      addIssue: (arg: IssueData) => {\n        addIssueToContext(ctx, arg);\n        if (arg.fatal) {\n          status.abort();\n        } else {\n          status.dirty();\n        }\n      },\n      get path() {\n        return ctx.path;\n      },\n    };\n\n    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n\n    if (effect.type === \"preprocess\") {\n      const processed = effect.transform(ctx.data, checkCtx);\n\n      if (ctx.common.async) {\n        return Promise.resolve(processed).then(async (processed) => {\n          if (status.value === \"aborted\") return INVALID;\n\n          const result = await this._def.schema._parseAsync({\n            data: processed,\n            path: ctx.path,\n            parent: ctx,\n          });\n          if (result.status === \"aborted\") return INVALID;\n          if (result.status === \"dirty\") return DIRTY(result.value);\n          if (status.value === \"dirty\") return DIRTY(result.value);\n          return result;\n        });\n      } else {\n        if (status.value === \"aborted\") return INVALID;\n        const result = this._def.schema._parseSync({\n          data: processed,\n          path: ctx.path,\n          parent: ctx,\n        });\n        if (result.status === \"aborted\") return INVALID;\n        if (result.status === \"dirty\") return DIRTY(result.value);\n        if (status.value === \"dirty\") return DIRTY(result.value);\n        return result;\n      }\n    }\n    if (effect.type === \"refinement\") {\n      const executeRefinement = (acc: unknown): any => {\n        const result = effect.refinement(acc, checkCtx);\n        if (ctx.common.async) {\n          return Promise.resolve(result);\n        }\n        if (result instanceof Promise) {\n          throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        }\n        return acc;\n      };\n\n      if (ctx.common.async === false) {\n        const inner = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        });\n        if (inner.status === \"aborted\") return INVALID;\n        if (inner.status === \"dirty\") status.dirty();\n\n        // return value is ignored\n        executeRefinement(inner.value);\n        return { status: status.value, value: inner.value };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n          if (inner.status === \"aborted\") return INVALID;\n          if (inner.status === \"dirty\") status.dirty();\n\n          return executeRefinement(inner.value).then(() => {\n            return { status: status.value, value: inner.value };\n          });\n        });\n      }\n    }\n\n    if (effect.type === \"transform\") {\n      if (ctx.common.async === false) {\n        const base = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        });\n\n        if (!isValid(base)) return INVALID;\n\n        const result = effect.transform(base.value, checkCtx);\n        if (result instanceof Promise) {\n          throw new Error(\n            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`\n          );\n        }\n\n        return { status: status.value, value: result };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n          if (!isValid(base)) return INVALID;\n\n          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n            status: status.value,\n            value: result,\n          }));\n        });\n      }\n    }\n\n    util.assertNever(effect);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodOptional",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodOptional",
    "startLine": 4483,
    "endLine": 4507,
    "text": "export class ZodOptional<T extends ZodTypeAny> extends ZodType<\n  T[\"_output\"] | undefined,\n  ZodOptionalDef<T>,\n  T[\"_input\"] | undefined\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.undefined) {\n      return OK(undefined);\n    }\n    return this._def.innerType._parse(input);\n  }\n\n  unwrap() {\n    return this._def.innerType;\n  }\n\n  static create = <Inner extends ZodTypeAny>(type: Inner, params?: RawCreateParams): ZodOptional<Inner> => {\n    return new ZodOptional({\n      innerType: type,\n      typeName: ZodFirstPartyTypeKind.ZodOptional,\n      ...processCreateParams(params),\n    }) as any;\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodOptional._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodOptional._parse",
    "startLine": 4488,
    "endLine": 4494,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.undefined) {\n      return OK(undefined);\n    }\n    return this._def.innerType._parse(input);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodOptional.unwrap",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodOptional.unwrap",
    "startLine": 4496,
    "endLine": 4498,
    "text": "  unwrap() {\n    return this._def.innerType;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNullable",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNullable",
    "startLine": 4523,
    "endLine": 4547,
    "text": "export class ZodNullable<T extends ZodTypeAny> extends ZodType<\n  T[\"_output\"] | null,\n  ZodNullableDef<T>,\n  T[\"_input\"] | null\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.null) {\n      return OK(null);\n    }\n    return this._def.innerType._parse(input);\n  }\n\n  unwrap() {\n    return this._def.innerType;\n  }\n\n  static create = <Inner extends ZodTypeAny>(type: Inner, params?: RawCreateParams): ZodNullable<Inner> => {\n    return new ZodNullable({\n      innerType: type,\n      typeName: ZodFirstPartyTypeKind.ZodNullable,\n      ...processCreateParams(params),\n    }) as any;\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNullable._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNullable._parse",
    "startLine": 4528,
    "endLine": 4534,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.null) {\n      return OK(null);\n    }\n    return this._def.innerType._parse(input);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNullable.unwrap",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNullable.unwrap",
    "startLine": 4536,
    "endLine": 4538,
    "text": "  unwrap() {\n    return this._def.innerType;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodDefault",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodDefault",
    "startLine": 4562,
    "endLine": 4597,
    "text": "export class ZodDefault<T extends ZodTypeAny> extends ZodType<\n  util.noUndefined<T[\"_output\"]>,\n  ZodDefaultDef<T>,\n  T[\"_input\"] | undefined\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n    let data = ctx.data;\n    if (ctx.parsedType === ZodParsedType.undefined) {\n      data = this._def.defaultValue();\n    }\n    return this._def.innerType._parse({\n      data,\n      path: ctx.path,\n      parent: ctx,\n    });\n  }\n\n  removeDefault() {\n    return this._def.innerType;\n  }\n\n  static create = <Inner extends ZodTypeAny>(\n    type: Inner,\n    params: RawCreateParams & {\n      default: Inner[\"_input\"] | (() => util.noUndefined<Inner[\"_input\"]>);\n    }\n  ): ZodDefault<Inner> => {\n    return new ZodDefault({\n      innerType: type,\n      typeName: ZodFirstPartyTypeKind.ZodDefault,\n      defaultValue: typeof params.default === \"function\" ? params.default : () => params.default as any,\n      ...processCreateParams(params),\n    }) as any;\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodDefault._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodDefault._parse",
    "startLine": 4567,
    "endLine": 4578,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n    let data = ctx.data;\n    if (ctx.parsedType === ZodParsedType.undefined) {\n      data = this._def.defaultValue();\n    }\n    return this._def.innerType._parse({\n      data,\n      path: ctx.path,\n      parent: ctx,\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodDefault.removeDefault",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodDefault.removeDefault",
    "startLine": 4580,
    "endLine": 4582,
    "text": "  removeDefault() {\n    return this._def.innerType;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodCatch",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodCatch",
    "startLine": 4612,
    "endLine": 4685,
    "text": "export class ZodCatch<T extends ZodTypeAny> extends ZodType<\n  T[\"_output\"],\n  ZodCatchDef<T>,\n  unknown // any input will pass validation // T[\"_input\"]\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n\n    // newCtx is used to not collect issues from inner types in ctx\n    const newCtx: ParseContext = {\n      ...ctx,\n      common: {\n        ...ctx.common,\n        issues: [],\n      },\n    };\n\n    const result = this._def.innerType._parse({\n      data: newCtx.data,\n      path: newCtx.path,\n      parent: {\n        ...newCtx,\n      },\n    });\n\n    if (isAsync(result)) {\n      return result.then((result) => {\n        return {\n          status: \"valid\",\n          value:\n            result.status === \"valid\"\n              ? result.value\n              : this._def.catchValue({\n                  get error() {\n                    return new ZodError(newCtx.common.issues);\n                  },\n                  input: newCtx.data,\n                }),\n        };\n      });\n    } else {\n      return {\n        status: \"valid\",\n        value:\n          result.status === \"valid\"\n            ? result.value\n            : this._def.catchValue({\n                get error() {\n                  return new ZodError(newCtx.common.issues);\n                },\n                input: newCtx.data,\n              }),\n      };\n    }\n  }\n\n  removeCatch() {\n    return this._def.innerType;\n  }\n\n  static create = <Inner extends ZodTypeAny>(\n    type: Inner,\n    params: RawCreateParams & {\n      catch: Inner[\"_output\"] | (() => Inner[\"_output\"]);\n    }\n  ): ZodCatch<Inner> => {\n    return new ZodCatch({\n      innerType: type,\n      typeName: ZodFirstPartyTypeKind.ZodCatch,\n      catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodCatch._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodCatch._parse",
    "startLine": 4617,
    "endLine": 4666,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n\n    // newCtx is used to not collect issues from inner types in ctx\n    const newCtx: ParseContext = {\n      ...ctx,\n      common: {\n        ...ctx.common,\n        issues: [],\n      },\n    };\n\n    const result = this._def.innerType._parse({\n      data: newCtx.data,\n      path: newCtx.path,\n      parent: {\n        ...newCtx,\n      },\n    });\n\n    if (isAsync(result)) {\n      return result.then((result) => {\n        return {\n          status: \"valid\",\n          value:\n            result.status === \"valid\"\n              ? result.value\n              : this._def.catchValue({\n                  get error() {\n                    return new ZodError(newCtx.common.issues);\n                  },\n                  input: newCtx.data,\n                }),\n        };\n      });\n    } else {\n      return {\n        status: \"valid\",\n        value:\n          result.status === \"valid\"\n            ? result.value\n            : this._def.catchValue({\n                get error() {\n                  return new ZodError(newCtx.common.issues);\n                },\n                input: newCtx.data,\n              }),\n      };\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodCatch.removeCatch",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodCatch.removeCatch",
    "startLine": 4668,
    "endLine": 4670,
    "text": "  removeCatch() {\n    return this._def.innerType;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNaN",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNaN",
    "startLine": 4699,
    "endLine": 4721,
    "text": "export class ZodNaN extends ZodType<number, ZodNaNDef, number> {\n  _parse(input: ParseInput): ParseReturnType<any> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.nan) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.nan,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    return { status: \"valid\", value: input.data };\n  }\n\n  static create = (params?: RawCreateParams): ZodNaN => {\n    return new ZodNaN({\n      typeName: ZodFirstPartyTypeKind.ZodNaN,\n      ...processCreateParams(params),\n    });\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodNaN._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodNaN._parse",
    "startLine": 4700,
    "endLine": 4713,
    "text": "  _parse(input: ParseInput): ParseReturnType<any> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.nan) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.nan,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    return { status: \"valid\", value: input.data };\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBranded",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBranded",
    "startLine": 4741,
    "endLine": 4759,
    "text": "export class ZodBranded<T extends ZodTypeAny, B extends string | number | symbol> extends ZodType<\n  T[\"_output\"] & BRAND<B>,\n  ZodBrandedDef<T>,\n  T[\"_input\"]\n> {\n  _parse(input: ParseInput): ParseReturnType<any> {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx,\n    });\n  }\n\n  unwrap() {\n    return this._def.type;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBranded._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBranded._parse",
    "startLine": 4746,
    "endLine": 4754,
    "text": "  _parse(input: ParseInput): ParseReturnType<any> {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx,\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodBranded.unwrap",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodBranded.unwrap",
    "startLine": 4756,
    "endLine": 4758,
    "text": "  unwrap() {\n    return this._def.type;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodPipeline",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodPipeline",
    "startLine": 4775,
    "endLine": 4835,
    "text": "export class ZodPipeline<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodType<\n  B[\"_output\"],\n  ZodPipelineDef<A, B>,\n  A[\"_input\"]\n> {\n  _parse(input: ParseInput): ParseReturnType<any> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.common.async) {\n      const handleAsync = async () => {\n        const inResult = await this._def.in._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        });\n        if (inResult.status === \"aborted\") return INVALID;\n        if (inResult.status === \"dirty\") {\n          status.dirty();\n          return DIRTY(inResult.value);\n        } else {\n          return this._def.out._parseAsync({\n            data: inResult.value,\n            path: ctx.path,\n            parent: ctx,\n          });\n        }\n      };\n      return handleAsync();\n    } else {\n      const inResult = this._def.in._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx,\n      });\n      if (inResult.status === \"aborted\") return INVALID;\n      if (inResult.status === \"dirty\") {\n        status.dirty();\n        return {\n          status: \"dirty\",\n          value: inResult.value,\n        };\n      } else {\n        return this._def.out._parseSync({\n          data: inResult.value,\n          path: ctx.path,\n          parent: ctx,\n        });\n      }\n    }\n  }\n\n  static create<ASchema extends ZodTypeAny, BSchema extends ZodTypeAny>(\n    a: ASchema,\n    b: BSchema\n  ): ZodPipeline<ASchema, BSchema> {\n    return new ZodPipeline({\n      in: a,\n      out: b,\n      typeName: ZodFirstPartyTypeKind.ZodPipeline,\n    });\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodPipeline._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodPipeline._parse",
    "startLine": 4780,
    "endLine": 4823,
    "text": "  _parse(input: ParseInput): ParseReturnType<any> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.common.async) {\n      const handleAsync = async () => {\n        const inResult = await this._def.in._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        });\n        if (inResult.status === \"aborted\") return INVALID;\n        if (inResult.status === \"dirty\") {\n          status.dirty();\n          return DIRTY(inResult.value);\n        } else {\n          return this._def.out._parseAsync({\n            data: inResult.value,\n            path: ctx.path,\n            parent: ctx,\n          });\n        }\n      };\n      return handleAsync();\n    } else {\n      const inResult = this._def.in._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx,\n      });\n      if (inResult.status === \"aborted\") return INVALID;\n      if (inResult.status === \"dirty\") {\n        status.dirty();\n        return {\n          status: \"dirty\",\n          value: inResult.value,\n        };\n      } else {\n        return this._def.out._parseSync({\n          data: inResult.value,\n          path: ctx.path,\n          parent: ctx,\n        });\n      }\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodPipeline.create",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodPipeline.create",
    "startLine": 4825,
    "endLine": 4834,
    "text": "  static create<ASchema extends ZodTypeAny, BSchema extends ZodTypeAny>(\n    a: ASchema,\n    b: BSchema\n  ): ZodPipeline<ASchema, BSchema> {\n    return new ZodPipeline({\n      in: a,\n      out: b,\n      typeName: ZodFirstPartyTypeKind.ZodPipeline,\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodReadonly",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodReadonly",
    "startLine": 4870,
    "endLine": 4897,
    "text": "export class ZodReadonly<T extends ZodTypeAny> extends ZodType<\n  MakeReadonly<T[\"_output\"]>,\n  ZodReadonlyDef<T>,\n  MakeReadonly<T[\"_input\"]>\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const result = this._def.innerType._parse(input);\n    const freeze = (data: ParseReturnType<this[\"_output\"]>) => {\n      if (isValid(data)) {\n        data.value = Object.freeze(data.value);\n      }\n      return data;\n    };\n    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n  }\n\n  static create = <Inner extends ZodTypeAny>(type: Inner, params?: RawCreateParams): ZodReadonly<Inner> => {\n    return new ZodReadonly({\n      innerType: type,\n      typeName: ZodFirstPartyTypeKind.ZodReadonly,\n      ...processCreateParams(params),\n    }) as any;\n  };\n\n  unwrap() {\n    return this._def.innerType;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodReadonly._parse",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodReadonly._parse",
    "startLine": 4875,
    "endLine": 4884,
    "text": "  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const result = this._def.innerType._parse(input);\n    const freeze = (data: ParseReturnType<this[\"_output\"]>) => {\n      if (isValid(data)) {\n        data.value = Object.freeze(data.value);\n      }\n      return data;\n    };\n    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:ZodReadonly.unwrap",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "ZodReadonly.unwrap",
    "startLine": 4894,
    "endLine": 4896,
    "text": "  unwrap() {\n    return this._def.innerType;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:cleanParams",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "cleanParams",
    "startLine": 4906,
    "endLine": 4911,
    "text": "function cleanParams(params: unknown, data: unknown) {\n  const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n\n  const p2 = typeof p === \"string\" ? { message: p } : p;\n  return p2;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:custom",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "custom",
    "startLine": 4913,
    "endLine": 4948,
    "text": "export function custom<T>(\n  check?: (data: any) => any,\n  _params: string | CustomParams | ((input: any) => CustomParams) = {},\n  /**\n   * @deprecated\n   *\n   * Pass `fatal` into the params object instead:\n   *\n   * ```ts\n   * z.string().custom((val) => val.length > 5, { fatal: false })\n   * ```\n   *\n   */\n  fatal?: boolean\n): ZodType<T, ZodTypeDef, T> {\n  if (check)\n    return ZodAny.create().superRefine((data, ctx) => {\n      const r = check(data);\n      if (r instanceof Promise) {\n        return r.then((r) => {\n          if (!r) {\n            const params = cleanParams(_params, data);\n            const _fatal = params.fatal ?? fatal ?? true;\n            ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n          }\n        });\n      }\n      if (!r) {\n        const params = cleanParams(_params, data);\n        const _fatal = params.fatal ?? fatal ?? true;\n        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n      }\n      return;\n    });\n  return ZodAny.create();\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts:Class",
    "file": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "symbol": "Class",
    "startLine": 5033,
    "endLine": 5035,
    "text": "abstract class Class {\n  constructor(..._: any[]) {}\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/ZodError.ts:ZodError",
    "file": "mcp-rag-server/node_modules/zod/src/v3/ZodError.ts",
    "symbol": "ZodError",
    "startLine": 194,
    "endLine": 316,
    "text": "export class ZodError<T = any> extends Error {\n  issues: ZodIssue[] = [];\n\n  get errors() {\n    return this.issues;\n  }\n\n  constructor(issues: ZodIssue[]) {\n    super();\n\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      // eslint-disable-next-line ban/ban\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      (this as any).__proto__ = actualProto;\n    }\n    this.name = \"ZodError\";\n    this.issues = issues;\n  }\n\n  format(): ZodFormattedError<T>;\n  format<U>(mapper: (issue: ZodIssue) => U): ZodFormattedError<T, U>;\n  format(_mapper?: any) {\n    const mapper: (issue: ZodIssue) => any =\n      _mapper ||\n      function (issue: ZodIssue) {\n        return issue.message;\n      };\n    const fieldErrors: ZodFormattedError<T> = { _errors: [] } as any;\n    const processError = (error: ZodError) => {\n      for (const issue of error.issues) {\n        if (issue.code === \"invalid_union\") {\n          issue.unionErrors.map(processError);\n        } else if (issue.code === \"invalid_return_type\") {\n          processError(issue.returnTypeError);\n        } else if (issue.code === \"invalid_arguments\") {\n          processError(issue.argumentsError);\n        } else if (issue.path.length === 0) {\n          (fieldErrors as any)._errors.push(mapper(issue));\n        } else {\n          let curr: any = fieldErrors;\n          let i = 0;\n          while (i < issue.path.length) {\n            const el = issue.path[i]!;\n            const terminal = i === issue.path.length - 1;\n\n            if (!terminal) {\n              curr[el] = curr[el] || { _errors: [] };\n              // if (typeof el === \"string\") {\n              //   curr[el] = curr[el] || { _errors: [] };\n              // } else if (typeof el === \"number\") {\n              //   const errorArray: any = [];\n              //   errorArray._errors = [];\n              //   curr[el] = curr[el] || errorArray;\n              // }\n            } else {\n              curr[el] = curr[el] || { _errors: [] };\n              curr[el]._errors.push(mapper(issue));\n            }\n\n            curr = curr[el];\n            i++;\n          }\n        }\n      }\n    };\n\n    processError(this);\n    return fieldErrors;\n  }\n\n  static create = (issues: ZodIssue[]) => {\n    const error = new ZodError(issues);\n    return error;\n  };\n\n  static assert(value: unknown): asserts value is ZodError {\n    if (!(value instanceof ZodError)) {\n      throw new Error(`Not a ZodError: ${value}`);\n    }\n  }\n\n  override toString() {\n    return this.message;\n  }\n  override get message() {\n    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n  }\n\n  get isEmpty(): boolean {\n    return this.issues.length === 0;\n  }\n\n  addIssue = (sub: ZodIssue) => {\n    this.issues = [...this.issues, sub];\n  };\n\n  addIssues = (subs: ZodIssue[] = []) => {\n    this.issues = [...this.issues, ...subs];\n  };\n\n  flatten(): typeToFlattenedError<T>;\n  flatten<U>(mapper?: (issue: ZodIssue) => U): typeToFlattenedError<T, U>;\n  flatten<U = string>(mapper: (issue: ZodIssue) => U = (issue: ZodIssue) => issue.message as any): any {\n    const fieldErrors: any = {};\n    const formErrors: U[] = [];\n    for (const sub of this.issues) {\n      if (sub.path.length > 0) {\n        const firstEl = sub.path[0]!;\n        fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n        fieldErrors[firstEl].push(mapper(sub));\n      } else {\n        formErrors.push(mapper(sub));\n      }\n    }\n    return { formErrors, fieldErrors };\n  }\n\n  get formErrors() {\n    return this.flatten();\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/ZodError.ts:ZodError.format",
    "file": "mcp-rag-server/node_modules/zod/src/v3/ZodError.ts",
    "symbol": "ZodError.format",
    "startLine": 217,
    "endLine": 264,
    "text": "  format(_mapper?: any) {\n    const mapper: (issue: ZodIssue) => any =\n      _mapper ||\n      function (issue: ZodIssue) {\n        return issue.message;\n      };\n    const fieldErrors: ZodFormattedError<T> = { _errors: [] } as any;\n    const processError = (error: ZodError) => {\n      for (const issue of error.issues) {\n        if (issue.code === \"invalid_union\") {\n          issue.unionErrors.map(processError);\n        } else if (issue.code === \"invalid_return_type\") {\n          processError(issue.returnTypeError);\n        } else if (issue.code === \"invalid_arguments\") {\n          processError(issue.argumentsError);\n        } else if (issue.path.length === 0) {\n          (fieldErrors as any)._errors.push(mapper(issue));\n        } else {\n          let curr: any = fieldErrors;\n          let i = 0;\n          while (i < issue.path.length) {\n            const el = issue.path[i]!;\n            const terminal = i === issue.path.length - 1;\n\n            if (!terminal) {\n              curr[el] = curr[el] || { _errors: [] };\n              // if (typeof el === \"string\") {\n              //   curr[el] = curr[el] || { _errors: [] };\n              // } else if (typeof el === \"number\") {\n              //   const errorArray: any = [];\n              //   errorArray._errors = [];\n              //   curr[el] = curr[el] || errorArray;\n              // }\n            } else {\n              curr[el] = curr[el] || { _errors: [] };\n              curr[el]._errors.push(mapper(issue));\n            }\n\n            curr = curr[el];\n            i++;\n          }\n        }\n      }\n    };\n\n    processError(this);\n    return fieldErrors;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/ZodError.ts:ZodError.assert",
    "file": "mcp-rag-server/node_modules/zod/src/v3/ZodError.ts",
    "symbol": "ZodError.assert",
    "startLine": 271,
    "endLine": 275,
    "text": "  static assert(value: unknown): asserts value is ZodError {\n    if (!(value instanceof ZodError)) {\n      throw new Error(`Not a ZodError: ${value}`);\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/ZodError.ts:ZodError.toString",
    "file": "mcp-rag-server/node_modules/zod/src/v3/ZodError.ts",
    "symbol": "ZodError.toString",
    "startLine": 277,
    "endLine": 279,
    "text": "  override toString() {\n    return this.message;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/ZodError.ts:ZodError.flatten",
    "file": "mcp-rag-server/node_modules/zod/src/v3/ZodError.ts",
    "symbol": "ZodError.flatten",
    "startLine": 298,
    "endLine": 311,
    "text": "  flatten<U = string>(mapper: (issue: ZodIssue) => U = (issue: ZodIssue) => issue.message as any): any {\n    const fieldErrors: any = {};\n    const formErrors: U[] = [];\n    for (const sub of this.issues) {\n      if (sub.path.length > 0) {\n        const firstEl = sub.path[0]!;\n        fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n        fieldErrors[firstEl].push(mapper(sub));\n      } else {\n        formErrors.push(mapper(sub));\n      }\n    }\n    return { formErrors, fieldErrors };\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/custom-paths/import.ts:ImportClass",
    "file": "node_modules/madge/test/typescript/custom-paths/import.ts",
    "symbol": "ImportClass",
    "startLine": 4,
    "endLine": 9,
    "text": "class ImportClass {\n    constructor(public greeting: string) { }\n    greet() {\n        return \"<h1>\" + this.greeting + \"</h1>\";\n    }\n};"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/custom-paths/import.ts:ImportClass.greet",
    "file": "node_modules/madge/test/typescript/custom-paths/import.ts",
    "symbol": "ImportClass.greet",
    "startLine": 6,
    "endLine": 8,
    "text": "    greet() {\n        return \"<h1>\" + this.greeting + \"</h1>\";\n    }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts:detective",
    "file": "node_modules/precinct/node_modules/detective-postcss/src/index.ts",
    "symbol": "detective",
    "startLine": 8,
    "endLine": 55,
    "text": "function detective(src, options: detective.Options = { url: false }) {\n    let references = [];\n    let root;\n    try {\n        root = parse(src);\n    } catch (e) {\n        throw new detective.MalformedCssError();\n    }\n    root.walkAtRules(rule => {\n        let file = null;\n        if (isImportRule(rule)) {\n            const firstNode = parseValue(rule.params).first;\n            file = getValueOrUrl(firstNode);\n            if (file) {\n                debug(`found %s of %s`, '@import', file);\n            }\n        }\n        if (isValueRule(rule)) {\n            const lastNode = parseValue(rule.params).last;\n            if (isFrom(lastNode.prev())) {\n                file = getValueOrUrl(lastNode);\n                if (file) {\n                    debug(`found %s of %s`, '@value with import', file);\n                }\n            }\n            if (options.url && isUrlNode(lastNode)) {\n                file = getValueOrUrl(lastNode);\n                if (file) {\n                    debug(`found %s of %s`, 'url() with import', file);\n                }\n            }\n        }\n        file && references.push(file);\n    });\n    if (options.url) {\n        root.walkDecls(decl => {\n            const { nodes } = parseValue(decl.value);\n            const files = nodes.filter(isUrlNode).map(getValueOrUrl);\n            if (files) {\n                files.forEach(file =>\n                    debug(`found %s of %s`, 'url() with import', file)\n                );\n                references = references.concat(files);\n            }\n        });\n    }\n    return references;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts:parseValue",
    "file": "node_modules/precinct/node_modules/detective-postcss/src/index.ts",
    "symbol": "parseValue",
    "startLine": 57,
    "endLine": 59,
    "text": "function parseValue(value: string) {\n    return postCssValuesParser(value).parse().first;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts:getValueOrUrl",
    "file": "node_modules/precinct/node_modules/detective-postcss/src/index.ts",
    "symbol": "getValueOrUrl",
    "startLine": 61,
    "endLine": 71,
    "text": "function getValueOrUrl(node: postCssValuesParser.Node) {\n    let ret;\n    if (isUrlNode(node)) {\n        // ['(', 'file', ')']\n        ret = node.nodes[1].value;\n    } else {\n        ret = node.value;\n    }\n    // is-url sometimes gets data: URLs wrong\n    return !isUrl(ret) && !ret.startsWith('data:') && ret;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts:isUrlNode",
    "file": "node_modules/precinct/node_modules/detective-postcss/src/index.ts",
    "symbol": "isUrlNode",
    "startLine": 73,
    "endLine": 75,
    "text": "function isUrlNode(node: postCssValuesParser.Node) {\n    return node.type === 'func' && node.value === 'url';\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts:isValueRule",
    "file": "node_modules/precinct/node_modules/detective-postcss/src/index.ts",
    "symbol": "isValueRule",
    "startLine": 77,
    "endLine": 79,
    "text": "function isValueRule(rule: AtRule) {\n    return rule.name === 'value';\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts:isImportRule",
    "file": "node_modules/precinct/node_modules/detective-postcss/src/index.ts",
    "symbol": "isImportRule",
    "startLine": 81,
    "endLine": 83,
    "text": "function isImportRule(rule: AtRule) {\n    return rule.name === 'import';\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts:isFrom",
    "file": "node_modules/precinct/node_modules/detective-postcss/src/index.ts",
    "symbol": "isFrom",
    "startLine": 85,
    "endLine": 87,
    "text": "function isFrom(node: postCssValuesParser.Node) {\n    return node.type == 'word' && node.value === 'from';\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts:MalformedCssError",
    "file": "node_modules/precinct/node_modules/detective-postcss/src/index.ts",
    "symbol": "MalformedCssError",
    "startLine": 94,
    "endLine": 94,
    "text": "    export class MalformedCssError extends Error {}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/tests/index.spec.ts:assert",
    "file": "node_modules/precinct/node_modules/detective-postcss/tests/index.spec.ts",
    "symbol": "assert",
    "startLine": 3,
    "endLine": 5,
    "text": "function assert(source: string, deps: string[], options?: detective.Options) {\n    expect(detective(source, options)).toEqual(deps);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/benchmarks/realworld.ts:num",
    "file": "mcp-rag-server/node_modules/zod/src/v3/benchmarks/realworld.ts",
    "symbol": "num",
    "startLine": 25,
    "endLine": 27,
    "text": "function num() {\n  return ++i;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/benchmarks/realworld.ts:str",
    "file": "mcp-rag-server/node_modules/zod/src/v3/benchmarks/realworld.ts",
    "symbol": "str",
    "startLine": 29,
    "endLine": 31,
    "text": "function str() {\n  return (++i % 100).toString(16);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/benchmarks/realworld.ts:array",
    "file": "mcp-rag-server/node_modules/zod/src/v3/benchmarks/realworld.ts",
    "symbol": "array",
    "startLine": 33,
    "endLine": 35,
    "text": "function array<T>(fn: () => T): T[] {\n  return Array.from({ length: ++i % 10 }, () => fn());\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts:addIssueToContext",
    "file": "mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
    "symbol": "addIssueToContext",
    "startLine": 72,
    "endLine": 86,
    "text": "export function addIssueToContext(ctx: ParseContext, issueData: IssueData): void {\n  const overrideMap = getErrorMap();\n  const issue = makeIssue({\n    issueData: issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [\n      ctx.common.contextualErrorMap, // contextual error map is first priority\n      ctx.schemaErrorMap, // then schema-bound map if available\n      overrideMap, // then global override map\n      overrideMap === defaultErrorMap ? undefined : defaultErrorMap, // then global default map\n    ].filter((x) => !!x),\n  });\n  ctx.common.issues.push(issue);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts:ParseStatus",
    "file": "mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
    "symbol": "ParseStatus",
    "startLine": 92,
    "endLine": 151,
    "text": "export class ParseStatus {\n  value: \"aborted\" | \"dirty\" | \"valid\" = \"valid\";\n  dirty(): void {\n    if (this.value === \"valid\") this.value = \"dirty\";\n  }\n  abort(): void {\n    if (this.value !== \"aborted\") this.value = \"aborted\";\n  }\n\n  static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType {\n    const arrayValue: any[] = [];\n    for (const s of results) {\n      if (s.status === \"aborted\") return INVALID;\n      if (s.status === \"dirty\") status.dirty();\n      arrayValue.push(s.value);\n    }\n\n    return { status: status.value, value: arrayValue };\n  }\n\n  static async mergeObjectAsync(\n    status: ParseStatus,\n    pairs: { key: ParseReturnType<any>; value: ParseReturnType<any> }[]\n  ): Promise<SyncParseReturnType<any>> {\n    const syncPairs: ObjectPair[] = [];\n    for (const pair of pairs) {\n      const key = await pair.key;\n      const value = await pair.value;\n      syncPairs.push({\n        key,\n        value,\n      });\n    }\n    return ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n\n  static mergeObjectSync(\n    status: ParseStatus,\n    pairs: {\n      key: SyncParseReturnType<any>;\n      value: SyncParseReturnType<any>;\n      alwaysSet?: boolean;\n    }[]\n  ): SyncParseReturnType {\n    const finalObject: any = {};\n    for (const pair of pairs) {\n      const { key, value } = pair;\n      if (key.status === \"aborted\") return INVALID;\n      if (value.status === \"aborted\") return INVALID;\n      if (key.status === \"dirty\") status.dirty();\n      if (value.status === \"dirty\") status.dirty();\n\n      if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n        finalObject[key.value] = value.value;\n      }\n    }\n\n    return { status: status.value, value: finalObject };\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts:ParseStatus.dirty",
    "file": "mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
    "symbol": "ParseStatus.dirty",
    "startLine": 94,
    "endLine": 96,
    "text": "  dirty(): void {\n    if (this.value === \"valid\") this.value = \"dirty\";\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts:ParseStatus.abort",
    "file": "mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
    "symbol": "ParseStatus.abort",
    "startLine": 97,
    "endLine": 99,
    "text": "  abort(): void {\n    if (this.value !== \"aborted\") this.value = \"aborted\";\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts:ParseStatus.mergeArray",
    "file": "mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
    "symbol": "ParseStatus.mergeArray",
    "startLine": 101,
    "endLine": 110,
    "text": "  static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType {\n    const arrayValue: any[] = [];\n    for (const s of results) {\n      if (s.status === \"aborted\") return INVALID;\n      if (s.status === \"dirty\") status.dirty();\n      arrayValue.push(s.value);\n    }\n\n    return { status: status.value, value: arrayValue };\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts:ParseStatus.mergeObjectAsync",
    "file": "mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
    "symbol": "ParseStatus.mergeObjectAsync",
    "startLine": 112,
    "endLine": 126,
    "text": "  static async mergeObjectAsync(\n    status: ParseStatus,\n    pairs: { key: ParseReturnType<any>; value: ParseReturnType<any> }[]\n  ): Promise<SyncParseReturnType<any>> {\n    const syncPairs: ObjectPair[] = [];\n    for (const pair of pairs) {\n      const key = await pair.key;\n      const value = await pair.value;\n      syncPairs.push({\n        key,\n        value,\n      });\n    }\n    return ParseStatus.mergeObjectSync(status, syncPairs);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts:ParseStatus.mergeObjectSync",
    "file": "mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
    "symbol": "ParseStatus.mergeObjectSync",
    "startLine": 128,
    "endLine": 150,
    "text": "  static mergeObjectSync(\n    status: ParseStatus,\n    pairs: {\n      key: SyncParseReturnType<any>;\n      value: SyncParseReturnType<any>;\n      alwaysSet?: boolean;\n    }[]\n  ): SyncParseReturnType {\n    const finalObject: any = {};\n    for (const pair of pairs) {\n      const { key, value } = pair;\n      if (key.status === \"aborted\") return INVALID;\n      if (value.status === \"aborted\") return INVALID;\n      if (key.status === \"dirty\") status.dirty();\n      if (value.status === \"dirty\") status.dirty();\n\n      if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n        finalObject[key.value] = value.value;\n      }\n    }\n\n    return { status: status.value, value: finalObject };\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/util.ts:assertIs",
    "file": "mcp-rag-server/node_modules/zod/src/v3/helpers/util.ts",
    "symbol": "assertIs",
    "startLine": 6,
    "endLine": 6,
    "text": "  export function assertIs<T>(_arg: T): void {}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/util.ts:assertNever",
    "file": "mcp-rag-server/node_modules/zod/src/v3/helpers/util.ts",
    "symbol": "assertNever",
    "startLine": 7,
    "endLine": 9,
    "text": "  export function assertNever(_x: never): never {\n    throw new Error();\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/util.ts:joinValues",
    "file": "mcp-rag-server/node_modules/zod/src/v3/helpers/util.ts",
    "symbol": "joinValues",
    "startLine": 69,
    "endLine": 71,
    "text": "  export function joinValues<T extends any[]>(array: T, separator = \" | \"): string {\n    return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/generics.test.ts:stripOuter",
    "file": "mcp-rag-server/node_modules/zod/src/v3/tests/generics.test.ts",
    "symbol": "stripOuter",
    "startLine": 8,
    "endLine": 17,
    "text": "  async function stripOuter<TData extends z.ZodTypeAny>(schema: TData, data: unknown) {\n    return z\n      .object({\n        nested: schema, // as z.ZodTypeAny,\n      })\n      .transform((data) => {\n        return data.nested!;\n      })\n      .parse({ nested: data });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/instanceof.test.ts:Test",
    "file": "mcp-rag-server/node_modules/zod/src/v3/tests/instanceof.test.ts",
    "symbol": "Test",
    "startLine": 8,
    "endLine": 8,
    "text": "  class Test {}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/instanceof.test.ts:Subtest",
    "file": "mcp-rag-server/node_modules/zod/src/v3/tests/instanceof.test.ts",
    "symbol": "Subtest",
    "startLine": 9,
    "endLine": 9,
    "text": "  class Subtest extends Test {}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/instanceof.test.ts:AbstractBar",
    "file": "mcp-rag-server/node_modules/zod/src/v3/tests/instanceof.test.ts",
    "symbol": "AbstractBar",
    "startLine": 10,
    "endLine": 12,
    "text": "  abstract class AbstractBar {\n    constructor(public val: string) {}\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/instanceof.test.ts:Bar",
    "file": "mcp-rag-server/node_modules/zod/src/v3/tests/instanceof.test.ts",
    "symbol": "Bar",
    "startLine": 13,
    "endLine": 13,
    "text": "  class Bar extends AbstractBar {}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/Mocker.ts:getRandomInt",
    "file": "mcp-rag-server/node_modules/zod/src/v3/tests/Mocker.ts",
    "symbol": "getRandomInt",
    "startLine": 1,
    "endLine": 3,
    "text": "function getRandomInt(max: number) {\n  return Math.floor(Math.random() * Math.floor(max));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/Mocker.ts:Mocker",
    "file": "mcp-rag-server/node_modules/zod/src/v3/tests/Mocker.ts",
    "symbol": "Mocker",
    "startLine": 7,
    "endLine": 54,
    "text": "export class Mocker {\n  pick = (...args: any[]): any => {\n    return args[getRandomInt(args.length)];\n  };\n\n  get string(): string {\n    return Math.random().toString(36).substring(7);\n  }\n  get number(): number {\n    return Math.random() * 100;\n  }\n  get bigint(): bigint {\n    return BigInt(Math.floor(Math.random() * 10000));\n  }\n  get boolean(): boolean {\n    return Math.random() < 0.5;\n  }\n  get date(): Date {\n    return new Date(Math.floor(Date.now() * Math.random()));\n  }\n  get symbol(): symbol {\n    return testSymbol;\n  }\n  get null(): null {\n    return null;\n  }\n  get undefined(): undefined {\n    return undefined;\n  }\n  get stringOptional(): string | undefined {\n    return this.pick(this.string, this.undefined);\n  }\n  get stringNullable(): string | null {\n    return this.pick(this.string, this.null);\n  }\n  get numberOptional(): number | undefined {\n    return this.pick(this.number, this.undefined);\n  }\n  get numberNullable(): number | null {\n    return this.pick(this.number, this.null);\n  }\n  get booleanOptional(): boolean | undefined {\n    return this.pick(this.boolean, this.undefined);\n  }\n  get booleanNullable(): boolean | null {\n    return this.pick(this.boolean, this.null);\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/nullable.test.ts:checkErrors",
    "file": "mcp-rag-server/node_modules/zod/src/v3/tests/nullable.test.ts",
    "symbol": "checkErrors",
    "startLine": 6,
    "endLine": 18,
    "text": "function checkErrors(a: z.ZodTypeAny, bad: any) {\n  let expected: any;\n  try {\n    a.parse(bad);\n  } catch (error) {\n    expected = (error as z.ZodError).formErrors;\n  }\n  try {\n    a.nullable().parse(bad);\n  } catch (error) {\n    expect((error as z.ZodError).formErrors).toEqual(expected);\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/optional.test.ts:checkErrors",
    "file": "mcp-rag-server/node_modules/zod/src/v3/tests/optional.test.ts",
    "symbol": "checkErrors",
    "startLine": 6,
    "endLine": 18,
    "text": "function checkErrors(a: z.ZodTypeAny, bad: any) {\n  let expected: any;\n  try {\n    a.parse(bad);\n  } catch (error) {\n    expected = (error as z.ZodError).formErrors;\n  }\n  try {\n    a.optional().parse(bad);\n  } catch (error) {\n    expect((error as z.ZodError).formErrors).toEqual(expected);\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/string.test.ts:makeJwt",
    "file": "mcp-rag-server/node_modules/zod/src/v3/tests/string.test.ts",
    "symbol": "makeJwt",
    "startLine": 250,
    "endLine": 255,
    "text": "function makeJwt(header: object, payload: object) {\n  const headerBase64 = Buffer.from(JSON.stringify(header)).toString(\"base64url\");\n  const payloadBase64 = Buffer.from(JSON.stringify(payload)).toString(\"base64url\");\n  const signature = \"signature\"; // Placeholder for the signature\n  return `${headerBase64}.${payloadBase64}.${signature}`;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts:string",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts",
    "symbol": "string",
    "startLine": 5,
    "endLine": 7,
    "text": "export function string<T = unknown>(params?: string | core.$ZodStringParams): ZodCoercedString<T> {\n  return core._coercedString(schemas.ZodString, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts:number",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts",
    "symbol": "number",
    "startLine": 10,
    "endLine": 12,
    "text": "export function number<T = unknown>(params?: string | core.$ZodNumberParams): ZodCoercedNumber<T> {\n  return core._coercedNumber(schemas.ZodNumber, params) as ZodCoercedNumber<T>;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts:boolean",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts",
    "symbol": "boolean",
    "startLine": 15,
    "endLine": 17,
    "text": "export function boolean<T = unknown>(params?: string | core.$ZodBooleanParams): ZodCoercedBoolean<T> {\n  return core._coercedBoolean(schemas.ZodBoolean, params) as ZodCoercedBoolean<T>;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts:bigint",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts",
    "symbol": "bigint",
    "startLine": 20,
    "endLine": 22,
    "text": "export function bigint<T = unknown>(params?: string | core.$ZodBigIntParams): ZodCoercedBigInt<T> {\n  return core._coercedBigint(schemas.ZodBigInt, params) as ZodCoercedBigInt<T>;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts:date",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts",
    "symbol": "date",
    "startLine": 25,
    "endLine": 27,
    "text": "export function date<T = unknown>(params?: string | core.$ZodDateParams): ZodCoercedDate<T> {\n  return core._coercedDate(schemas.ZodDate, params) as ZodCoercedDate<T>;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/compat.ts:setErrorMap",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/compat.ts",
    "symbol": "setErrorMap",
    "startLine": 46,
    "endLine": 50,
    "text": "export function setErrorMap(map: core.$ZodErrorMap): void {\n  core.config({\n    customError: map,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/compat.ts:getErrorMap",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/compat.ts",
    "symbol": "getErrorMap",
    "startLine": 53,
    "endLine": 55,
    "text": "export function getErrorMap(): core.$ZodErrorMap<core.$ZodIssue> | undefined {\n  return core.config().customError;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/iso.ts:datetime",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/iso.ts",
    "symbol": "datetime",
    "startLine": 23,
    "endLine": 25,
    "text": "export function datetime(params?: string | core.$ZodISODateTimeParams): ZodISODateTime {\n  return core._isoDateTime(ZodISODateTime, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/iso.ts:date",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/iso.ts",
    "symbol": "date",
    "startLine": 43,
    "endLine": 45,
    "text": "export function date(params?: string | core.$ZodISODateParams): ZodISODate {\n  return core._isoDate(ZodISODate, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/iso.ts:time",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/iso.ts",
    "symbol": "time",
    "startLine": 65,
    "endLine": 67,
    "text": "export function time(params?: string | core.$ZodISOTimeParams): ZodISOTime {\n  return core._isoTime(ZodISOTime, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/iso.ts:duration",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/iso.ts",
    "symbol": "duration",
    "startLine": 88,
    "endLine": 90,
    "text": "export function duration(params?: string | core.$ZodISODurationParams): ZodISODuration {\n  return core._isoDuration(ZodISODuration, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:string",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "string",
    "startLine": 368,
    "endLine": 368,
    "text": "export function string(params?: string | core.$ZodStringParams): ZodString;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:string",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "string",
    "startLine": 369,
    "endLine": 369,
    "text": "export function string<T extends string>(params?: string | core.$ZodStringParams): core.$ZodType<T, T>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:string",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "string",
    "startLine": 370,
    "endLine": 372,
    "text": "export function string(params?: string | core.$ZodStringParams): ZodString {\n  return core._string(ZodString, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:email",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "email",
    "startLine": 395,
    "endLine": 397,
    "text": "export function email(params?: string | core.$ZodEmailParams): ZodEmail {\n  return core._email(ZodEmail, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:guid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "guid",
    "startLine": 409,
    "endLine": 411,
    "text": "export function guid(params?: string | core.$ZodGUIDParams): ZodGUID {\n  return core._guid(ZodGUID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:uuid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "uuid",
    "startLine": 423,
    "endLine": 425,
    "text": "export function uuid(params?: string | core.$ZodUUIDParams): ZodUUID {\n  return core._uuid(ZodUUID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:uuidv4",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "uuidv4",
    "startLine": 427,
    "endLine": 429,
    "text": "export function uuidv4(params?: string | core.$ZodUUIDv4Params): ZodUUID {\n  return core._uuidv4(ZodUUID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:uuidv6",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "uuidv6",
    "startLine": 433,
    "endLine": 435,
    "text": "export function uuidv6(params?: string | core.$ZodUUIDv6Params): ZodUUID {\n  return core._uuidv6(ZodUUID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:uuidv7",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "uuidv7",
    "startLine": 439,
    "endLine": 441,
    "text": "export function uuidv7(params?: string | core.$ZodUUIDv7Params): ZodUUID {\n  return core._uuidv7(ZodUUID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:url",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "url",
    "startLine": 453,
    "endLine": 455,
    "text": "export function url(params?: string | core.$ZodURLParams): ZodURL {\n  return core._url(ZodURL, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:emoji",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "emoji",
    "startLine": 467,
    "endLine": 469,
    "text": "export function emoji(params?: string | core.$ZodEmojiParams): ZodEmoji {\n  return core._emoji(ZodEmoji, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:nanoid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "nanoid",
    "startLine": 481,
    "endLine": 483,
    "text": "export function nanoid(params?: string | core.$ZodNanoIDParams): ZodNanoID {\n  return core._nanoid(ZodNanoID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:cuid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "cuid",
    "startLine": 495,
    "endLine": 497,
    "text": "export function cuid(params?: string | core.$ZodCUIDParams): ZodCUID {\n  return core._cuid(ZodCUID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:cuid2",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "cuid2",
    "startLine": 509,
    "endLine": 511,
    "text": "export function cuid2(params?: string | core.$ZodCUID2Params): ZodCUID2 {\n  return core._cuid2(ZodCUID2, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:ulid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "ulid",
    "startLine": 523,
    "endLine": 525,
    "text": "export function ulid(params?: string | core.$ZodULIDParams): ZodULID {\n  return core._ulid(ZodULID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:xid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "xid",
    "startLine": 537,
    "endLine": 539,
    "text": "export function xid(params?: string | core.$ZodXIDParams): ZodXID {\n  return core._xid(ZodXID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:ksuid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "ksuid",
    "startLine": 551,
    "endLine": 553,
    "text": "export function ksuid(params?: string | core.$ZodKSUIDParams): ZodKSUID {\n  return core._ksuid(ZodKSUID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:ipv4",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "ipv4",
    "startLine": 579,
    "endLine": 581,
    "text": "export function ipv4(params?: string | core.$ZodIPv4Params): ZodIPv4 {\n  return core._ipv4(ZodIPv4, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:ipv6",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "ipv6",
    "startLine": 592,
    "endLine": 594,
    "text": "export function ipv6(params?: string | core.$ZodIPv6Params): ZodIPv6 {\n  return core._ipv6(ZodIPv6, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:cidrv4",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "cidrv4",
    "startLine": 605,
    "endLine": 607,
    "text": "export function cidrv4(params?: string | core.$ZodCIDRv4Params): ZodCIDRv4 {\n  return core._cidrv4(ZodCIDRv4, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:cidrv6",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "cidrv6",
    "startLine": 618,
    "endLine": 620,
    "text": "export function cidrv6(params?: string | core.$ZodCIDRv6Params): ZodCIDRv6 {\n  return core._cidrv6(ZodCIDRv6, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:base64",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "base64",
    "startLine": 631,
    "endLine": 633,
    "text": "export function base64(params?: string | core.$ZodBase64Params): ZodBase64 {\n  return core._base64(ZodBase64, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:base64url",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "base64url",
    "startLine": 647,
    "endLine": 649,
    "text": "export function base64url(params?: string | core.$ZodBase64URLParams): ZodBase64URL {\n  return core._base64url(ZodBase64URL, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:e164",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "e164",
    "startLine": 661,
    "endLine": 663,
    "text": "export function e164(params?: string | core.$ZodE164Params): ZodE164 {\n  return core._e164(ZodE164, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:jwt",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "jwt",
    "startLine": 675,
    "endLine": 677,
    "text": "export function jwt(params?: string | core.$ZodJWTParams): ZodJWT {\n  return core._jwt(ZodJWT, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:stringFormat",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "stringFormat",
    "startLine": 693,
    "endLine": 699,
    "text": "export function stringFormat<Format extends string>(\n  format: Format,\n  fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp,\n  _params: string | core.$ZodStringFormatParams = {}\n): ZodCustomStringFormat<Format> {\n  return core._stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:number",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "number",
    "startLine": 770,
    "endLine": 772,
    "text": "export function number(params?: string | core.$ZodNumberParams): ZodNumber {\n  return core._number(ZodNumber, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:int",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "int",
    "startLine": 788,
    "endLine": 790,
    "text": "export function int(params?: string | core.$ZodCheckNumberFormatParams): ZodInt {\n  return core._int(ZodNumberFormat, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:float32",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "float32",
    "startLine": 794,
    "endLine": 796,
    "text": "export function float32(params?: string | core.$ZodCheckNumberFormatParams): ZodFloat32 {\n  return core._float32(ZodNumberFormat, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:float64",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "float64",
    "startLine": 800,
    "endLine": 802,
    "text": "export function float64(params?: string | core.$ZodCheckNumberFormatParams): ZodFloat64 {\n  return core._float64(ZodNumberFormat, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:int32",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "int32",
    "startLine": 806,
    "endLine": 808,
    "text": "export function int32(params?: string | core.$ZodCheckNumberFormatParams): ZodInt32 {\n  return core._int32(ZodNumberFormat, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:uint32",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "uint32",
    "startLine": 812,
    "endLine": 814,
    "text": "export function uint32(params?: string | core.$ZodCheckNumberFormatParams): ZodUInt32 {\n  return core._uint32(ZodNumberFormat, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:boolean",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "boolean",
    "startLine": 824,
    "endLine": 826,
    "text": "export function boolean(params?: string | core.$ZodBooleanParams): ZodBoolean {\n  return core._boolean(ZodBoolean, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:bigint",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "bigint",
    "startLine": 874,
    "endLine": 876,
    "text": "export function bigint(params?: string | core.$ZodBigIntParams): ZodBigInt {\n  return core._bigint(ZodBigInt, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:int64",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "int64",
    "startLine": 892,
    "endLine": 894,
    "text": "export function int64(params?: string | core.$ZodBigIntFormatParams): ZodBigIntFormat {\n  return core._int64(ZodBigIntFormat, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:uint64",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "uint64",
    "startLine": 897,
    "endLine": 899,
    "text": "export function uint64(params?: string | core.$ZodBigIntFormatParams): ZodBigIntFormat {\n  return core._uint64(ZodBigIntFormat, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:symbol",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "symbol",
    "startLine": 908,
    "endLine": 910,
    "text": "export function symbol(params?: string | core.$ZodSymbolParams): ZodSymbol {\n  return core._symbol(ZodSymbol, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:_undefined",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "_undefined",
    "startLine": 922,
    "endLine": 924,
    "text": "function _undefined(params?: string | core.$ZodUndefinedParams): ZodUndefined {\n  return core._undefined(ZodUndefined, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:_null",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "_null",
    "startLine": 934,
    "endLine": 936,
    "text": "function _null(params?: string | core.$ZodNullParams): ZodNull {\n  return core._null(ZodNull, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:any",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "any",
    "startLine": 946,
    "endLine": 948,
    "text": "export function any(): ZodAny {\n  return core._any(ZodAny);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:unknown",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "unknown",
    "startLine": 957,
    "endLine": 959,
    "text": "export function unknown(): ZodUnknown {\n  return core._unknown(ZodUnknown);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:never",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "never",
    "startLine": 968,
    "endLine": 970,
    "text": "export function never(params?: string | core.$ZodNeverParams): ZodNever {\n  return core._never(ZodNever, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:_void",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "_void",
    "startLine": 979,
    "endLine": 981,
    "text": "function _void(params?: string | core.$ZodVoidParams): ZodVoid {\n  return core._void(ZodVoid, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:date",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "date",
    "startLine": 1008,
    "endLine": 1010,
    "text": "export function date(params?: string | core.$ZodDateParams): ZodDate {\n  return core._date(ZodDate, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:array",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "array",
    "startLine": 1037,
    "endLine": 1039,
    "text": "export function array<T extends core.SomeType>(element: T, params?: string | core.$ZodArrayParams): ZodArray<T> {\n  return core._array(ZodArray, element as any, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:keyof",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "keyof",
    "startLine": 1042,
    "endLine": 1045,
    "text": "export function keyof<T extends ZodObject>(schema: T): ZodLiteral<Exclude<keyof T[\"_zod\"][\"output\"], symbol>> {\n  const shape = schema._zod.def.shape;\n  return literal(Object.keys(shape)) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:object",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "object",
    "startLine": 1159,
    "endLine": 1172,
    "text": "export function object<T extends core.$ZodLooseShape = Partial<Record<never, core.SomeType>>>(\n  shape?: T,\n  params?: string | core.$ZodObjectParams\n): ZodObject<util.Writeable<T>, core.$strip> {\n  const def: core.$ZodObjectDef = {\n    type: \"object\",\n    get shape() {\n      util.assignProp(this, \"shape\", { ...shape });\n      return this.shape;\n    },\n    ...util.normalizeParams(params),\n  };\n  return new ZodObject(def) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:strictObject",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "strictObject",
    "startLine": 1176,
    "endLine": 1189,
    "text": "export function strictObject<T extends core.$ZodLooseShape>(\n  shape: T,\n  params?: string | core.$ZodObjectParams\n): ZodObject<T, core.$strict> {\n  return new ZodObject({\n    type: \"object\",\n    get shape() {\n      util.assignProp(this, \"shape\", { ...shape });\n      return this.shape;\n    },\n    catchall: never(),\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:looseObject",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "looseObject",
    "startLine": 1193,
    "endLine": 1206,
    "text": "export function looseObject<T extends core.$ZodLooseShape>(\n  shape: T,\n  params?: string | core.$ZodObjectParams\n): ZodObject<T, core.$loose> {\n  return new ZodObject({\n    type: \"object\",\n    get shape() {\n      util.assignProp(this, \"shape\", { ...shape });\n      return this.shape;\n    },\n    catchall: unknown(),\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:union",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "union",
    "startLine": 1220,
    "endLine": 1229,
    "text": "export function union<const T extends readonly core.SomeType[]>(\n  options: T,\n  params?: string | core.$ZodUnionParams\n): ZodUnion<T> {\n  return new ZodUnion({\n    type: \"union\",\n    options: options as any as core.$ZodType[],\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:discriminatedUnion",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "discriminatedUnion",
    "startLine": 1245,
    "endLine": 1259,
    "text": "export function discriminatedUnion<\n  Types extends readonly [core.$ZodTypeDiscriminable, ...core.$ZodTypeDiscriminable[]],\n>(\n  discriminator: string,\n  options: Types,\n  params?: string | core.$ZodDiscriminatedUnionParams\n): ZodDiscriminatedUnion<Types> {\n  // const [options, params] = args;\n  return new ZodDiscriminatedUnion({\n    type: \"union\",\n    options,\n    discriminator,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:intersection",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "intersection",
    "startLine": 1273,
    "endLine": 1282,
    "text": "export function intersection<T extends core.SomeType, U extends core.SomeType>(\n  left: T,\n  right: U\n): ZodIntersection<T, U> {\n  return new ZodIntersection({\n    type: \"intersection\",\n    left: left as any as core.$ZodType,\n    right: right as any as core.$ZodType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:tuple",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "tuple",
    "startLine": 1302,
    "endLine": 1305,
    "text": "export function tuple<T extends readonly [core.SomeType, ...core.SomeType[]]>(\n  items: T,\n  params?: string | core.$ZodTupleParams\n): ZodTuple<T, null>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:tuple",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "tuple",
    "startLine": 1306,
    "endLine": 1310,
    "text": "export function tuple<T extends readonly [core.SomeType, ...core.SomeType[]], Rest extends core.SomeType>(\n  items: T,\n  rest: Rest,\n  params?: string | core.$ZodTupleParams\n): ZodTuple<T, Rest>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:tuple",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "tuple",
    "startLine": 1311,
    "endLine": 1311,
    "text": "export function tuple(items: [], params?: string | core.$ZodTupleParams): ZodTuple<[], null>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:tuple",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "tuple",
    "startLine": 1312,
    "endLine": 1326,
    "text": "export function tuple(\n  items: core.SomeType[],\n  _paramsOrRest?: string | core.$ZodTupleParams | core.SomeType,\n  _params?: string | core.$ZodTupleParams\n) {\n  const hasRest = _paramsOrRest instanceof core.$ZodType;\n  const params = hasRest ? _params : _paramsOrRest;\n  const rest = hasRest ? _paramsOrRest : null;\n  return new ZodTuple({\n    type: \"tuple\",\n    items: items as any as core.$ZodType[],\n    rest,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:record",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "record",
    "startLine": 1345,
    "endLine": 1356,
    "text": "export function record<Key extends core.$ZodRecordKey, Value extends core.SomeType>(\n  keyType: Key,\n  valueType: Value,\n  params?: string | core.$ZodRecordParams\n): ZodRecord<Key, Value> {\n  return new ZodRecord({\n    type: \"record\",\n    keyType,\n    valueType: valueType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:partialRecord",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "partialRecord",
    "startLine": 1358,
    "endLine": 1369,
    "text": "export function partialRecord<Key extends core.$ZodRecordKey, Value extends core.SomeType>(\n  keyType: Key,\n  valueType: Value,\n  params?: string | core.$ZodRecordParams\n): ZodRecord<Key & core.$partial, Value> {\n  return new ZodRecord({\n    type: \"record\",\n    keyType: union([keyType, never()]),\n    valueType: valueType as any,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:map",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "map",
    "startLine": 1385,
    "endLine": 1396,
    "text": "export function map<Key extends core.SomeType, Value extends core.SomeType>(\n  keyType: Key,\n  valueType: Value,\n  params?: string | core.$ZodMapParams\n): ZodMap<Key, Value> {\n  return new ZodMap({\n    type: \"map\",\n    keyType: keyType as any as core.$ZodType,\n    valueType: valueType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:set",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "set",
    "startLine": 1418,
    "endLine": 1427,
    "text": "export function set<Value extends core.SomeType>(\n  valueType: Value,\n  params?: string | core.$ZodSetParams\n): ZodSet<Value> {\n  return new ZodSet({\n    type: \"set\",\n    valueType: valueType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:_enum",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "_enum",
    "startLine": 1487,
    "endLine": 1490,
    "text": "function _enum<const T extends readonly string[]>(\n  values: T,\n  params?: string | core.$ZodEnumParams\n): ZodEnum<util.ToEnum<T[number]>>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:_enum",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "_enum",
    "startLine": 1491,
    "endLine": 1491,
    "text": "function _enum<const T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodEnum<T>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:_enum",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "_enum",
    "startLine": 1492,
    "endLine": 1500,
    "text": "function _enum(values: any, params?: string | core.$ZodEnumParams) {\n  const entries: any = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n\n  return new ZodEnum({\n    type: \"enum\",\n    entries,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:nativeEnum",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "nativeEnum",
    "startLine": 1510,
    "endLine": 1516,
    "text": "export function nativeEnum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodEnum<T> {\n  return new ZodEnum({\n    type: \"enum\",\n    entries,\n    ...util.normalizeParams(params),\n  }) as any as ZodEnum<T>;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:literal",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "literal",
    "startLine": 1540,
    "endLine": 1543,
    "text": "export function literal<const T extends ReadonlyArray<util.Literal>>(\n  value: T,\n  params?: string | core.$ZodLiteralParams\n): ZodLiteral<T[number]>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:literal",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "literal",
    "startLine": 1544,
    "endLine": 1547,
    "text": "export function literal<const T extends util.Literal>(\n  value: T,\n  params?: string | core.$ZodLiteralParams\n): ZodLiteral<T>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:literal",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "literal",
    "startLine": 1548,
    "endLine": 1554,
    "text": "export function literal(value: any, params: any) {\n  return new ZodLiteral({\n    type: \"literal\",\n    values: Array.isArray(value) ? value : [value],\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:file",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "file",
    "startLine": 1571,
    "endLine": 1573,
    "text": "export function file(params?: string | core.$ZodFileParams): ZodFile {\n  return core._file(ZodFile, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:transform",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "transform",
    "startLine": 1615,
    "endLine": 1622,
    "text": "export function transform<I = unknown, O = I>(\n  fn: (input: I, ctx: core.ParsePayload) => O\n): ZodTransform<Awaited<O>, I> {\n  return new ZodTransform({\n    type: \"transform\",\n    transform: fn as any,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:optional",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "optional",
    "startLine": 1640,
    "endLine": 1645,
    "text": "export function optional<T extends core.SomeType>(innerType: T): ZodOptional<T> {\n  return new ZodOptional({\n    type: \"optional\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:nullable",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "nullable",
    "startLine": 1663,
    "endLine": 1668,
    "text": "export function nullable<T extends core.SomeType>(innerType: T): ZodNullable<T> {\n  return new ZodNullable({\n    type: \"nullable\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:nullish",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "nullish",
    "startLine": 1671,
    "endLine": 1673,
    "text": "export function nullish<T extends core.SomeType>(innerType: T): ZodOptional<ZodNullable<T>> {\n  return optional(nullable(innerType));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:_default",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "_default",
    "startLine": 1691,
    "endLine": 1702,
    "text": "export function _default<T extends core.SomeType>(\n  innerType: T,\n  defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)\n): ZodDefault<T> {\n  return new ZodDefault({\n    type: \"default\",\n    innerType: innerType as any as core.$ZodType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? (defaultValue as Function)() : defaultValue;\n    },\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:prefault",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "prefault",
    "startLine": 1719,
    "endLine": 1730,
    "text": "export function prefault<T extends core.SomeType>(\n  innerType: T,\n  defaultValue: core.input<T> | (() => core.input<T>)\n): ZodPrefault<T> {\n  return new ZodPrefault({\n    type: \"prefault\",\n    innerType: innerType as any as core.$ZodType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? (defaultValue as Function)() : defaultValue;\n    },\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:nonoptional",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "nonoptional",
    "startLine": 1748,
    "endLine": 1757,
    "text": "export function nonoptional<T extends core.SomeType>(\n  innerType: T,\n  params?: string | core.$ZodNonOptionalParams\n): ZodNonOptional<T> {\n  return new ZodNonOptional({\n    type: \"nonoptional\",\n    innerType: innerType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:success",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "success",
    "startLine": 1772,
    "endLine": 1777,
    "text": "export function success<T extends core.SomeType>(innerType: T): ZodSuccess<T> {\n  return new ZodSuccess({\n    type: \"success\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:_catch",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "_catch",
    "startLine": 1795,
    "endLine": 1806,
    "text": "function _catch<T extends core.SomeType>(\n  innerType: T,\n  catchValue: core.output<T> | ((ctx: core.$ZodCatchCtx) => core.output<T>)\n): ZodCatch<T> {\n  return new ZodCatch({\n    type: \"catch\",\n    innerType: innerType as any as core.$ZodType,\n    catchValue: (typeof catchValue === \"function\" ? catchValue : () => catchValue) as (\n      ctx: core.$ZodCatchCtx\n    ) => core.output<T>,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:nan",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "nan",
    "startLine": 1816,
    "endLine": 1818,
    "text": "export function nan(params?: string | core.$ZodNaNParams): ZodNaN {\n  return core._nan(ZodNaN, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:pipe",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "pipe",
    "startLine": 1835,
    "endLine": 1838,
    "text": "export function pipe<\n  const A extends core.SomeType,\n  B extends core.$ZodType<unknown, core.output<A>> = core.$ZodType<unknown, core.output<A>>,\n>(in_: A, out: B | core.$ZodType<unknown, core.output<A>>): ZodPipe<A, B>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:pipe",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "pipe",
    "startLine": 1839,
    "endLine": 1846,
    "text": "export function pipe(in_: core.SomeType, out: core.SomeType) {\n  return new ZodPipe({\n    type: \"pipe\",\n    in: in_ as unknown as core.$ZodType,\n    out: out as unknown as core.$ZodType,\n    // ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:readonly",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "readonly",
    "startLine": 1860,
    "endLine": 1865,
    "text": "export function readonly<T extends core.SomeType>(innerType: T): ZodReadonly<T> {\n  return new ZodReadonly({\n    type: \"readonly\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:templateLiteral",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "templateLiteral",
    "startLine": 1879,
    "endLine": 1888,
    "text": "export function templateLiteral<const Parts extends core.$ZodTemplateLiteralPart[]>(\n  parts: Parts,\n  params?: string | core.$ZodTemplateLiteralParams\n): ZodTemplateLiteral<core.$PartsToTemplateLiteral<Parts>> {\n  return new ZodTemplateLiteral({\n    type: \"template_literal\",\n    parts,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:lazy",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "lazy",
    "startLine": 1903,
    "endLine": 1908,
    "text": "export function lazy<T extends core.SomeType>(getter: () => T): ZodLazy<T> {\n  return new ZodLazy({\n    type: \"lazy\",\n    getter: getter as any,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:promise",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "promise",
    "startLine": 1923,
    "endLine": 1928,
    "text": "export function promise<T extends core.SomeType>(innerType: T): ZodPromise<T> {\n  return new ZodPromise({\n    type: \"promise\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:check",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "check",
    "startLine": 1940,
    "endLine": 1948,
    "text": "export function check<O = unknown>(fn: core.CheckFn<O>): core.$ZodCheck<O> {\n  const ch = new core.$ZodCheck({\n    check: \"custom\",\n    // ...util.normalizeParams(params),\n  });\n\n  ch._zod.check = fn;\n  return ch;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:custom",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "custom",
    "startLine": 1950,
    "endLine": 1955,
    "text": "export function custom<O>(\n  fn?: (data: unknown) => unknown,\n  _params?: string | core.$ZodCustomParams | undefined\n): ZodCustom<O, O> {\n  return core._custom(ZodCustom, fn ?? (() => true), _params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:refine",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "refine",
    "startLine": 1957,
    "endLine": 1962,
    "text": "export function refine<T>(\n  fn: (arg: NoInfer<T>) => util.MaybeAsync<unknown>,\n  _params: string | core.$ZodCustomParams = {}\n): core.$ZodCheck<T> {\n  return core._refine(ZodCustom, fn, _params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:superRefine",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "superRefine",
    "startLine": 1965,
    "endLine": 1985,
    "text": "export function superRefine<T>(fn: (arg: T, payload: RefinementCtx<T>) => void | Promise<void>): core.$ZodCheck<T> {\n  const ch = check<T>((payload) => {\n    (payload as RefinementCtx).addIssue = (issue) => {\n      if (typeof issue === \"string\") {\n        payload.issues.push(util.issue(issue, payload.value, ch._zod.def));\n      } else {\n        // for Zod 3 backwards compatibility\n        const _issue: any = issue;\n        if (_issue.fatal) _issue.continue = false;\n        _issue.code ??= \"custom\";\n        _issue.input ??= payload.value;\n        _issue.inst ??= ch;\n        _issue.continue ??= !ch._zod.def.abort;\n        payload.issues.push(util.issue(_issue));\n      }\n    };\n\n    return fn(payload.value, payload as RefinementCtx<T>);\n  });\n  return ch;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:_instanceof",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "_instanceof",
    "startLine": 1992,
    "endLine": 2007,
    "text": "function _instanceof<T extends typeof util.Class>(\n  cls: T,\n  params: ZodInstanceOfParams = {\n    error: `Input not instance of ${cls.name}`,\n  }\n): ZodCustom<InstanceType<T>, InstanceType<T>> {\n  const inst = new ZodCustom({\n    type: \"custom\",\n    check: \"custom\",\n    fn: (data) => data instanceof cls,\n    abort: true,\n    ...(util.normalizeParams(params) as any),\n  });\n  inst._zod.bag.Class = cls;\n  return inst as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:json",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "json",
    "startLine": 2038,
    "endLine": 2044,
    "text": "export function json(params?: string | core.$ZodCustomParams): ZodJSONSchema {\n  const jsonSchema: any = lazy(() => {\n    return union([string(params), number(), boolean(), _null(), array(jsonSchema), record(string(), jsonSchema)]);\n  });\n\n  return jsonSchema;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts:preprocess",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "symbol": "preprocess",
    "startLine": 2049,
    "endLine": 2054,
    "text": "export function preprocess<A, U extends core.SomeType, B = unknown>(\n  fn: (arg: B, ctx: RefinementCtx) => A,\n  schema: U\n): ZodPipe<ZodTransform<A, B>, U> {\n  return pipe(transform(fn as any), schema as any) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_string",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_string",
    "startLine": 61,
    "endLine": 69,
    "text": "export function _string<T extends schemas.$ZodString>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodStringParams\n): T {\n  return new Class({\n    type: \"string\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_coercedString",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_coercedString",
    "startLine": 71,
    "endLine": 80,
    "text": "export function _coercedString<T extends schemas.$ZodString>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodStringParams\n): T {\n  return new Class({\n    type: \"string\",\n    coerce: true,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_email",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_email",
    "startLine": 89,
    "endLine": 100,
    "text": "export function _email<T extends schemas.$ZodEmail>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodEmailParams | $ZodCheckEmailParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"email\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_guid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_guid",
    "startLine": 105,
    "endLine": 116,
    "text": "export function _guid<T extends schemas.$ZodGUID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodGUIDParams | $ZodCheckGUIDParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"guid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_uuid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_uuid",
    "startLine": 121,
    "endLine": 132,
    "text": "export function _uuid<T extends schemas.$ZodUUID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodUUIDParams | $ZodCheckUUIDParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_uuidv4",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_uuidv4",
    "startLine": 137,
    "endLine": 149,
    "text": "export function _uuidv4<T extends schemas.$ZodUUID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodUUIDv4Params | $ZodCheckUUIDv4Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    version: \"v4\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_uuidv6",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_uuidv6",
    "startLine": 154,
    "endLine": 166,
    "text": "export function _uuidv6<T extends schemas.$ZodUUID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodUUIDv6Params | $ZodCheckUUIDv6Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    version: \"v6\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_uuidv7",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_uuidv7",
    "startLine": 171,
    "endLine": 183,
    "text": "export function _uuidv7<T extends schemas.$ZodUUID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodUUIDv7Params | $ZodCheckUUIDv7Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    version: \"v7\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_url",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_url",
    "startLine": 188,
    "endLine": 199,
    "text": "export function _url<T extends schemas.$ZodURL>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodURLParams | $ZodCheckURLParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"url\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_emoji",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_emoji",
    "startLine": 204,
    "endLine": 215,
    "text": "export function _emoji<T extends schemas.$ZodEmoji>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodEmojiParams | $ZodCheckEmojiParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"emoji\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_nanoid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_nanoid",
    "startLine": 220,
    "endLine": 231,
    "text": "export function _nanoid<T extends schemas.$ZodNanoID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodNanoIDParams | $ZodCheckNanoIDParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"nanoid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_cuid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_cuid",
    "startLine": 236,
    "endLine": 247,
    "text": "export function _cuid<T extends schemas.$ZodCUID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCUIDParams | $ZodCheckCUIDParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"cuid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_cuid2",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_cuid2",
    "startLine": 252,
    "endLine": 263,
    "text": "export function _cuid2<T extends schemas.$ZodCUID2>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCUID2Params | $ZodCheckCUID2Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"cuid2\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_ulid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_ulid",
    "startLine": 268,
    "endLine": 279,
    "text": "export function _ulid<T extends schemas.$ZodULID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodULIDParams | $ZodCheckULIDParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"ulid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_xid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_xid",
    "startLine": 284,
    "endLine": 295,
    "text": "export function _xid<T extends schemas.$ZodXID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodXIDParams | $ZodCheckXIDParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"xid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_ksuid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_ksuid",
    "startLine": 300,
    "endLine": 311,
    "text": "export function _ksuid<T extends schemas.$ZodKSUID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodKSUIDParams | $ZodCheckKSUIDParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"ksuid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_ipv4",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_ipv4",
    "startLine": 332,
    "endLine": 343,
    "text": "export function _ipv4<T extends schemas.$ZodIPv4>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodIPv4Params | $ZodCheckIPv4Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"ipv4\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_ipv6",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_ipv6",
    "startLine": 348,
    "endLine": 359,
    "text": "export function _ipv6<T extends schemas.$ZodIPv6>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodIPv6Params | $ZodCheckIPv6Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"ipv6\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_cidrv4",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_cidrv4",
    "startLine": 364,
    "endLine": 375,
    "text": "export function _cidrv4<T extends schemas.$ZodCIDRv4>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCIDRv4Params | $ZodCheckCIDRv4Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"cidrv4\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_cidrv6",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_cidrv6",
    "startLine": 380,
    "endLine": 391,
    "text": "export function _cidrv6<T extends schemas.$ZodCIDRv6>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCIDRv6Params | $ZodCheckCIDRv6Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"cidrv6\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_base64",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_base64",
    "startLine": 396,
    "endLine": 407,
    "text": "export function _base64<T extends schemas.$ZodBase64>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBase64Params | $ZodCheckBase64Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"base64\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_base64url",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_base64url",
    "startLine": 412,
    "endLine": 423,
    "text": "export function _base64url<T extends schemas.$ZodBase64URL>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBase64URLParams | $ZodCheckBase64URLParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"base64url\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_e164",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_e164",
    "startLine": 428,
    "endLine": 439,
    "text": "export function _e164<T extends schemas.$ZodE164>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodE164Params | $ZodCheckE164Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"e164\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_jwt",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_jwt",
    "startLine": 444,
    "endLine": 455,
    "text": "export function _jwt<T extends schemas.$ZodJWT>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodJWTParams | $ZodCheckJWTParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"jwt\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_isoDateTime",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_isoDateTime",
    "startLine": 467,
    "endLine": 480,
    "text": "export function _isoDateTime<T extends schemas.$ZodISODateTime>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodISODateTimeParams | $ZodCheckISODateTimeParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"datetime\",\n    check: \"string_format\",\n    offset: false,\n    local: false,\n    precision: null,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_isoDate",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_isoDate",
    "startLine": 485,
    "endLine": 495,
    "text": "export function _isoDate<T extends schemas.$ZodISODate>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodISODateParams | $ZodCheckISODateParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"date\",\n    check: \"string_format\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_isoTime",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_isoTime",
    "startLine": 500,
    "endLine": 511,
    "text": "export function _isoTime<T extends schemas.$ZodISOTime>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodISOTimeParams | $ZodCheckISOTimeParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"time\",\n    check: \"string_format\",\n    precision: null,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_isoDuration",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_isoDuration",
    "startLine": 516,
    "endLine": 526,
    "text": "export function _isoDuration<T extends schemas.$ZodISODuration>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodISODurationParams | $ZodCheckISODurationParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"duration\",\n    check: \"string_format\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_number",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_number",
    "startLine": 532,
    "endLine": 541,
    "text": "export function _number<T extends schemas.$ZodNumber>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodNumberParams\n): T {\n  return new Class({\n    type: \"number\",\n    checks: [],\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_coercedNumber",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_coercedNumber",
    "startLine": 543,
    "endLine": 553,
    "text": "export function _coercedNumber<T extends schemas.$ZodNumber>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodNumberParams\n): T {\n  return new Class({\n    type: \"number\",\n    coerce: true,\n    checks: [],\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_int",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_int",
    "startLine": 555,
    "endLine": 566,
    "text": "export function _int<T extends schemas.$ZodNumberFormat>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCheckNumberFormatParams\n): T {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"safeint\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_float32",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_float32",
    "startLine": 567,
    "endLine": 578,
    "text": "export function _float32<T extends schemas.$ZodNumberFormat>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCheckNumberFormatParams\n): T {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"float32\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_float64",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_float64",
    "startLine": 579,
    "endLine": 590,
    "text": "export function _float64<T extends schemas.$ZodNumberFormat>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCheckNumberFormatParams\n): T {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"float64\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_int32",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_int32",
    "startLine": 591,
    "endLine": 602,
    "text": "export function _int32<T extends schemas.$ZodNumberFormat>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCheckNumberFormatParams\n): T {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"int32\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_uint32",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_uint32",
    "startLine": 603,
    "endLine": 614,
    "text": "export function _uint32<T extends schemas.$ZodNumberFormat>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCheckNumberFormatParams\n): T {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"uint32\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_boolean",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_boolean",
    "startLine": 618,
    "endLine": 626,
    "text": "export function _boolean<T extends schemas.$ZodBoolean>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBooleanParams\n): T {\n  return new Class({\n    type: \"boolean\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_coercedBoolean",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_coercedBoolean",
    "startLine": 627,
    "endLine": 636,
    "text": "export function _coercedBoolean<T extends schemas.$ZodBoolean>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBooleanParams\n): T {\n  return new Class({\n    type: \"boolean\",\n    coerce: true,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_bigint",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_bigint",
    "startLine": 642,
    "endLine": 650,
    "text": "export function _bigint<T extends schemas.$ZodBigInt>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBigIntParams\n): T {\n  return new Class({\n    type: \"bigint\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_coercedBigint",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_coercedBigint",
    "startLine": 651,
    "endLine": 660,
    "text": "export function _coercedBigint<T extends schemas.$ZodBigInt>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBigIntParams\n): T {\n  return new Class({\n    type: \"bigint\",\n    coerce: true,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_int64",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_int64",
    "startLine": 662,
    "endLine": 673,
    "text": "export function _int64<T extends schemas.$ZodBigIntFormat>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBigIntFormatParams\n): T {\n  return new Class({\n    type: \"bigint\",\n    check: \"bigint_format\",\n    abort: false,\n    format: \"int64\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_uint64",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_uint64",
    "startLine": 674,
    "endLine": 685,
    "text": "export function _uint64<T extends schemas.$ZodBigIntFormat>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBigIntFormatParams\n): T {\n  return new Class({\n    type: \"bigint\",\n    check: \"bigint_format\",\n    abort: false,\n    format: \"uint64\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_symbol",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_symbol",
    "startLine": 689,
    "endLine": 697,
    "text": "export function _symbol<T extends schemas.$ZodSymbol>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodSymbolParams\n): T {\n  return new Class({\n    type: \"symbol\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_undefined",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_undefined",
    "startLine": 701,
    "endLine": 709,
    "text": "export function _undefined<T extends schemas.$ZodUndefined>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodUndefinedParams\n): T {\n  return new Class({\n    type: \"undefined\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_null",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_null",
    "startLine": 713,
    "endLine": 718,
    "text": "export function _null<T extends schemas.$ZodNull>(Class: util.SchemaClass<T>, params?: string | $ZodNullParams): T {\n  return new Class({\n    type: \"null\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_any",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_any",
    "startLine": 722,
    "endLine": 726,
    "text": "export function _any<T extends schemas.$ZodAny>(Class: util.SchemaClass<T>): T {\n  return new Class({\n    type: \"any\",\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_unknown",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_unknown",
    "startLine": 730,
    "endLine": 734,
    "text": "export function _unknown<T extends schemas.$ZodUnknown>(Class: util.SchemaClass<T>): T {\n  return new Class({\n    type: \"unknown\",\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_never",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_never",
    "startLine": 738,
    "endLine": 743,
    "text": "export function _never<T extends schemas.$ZodNever>(Class: util.SchemaClass<T>, params?: string | $ZodNeverParams): T {\n  return new Class({\n    type: \"never\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_void",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_void",
    "startLine": 747,
    "endLine": 752,
    "text": "export function _void<T extends schemas.$ZodVoid>(Class: util.SchemaClass<T>, params?: string | $ZodVoidParams): T {\n  return new Class({\n    type: \"void\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_date",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_date",
    "startLine": 756,
    "endLine": 761,
    "text": "export function _date<T extends schemas.$ZodDate>(Class: util.SchemaClass<T>, params?: string | $ZodDateParams): T {\n  return new Class({\n    type: \"date\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_coercedDate",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_coercedDate",
    "startLine": 762,
    "endLine": 771,
    "text": "export function _coercedDate<T extends schemas.$ZodDate>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodDateParams\n): T {\n  return new Class({\n    type: \"date\",\n    coerce: true,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_nan",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_nan",
    "startLine": 775,
    "endLine": 780,
    "text": "export function _nan<T extends schemas.$ZodNaN>(Class: util.SchemaClass<T>, params?: string | $ZodNaNParams): T {\n  return new Class({\n    type: \"nan\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_lt",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_lt",
    "startLine": 785,
    "endLine": 795,
    "text": "export function _lt(\n  value: util.Numeric,\n  params?: string | $ZodCheckLessThanParams\n): checks.$ZodCheckLessThan<util.Numeric> {\n  return new checks.$ZodCheckLessThan({\n    check: \"less_than\",\n    ...util.normalizeParams(params),\n    value,\n    inclusive: false,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_lte",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_lte",
    "startLine": 797,
    "endLine": 808,
    "text": "export function _lte(\n  value: util.Numeric,\n  params?: string | $ZodCheckLessThanParams\n): checks.$ZodCheckLessThan<util.Numeric> {\n  return new checks.$ZodCheckLessThan({\n    check: \"less_than\",\n\n    ...util.normalizeParams(params),\n    value,\n    inclusive: true,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_gt",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_gt",
    "startLine": 816,
    "endLine": 824,
    "text": "export function _gt(value: util.Numeric, params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {\n  return new checks.$ZodCheckGreaterThan({\n    check: \"greater_than\",\n\n    ...util.normalizeParams(params),\n    value,\n    inclusive: false,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_gte",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_gte",
    "startLine": 826,
    "endLine": 833,
    "text": "export function _gte(value: util.Numeric, params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {\n  return new checks.$ZodCheckGreaterThan({\n    check: \"greater_than\",\n    ...util.normalizeParams(params),\n    value,\n    inclusive: true,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_positive",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_positive",
    "startLine": 840,
    "endLine": 842,
    "text": "export function _positive(params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {\n  return _gt(0, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_negative",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_negative",
    "startLine": 845,
    "endLine": 847,
    "text": "export function _negative(params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan {\n  return _lt(0, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_nonpositive",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_nonpositive",
    "startLine": 850,
    "endLine": 852,
    "text": "export function _nonpositive(params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan {\n  return _lte(0, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_nonnegative",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_nonnegative",
    "startLine": 855,
    "endLine": 857,
    "text": "export function _nonnegative(params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {\n  return _gte(0, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_multipleOf",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_multipleOf",
    "startLine": 860,
    "endLine": 869,
    "text": "export function _multipleOf(\n  value: number | bigint,\n  params?: string | $ZodCheckMultipleOfParams\n): checks.$ZodCheckMultipleOf {\n  return new checks.$ZodCheckMultipleOf({\n    check: \"multiple_of\",\n    ...util.normalizeParams(params),\n    value,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_maxSize",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_maxSize",
    "startLine": 872,
    "endLine": 881,
    "text": "export function _maxSize(\n  maximum: number,\n  params?: string | $ZodCheckMaxSizeParams\n): checks.$ZodCheckMaxSize<util.HasSize> {\n  return new checks.$ZodCheckMaxSize({\n    check: \"max_size\",\n    ...util.normalizeParams(params),\n    maximum,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_minSize",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_minSize",
    "startLine": 884,
    "endLine": 893,
    "text": "export function _minSize(\n  minimum: number,\n  params?: string | $ZodCheckMinSizeParams\n): checks.$ZodCheckMinSize<util.HasSize> {\n  return new checks.$ZodCheckMinSize({\n    check: \"min_size\",\n    ...util.normalizeParams(params),\n    minimum,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_size",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_size",
    "startLine": 896,
    "endLine": 905,
    "text": "export function _size(\n  size: number,\n  params?: string | $ZodCheckSizeEqualsParams\n): checks.$ZodCheckSizeEquals<util.HasSize> {\n  return new checks.$ZodCheckSizeEquals({\n    check: \"size_equals\",\n    ...util.normalizeParams(params),\n    size,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_maxLength",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_maxLength",
    "startLine": 908,
    "endLine": 918,
    "text": "export function _maxLength(\n  maximum: number,\n  params?: string | $ZodCheckMaxLengthParams\n): checks.$ZodCheckMaxLength<util.HasLength> {\n  const ch = new checks.$ZodCheckMaxLength({\n    check: \"max_length\",\n    ...util.normalizeParams(params),\n    maximum,\n  });\n  return ch;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_minLength",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_minLength",
    "startLine": 921,
    "endLine": 930,
    "text": "export function _minLength(\n  minimum: number,\n  params?: string | $ZodCheckMinLengthParams\n): checks.$ZodCheckMinLength<util.HasLength> {\n  return new checks.$ZodCheckMinLength({\n    check: \"min_length\",\n    ...util.normalizeParams(params),\n    minimum,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_length",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_length",
    "startLine": 933,
    "endLine": 942,
    "text": "export function _length(\n  length: number,\n  params?: string | $ZodCheckLengthEqualsParams\n): checks.$ZodCheckLengthEquals<util.HasLength> {\n  return new checks.$ZodCheckLengthEquals({\n    check: \"length_equals\",\n    ...util.normalizeParams(params),\n    length,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_regex",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_regex",
    "startLine": 945,
    "endLine": 952,
    "text": "export function _regex(pattern: RegExp, params?: string | $ZodCheckRegexParams): checks.$ZodCheckRegex {\n  return new checks.$ZodCheckRegex({\n    check: \"string_format\",\n    format: \"regex\",\n    ...util.normalizeParams(params),\n    pattern,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_lowercase",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_lowercase",
    "startLine": 955,
    "endLine": 961,
    "text": "export function _lowercase(params?: string | $ZodCheckLowerCaseParams): checks.$ZodCheckLowerCase {\n  return new checks.$ZodCheckLowerCase({\n    check: \"string_format\",\n    format: \"lowercase\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_uppercase",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_uppercase",
    "startLine": 965,
    "endLine": 971,
    "text": "export function _uppercase(params?: string | $ZodCheckUpperCaseParams): checks.$ZodCheckUpperCase {\n  return new checks.$ZodCheckUpperCase({\n    check: \"string_format\",\n    format: \"uppercase\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_includes",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_includes",
    "startLine": 974,
    "endLine": 981,
    "text": "export function _includes(includes: string, params?: string | $ZodCheckIncludesParams): checks.$ZodCheckIncludes {\n  return new checks.$ZodCheckIncludes({\n    check: \"string_format\",\n    format: \"includes\",\n    ...util.normalizeParams(params),\n    includes,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_startsWith",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_startsWith",
    "startLine": 983,
    "endLine": 990,
    "text": "export function _startsWith(prefix: string, params?: string | $ZodCheckStartsWithParams): checks.$ZodCheckStartsWith {\n  return new checks.$ZodCheckStartsWith({\n    check: \"string_format\",\n    format: \"starts_with\",\n    ...util.normalizeParams(params),\n    prefix,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_endsWith",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_endsWith",
    "startLine": 994,
    "endLine": 1001,
    "text": "export function _endsWith(suffix: string, params?: string | $ZodCheckEndsWithParams): checks.$ZodCheckEndsWith {\n  return new checks.$ZodCheckEndsWith({\n    check: \"string_format\",\n    format: \"ends_with\",\n    ...util.normalizeParams(params),\n    suffix,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_property",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_property",
    "startLine": 1004,
    "endLine": 1015,
    "text": "export function _property<K extends string, T extends schemas.$ZodType>(\n  property: K,\n  schema: T,\n  params?: string | $ZodCheckPropertyParams\n): checks.$ZodCheckProperty<{ [k in K]: core.output<T> }> {\n  return new checks.$ZodCheckProperty({\n    check: \"property\",\n    property,\n    schema,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_mime",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_mime",
    "startLine": 1018,
    "endLine": 1024,
    "text": "export function _mime(types: util.MimeTypes[], params?: string | $ZodCheckMimeTypeParams): checks.$ZodCheckMimeType {\n  return new checks.$ZodCheckMimeType({\n    check: \"mime_type\",\n    mime: types,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_overwrite",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_overwrite",
    "startLine": 1026,
    "endLine": 1031,
    "text": "export function _overwrite<T>(tx: (input: T) => T): checks.$ZodCheckOverwrite<T> {\n  return new checks.$ZodCheckOverwrite({\n    check: \"overwrite\",\n    tx,\n  }) as checks.$ZodCheckOverwrite<T>;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_normalize",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_normalize",
    "startLine": 1033,
    "endLine": 1035,
    "text": "export function _normalize(form?: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\" | (string & {})): checks.$ZodCheckOverwrite<string> {\n  return _overwrite((input) => input.normalize(form));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_trim",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_trim",
    "startLine": 1038,
    "endLine": 1040,
    "text": "export function _trim(): checks.$ZodCheckOverwrite<string> {\n  return _overwrite((input) => input.trim());\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_toLowerCase",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_toLowerCase",
    "startLine": 1042,
    "endLine": 1044,
    "text": "export function _toLowerCase(): checks.$ZodCheckOverwrite<string> {\n  return _overwrite((input) => input.toLowerCase());\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_toUpperCase",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_toUpperCase",
    "startLine": 1046,
    "endLine": 1048,
    "text": "export function _toUpperCase(): checks.$ZodCheckOverwrite<string> {\n  return _overwrite((input) => input.toUpperCase());\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_array",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_array",
    "startLine": 1054,
    "endLine": 1067,
    "text": "export function _array<T extends schemas.$ZodType>(\n  Class: util.SchemaClass<schemas.$ZodArray>,\n  element: T,\n  params?: string | $ZodArrayParams\n): schemas.$ZodArray<T> {\n  return new Class({\n    type: \"array\",\n    element,\n    // get element() {\n    //   return element;\n    // },\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_union",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_union",
    "startLine": 1073,
    "endLine": 1083,
    "text": "export function _union<const T extends readonly schemas.$ZodObject[]>(\n  Class: util.SchemaClass<schemas.$ZodUnion>,\n  options: T,\n  params?: string | $ZodUnionParams\n): schemas.$ZodUnion<T> {\n  return new Class({\n    type: \"union\",\n    options,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_discriminatedUnion",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_discriminatedUnion",
    "startLine": 1094,
    "endLine": 1106,
    "text": "export function _discriminatedUnion<Types extends [$ZodTypeDiscriminable, ...$ZodTypeDiscriminable[]]>(\n  Class: util.SchemaClass<schemas.$ZodDiscriminatedUnion>,\n  discriminator: string,\n  options: Types,\n  params?: string | $ZodDiscriminatedUnionParams\n): schemas.$ZodDiscriminatedUnion<Types> {\n  return new Class({\n    type: \"union\",\n    options,\n    discriminator,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_intersection",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_intersection",
    "startLine": 1110,
    "endLine": 1120,
    "text": "export function _intersection<T extends schemas.$ZodObject, U extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodIntersection>,\n  left: T,\n  right: U\n): schemas.$ZodIntersection<T, U> {\n  return new Class({\n    type: \"intersection\",\n    left,\n    right,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_tuple",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_tuple",
    "startLine": 1124,
    "endLine": 1128,
    "text": "export function _tuple<T extends readonly [schemas.$ZodType, ...schemas.$ZodType[]]>(\n  Class: util.SchemaClass<schemas.$ZodTuple>,\n  items: T,\n  params?: string | $ZodTupleParams\n): schemas.$ZodTuple<T, null>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_tuple",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_tuple",
    "startLine": 1129,
    "endLine": 1134,
    "text": "export function _tuple<T extends readonly [schemas.$ZodType, ...schemas.$ZodType[]], Rest extends schemas.$ZodType>(\n  Class: util.SchemaClass<schemas.$ZodTuple>,\n  items: T,\n  rest: Rest,\n  params?: string | $ZodTupleParams\n): schemas.$ZodTuple<T, Rest>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_tuple",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_tuple",
    "startLine": 1140,
    "endLine": 1155,
    "text": "export function _tuple(\n  Class: util.SchemaClass<schemas.$ZodTuple>,\n  items: schemas.$ZodType[],\n  _paramsOrRest?: string | $ZodTupleParams | schemas.$ZodType,\n  _params?: string | $ZodTupleParams\n) {\n  const hasRest = _paramsOrRest instanceof schemas.$ZodType;\n  const params = hasRest ? _params : _paramsOrRest;\n  const rest = hasRest ? _paramsOrRest : null;\n  return new Class({\n    type: \"tuple\",\n    items,\n    rest,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_record",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_record",
    "startLine": 1159,
    "endLine": 1171,
    "text": "export function _record<Key extends schemas.$ZodRecordKey, Value extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodRecord>,\n  keyType: Key,\n  valueType: Value,\n  params?: string | $ZodRecordParams\n): schemas.$ZodRecord<Key, Value> {\n  return new Class({\n    type: \"record\",\n    keyType,\n    valueType,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_map",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_map",
    "startLine": 1175,
    "endLine": 1187,
    "text": "export function _map<Key extends schemas.$ZodObject, Value extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodMap>,\n  keyType: Key,\n  valueType: Value,\n  params?: string | $ZodMapParams\n): schemas.$ZodMap<Key, Value> {\n  return new Class({\n    type: \"map\",\n    keyType,\n    valueType,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_set",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_set",
    "startLine": 1191,
    "endLine": 1201,
    "text": "export function _set<Value extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodSet>,\n  valueType: Value,\n  params?: string | $ZodSetParams\n): schemas.$ZodSet<Value> {\n  return new Class({\n    type: \"set\",\n    valueType,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_enum",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_enum",
    "startLine": 1205,
    "endLine": 1209,
    "text": "export function _enum<const T extends string[]>(\n  Class: util.SchemaClass<schemas.$ZodEnum>,\n  values: T,\n  params?: string | $ZodEnumParams\n): schemas.$ZodEnum<util.ToEnum<T[number]>>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_enum",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_enum",
    "startLine": 1210,
    "endLine": 1214,
    "text": "export function _enum<T extends util.EnumLike>(\n  Class: util.SchemaClass<schemas.$ZodEnum>,\n  entries: T,\n  params?: string | $ZodEnumParams\n): schemas.$ZodEnum<T>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_enum",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_enum",
    "startLine": 1215,
    "endLine": 1234,
    "text": "export function _enum(Class: util.SchemaClass<schemas.$ZodEnum>, values: any, params?: string | $ZodEnumParams) {\n  const entries: any = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n  // if (Array.isArray(values)) {\n  //   for (const value of values) {\n  //     entries[value] = value;\n  //   }\n  // } else {\n  //   Object.assign(entries, values);\n  // }\n  // const entries: util.EnumLike = {};\n  // for (const val of values) {\n  //   entries[val] = val;\n  // }\n\n  return new Class({\n    type: \"enum\",\n    entries,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_nativeEnum",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_nativeEnum",
    "startLine": 1243,
    "endLine": 1253,
    "text": "export function _nativeEnum<T extends util.EnumLike>(\n  Class: util.SchemaClass<schemas.$ZodEnum>,\n  entries: T,\n  params?: string | $ZodEnumParams\n): schemas.$ZodEnum<T> {\n  return new Class({\n    type: \"enum\",\n    entries,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_literal",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_literal",
    "startLine": 1257,
    "endLine": 1261,
    "text": "export function _literal<const T extends Array<util.Literal>>(\n  Class: util.SchemaClass<schemas.$ZodLiteral>,\n  value: T,\n  params?: string | $ZodLiteralParams\n): schemas.$ZodLiteral<T[number]>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_literal",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_literal",
    "startLine": 1262,
    "endLine": 1266,
    "text": "export function _literal<const T extends util.Literal>(\n  Class: util.SchemaClass<schemas.$ZodLiteral>,\n  value: T,\n  params?: string | $ZodLiteralParams\n): schemas.$ZodLiteral<T>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_literal",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_literal",
    "startLine": 1267,
    "endLine": 1273,
    "text": "export function _literal(Class: util.SchemaClass<schemas.$ZodLiteral>, value: any, params: any) {\n  return new Class({\n    type: \"literal\",\n    values: Array.isArray(value) ? value : [value],\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_file",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_file",
    "startLine": 1277,
    "endLine": 1282,
    "text": "export function _file(Class: util.SchemaClass<schemas.$ZodFile>, params?: string | $ZodFileParams): schemas.$ZodFile {\n  return new Class({\n    type: \"file\",\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_transform",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_transform",
    "startLine": 1286,
    "endLine": 1294,
    "text": "export function _transform<I = unknown, O = I>(\n  Class: util.SchemaClass<schemas.$ZodTransform>,\n  fn: (input: I, ctx?: schemas.ParsePayload) => O\n): schemas.$ZodTransform<Awaited<O>, I> {\n  return new Class({\n    type: \"transform\",\n    transform: fn as any,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_optional",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_optional",
    "startLine": 1298,
    "endLine": 1306,
    "text": "export function _optional<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodOptional>,\n  innerType: T\n): schemas.$ZodOptional<T> {\n  return new Class({\n    type: \"optional\",\n    innerType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_nullable",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_nullable",
    "startLine": 1310,
    "endLine": 1318,
    "text": "export function _nullable<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodNullable>,\n  innerType: T\n): schemas.$ZodNullable<T> {\n  return new Class({\n    type: \"nullable\",\n    innerType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_default",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_default",
    "startLine": 1322,
    "endLine": 1334,
    "text": "export function _default<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodDefault>,\n  innerType: T,\n  defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)\n): schemas.$ZodDefault<T> {\n  return new Class({\n    type: \"default\",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? (defaultValue as Function)() : defaultValue;\n    },\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_nonoptional",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_nonoptional",
    "startLine": 1338,
    "endLine": 1348,
    "text": "export function _nonoptional<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodNonOptional>,\n  innerType: T,\n  params?: string | $ZodNonOptionalParams\n): schemas.$ZodNonOptional<T> {\n  return new Class({\n    type: \"nonoptional\",\n    innerType,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_success",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_success",
    "startLine": 1352,
    "endLine": 1360,
    "text": "export function _success<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodSuccess>,\n  innerType: T\n): schemas.$ZodSuccess<T> {\n  return new Class({\n    type: \"success\",\n    innerType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_catch",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_catch",
    "startLine": 1364,
    "endLine": 1374,
    "text": "export function _catch<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodCatch>,\n  innerType: T,\n  catchValue: core.output<T> | ((ctx: schemas.$ZodCatchCtx) => core.output<T>)\n): schemas.$ZodCatch<T> {\n  return new Class({\n    type: \"catch\",\n    innerType,\n    catchValue: (typeof catchValue === \"function\" ? catchValue : () => catchValue) as any,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_pipe",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_pipe",
    "startLine": 1378,
    "endLine": 1391,
    "text": "export function _pipe<\n  const A extends schemas.$ZodType,\n  B extends schemas.$ZodType<unknown, core.output<A>> = schemas.$ZodType<unknown, core.output<A>>,\n>(\n  Class: util.SchemaClass<schemas.$ZodPipe>,\n  in_: A,\n  out: B | schemas.$ZodType<unknown, core.output<A>>\n): schemas.$ZodPipe<A, B> {\n  return new Class({\n    type: \"pipe\",\n    in: in_,\n    out,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_readonly",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_readonly",
    "startLine": 1395,
    "endLine": 1403,
    "text": "export function _readonly<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodReadonly>,\n  innerType: T\n): schemas.$ZodReadonly<T> {\n  return new Class({\n    type: \"readonly\",\n    innerType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_templateLiteral",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_templateLiteral",
    "startLine": 1407,
    "endLine": 1417,
    "text": "export function _templateLiteral<const Parts extends schemas.$ZodTemplateLiteralPart[]>(\n  Class: util.SchemaClass<schemas.$ZodTemplateLiteral>,\n  parts: Parts,\n  params?: string | $ZodTemplateLiteralParams\n): schemas.$ZodTemplateLiteral<schemas.$PartsToTemplateLiteral<Parts>> {\n  return new Class({\n    type: \"template_literal\",\n    parts,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_lazy",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_lazy",
    "startLine": 1421,
    "endLine": 1429,
    "text": "export function _lazy<T extends schemas.$ZodType>(\n  Class: util.SchemaClass<schemas.$ZodLazy>,\n  getter: () => T\n): schemas.$ZodLazy<T> {\n  return new Class({\n    type: \"lazy\",\n    getter,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_promise",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_promise",
    "startLine": 1433,
    "endLine": 1441,
    "text": "export function _promise<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodPromise>,\n  innerType: T\n): schemas.$ZodPromise<T> {\n  return new Class({\n    type: \"promise\",\n    innerType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_custom",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_custom",
    "startLine": 1445,
    "endLine": 1460,
    "text": "export function _custom<O = unknown, I = O>(\n  Class: util.SchemaClass<schemas.$ZodCustom>,\n  fn: (data: O) => unknown,\n  _params: string | $ZodCustomParams | undefined\n): schemas.$ZodCustom<O, I> {\n  const norm = util.normalizeParams(_params);\n  norm.abort ??= true; // default to abort:false\n  const schema = new Class({\n    type: \"custom\",\n    check: \"custom\",\n    fn: fn as any,\n    ...norm,\n  });\n\n  return schema as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_refine",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_refine",
    "startLine": 1470,
    "endLine": 1483,
    "text": "export function _refine<O = unknown, I = O>(\n  Class: util.SchemaClass<schemas.$ZodCustom>,\n  fn: (data: O) => unknown,\n  _params: string | $ZodCustomParams | undefined\n): schemas.$ZodCustom<O, I> {\n  const schema = new Class({\n    type: \"custom\",\n    check: \"custom\",\n    fn: fn as any,\n    ...util.normalizeParams(_params),\n  });\n\n  return schema as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_stringbool",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_stringbool",
    "startLine": 1501,
    "endLine": 1571,
    "text": "export function _stringbool(\n  Classes: {\n    Pipe?: typeof schemas.$ZodPipe;\n    Boolean?: typeof schemas.$ZodBoolean;\n    Transform?: typeof schemas.$ZodTransform;\n    String?: typeof schemas.$ZodString;\n  },\n  _params?: string | $ZodStringBoolParams\n): schemas.$ZodPipe<\n  schemas.$ZodPipe<schemas.$ZodString, schemas.$ZodTransform<boolean, string>>,\n  schemas.$ZodBoolean<boolean>\n> {\n  const params = util.normalizeParams(_params);\n\n  let truthyArray = params.truthy ?? [\"true\", \"1\", \"yes\", \"on\", \"y\", \"enabled\"];\n  let falsyArray = params.falsy ?? [\"false\", \"0\", \"no\", \"off\", \"n\", \"disabled\"];\n  if (params.case !== \"sensitive\") {\n    truthyArray = truthyArray.map((v) => (typeof v === \"string\" ? v.toLowerCase() : v));\n    falsyArray = falsyArray.map((v) => (typeof v === \"string\" ? v.toLowerCase() : v));\n  }\n\n  const truthySet = new Set(truthyArray);\n  const falsySet = new Set(falsyArray);\n\n  const _Pipe = Classes.Pipe ?? schemas.$ZodPipe;\n  const _Boolean = Classes.Boolean ?? schemas.$ZodBoolean;\n  const _String = Classes.String ?? schemas.$ZodString;\n  const _Transform = Classes.Transform ?? schemas.$ZodTransform;\n\n  const tx = new _Transform({\n    type: \"transform\",\n    transform: (input, payload: schemas.ParsePayload<unknown>) => {\n      let data: string = input as string;\n      if (params.case !== \"sensitive\") data = data.toLowerCase();\n      if (truthySet.has(data)) {\n        return true;\n      } else if (falsySet.has(data)) {\n        return false;\n      } else {\n        payload.issues.push({\n          code: \"invalid_value\",\n          expected: \"stringbool\",\n          values: [...truthySet, ...falsySet],\n          input: payload.value,\n          inst: tx,\n        });\n        return {} as never;\n      }\n    },\n    error: params.error,\n  });\n  // params.error;\n\n  const innerPipe = new _Pipe({\n    type: \"pipe\",\n    in: new _String({ type: \"string\", error: params.error }),\n    out: tx,\n    error: params.error,\n  });\n\n  const outerPipe = new _Pipe({\n    type: \"pipe\",\n    in: innerPipe,\n    out: new _Boolean({\n      type: \"boolean\",\n      error: params.error,\n    }),\n    error: params.error,\n  });\n  return outerPipe as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts:_stringFormat",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "symbol": "_stringFormat",
    "startLine": 1573,
    "endLine": 1594,
    "text": "export function _stringFormat<Format extends string>(\n  Class: typeof schemas.$ZodCustomStringFormat,\n  format: Format,\n  fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp,\n  _params: string | $ZodStringFormatParams = {}\n): schemas.$ZodCustomStringFormat<Format> {\n  const params = util.normalizeParams(_params);\n  const def: schemas.$ZodCustomStringFormatDef = {\n    ...util.normalizeParams(_params),\n    check: \"string_format\",\n    type: \"string\",\n    format,\n    fn: typeof fnOrRegex === \"function\" ? fnOrRegex : (val) => fnOrRegex.test(val),\n    ...params,\n  };\n  if (fnOrRegex instanceof RegExp) {\n    def.pattern = fnOrRegex;\n  }\n\n  const inst = new Class(def);\n  return inst as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/checks.ts:handleCheckPropertyResult",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/checks.ts",
    "symbol": "handleCheckPropertyResult",
    "startLine": 1075,
    "endLine": 1083,
    "text": "function handleCheckPropertyResult(\n  result: schemas.ParsePayload<unknown>,\n  payload: schemas.ParsePayload<unknown>,\n  property: string\n) {\n  if (result.issues.length) {\n    payload.issues.push(...util.prefixIssues(property, result.issues));\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/config.ts:config",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/config.ts",
    "symbol": "config",
    "startLine": 12,
    "endLine": 15,
    "text": "export function config(config?: Partial<$ZodConfig>): $ZodConfig {\n  if (config) Object.assign(globalConfig, config);\n  return globalConfig;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/core.ts:$constructor",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/core.ts",
    "symbol": "$constructor",
    "startLine": 17,
    "endLine": 64,
    "text": "export /*@__NO_SIDE_EFFECTS__*/ function $constructor<T extends ZodTrait, D = T[\"_zod\"][\"def\"]>(\n  name: string,\n  initializer: (inst: T, def: D) => void,\n  params?: { Parent?: typeof Class }\n): $constructor<T, D> {\n  function init(inst: T, def: D) {\n    Object.defineProperty(inst, \"_zod\", {\n      value: inst._zod ?? {},\n      enumerable: false,\n    });\n\n    inst._zod.traits ??= new Set();\n\n    inst._zod.traits.add(name);\n    initializer(inst, def);\n    // support prototype modifications\n    for (const k in _.prototype) {\n      if (!(k in inst)) Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });\n    }\n    inst._zod.constr = _;\n    inst._zod.def = def;\n  }\n\n  // doesn't work if Parent has a constructor with arguments\n  const Parent = params?.Parent ?? Object;\n  class Definition extends Parent {}\n  Object.defineProperty(Definition, \"name\", { value: name });\n\n  function _(this: any, def: D) {\n    const inst = params?.Parent ? new Definition() : this;\n    init(inst, def);\n    inst._zod.deferred ??= [];\n    for (const fn of inst._zod.deferred) {\n      fn();\n    }\n    return inst;\n  }\n\n  Object.defineProperty(_, \"init\", { value: init });\n  Object.defineProperty(_, Symbol.hasInstance, {\n    value: (inst: any) => {\n      if (params?.Parent && inst instanceof params.Parent) return true;\n      return inst?._zod?.traits?.has(name);\n    },\n  });\n  Object.defineProperty(_, \"name\", { value: name });\n  return _ as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/core.ts:init",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/core.ts",
    "symbol": "init",
    "startLine": 22,
    "endLine": 38,
    "text": "  function init(inst: T, def: D) {\n    Object.defineProperty(inst, \"_zod\", {\n      value: inst._zod ?? {},\n      enumerable: false,\n    });\n\n    inst._zod.traits ??= new Set();\n\n    inst._zod.traits.add(name);\n    initializer(inst, def);\n    // support prototype modifications\n    for (const k in _.prototype) {\n      if (!(k in inst)) Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });\n    }\n    inst._zod.constr = _;\n    inst._zod.def = def;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/core.ts:Definition",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/core.ts",
    "symbol": "Definition",
    "startLine": 42,
    "endLine": 42,
    "text": "  class Definition extends Parent {}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/core.ts:_",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/core.ts",
    "symbol": "_",
    "startLine": 45,
    "endLine": 53,
    "text": "  function _(this: any, def: D) {\n    const inst = params?.Parent ? new Definition() : this;\n    init(inst, def);\n    inst._zod.deferred ??= [];\n    for (const fn of inst._zod.deferred) {\n      fn();\n    }\n    return inst;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/core.ts:$ZodAsyncError",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/core.ts",
    "symbol": "$ZodAsyncError",
    "startLine": 75,
    "endLine": 79,
    "text": "export class $ZodAsyncError extends Error {\n  constructor() {\n    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/core.ts:config",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/core.ts",
    "symbol": "config",
    "startLine": 131,
    "endLine": 134,
    "text": "export function config(newConfig?: Partial<$ZodConfig>): $ZodConfig {\n  if (newConfig) Object.assign(globalConfig, newConfig);\n  return globalConfig;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/doc.ts:Doc",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/doc.ts",
    "symbol": "Doc",
    "startLine": 3,
    "endLine": 44,
    "text": "export class Doc {\n  args!: string[];\n  content: string[] = [];\n  indent = 0;\n\n  constructor(args: string[] = []) {\n    if (this) this.args = args;\n  }\n\n  indented(fn: (doc: Doc) => void) {\n    this.indent += 1;\n    fn(this);\n    this.indent -= 1;\n  }\n\n  write(fn: ModeWriter): void;\n  write(line: string): void;\n  write(arg: any) {\n    if (typeof arg === \"function\") {\n      (arg as ModeWriter)(this, { execution: \"sync\" });\n      (arg as ModeWriter)(this, { execution: \"async\" });\n      return;\n    }\n\n    const content = arg as string;\n    const lines = content.split(\"\\n\").filter((x) => x);\n    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));\n    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => \" \".repeat(this.indent * 2) + x);\n    for (const line of dedented) {\n      this.content.push(line);\n    }\n  }\n\n  compile() {\n    const F = Function;\n    const args = this?.args;\n    const content = this?.content ?? [``];\n    const lines = [...content.map((x) => `  ${x}`)];\n    // console.log(lines.join(\"\\n\"));\n    return new F(...args, lines.join(\"\\n\"));\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/doc.ts:Doc.indented",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/doc.ts",
    "symbol": "Doc.indented",
    "startLine": 12,
    "endLine": 16,
    "text": "  indented(fn: (doc: Doc) => void) {\n    this.indent += 1;\n    fn(this);\n    this.indent -= 1;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/doc.ts:Doc.write",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/doc.ts",
    "symbol": "Doc.write",
    "startLine": 20,
    "endLine": 34,
    "text": "  write(arg: any) {\n    if (typeof arg === \"function\") {\n      (arg as ModeWriter)(this, { execution: \"sync\" });\n      (arg as ModeWriter)(this, { execution: \"async\" });\n      return;\n    }\n\n    const content = arg as string;\n    const lines = content.split(\"\\n\").filter((x) => x);\n    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));\n    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => \" \".repeat(this.indent * 2) + x);\n    for (const line of dedented) {\n      this.content.push(line);\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/doc.ts:Doc.compile",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/doc.ts",
    "symbol": "Doc.compile",
    "startLine": 36,
    "endLine": 43,
    "text": "  compile() {\n    const F = Function;\n    const args = this?.args;\n    const content = this?.content ?? [``];\n    const lines = [...content.map((x) => `  ${x}`)];\n    // console.log(lines.join(\"\\n\"));\n    return new F(...args, lines.join(\"\\n\"));\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts:flattenError",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
    "symbol": "flattenError",
    "startLine": 227,
    "endLine": 227,
    "text": "export function flattenError<T>(error: $ZodError<T>): _FlattenedError<T>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts:flattenError",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
    "symbol": "flattenError",
    "startLine": 228,
    "endLine": 228,
    "text": "export function flattenError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): _FlattenedError<T, U>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts:flattenError",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
    "symbol": "flattenError",
    "startLine": 229,
    "endLine": 241,
    "text": "export function flattenError(error: $ZodError, mapper = (issue: $ZodIssue) => issue.message): any {\n  const fieldErrors: any = {};\n  const formErrors: any[] = [];\n  for (const sub of error.issues) {\n    if (sub.path.length > 0) {\n      fieldErrors[sub.path[0]!] = fieldErrors[sub.path[0]!] || [];\n      fieldErrors[sub.path[0]!].push(mapper(sub));\n    } else {\n      formErrors.push(mapper(sub));\n    }\n  }\n  return { formErrors, fieldErrors };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts:formatError",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
    "symbol": "formatError",
    "startLine": 255,
    "endLine": 255,
    "text": "export function formatError<T>(error: $ZodError<T>): $ZodFormattedError<T>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts:formatError",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
    "symbol": "formatError",
    "startLine": 256,
    "endLine": 256,
    "text": "export function formatError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): $ZodFormattedError<T, U>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts:formatError",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
    "symbol": "formatError",
    "startLine": 257,
    "endLine": 296,
    "text": "export function formatError<T>(error: $ZodError, _mapper?: any) {\n  const mapper: (issue: $ZodIssue) => any =\n    _mapper ||\n    function (issue: $ZodIssue) {\n      return issue.message;\n    };\n  const fieldErrors: $ZodFormattedError<T> = { _errors: [] } as any;\n  const processError = (error: { issues: $ZodIssue[] }) => {\n    for (const issue of error.issues) {\n      if (issue.code === \"invalid_union\" && issue.errors.length) {\n        issue.errors.map((issues) => processError({ issues }));\n      } else if (issue.code === \"invalid_key\") {\n        processError({ issues: issue.issues });\n      } else if (issue.code === \"invalid_element\") {\n        processError({ issues: issue.issues });\n      } else if (issue.path.length === 0) {\n        (fieldErrors as any)._errors.push(mapper(issue));\n      } else {\n        let curr: any = fieldErrors;\n        let i = 0;\n        while (i < issue.path.length) {\n          const el = issue.path[i]!;\n          const terminal = i === issue.path.length - 1;\n\n          if (!terminal) {\n            curr[el] = curr[el] || { _errors: [] };\n          } else {\n            curr[el] = curr[el] || { _errors: [] };\n            curr[el]._errors.push(mapper(issue));\n          }\n\n          curr = curr[el];\n          i++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return fieldErrors;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts:treeifyError",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
    "symbol": "treeifyError",
    "startLine": 306,
    "endLine": 306,
    "text": "export function treeifyError<T>(error: $ZodError<T>): $ZodErrorTree<T>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts:treeifyError",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
    "symbol": "treeifyError",
    "startLine": 307,
    "endLine": 307,
    "text": "export function treeifyError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): $ZodErrorTree<T, U>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts:treeifyError",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
    "symbol": "treeifyError",
    "startLine": 308,
    "endLine": 358,
    "text": "export function treeifyError<T>(error: $ZodError, _mapper?: any) {\n  const mapper: (issue: $ZodIssue) => any =\n    _mapper ||\n    function (issue: $ZodIssue) {\n      return issue.message;\n    };\n  const result: $ZodErrorTree<T> = { errors: [] } as any;\n  const processError = (error: { issues: $ZodIssue[] }, path: PropertyKey[] = []) => {\n    for (const issue of error.issues) {\n      if (issue.code === \"invalid_union\" && issue.errors.length) {\n        // regular union error\n        issue.errors.map((issues) => processError({ issues }, issue.path));\n      } else if (issue.code === \"invalid_key\") {\n        processError({ issues: issue.issues }, issue.path);\n      } else if (issue.code === \"invalid_element\") {\n        processError({ issues: issue.issues }, issue.path);\n      } else {\n        const fullpath = [...path, ...issue.path];\n        if (fullpath.length === 0) {\n          result.errors.push(mapper(issue));\n          continue;\n        }\n\n        let curr: any = result;\n        let i = 0;\n        while (i < fullpath.length) {\n          const el = fullpath[i]!;\n\n          const terminal = i === fullpath.length - 1;\n          if (typeof el === \"string\") {\n            curr.properties ??= {};\n            curr.properties[el] ??= { errors: [] };\n            curr = curr.properties[el];\n          } else {\n            curr.items ??= [];\n            curr.items[el] ??= { errors: [] };\n            curr = curr.items[el];\n          }\n\n          if (terminal) {\n            curr.errors.push(mapper(issue));\n          }\n\n          i++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return result;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts:toDotPath",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
    "symbol": "toDotPath",
    "startLine": 392,
    "endLine": 405,
    "text": "export function toDotPath(path: (string | number | symbol)[]): string {\n  const segs: string[] = [];\n  for (const seg of path) {\n    if (typeof seg === \"number\") segs.push(`[${seg}]`);\n    else if (typeof seg === \"symbol\") segs.push(`[${JSON.stringify(String(seg))}]`);\n    else if (/[^\\w$]/.test(seg)) segs.push(`[${JSON.stringify(seg)}]`);\n    else {\n      if (segs.length) segs.push(\".\");\n      segs.push(seg);\n    }\n  }\n\n  return segs.join(\"\");\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts:prettifyError",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
    "symbol": "prettifyError",
    "startLine": 411,
    "endLine": 424,
    "text": "export function prettifyError(error: BaseError): string {\n  const lines: string[] = [];\n  // sort by path length\n  const issues = [...error.issues].sort((a, b) => a.path.length - b.path.length);\n\n  // Process each issue\n  for (const issue of issues) {\n    lines.push(` ${issue.message}`);\n    if (issue.path?.length) lines.push(`   at ${toDotPath(issue.path)}`);\n  }\n\n  // Convert Map to formatted string\n  return lines.join(\"\\n\");\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts:$ZodFunction",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
    "symbol": "$ZodFunction",
    "startLine": 44,
    "endLine": 132,
    "text": "export class $ZodFunction<\n  Args extends $ZodFunctionIn = $ZodFunctionIn,\n  Returns extends $ZodFunctionOut = $ZodFunctionOut,\n> {\n  def: $ZodFunctionDef<Args, Returns>;\n\n  /** @deprecated */\n  _def!: $ZodFunctionDef<Args, Returns>;\n  _input!: $InferInnerFunctionType<Args, Returns>;\n  _output!: $InferOuterFunctionType<Args, Returns>;\n\n  constructor(def: $ZodFunctionDef<Args, Returns>) {\n    this._def = def;\n    this.def = def;\n  }\n\n  implement<F extends $InferInnerFunctionType<Args, Returns>>(\n    func: F\n  ): // allow for return type inference\n  (\n    ...args: Parameters<this[\"_output\"]>\n  ) => ReturnType<F> extends ReturnType<this[\"_output\"]> ? ReturnType<F> : ReturnType<this[\"_output\"]> {\n    if (typeof func !== \"function\") {\n      throw new Error(\"implement() must be called with a function\");\n    }\n    const impl = ((...args: any[]) => {\n      const parsedArgs = this._def.input ? parse(this._def.input, args, undefined, { callee: impl }) : args;\n      if (!Array.isArray(parsedArgs)) {\n        throw new Error(\"Invalid arguments schema: not an array or tuple schema.\");\n      }\n      const output = func(...(parsedArgs as any));\n      return this._def.output ? parse(this._def.output, output, undefined, { callee: impl }) : output;\n    }) as any;\n    return impl;\n  }\n\n  implementAsync<F extends $InferInnerFunctionTypeAsync<Args, Returns>>(\n    func: F\n  ): F extends $InferOuterFunctionTypeAsync<Args, Returns> ? F : $InferOuterFunctionTypeAsync<Args, Returns> {\n    if (typeof func !== \"function\") {\n      throw new Error(\"implement() must be called with a function\");\n    }\n\n    const impl = (async (...args: any[]) => {\n      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, undefined, { callee: impl }) : args;\n      if (!Array.isArray(parsedArgs)) {\n        throw new Error(\"Invalid arguments schema: not an array or tuple schema.\");\n      }\n      const output = await func(...(parsedArgs as any));\n      return this._def.output ? parseAsync(this._def.output, output, undefined, { callee: impl }) : output;\n    }) as any;\n    return impl;\n  }\n\n  input<const Items extends util.TupleItems, const Rest extends $ZodFunctionOut = $ZodFunctionOut>(\n    args: Items,\n    rest?: Rest\n  ): $ZodFunction<schemas.$ZodTuple<Items, Rest>, Returns>;\n  input<NewArgs extends $ZodFunctionIn>(args: NewArgs): $ZodFunction<NewArgs, Returns>;\n  input(...args: any[]): $ZodFunction<any, Returns> {\n    const F: any = this.constructor;\n    if (Array.isArray(args[0])) {\n      return new F({\n        type: \"function\",\n        input: new $ZodTuple({\n          type: \"tuple\",\n          items: args[0],\n          rest: args[1],\n        }),\n        output: this._def.output,\n      });\n    }\n\n    return new F({\n      type: \"function\",\n      input: args[0],\n      output: this._def.output,\n    });\n  }\n\n  output<NewReturns extends schemas.$ZodType>(output: NewReturns): $ZodFunction<Args, NewReturns> {\n    const F: any = this.constructor;\n    return new F({\n      type: \"function\",\n      input: this._def.input,\n      output,\n    });\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts:$ZodFunction.implement",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
    "symbol": "$ZodFunction.implement",
    "startLine": 60,
    "endLine": 78,
    "text": "  implement<F extends $InferInnerFunctionType<Args, Returns>>(\n    func: F\n  ): // allow for return type inference\n  (\n    ...args: Parameters<this[\"_output\"]>\n  ) => ReturnType<F> extends ReturnType<this[\"_output\"]> ? ReturnType<F> : ReturnType<this[\"_output\"]> {\n    if (typeof func !== \"function\") {\n      throw new Error(\"implement() must be called with a function\");\n    }\n    const impl = ((...args: any[]) => {\n      const parsedArgs = this._def.input ? parse(this._def.input, args, undefined, { callee: impl }) : args;\n      if (!Array.isArray(parsedArgs)) {\n        throw new Error(\"Invalid arguments schema: not an array or tuple schema.\");\n      }\n      const output = func(...(parsedArgs as any));\n      return this._def.output ? parse(this._def.output, output, undefined, { callee: impl }) : output;\n    }) as any;\n    return impl;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts:$ZodFunction.implementAsync",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
    "symbol": "$ZodFunction.implementAsync",
    "startLine": 80,
    "endLine": 96,
    "text": "  implementAsync<F extends $InferInnerFunctionTypeAsync<Args, Returns>>(\n    func: F\n  ): F extends $InferOuterFunctionTypeAsync<Args, Returns> ? F : $InferOuterFunctionTypeAsync<Args, Returns> {\n    if (typeof func !== \"function\") {\n      throw new Error(\"implement() must be called with a function\");\n    }\n\n    const impl = (async (...args: any[]) => {\n      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, undefined, { callee: impl }) : args;\n      if (!Array.isArray(parsedArgs)) {\n        throw new Error(\"Invalid arguments schema: not an array or tuple schema.\");\n      }\n      const output = await func(...(parsedArgs as any));\n      return this._def.output ? parseAsync(this._def.output, output, undefined, { callee: impl }) : output;\n    }) as any;\n    return impl;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts:$ZodFunction.input",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
    "symbol": "$ZodFunction.input",
    "startLine": 103,
    "endLine": 122,
    "text": "  input(...args: any[]): $ZodFunction<any, Returns> {\n    const F: any = this.constructor;\n    if (Array.isArray(args[0])) {\n      return new F({\n        type: \"function\",\n        input: new $ZodTuple({\n          type: \"tuple\",\n          items: args[0],\n          rest: args[1],\n        }),\n        output: this._def.output,\n      });\n    }\n\n    return new F({\n      type: \"function\",\n      input: args[0],\n      output: this._def.output,\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts:$ZodFunction.output",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
    "symbol": "$ZodFunction.output",
    "startLine": 124,
    "endLine": 131,
    "text": "  output<NewReturns extends schemas.$ZodType>(output: NewReturns): $ZodFunction<Args, NewReturns> {\n    const F: any = this.constructor;\n    return new F({\n      type: \"function\",\n      input: this._def.input,\n      output,\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts:_function",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
    "symbol": "_function",
    "startLine": 139,
    "endLine": 139,
    "text": "function _function(): $ZodFunction;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts:_function",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
    "symbol": "_function",
    "startLine": 140,
    "endLine": 142,
    "text": "function _function<const In extends Array<schemas.$ZodType> = Array<schemas.$ZodType>>(params: {\n  input: In;\n}): $ZodFunction<$ZodTuple<In, null>, $ZodFunctionOut>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts:_function",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
    "symbol": "_function",
    "startLine": 143,
    "endLine": 149,
    "text": "function _function<\n  const In extends Array<schemas.$ZodType> = Array<schemas.$ZodType>,\n  const Out extends $ZodFunctionOut = $ZodFunctionOut,\n>(params: {\n  input: In;\n  output: Out;\n}): $ZodFunction<$ZodTuple<In, null>, Out>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts:_function",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
    "symbol": "_function",
    "startLine": 150,
    "endLine": 152,
    "text": "function _function<const In extends $ZodFunctionIn = $ZodFunctionIn>(params: {\n  input: In;\n}): $ZodFunction<In, $ZodFunctionOut>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts:_function",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
    "symbol": "_function",
    "startLine": 153,
    "endLine": 155,
    "text": "function _function<const Out extends $ZodFunctionOut = $ZodFunctionOut>(params: {\n  output: Out;\n}): $ZodFunction<$ZodFunctionIn, Out>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts:_function",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
    "symbol": "_function",
    "startLine": 156,
    "endLine": 162,
    "text": "function _function<\n  In extends $ZodFunctionIn = $ZodFunctionIn,\n  Out extends schemas.$ZodType = schemas.$ZodType,\n>(params?: {\n  input: In;\n  output: Out;\n}): $ZodFunction<In, Out>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts:_function",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
    "symbol": "_function",
    "startLine": 163,
    "endLine": 174,
    "text": "function _function(params?: {\n  output?: schemas.$ZodType;\n  input?: $ZodFunctionArgs | Array<schemas.$ZodType>;\n}): any {\n  return new $ZodFunction({\n    type: \"function\",\n    input: Array.isArray(params?.input)\n      ? _tuple(schemas.$ZodTuple, params?.input as any)\n      : (params?.input ?? _array(schemas.$ZodArray, _unknown(schemas.$ZodUnknown))),\n    output: params?.output ?? _unknown(schemas.$ZodUnknown),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/regexes.ts:emoji",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/regexes.ts",
    "symbol": "emoji",
    "startLine": 53,
    "endLine": 55,
    "text": "export function emoji(): RegExp {\n  return new RegExp(_emoji, \"u\");\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/regexes.ts:timeSource",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/regexes.ts",
    "symbol": "timeSource",
    "startLine": 84,
    "endLine": 95,
    "text": "function timeSource(args: { precision?: number | null | undefined }) {\n  const hhmm = `(?:[01]\\\\d|2[0-3]):[0-5]\\\\d`;\n  const regex =\n    typeof args.precision === \"number\"\n      ? args.precision === -1\n        ? `${hhmm}`\n        : args.precision === 0\n          ? `${hhmm}:[0-5]\\\\d`\n          : `${hhmm}:[0-5]\\\\d\\\\.\\\\d{${args.precision}}`\n      : `${hhmm}(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?`;\n  return regex;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/regexes.ts:time",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/regexes.ts",
    "symbol": "time",
    "startLine": 96,
    "endLine": 101,
    "text": "export function time(args: {\n  precision?: number | null;\n  // local?: boolean;\n}): RegExp {\n  return new RegExp(`^${timeSource(args)}$`);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/regexes.ts:datetime",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/regexes.ts",
    "symbol": "datetime",
    "startLine": 104,
    "endLine": 116,
    "text": "export function datetime(args: {\n  precision?: number | null;\n  offset?: boolean;\n  local?: boolean;\n}): RegExp {\n  const time = timeSource({ precision: args.precision });\n  const opts = [\"Z\"];\n  if (args.local) opts.push(\"\");\n  if (args.offset) opts.push(`([+-]\\\\d{2}:\\\\d{2})`);\n  const timeRegex = `${time}(?:${opts.join(\"|\")})`;\n\n  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/registries.ts:$ZodRegistry",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
    "symbol": "$ZodRegistry",
    "startLine": 27,
    "endLine": 79,
    "text": "export class $ZodRegistry<Meta extends MetadataType = MetadataType, Schema extends $ZodType = $ZodType> {\n  _meta!: Meta;\n  _schema!: Schema;\n  _map: Map<Schema, $replace<Meta, Schema>> = new Map();\n  _idmap: Map<string, Schema> = new Map();\n\n  add<S extends Schema>(\n    schema: S,\n    ..._meta: undefined extends Meta ? [$replace<Meta, S>?] : [$replace<Meta, S>]\n  ): this {\n    const meta: any = _meta[0];\n    this._map.set(schema, meta!);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      if (this._idmap.has(meta.id!)) {\n        throw new Error(`ID ${meta.id} already exists in the registry`);\n      }\n      this._idmap.set(meta.id!, schema);\n    }\n    return this as any;\n  }\n\n  clear(): this {\n    this._map = new Map();\n    this._idmap = new Map();\n    return this;\n  }\n\n  remove(schema: Schema): this {\n    const meta: any = this._map.get(schema);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      this._idmap.delete(meta.id!);\n    }\n    this._map.delete(schema);\n    return this;\n  }\n\n  get<S extends Schema>(schema: S): $replace<Meta, S> | undefined {\n    // return this._map.get(schema) as any;\n\n    // inherit metadata\n    const p = schema._zod.parent as Schema;\n    if (p) {\n      const pm: any = { ...(this.get(p) ?? {}) };\n      delete pm.id; // do not inherit id\n      return { ...pm, ...this._map.get(schema) } as any;\n    }\n    return this._map.get(schema) as any;\n  }\n\n  has(schema: Schema): boolean {\n    return this._map.has(schema);\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/registries.ts:$ZodRegistry.add",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
    "symbol": "$ZodRegistry.add",
    "startLine": 33,
    "endLine": 46,
    "text": "  add<S extends Schema>(\n    schema: S,\n    ..._meta: undefined extends Meta ? [$replace<Meta, S>?] : [$replace<Meta, S>]\n  ): this {\n    const meta: any = _meta[0];\n    this._map.set(schema, meta!);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      if (this._idmap.has(meta.id!)) {\n        throw new Error(`ID ${meta.id} already exists in the registry`);\n      }\n      this._idmap.set(meta.id!, schema);\n    }\n    return this as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/registries.ts:$ZodRegistry.clear",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
    "symbol": "$ZodRegistry.clear",
    "startLine": 48,
    "endLine": 52,
    "text": "  clear(): this {\n    this._map = new Map();\n    this._idmap = new Map();\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/registries.ts:$ZodRegistry.remove",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
    "symbol": "$ZodRegistry.remove",
    "startLine": 54,
    "endLine": 61,
    "text": "  remove(schema: Schema): this {\n    const meta: any = this._map.get(schema);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      this._idmap.delete(meta.id!);\n    }\n    this._map.delete(schema);\n    return this;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/registries.ts:$ZodRegistry.get",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
    "symbol": "$ZodRegistry.get",
    "startLine": 63,
    "endLine": 74,
    "text": "  get<S extends Schema>(schema: S): $replace<Meta, S> | undefined {\n    // return this._map.get(schema) as any;\n\n    // inherit metadata\n    const p = schema._zod.parent as Schema;\n    if (p) {\n      const pm: any = { ...(this.get(p) ?? {}) };\n      delete pm.id; // do not inherit id\n      return { ...pm, ...this._map.get(schema) } as any;\n    }\n    return this._map.get(schema) as any;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/registries.ts:$ZodRegistry.has",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
    "symbol": "$ZodRegistry.has",
    "startLine": 76,
    "endLine": 78,
    "text": "  has(schema: Schema): boolean {\n    return this._map.has(schema);\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/registries.ts:registry",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
    "symbol": "registry",
    "startLine": 92,
    "endLine": 94,
    "text": "export function registry<T extends MetadataType = MetadataType, S extends $ZodType = $ZodType>(): $ZodRegistry<T, S> {\n  return new $ZodRegistry<T, S>();\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:isValidBase64",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "isValidBase64",
    "startLine": 800,
    "endLine": 809,
    "text": "export function isValidBase64(data: string): boolean {\n  if (data === \"\") return true;\n  if (data.length % 4 !== 0) return false;\n  try {\n    atob(data);\n    return true;\n  } catch {\n    return false;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:isValidBase64URL",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "isValidBase64URL",
    "startLine": 843,
    "endLine": 848,
    "text": "export function isValidBase64URL(data: string): boolean {\n  if (!regexes.base64url.test(data)) return false;\n  const base64 = data.replace(/[-_]/g, (c) => (c === \"-\" ? \"+\" : \"/\"));\n  const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, \"=\");\n  return isValidBase64(padded);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:isValidJWT",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "isValidJWT",
    "startLine": 897,
    "endLine": 911,
    "text": "export function isValidJWT(token: string, algorithm: util.JWTAlgorithm | null = null): boolean {\n  try {\n    const tokensParts = token.split(\".\");\n    if (tokensParts.length !== 3) return false;\n    const [header] = tokensParts;\n    if (!header) return false;\n    const parsedHeader = JSON.parse(atob(header));\n    if (\"typ\" in parsedHeader && parsedHeader?.typ !== \"JWT\") return false;\n    if (!parsedHeader.alg) return false;\n    if (algorithm && (!(\"alg\" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;\n    return true;\n  } catch {\n    return false;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:handleArrayResult",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "handleArrayResult",
    "startLine": 1510,
    "endLine": 1515,
    "text": "function handleArrayResult(result: ParsePayload<any>, final: ParsePayload<any[]>, index: number) {\n  if (result.issues.length) {\n    final.issues.push(...util.prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:handleObjectResult",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "handleObjectResult",
    "startLine": 1599,
    "endLine": 1606,
    "text": "function handleObjectResult(result: ParsePayload, final: ParsePayload, key: PropertyKey) {\n  // if(isOptional)\n  if (result.issues.length) {\n    final.issues.push(...util.prefixIssues(key, result.issues));\n  }\n\n  (final.value as any)[key] = result.value;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:handleOptionalObjectResult",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "handleOptionalObjectResult",
    "startLine": 1608,
    "endLine": 1628,
    "text": "function handleOptionalObjectResult(result: ParsePayload, final: ParsePayload, key: PropertyKey, input: any) {\n  if (result.issues.length) {\n    // validation failed against value schema\n    if (input[key] === undefined) {\n      // if input was undefined, ignore the error\n      if (key in input) {\n        (final.value as any)[key] = undefined;\n      } else {\n        (final.value as any)[key] = result.value;\n      }\n    } else {\n      final.issues.push(...util.prefixIssues(key, result.issues));\n    }\n  } else if (result.value === undefined) {\n    // validation returned `undefined`\n    if (key in input) (final.value as any)[key] = undefined;\n  } else {\n    // non-undefined value\n    (final.value as any)[key] = result.value;\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:handleUnionResults",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "handleUnionResults",
    "startLine": 1920,
    "endLine": 1936,
    "text": "function handleUnionResults(results: ParsePayload[], final: ParsePayload, inst: $ZodUnion, ctx?: ParseContext) {\n  for (const result of results) {\n    if (result.issues.length === 0) {\n      final.value = result.value;\n      return final;\n    }\n  }\n\n  final.issues.push({\n    code: \"invalid_union\",\n    input: final.value,\n    inst,\n    errors: results.map((result) => result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n  });\n\n  return final;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:mergeValues",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "mergeValues",
    "startLine": 2139,
    "endLine": 2195,
    "text": "function mergeValues(\n  a: any,\n  b: any\n): { valid: true; data: any } | { valid: false; mergeErrorPath: (string | number)[] } {\n  // const aType = parse.t(a);\n  // const bType = parse.t(b);\n\n  if (a === b) {\n    return { valid: true, data: a };\n  }\n  if (a instanceof Date && b instanceof Date && +a === +b) {\n    return { valid: true, data: a };\n  }\n  if (util.isPlainObject(a) && util.isPlainObject(b)) {\n    const bKeys = Object.keys(b);\n    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);\n\n    const newObj: any = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [key, ...sharedValue.mergeErrorPath],\n        };\n      }\n      newObj[key] = sharedValue.data;\n    }\n\n    return { valid: true, data: newObj };\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return { valid: false, mergeErrorPath: [] };\n    }\n\n    const newArray: unknown[] = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [index, ...sharedValue.mergeErrorPath],\n        };\n      }\n\n      newArray.push(sharedValue.data);\n    }\n\n    return { valid: true, data: newArray };\n  }\n\n  return { valid: false, mergeErrorPath: [] };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:handleIntersectionResults",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "handleIntersectionResults",
    "startLine": 2197,
    "endLine": 2214,
    "text": "function handleIntersectionResults(result: ParsePayload, left: ParsePayload, right: ParsePayload): ParsePayload {\n  if (left.issues.length) {\n    result.issues.push(...left.issues);\n  }\n  if (right.issues.length) {\n    result.issues.push(...right.issues);\n  }\n  if (util.aborted(result)) return result;\n\n  const merged = mergeValues(left.value, right.value);\n\n  if (!merged.valid) {\n    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);\n  }\n\n  result.value = merged.data;\n  return result;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:handleTupleResult",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "handleTupleResult",
    "startLine": 2358,
    "endLine": 2363,
    "text": "function handleTupleResult(result: ParsePayload, final: ParsePayload<any[]>, index: number) {\n  if (result.issues.length) {\n    final.issues.push(...util.prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:handleMapResult",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "handleMapResult",
    "startLine": 2604,
    "endLine": 2641,
    "text": "function handleMapResult(\n  keyResult: ParsePayload,\n  valueResult: ParsePayload,\n  final: ParsePayload<Map<unknown, unknown>>,\n  key: unknown,\n  input: Map<any, any>,\n  inst: $ZodMap,\n  ctx?: ParseContext | undefined\n): void {\n  if (keyResult.issues.length) {\n    if (util.propertyKeyTypes.has(typeof key)) {\n      final.issues.push(...util.prefixIssues(key as PropertyKey, keyResult.issues));\n    } else {\n      final.issues.push({\n        origin: \"map\",\n        code: \"invalid_key\",\n        input,\n        inst,\n        issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n      });\n    }\n  }\n  if (valueResult.issues.length) {\n    if (util.propertyKeyTypes.has(typeof key)) {\n      final.issues.push(...util.prefixIssues(key as PropertyKey, valueResult.issues));\n    } else {\n      final.issues.push({\n        origin: \"map\",\n        code: \"invalid_element\",\n        input,\n        inst,\n        key: key,\n        issues: valueResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n      });\n    }\n  }\n  final.value.set(keyResult.value, valueResult.value);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:handleSetResult",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "handleSetResult",
    "startLine": 2696,
    "endLine": 2701,
    "text": "function handleSetResult(result: ParsePayload, final: ParsePayload<Set<any>>) {\n  if (result.issues.length) {\n    final.issues.push(...result.issues);\n  }\n  final.value.add(result.value);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:handleDefaultResult",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "handleDefaultResult",
    "startLine": 3106,
    "endLine": 3111,
    "text": "function handleDefaultResult(payload: ParsePayload, def: $ZodDefaultDef) {\n  if (payload.value === undefined) {\n    payload.value = def.defaultValue;\n  }\n  return payload;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:handleNonOptionalResult",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "handleNonOptionalResult",
    "startLine": 3203,
    "endLine": 3213,
    "text": "function handleNonOptionalResult(payload: ParsePayload, inst: $ZodNonOptional) {\n  if (!payload.issues.length && payload.value === undefined) {\n    payload.issues.push({\n      code: \"invalid_type\",\n      expected: \"nonoptional\",\n      input: payload.value,\n      inst,\n    });\n  }\n  return payload;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:handlePipeResult",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "handlePipeResult",
    "startLine": 3452,
    "endLine": 3457,
    "text": "function handlePipeResult(left: ParsePayload, def: $ZodPipeDef, ctx: ParseContext) {\n  if (util.aborted(left)) {\n    return left;\n  }\n  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:handleReadonlyResult",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "handleReadonlyResult",
    "startLine": 3505,
    "endLine": 3508,
    "text": "function handleReadonlyResult(payload: ParsePayload): ParsePayload {\n  payload.value = Object.freeze(payload.value);\n  return payload;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts:handleRefineResult",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "symbol": "handleRefineResult",
    "startLine": 3764,
    "endLine": 3777,
    "text": "function handleRefineResult(result: unknown, payload: ParsePayload, input: unknown, inst: $ZodCustom): void {\n  if (!result) {\n    const _iss: any = {\n      code: \"custom\",\n      input,\n      inst, // incorporates params.error into issue reporting\n      path: [...(inst._zod.def.path ?? [])], // incorporates params.error into issue reporting\n      continue: !inst._zod.def.abort,\n      // params: inst._zod.def.params,\n    };\n    if (inst._zod.def.params) _iss.params = inst._zod.def.params;\n    payload.issues.push(util.issue(_iss));\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts:JSONSchemaGenerator",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
    "symbol": "JSONSchemaGenerator",
    "startLine": 72,
    "endLine": 821,
    "text": "export class JSONSchemaGenerator {\n  metadataRegistry: $ZodRegistry<Record<string, any>>;\n  target: \"draft-7\" | \"draft-2020-12\";\n  unrepresentable: \"throw\" | \"any\";\n  override: (ctx: {\n    zodSchema: schemas.$ZodTypes;\n    jsonSchema: JSONSchema.BaseSchema;\n    path: (string | number)[];\n  }) => void;\n  io: \"input\" | \"output\";\n\n  counter = 0;\n  seen: Map<schemas.$ZodType, Seen>;\n\n  constructor(params?: JSONSchemaGeneratorParams) {\n    this.metadataRegistry = params?.metadata ?? globalRegistry;\n    this.target = params?.target ?? \"draft-2020-12\";\n    this.unrepresentable = params?.unrepresentable ?? \"throw\";\n    this.override = params?.override ?? (() => {});\n    this.io = params?.io ?? \"output\";\n\n    this.seen = new Map();\n  }\n\n  process(schema: schemas.$ZodType, _params: ProcessParams = { path: [], schemaPath: [] }): JSONSchema.BaseSchema {\n    const def = (schema as schemas.$ZodTypes)._zod.def;\n\n    const formatMap: Partial<Record<checks.$ZodStringFormats, string | undefined>> = {\n      guid: \"uuid\",\n      url: \"uri\",\n      datetime: \"date-time\",\n      json_string: \"json-string\",\n      regex: \"\", // do not set\n    };\n\n    // check for schema in seens\n    const seen = this.seen.get(schema);\n\n    if (seen) {\n      seen.count++;\n\n      // check if cycle\n      const isCycle = _params.schemaPath.includes(schema);\n      if (isCycle) {\n        seen.cycle = _params.path;\n      }\n\n      return seen.schema;\n    }\n\n    // initialize\n    const result: Seen = { schema: {}, count: 1, cycle: undefined, path: _params.path };\n    this.seen.set(schema, result);\n\n    // custom method overrides default behavior\n    const overrideSchema = schema._zod.toJSONSchema?.();\n    if (overrideSchema) {\n      result.schema = overrideSchema as any;\n    } else {\n      const params = {\n        ..._params,\n        schemaPath: [..._params.schemaPath, schema],\n        path: _params.path,\n      };\n\n      const parent = schema._zod.parent;\n\n      if (parent) {\n        // schema was cloned from another schema\n        result.ref = parent;\n        this.process(parent, params);\n        this.seen.get(parent)!.isParent = true;\n      } else {\n        const _json = result.schema;\n        switch (def.type) {\n          case \"string\": {\n            const json: JSONSchema.StringSchema = _json as any;\n            json.type = \"string\";\n            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod\n              .bag as schemas.$ZodStringInternals<unknown>[\"bag\"];\n            if (typeof minimum === \"number\") json.minLength = minimum;\n            if (typeof maximum === \"number\") json.maxLength = maximum;\n            // custom pattern overrides format\n            if (format) {\n              json.format = formatMap[format as checks.$ZodStringFormats] ?? format;\n              if (json.format === \"\") delete json.format; // empty format is not valid\n            }\n            if (contentEncoding) json.contentEncoding = contentEncoding;\n            if (patterns && patterns.size > 0) {\n              const regexes = [...patterns];\n              if (regexes.length === 1) json.pattern = regexes[0]!.source;\n              else if (regexes.length > 1) {\n                result.schema.allOf = [\n                  ...regexes.map((regex) => ({\n                    ...(this.target === \"draft-7\" ? ({ type: \"string\" } as const) : {}),\n                    pattern: regex.source,\n                  })),\n                ];\n              }\n            }\n\n            break;\n          }\n          case \"number\": {\n            const json: JSONSchema.NumberSchema | JSONSchema.IntegerSchema = _json as any;\n            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;\n            if (typeof format === \"string\" && format.includes(\"int\")) json.type = \"integer\";\n            else json.type = \"number\";\n\n            if (typeof exclusiveMinimum === \"number\") json.exclusiveMinimum = exclusiveMinimum;\n            if (typeof minimum === \"number\") {\n              json.minimum = minimum;\n              if (typeof exclusiveMinimum === \"number\") {\n                if (exclusiveMinimum >= minimum) delete json.minimum;\n                else delete json.exclusiveMinimum;\n              }\n            }\n\n            if (typeof exclusiveMaximum === \"number\") json.exclusiveMaximum = exclusiveMaximum;\n            if (typeof maximum === \"number\") {\n              json.maximum = maximum;\n              if (typeof exclusiveMaximum === \"number\") {\n                if (exclusiveMaximum <= maximum) delete json.maximum;\n                else delete json.exclusiveMaximum;\n              }\n            }\n\n            if (typeof multipleOf === \"number\") json.multipleOf = multipleOf;\n\n            break;\n          }\n          case \"boolean\": {\n            const json = _json as JSONSchema.BooleanSchema;\n            json.type = \"boolean\";\n            break;\n          }\n          case \"bigint\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"BigInt cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"symbol\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Symbols cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"null\": {\n            _json.type = \"null\";\n            break;\n          }\n          case \"any\": {\n            break;\n          }\n          case \"unknown\": {\n            break;\n          }\n          case \"undefined\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Undefined cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"void\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Void cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"never\": {\n            _json.not = {};\n            break;\n          }\n          case \"date\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Date cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"array\": {\n            const json: JSONSchema.ArraySchema = _json as any;\n            const { minimum, maximum } = schema._zod.bag;\n            if (typeof minimum === \"number\") json.minItems = minimum;\n            if (typeof maximum === \"number\") json.maxItems = maximum;\n\n            json.type = \"array\";\n            json.items = this.process(def.element, { ...params, path: [...params.path, \"items\"] });\n            break;\n          }\n          case \"object\": {\n            const json: JSONSchema.ObjectSchema = _json as any;\n            json.type = \"object\";\n            json.properties = {};\n            const shape = def.shape; // params.shapeCache.get(schema)!;\n\n            for (const key in shape) {\n              json.properties[key] = this.process(shape[key]!, {\n                ...params,\n                path: [...params.path, \"properties\", key],\n              });\n            }\n\n            // required keys\n            const allKeys = new Set(Object.keys(shape));\n            // const optionalKeys = new Set(def.optional);\n            const requiredKeys = new Set(\n              [...allKeys].filter((key) => {\n                const v = def.shape[key]!._zod;\n                if (this.io === \"input\") {\n                  return v.optin === undefined;\n                } else {\n                  return v.optout === undefined;\n                }\n              })\n            );\n\n            if (requiredKeys.size > 0) {\n              json.required = Array.from(requiredKeys);\n            }\n\n            // catchall\n            if (def.catchall?._zod.def.type === \"never\") {\n              // strict\n              json.additionalProperties = false;\n            } else if (!def.catchall) {\n              // regular\n              if (this.io === \"output\") json.additionalProperties = false;\n            } else if (def.catchall) {\n              json.additionalProperties = this.process(def.catchall, {\n                ...params,\n                path: [...params.path, \"additionalProperties\"],\n              });\n            }\n\n            break;\n          }\n          case \"union\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            json.anyOf = def.options.map((x, i) =>\n              this.process(x, {\n                ...params,\n                path: [...params.path, \"anyOf\", i],\n              })\n            );\n            break;\n          }\n          case \"intersection\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            const a = this.process(def.left, {\n              ...params,\n              path: [...params.path, \"allOf\", 0],\n            });\n            const b = this.process(def.right, {\n              ...params,\n              path: [...params.path, \"allOf\", 1],\n            });\n\n            const isSimpleIntersection = (val: any) => \"allOf\" in val && Object.keys(val).length === 1;\n            const allOf = [\n              ...(isSimpleIntersection(a) ? (a.allOf as any[]) : [a]),\n              ...(isSimpleIntersection(b) ? (b.allOf as any[]) : [b]),\n            ];\n            json.allOf = allOf;\n            break;\n          }\n          case \"tuple\": {\n            const json: JSONSchema.ArraySchema = _json as any;\n            json.type = \"array\";\n            const prefixItems = def.items.map((x, i) =>\n              this.process(x, { ...params, path: [...params.path, \"prefixItems\", i] })\n            );\n            if (this.target === \"draft-2020-12\") {\n              json.prefixItems = prefixItems;\n            } else {\n              json.items = prefixItems;\n            }\n\n            if (def.rest) {\n              const rest = this.process(def.rest, {\n                ...params,\n                path: [...params.path, \"items\"],\n              });\n              if (this.target === \"draft-2020-12\") {\n                json.items = rest;\n              } else {\n                json.additionalItems = rest;\n              }\n            }\n\n            // additionalItems\n            if (def.rest) {\n              json.items = this.process(def.rest, {\n                ...params,\n                path: [...params.path, \"items\"],\n              });\n            }\n\n            // length\n            const { minimum, maximum } = schema._zod.bag as {\n              minimum?: number;\n              maximum?: number;\n            };\n            if (typeof minimum === \"number\") json.minItems = minimum;\n            if (typeof maximum === \"number\") json.maxItems = maximum;\n            break;\n          }\n          case \"record\": {\n            const json: JSONSchema.ObjectSchema = _json as any;\n            json.type = \"object\";\n            json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, \"propertyNames\"] });\n            json.additionalProperties = this.process(def.valueType, {\n              ...params,\n              path: [...params.path, \"additionalProperties\"],\n            });\n            break;\n          }\n          case \"map\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Map cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"set\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Set cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"enum\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            const values = getEnumValues(def.entries);\n            // Number enums can have both string and number values\n            if (values.every((v) => typeof v === \"number\")) json.type = \"number\";\n            if (values.every((v) => typeof v === \"string\")) json.type = \"string\";\n            json.enum = values;\n            break;\n          }\n          case \"literal\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            const vals: (string | number | boolean | null)[] = [];\n            for (const val of def.values) {\n              if (val === undefined) {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                } else {\n                  // do not add to vals\n                }\n              } else if (typeof val === \"bigint\") {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                } else {\n                  vals.push(Number(val));\n                }\n              } else {\n                vals.push(val);\n              }\n            }\n            if (vals.length === 0) {\n              // do nothing (an undefined literal was stripped)\n            } else if (vals.length === 1) {\n              const val = vals[0]!;\n              json.type = val === null ? (\"null\" as const) : (typeof val as any);\n              json.const = val;\n            } else {\n              if (vals.every((v) => typeof v === \"number\")) json.type = \"number\";\n              if (vals.every((v) => typeof v === \"string\")) json.type = \"string\";\n              if (vals.every((v) => typeof v === \"boolean\")) json.type = \"string\";\n              if (vals.every((v) => v === null)) json.type = \"null\";\n              json.enum = vals;\n            }\n            break;\n          }\n\n          case \"file\": {\n            const json: JSONSchema.StringSchema = _json as any;\n            const file: JSONSchema.StringSchema = {\n              type: \"string\",\n              format: \"binary\",\n              contentEncoding: \"binary\",\n            };\n\n            const { minimum, maximum, mime } = schema._zod.bag as schemas.$ZodFileInternals[\"bag\"];\n            if (minimum !== undefined) file.minLength = minimum;\n            if (maximum !== undefined) file.maxLength = maximum;\n            if (mime) {\n              if (mime.length === 1) {\n                file.contentMediaType = mime[0]!;\n                Object.assign(json, file);\n              } else {\n                json.anyOf = mime.map((m) => {\n                  const mFile: JSONSchema.StringSchema = { ...file, contentMediaType: m };\n                  return mFile;\n                });\n              }\n            } else {\n              Object.assign(json, file);\n            }\n\n            // if (this.unrepresentable === \"throw\") {\n            //   throw new Error(\"File cannot be represented in JSON Schema\");\n            // }\n            break;\n          }\n          case \"transform\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Transforms cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n\n          case \"nullable\": {\n            const inner = this.process(def.innerType, params);\n            _json.anyOf = [inner, { type: \"null\" }];\n            break;\n          }\n          case \"nonoptional\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            break;\n          }\n          case \"success\": {\n            const json = _json as JSONSchema.BooleanSchema;\n            json.type = \"boolean\";\n            break;\n          }\n          case \"default\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n            break;\n          }\n          case \"prefault\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            if (this.io === \"input\") _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n\n            break;\n          }\n          case \"catch\": {\n            // use conditionals\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            let catchValue: any;\n            try {\n              catchValue = def.catchValue(undefined as any);\n            } catch {\n              throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n            }\n            _json.default = catchValue;\n            break;\n          }\n          case \"nan\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"NaN cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"template_literal\": {\n            const json = _json as JSONSchema.StringSchema;\n            const pattern = schema._zod.pattern;\n            if (!pattern) throw new Error(\"Pattern not found in template literal\");\n            json.type = \"string\";\n            json.pattern = pattern.source;\n            break;\n          }\n          case \"pipe\": {\n            const innerType = this.io === \"input\" ? (def.in._zod.def.type === \"transform\" ? def.out : def.in) : def.out;\n            this.process(innerType, params);\n            result.ref = innerType;\n            break;\n          }\n          case \"readonly\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            _json.readOnly = true;\n            break;\n          }\n          // passthrough types\n          case \"promise\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            break;\n          }\n          case \"optional\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            break;\n          }\n          case \"lazy\": {\n            const innerType = (schema as schemas.$ZodLazy)._zod.innerType;\n            this.process(innerType, params);\n            result.ref = innerType;\n            break;\n          }\n          case \"custom\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Custom types cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          default: {\n            def satisfies never;\n          }\n        }\n      }\n    }\n\n    // metadata\n    const meta = this.metadataRegistry.get(schema);\n    if (meta) Object.assign(result.schema, meta);\n\n    if (this.io === \"input\" && isTransforming(schema)) {\n      // examples/defaults only apply to output type of pipe\n      delete result.schema.examples;\n      delete result.schema.default;\n    }\n\n    // set prefault as default\n    if (this.io === \"input\" && result.schema._prefault) result.schema.default ??= result.schema._prefault;\n    delete result.schema._prefault;\n\n    // pulling fresh from this.seen in case it was overwritten\n    const _result = this.seen.get(schema)!;\n\n    return _result.schema;\n  }\n\n  emit(schema: schemas.$ZodType, _params?: EmitParams): JSONSchema.BaseSchema {\n    const params = {\n      cycles: _params?.cycles ?? \"ref\",\n      reused: _params?.reused ?? \"inline\",\n      // unrepresentable: _params?.unrepresentable ?? \"throw\",\n      // uri: _params?.uri ?? ((id) => `${id}`),\n      external: _params?.external ?? undefined,\n    } satisfies EmitParams;\n\n    // iterate over seen map;\n    const root = this.seen.get(schema);\n\n    if (!root) throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n\n    // initialize result with root schema fields\n    // Object.assign(result, seen.cached);\n\n    // returns a ref to the schema\n    // defId will be empty if the ref points to an external schema (or #)\n    const makeURI = (entry: [schemas.$ZodType<unknown, unknown>, Seen]): { ref: string; defId?: string } => {\n      // comparing the seen objects because sometimes\n      // multiple schemas map to the same seen object.\n      // e.g. lazy\n\n      // external is configured\n      const defsSegment = this.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      if (params.external) {\n        const externalId = params.external.registry.get(entry[0])?.id; // ?? \"__shared\";// `__schema${this.counter++}`;\n\n        // check if schema is in the external registry\n        const uriGenerator = params.external.uri ?? ((id) => id);\n        if (externalId) {\n          return { ref: uriGenerator(externalId) };\n        }\n\n        // otherwise, add to __shared\n        const id: string = entry[1].defId ?? (entry[1].schema.id as string) ?? `schema${this.counter++}`;\n        entry[1].defId = id; // set defId so it will be reused if needed\n        return { defId: id, ref: `${uriGenerator(\"__shared\")}#/${defsSegment}/${id}` };\n      }\n\n      if (entry[1] === root) {\n        return { ref: \"#\" };\n      }\n\n      // self-contained schema\n      const uriPrefix = `#`;\n      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;\n      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;\n      return { defId, ref: defUriPrefix + defId };\n    };\n\n    // stored cached version in `def` property\n    // remove all properties, set $ref\n    const extractToDef = (entry: [schemas.$ZodType<unknown, unknown>, Seen]): void => {\n      // if the schema is already a reference, do not extract it\n      if (entry[1].schema.$ref) {\n        return;\n      }\n      const seen = entry[1];\n      const { ref, defId } = makeURI(entry);\n\n      seen.def = { ...seen.schema };\n      // defId won't be set if the schema is a reference to an external schema\n      if (defId) seen.defId = defId;\n      // wipe away all properties except $ref\n      const schema = seen.schema;\n      for (const key in schema) {\n        delete schema[key];\n      }\n      schema.$ref = ref;\n    };\n\n    // throw on cycles\n\n    // break cycles\n    if (params.cycles === \"throw\") {\n      for (const entry of this.seen.entries()) {\n        const seen = entry[1];\n        if (seen.cycle) {\n          throw new Error(\n            \"Cycle detected: \" +\n              `#/${seen.cycle?.join(\"/\")}/<root>` +\n              '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.'\n          );\n        }\n      }\n    }\n\n    // extract schemas into $defs\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n\n      // convert root schema to # $ref\n      if (schema === entry[0]) {\n        extractToDef(entry); // this has special handling for the root schema\n        continue;\n      }\n\n      // extract schemas that are in the external registry\n      if (params.external) {\n        const ext = params.external.registry.get(entry[0])?.id;\n        if (schema !== entry[0] && ext) {\n          extractToDef(entry);\n          continue;\n        }\n      }\n\n      // extract schemas with `id` meta\n      const id = this.metadataRegistry.get(entry[0])?.id;\n      if (id) {\n        extractToDef(entry);\n        continue;\n      }\n\n      // break cycles\n      if (seen.cycle) {\n        // any\n        extractToDef(entry);\n        continue;\n      }\n\n      // extract reused schemas\n      if (seen.count > 1) {\n        if (params.reused === \"ref\") {\n          extractToDef(entry);\n          // biome-ignore lint:\n          continue;\n        }\n      }\n    }\n\n    // flatten _refs\n    const flattenRef = (zodSchema: schemas.$ZodType, params: Pick<ToJSONSchemaParams, \"target\">) => {\n      const seen = this.seen.get(zodSchema)!;\n      const schema = seen.def ?? seen.schema;\n\n      const _cached = { ...schema };\n\n      // already seen\n      if (seen.ref === null) {\n        return;\n      }\n\n      // flatten ref if defined\n      const ref = seen.ref;\n      seen.ref = null; // prevent recursion\n      if (ref) {\n        flattenRef(ref, params);\n\n        // merge referenced schema into current\n        const refSchema = this.seen.get(ref)!.schema;\n        if (refSchema.$ref && params.target === \"draft-7\") {\n          schema.allOf = schema.allOf ?? [];\n          schema.allOf.push(refSchema);\n        } else {\n          Object.assign(schema, refSchema);\n          Object.assign(schema, _cached); // prevent overwriting any fields in the original schema\n        }\n      }\n\n      // execute overrides\n      if (!seen.isParent)\n        this.override({\n          zodSchema: zodSchema as schemas.$ZodTypes,\n          jsonSchema: schema,\n          path: seen.path ?? [],\n        });\n    };\n\n    for (const entry of [...this.seen.entries()].reverse()) {\n      flattenRef(entry[0], { target: this.target });\n    }\n\n    const result: JSONSchema.BaseSchema = {};\n    if (this.target === \"draft-2020-12\") {\n      result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n    } else if (this.target === \"draft-7\") {\n      result.$schema = \"http://json-schema.org/draft-07/schema#\";\n    } else {\n      console.warn(`Invalid target: ${this.target}`);\n    }\n\n    if (params.external?.uri) {\n      const id = params.external.registry.get(schema)?.id;\n      if (!id) throw new Error(\"Schema is missing an `id` property\");\n      result.$id = params.external.uri(id);\n    }\n\n    Object.assign(result, root.def);\n\n    // build defs object\n    const defs: JSONSchema.BaseSchema[\"$defs\"] = params.external?.defs ?? {};\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n      if (seen.def && seen.defId) {\n        defs[seen.defId] = seen.def;\n      }\n    }\n\n    // set definitions in result\n    if (params.external) {\n    } else {\n      if (Object.keys(defs).length > 0) {\n        if (this.target === \"draft-2020-12\") {\n          result.$defs = defs;\n        } else {\n          result.definitions = defs;\n        }\n      }\n    }\n\n    try {\n      // this \"finalizes\" this schema and ensures all cycles are removed\n      // each call to .emit() is functionally independent\n      // though the seen map is shared\n      return JSON.parse(JSON.stringify(result));\n    } catch (_err) {\n      throw new Error(\"Error converting schema to JSON.\");\n    }\n  }\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts:JSONSchemaGenerator.process",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
    "symbol": "JSONSchemaGenerator.process",
    "startLine": 96,
    "endLine": 598,
    "text": "  process(schema: schemas.$ZodType, _params: ProcessParams = { path: [], schemaPath: [] }): JSONSchema.BaseSchema {\n    const def = (schema as schemas.$ZodTypes)._zod.def;\n\n    const formatMap: Partial<Record<checks.$ZodStringFormats, string | undefined>> = {\n      guid: \"uuid\",\n      url: \"uri\",\n      datetime: \"date-time\",\n      json_string: \"json-string\",\n      regex: \"\", // do not set\n    };\n\n    // check for schema in seens\n    const seen = this.seen.get(schema);\n\n    if (seen) {\n      seen.count++;\n\n      // check if cycle\n      const isCycle = _params.schemaPath.includes(schema);\n      if (isCycle) {\n        seen.cycle = _params.path;\n      }\n\n      return seen.schema;\n    }\n\n    // initialize\n    const result: Seen = { schema: {}, count: 1, cycle: undefined, path: _params.path };\n    this.seen.set(schema, result);\n\n    // custom method overrides default behavior\n    const overrideSchema = schema._zod.toJSONSchema?.();\n    if (overrideSchema) {\n      result.schema = overrideSchema as any;\n    } else {\n      const params = {\n        ..._params,\n        schemaPath: [..._params.schemaPath, schema],\n        path: _params.path,\n      };\n\n      const parent = schema._zod.parent;\n\n      if (parent) {\n        // schema was cloned from another schema\n        result.ref = parent;\n        this.process(parent, params);\n        this.seen.get(parent)!.isParent = true;\n      } else {\n        const _json = result.schema;\n        switch (def.type) {\n          case \"string\": {\n            const json: JSONSchema.StringSchema = _json as any;\n            json.type = \"string\";\n            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod\n              .bag as schemas.$ZodStringInternals<unknown>[\"bag\"];\n            if (typeof minimum === \"number\") json.minLength = minimum;\n            if (typeof maximum === \"number\") json.maxLength = maximum;\n            // custom pattern overrides format\n            if (format) {\n              json.format = formatMap[format as checks.$ZodStringFormats] ?? format;\n              if (json.format === \"\") delete json.format; // empty format is not valid\n            }\n            if (contentEncoding) json.contentEncoding = contentEncoding;\n            if (patterns && patterns.size > 0) {\n              const regexes = [...patterns];\n              if (regexes.length === 1) json.pattern = regexes[0]!.source;\n              else if (regexes.length > 1) {\n                result.schema.allOf = [\n                  ...regexes.map((regex) => ({\n                    ...(this.target === \"draft-7\" ? ({ type: \"string\" } as const) : {}),\n                    pattern: regex.source,\n                  })),\n                ];\n              }\n            }\n\n            break;\n          }\n          case \"number\": {\n            const json: JSONSchema.NumberSchema | JSONSchema.IntegerSchema = _json as any;\n            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;\n            if (typeof format === \"string\" && format.includes(\"int\")) json.type = \"integer\";\n            else json.type = \"number\";\n\n            if (typeof exclusiveMinimum === \"number\") json.exclusiveMinimum = exclusiveMinimum;\n            if (typeof minimum === \"number\") {\n              json.minimum = minimum;\n              if (typeof exclusiveMinimum === \"number\") {\n                if (exclusiveMinimum >= minimum) delete json.minimum;\n                else delete json.exclusiveMinimum;\n              }\n            }\n\n            if (typeof exclusiveMaximum === \"number\") json.exclusiveMaximum = exclusiveMaximum;\n            if (typeof maximum === \"number\") {\n              json.maximum = maximum;\n              if (typeof exclusiveMaximum === \"number\") {\n                if (exclusiveMaximum <= maximum) delete json.maximum;\n                else delete json.exclusiveMaximum;\n              }\n            }\n\n            if (typeof multipleOf === \"number\") json.multipleOf = multipleOf;\n\n            break;\n          }\n          case \"boolean\": {\n            const json = _json as JSONSchema.BooleanSchema;\n            json.type = \"boolean\";\n            break;\n          }\n          case \"bigint\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"BigInt cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"symbol\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Symbols cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"null\": {\n            _json.type = \"null\";\n            break;\n          }\n          case \"any\": {\n            break;\n          }\n          case \"unknown\": {\n            break;\n          }\n          case \"undefined\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Undefined cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"void\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Void cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"never\": {\n            _json.not = {};\n            break;\n          }\n          case \"date\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Date cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"array\": {\n            const json: JSONSchema.ArraySchema = _json as any;\n            const { minimum, maximum } = schema._zod.bag;\n            if (typeof minimum === \"number\") json.minItems = minimum;\n            if (typeof maximum === \"number\") json.maxItems = maximum;\n\n            json.type = \"array\";\n            json.items = this.process(def.element, { ...params, path: [...params.path, \"items\"] });\n            break;\n          }\n          case \"object\": {\n            const json: JSONSchema.ObjectSchema = _json as any;\n            json.type = \"object\";\n            json.properties = {};\n            const shape = def.shape; // params.shapeCache.get(schema)!;\n\n            for (const key in shape) {\n              json.properties[key] = this.process(shape[key]!, {\n                ...params,\n                path: [...params.path, \"properties\", key],\n              });\n            }\n\n            // required keys\n            const allKeys = new Set(Object.keys(shape));\n            // const optionalKeys = new Set(def.optional);\n            const requiredKeys = new Set(\n              [...allKeys].filter((key) => {\n                const v = def.shape[key]!._zod;\n                if (this.io === \"input\") {\n                  return v.optin === undefined;\n                } else {\n                  return v.optout === undefined;\n                }\n              })\n            );\n\n            if (requiredKeys.size > 0) {\n              json.required = Array.from(requiredKeys);\n            }\n\n            // catchall\n            if (def.catchall?._zod.def.type === \"never\") {\n              // strict\n              json.additionalProperties = false;\n            } else if (!def.catchall) {\n              // regular\n              if (this.io === \"output\") json.additionalProperties = false;\n            } else if (def.catchall) {\n              json.additionalProperties = this.process(def.catchall, {\n                ...params,\n                path: [...params.path, \"additionalProperties\"],\n              });\n            }\n\n            break;\n          }\n          case \"union\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            json.anyOf = def.options.map((x, i) =>\n              this.process(x, {\n                ...params,\n                path: [...params.path, \"anyOf\", i],\n              })\n            );\n            break;\n          }\n          case \"intersection\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            const a = this.process(def.left, {\n              ...params,\n              path: [...params.path, \"allOf\", 0],\n            });\n            const b = this.process(def.right, {\n              ...params,\n              path: [...params.path, \"allOf\", 1],\n            });\n\n            const isSimpleIntersection = (val: any) => \"allOf\" in val && Object.keys(val).length === 1;\n            const allOf = [\n              ...(isSimpleIntersection(a) ? (a.allOf as any[]) : [a]),\n              ...(isSimpleIntersection(b) ? (b.allOf as any[]) : [b]),\n            ];\n            json.allOf = allOf;\n            break;\n          }\n          case \"tuple\": {\n            const json: JSONSchema.ArraySchema = _json as any;\n            json.type = \"array\";\n            const prefixItems = def.items.map((x, i) =>\n              this.process(x, { ...params, path: [...params.path, \"prefixItems\", i] })\n            );\n            if (this.target === \"draft-2020-12\") {\n              json.prefixItems = prefixItems;\n            } else {\n              json.items = prefixItems;\n            }\n\n            if (def.rest) {\n              const rest = this.process(def.rest, {\n                ...params,\n                path: [...params.path, \"items\"],\n              });\n              if (this.target === \"draft-2020-12\") {\n                json.items = rest;\n              } else {\n                json.additionalItems = rest;\n              }\n            }\n\n            // additionalItems\n            if (def.rest) {\n              json.items = this.process(def.rest, {\n                ...params,\n                path: [...params.path, \"items\"],\n              });\n            }\n\n            // length\n            const { minimum, maximum } = schema._zod.bag as {\n              minimum?: number;\n              maximum?: number;\n            };\n            if (typeof minimum === \"number\") json.minItems = minimum;\n            if (typeof maximum === \"number\") json.maxItems = maximum;\n            break;\n          }\n          case \"record\": {\n            const json: JSONSchema.ObjectSchema = _json as any;\n            json.type = \"object\";\n            json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, \"propertyNames\"] });\n            json.additionalProperties = this.process(def.valueType, {\n              ...params,\n              path: [...params.path, \"additionalProperties\"],\n            });\n            break;\n          }\n          case \"map\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Map cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"set\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Set cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"enum\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            const values = getEnumValues(def.entries);\n            // Number enums can have both string and number values\n            if (values.every((v) => typeof v === \"number\")) json.type = \"number\";\n            if (values.every((v) => typeof v === \"string\")) json.type = \"string\";\n            json.enum = values;\n            break;\n          }\n          case \"literal\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            const vals: (string | number | boolean | null)[] = [];\n            for (const val of def.values) {\n              if (val === undefined) {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                } else {\n                  // do not add to vals\n                }\n              } else if (typeof val === \"bigint\") {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                } else {\n                  vals.push(Number(val));\n                }\n              } else {\n                vals.push(val);\n              }\n            }\n            if (vals.length === 0) {\n              // do nothing (an undefined literal was stripped)\n            } else if (vals.length === 1) {\n              const val = vals[0]!;\n              json.type = val === null ? (\"null\" as const) : (typeof val as any);\n              json.const = val;\n            } else {\n              if (vals.every((v) => typeof v === \"number\")) json.type = \"number\";\n              if (vals.every((v) => typeof v === \"string\")) json.type = \"string\";\n              if (vals.every((v) => typeof v === \"boolean\")) json.type = \"string\";\n              if (vals.every((v) => v === null)) json.type = \"null\";\n              json.enum = vals;\n            }\n            break;\n          }\n\n          case \"file\": {\n            const json: JSONSchema.StringSchema = _json as any;\n            const file: JSONSchema.StringSchema = {\n              type: \"string\",\n              format: \"binary\",\n              contentEncoding: \"binary\",\n            };\n\n            const { minimum, maximum, mime } = schema._zod.bag as schemas.$ZodFileInternals[\"bag\"];\n            if (minimum !== undefined) file.minLength = minimum;\n            if (maximum !== undefined) file.maxLength = maximum;\n            if (mime) {\n              if (mime.length === 1) {\n                file.contentMediaType = mime[0]!;\n                Object.assign(json, file);\n              } else {\n                json.anyOf = mime.map((m) => {\n                  const mFile: JSONSchema.StringSchema = { ...file, contentMediaType: m };\n                  return mFile;\n                });\n              }\n            } else {\n              Object.assign(json, file);\n            }\n\n            // if (this.unrepresentable === \"throw\") {\n            //   throw new Error(\"File cannot be represented in JSON Schema\");\n            // }\n            break;\n          }\n          case \"transform\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Transforms cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n\n          case \"nullable\": {\n            const inner = this.process(def.innerType, params);\n            _json.anyOf = [inner, { type: \"null\" }];\n            break;\n          }\n          case \"nonoptional\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            break;\n          }\n          case \"success\": {\n            const json = _json as JSONSchema.BooleanSchema;\n            json.type = \"boolean\";\n            break;\n          }\n          case \"default\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n            break;\n          }\n          case \"prefault\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            if (this.io === \"input\") _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n\n            break;\n          }\n          case \"catch\": {\n            // use conditionals\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            let catchValue: any;\n            try {\n              catchValue = def.catchValue(undefined as any);\n            } catch {\n              throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n            }\n            _json.default = catchValue;\n            break;\n          }\n          case \"nan\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"NaN cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"template_literal\": {\n            const json = _json as JSONSchema.StringSchema;\n            const pattern = schema._zod.pattern;\n            if (!pattern) throw new Error(\"Pattern not found in template literal\");\n            json.type = \"string\";\n            json.pattern = pattern.source;\n            break;\n          }\n          case \"pipe\": {\n            const innerType = this.io === \"input\" ? (def.in._zod.def.type === \"transform\" ? def.out : def.in) : def.out;\n            this.process(innerType, params);\n            result.ref = innerType;\n            break;\n          }\n          case \"readonly\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            _json.readOnly = true;\n            break;\n          }\n          // passthrough types\n          case \"promise\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            break;\n          }\n          case \"optional\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            break;\n          }\n          case \"lazy\": {\n            const innerType = (schema as schemas.$ZodLazy)._zod.innerType;\n            this.process(innerType, params);\n            result.ref = innerType;\n            break;\n          }\n          case \"custom\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Custom types cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          default: {\n            def satisfies never;\n          }\n        }\n      }\n    }\n\n    // metadata\n    const meta = this.metadataRegistry.get(schema);\n    if (meta) Object.assign(result.schema, meta);\n\n    if (this.io === \"input\" && isTransforming(schema)) {\n      // examples/defaults only apply to output type of pipe\n      delete result.schema.examples;\n      delete result.schema.default;\n    }\n\n    // set prefault as default\n    if (this.io === \"input\" && result.schema._prefault) result.schema.default ??= result.schema._prefault;\n    delete result.schema._prefault;\n\n    // pulling fresh from this.seen in case it was overwritten\n    const _result = this.seen.get(schema)!;\n\n    return _result.schema;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts:JSONSchemaGenerator.emit",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
    "symbol": "JSONSchemaGenerator.emit",
    "startLine": 600,
    "endLine": 820,
    "text": "  emit(schema: schemas.$ZodType, _params?: EmitParams): JSONSchema.BaseSchema {\n    const params = {\n      cycles: _params?.cycles ?? \"ref\",\n      reused: _params?.reused ?? \"inline\",\n      // unrepresentable: _params?.unrepresentable ?? \"throw\",\n      // uri: _params?.uri ?? ((id) => `${id}`),\n      external: _params?.external ?? undefined,\n    } satisfies EmitParams;\n\n    // iterate over seen map;\n    const root = this.seen.get(schema);\n\n    if (!root) throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n\n    // initialize result with root schema fields\n    // Object.assign(result, seen.cached);\n\n    // returns a ref to the schema\n    // defId will be empty if the ref points to an external schema (or #)\n    const makeURI = (entry: [schemas.$ZodType<unknown, unknown>, Seen]): { ref: string; defId?: string } => {\n      // comparing the seen objects because sometimes\n      // multiple schemas map to the same seen object.\n      // e.g. lazy\n\n      // external is configured\n      const defsSegment = this.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      if (params.external) {\n        const externalId = params.external.registry.get(entry[0])?.id; // ?? \"__shared\";// `__schema${this.counter++}`;\n\n        // check if schema is in the external registry\n        const uriGenerator = params.external.uri ?? ((id) => id);\n        if (externalId) {\n          return { ref: uriGenerator(externalId) };\n        }\n\n        // otherwise, add to __shared\n        const id: string = entry[1].defId ?? (entry[1].schema.id as string) ?? `schema${this.counter++}`;\n        entry[1].defId = id; // set defId so it will be reused if needed\n        return { defId: id, ref: `${uriGenerator(\"__shared\")}#/${defsSegment}/${id}` };\n      }\n\n      if (entry[1] === root) {\n        return { ref: \"#\" };\n      }\n\n      // self-contained schema\n      const uriPrefix = `#`;\n      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;\n      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;\n      return { defId, ref: defUriPrefix + defId };\n    };\n\n    // stored cached version in `def` property\n    // remove all properties, set $ref\n    const extractToDef = (entry: [schemas.$ZodType<unknown, unknown>, Seen]): void => {\n      // if the schema is already a reference, do not extract it\n      if (entry[1].schema.$ref) {\n        return;\n      }\n      const seen = entry[1];\n      const { ref, defId } = makeURI(entry);\n\n      seen.def = { ...seen.schema };\n      // defId won't be set if the schema is a reference to an external schema\n      if (defId) seen.defId = defId;\n      // wipe away all properties except $ref\n      const schema = seen.schema;\n      for (const key in schema) {\n        delete schema[key];\n      }\n      schema.$ref = ref;\n    };\n\n    // throw on cycles\n\n    // break cycles\n    if (params.cycles === \"throw\") {\n      for (const entry of this.seen.entries()) {\n        const seen = entry[1];\n        if (seen.cycle) {\n          throw new Error(\n            \"Cycle detected: \" +\n              `#/${seen.cycle?.join(\"/\")}/<root>` +\n              '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.'\n          );\n        }\n      }\n    }\n\n    // extract schemas into $defs\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n\n      // convert root schema to # $ref\n      if (schema === entry[0]) {\n        extractToDef(entry); // this has special handling for the root schema\n        continue;\n      }\n\n      // extract schemas that are in the external registry\n      if (params.external) {\n        const ext = params.external.registry.get(entry[0])?.id;\n        if (schema !== entry[0] && ext) {\n          extractToDef(entry);\n          continue;\n        }\n      }\n\n      // extract schemas with `id` meta\n      const id = this.metadataRegistry.get(entry[0])?.id;\n      if (id) {\n        extractToDef(entry);\n        continue;\n      }\n\n      // break cycles\n      if (seen.cycle) {\n        // any\n        extractToDef(entry);\n        continue;\n      }\n\n      // extract reused schemas\n      if (seen.count > 1) {\n        if (params.reused === \"ref\") {\n          extractToDef(entry);\n          // biome-ignore lint:\n          continue;\n        }\n      }\n    }\n\n    // flatten _refs\n    const flattenRef = (zodSchema: schemas.$ZodType, params: Pick<ToJSONSchemaParams, \"target\">) => {\n      const seen = this.seen.get(zodSchema)!;\n      const schema = seen.def ?? seen.schema;\n\n      const _cached = { ...schema };\n\n      // already seen\n      if (seen.ref === null) {\n        return;\n      }\n\n      // flatten ref if defined\n      const ref = seen.ref;\n      seen.ref = null; // prevent recursion\n      if (ref) {\n        flattenRef(ref, params);\n\n        // merge referenced schema into current\n        const refSchema = this.seen.get(ref)!.schema;\n        if (refSchema.$ref && params.target === \"draft-7\") {\n          schema.allOf = schema.allOf ?? [];\n          schema.allOf.push(refSchema);\n        } else {\n          Object.assign(schema, refSchema);\n          Object.assign(schema, _cached); // prevent overwriting any fields in the original schema\n        }\n      }\n\n      // execute overrides\n      if (!seen.isParent)\n        this.override({\n          zodSchema: zodSchema as schemas.$ZodTypes,\n          jsonSchema: schema,\n          path: seen.path ?? [],\n        });\n    };\n\n    for (const entry of [...this.seen.entries()].reverse()) {\n      flattenRef(entry[0], { target: this.target });\n    }\n\n    const result: JSONSchema.BaseSchema = {};\n    if (this.target === \"draft-2020-12\") {\n      result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n    } else if (this.target === \"draft-7\") {\n      result.$schema = \"http://json-schema.org/draft-07/schema#\";\n    } else {\n      console.warn(`Invalid target: ${this.target}`);\n    }\n\n    if (params.external?.uri) {\n      const id = params.external.registry.get(schema)?.id;\n      if (!id) throw new Error(\"Schema is missing an `id` property\");\n      result.$id = params.external.uri(id);\n    }\n\n    Object.assign(result, root.def);\n\n    // build defs object\n    const defs: JSONSchema.BaseSchema[\"$defs\"] = params.external?.defs ?? {};\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n      if (seen.def && seen.defId) {\n        defs[seen.defId] = seen.def;\n      }\n    }\n\n    // set definitions in result\n    if (params.external) {\n    } else {\n      if (Object.keys(defs).length > 0) {\n        if (this.target === \"draft-2020-12\") {\n          result.$defs = defs;\n        } else {\n          result.definitions = defs;\n        }\n      }\n    }\n\n    try {\n      // this \"finalizes\" this schema and ensures all cycles are removed\n      // each call to .emit() is functionally independent\n      // though the seen map is shared\n      return JSON.parse(JSON.stringify(result));\n    } catch (_err) {\n      throw new Error(\"Error converting schema to JSON.\");\n    }\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts:toJSONSchema",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
    "symbol": "toJSONSchema",
    "startLine": 828,
    "endLine": 828,
    "text": "export function toJSONSchema(schema: schemas.$ZodType, _params?: ToJSONSchemaParams): JSONSchema.BaseSchema;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts:toJSONSchema",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
    "symbol": "toJSONSchema",
    "startLine": 829,
    "endLine": 832,
    "text": "export function toJSONSchema(\n  registry: $ZodRegistry<{ id?: string | undefined }>,\n  _params?: RegistryToJSONSchemaParams\n): { schemas: Record<string, JSONSchema.BaseSchema> };"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts:toJSONSchema",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
    "symbol": "toJSONSchema",
    "startLine": 833,
    "endLine": 873,
    "text": "export function toJSONSchema(\n  input: schemas.$ZodType | $ZodRegistry<{ id?: string | undefined }>,\n  _params?: ToJSONSchemaParams\n): any {\n  if (input instanceof $ZodRegistry) {\n    const gen = new JSONSchemaGenerator(_params);\n    const defs: any = {};\n    for (const entry of input._idmap.entries()) {\n      const [_, schema] = entry;\n      gen.process(schema);\n    }\n\n    const schemas: Record<string, JSONSchema.BaseSchema> = {};\n    const external = {\n      registry: input,\n      uri: (_params as RegistryToJSONSchemaParams)?.uri,\n      defs,\n    };\n    for (const entry of input._idmap.entries()) {\n      const [key, schema] = entry;\n      schemas[key] = gen.emit(schema, {\n        ..._params,\n        external,\n      });\n    }\n\n    if (Object.keys(defs).length > 0) {\n      const defsSegment = gen.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      schemas.__shared = {\n        [defsSegment]: defs,\n      };\n    }\n\n    return { schemas };\n  }\n\n  const gen = new JSONSchemaGenerator(_params);\n  gen.process(input);\n\n  return gen.emit(input, _params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts:isTransforming",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
    "symbol": "isTransforming",
    "startLine": 875,
    "endLine": 977,
    "text": "function isTransforming(\n  _schema: schemas.$ZodType,\n  _ctx?: {\n    seen: Set<schemas.$ZodType>;\n  }\n): boolean {\n  const ctx = _ctx ?? { seen: new Set() };\n\n  if (ctx.seen.has(_schema)) return false;\n  ctx.seen.add(_schema);\n\n  const schema = _schema as schemas.$ZodTypes;\n  const def = schema._zod.def;\n  switch (def.type) {\n    case \"string\":\n    case \"number\":\n    case \"bigint\":\n    case \"boolean\":\n    case \"date\":\n    case \"symbol\":\n    case \"undefined\":\n    case \"null\":\n    case \"any\":\n    case \"unknown\":\n    case \"never\":\n    case \"void\":\n    case \"literal\":\n    case \"enum\":\n    case \"nan\":\n    case \"file\":\n    case \"template_literal\":\n      return false;\n    case \"array\": {\n      return isTransforming(def.element, ctx);\n    }\n    case \"object\": {\n      for (const key in def.shape) {\n        if (isTransforming(def.shape[key]!, ctx)) return true;\n      }\n      return false;\n    }\n    case \"union\": {\n      for (const option of def.options) {\n        if (isTransforming(option, ctx)) return true;\n      }\n      return false;\n    }\n    case \"intersection\": {\n      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n    }\n    case \"tuple\": {\n      for (const item of def.items) {\n        if (isTransforming(item, ctx)) return true;\n      }\n      if (def.rest && isTransforming(def.rest, ctx)) return true;\n      return false;\n    }\n    case \"record\": {\n      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n    }\n    case \"map\": {\n      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n    }\n    case \"set\": {\n      return isTransforming(def.valueType, ctx);\n    }\n\n    // inner types\n    case \"promise\":\n    case \"optional\":\n    case \"nonoptional\":\n    case \"nullable\":\n    case \"readonly\":\n      return isTransforming(def.innerType, ctx);\n    case \"lazy\":\n      return isTransforming(def.getter(), ctx);\n    case \"default\": {\n      return isTransforming(def.innerType, ctx);\n    }\n    case \"prefault\": {\n      return isTransforming(def.innerType, ctx);\n    }\n    case \"custom\": {\n      return false;\n    }\n    case \"transform\": {\n      return true;\n    }\n    case \"pipe\": {\n      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n    }\n    case \"success\": {\n      return false;\n    }\n    case \"catch\": {\n      return false;\n    }\n\n    default:\n      def satisfies never;\n  }\n  throw new Error(`Unknown schema type: ${(def as any).type}`);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:assertEqual",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "assertEqual",
    "startLine": 186,
    "endLine": 188,
    "text": "export function assertEqual<A, B>(val: AssertEqual<A, B>): AssertEqual<A, B> {\n  return val;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:assertNotEqual",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "assertNotEqual",
    "startLine": 190,
    "endLine": 192,
    "text": "export function assertNotEqual<A, B>(val: AssertNotEqual<A, B>): AssertNotEqual<A, B> {\n  return val;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:assertIs",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "assertIs",
    "startLine": 194,
    "endLine": 194,
    "text": "export function assertIs<T>(_arg: T): void {}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:assertNever",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "assertNever",
    "startLine": 196,
    "endLine": 198,
    "text": "export function assertNever(_x: never): never {\n  throw new Error();\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:assert",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "assert",
    "startLine": 199,
    "endLine": 199,
    "text": "export function assert<T>(_: any): asserts _ is T {}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:getEnumValues",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "getEnumValues",
    "startLine": 201,
    "endLine": 207,
    "text": "export function getEnumValues(entries: EnumLike): EnumValue[] {\n  const numericValues = Object.values(entries).filter((v) => typeof v === \"number\");\n  const values = Object.entries(entries)\n    .filter(([k, _]) => numericValues.indexOf(+k) === -1)\n    .map(([_, v]) => v);\n  return values;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:joinValues",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "joinValues",
    "startLine": 209,
    "endLine": 211,
    "text": "export function joinValues<T extends Primitive[]>(array: T, separator = \"|\"): string {\n  return array.map((val) => stringifyPrimitive(val)).join(separator);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:jsonStringifyReplacer",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "jsonStringifyReplacer",
    "startLine": 213,
    "endLine": 216,
    "text": "export function jsonStringifyReplacer(_: string, value: any): any {\n  if (typeof value === \"bigint\") return value.toString();\n  return value;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:cached",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "cached",
    "startLine": 218,
    "endLine": 230,
    "text": "export function cached<T>(getter: () => T): { value: T } {\n  const set = false;\n  return {\n    get value() {\n      if (!set) {\n        const value = getter();\n        Object.defineProperty(this, \"value\", { value });\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    },\n  };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:nullish",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "nullish",
    "startLine": 232,
    "endLine": 234,
    "text": "export function nullish(input: any): boolean {\n  return input === null || input === undefined;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:cleanRegex",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "cleanRegex",
    "startLine": 236,
    "endLine": 240,
    "text": "export function cleanRegex(source: string): string {\n  const start = source.startsWith(\"^\") ? 1 : 0;\n  const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n  return source.slice(start, end);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:floatSafeRemainder",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "floatSafeRemainder",
    "startLine": 242,
    "endLine": 249,
    "text": "export function floatSafeRemainder(val: number, step: number): number {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return (valInt % stepInt) / 10 ** decCount;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:defineLazy",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "defineLazy",
    "startLine": 251,
    "endLine": 271,
    "text": "export function defineLazy<T, K extends keyof T>(object: T, key: K, getter: () => T[K]): void {\n  const set = false;\n  Object.defineProperty(object, key, {\n    get() {\n      if (!set) {\n        const value = getter();\n        object[key] = value;\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    },\n    set(v) {\n      Object.defineProperty(object, key, {\n        value: v,\n        // configurable: true,\n      });\n      // object[key] = v;\n    },\n    configurable: true,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:assignProp",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "assignProp",
    "startLine": 273,
    "endLine": 284,
    "text": "export function assignProp<T extends object, K extends PropertyKey>(\n  target: T,\n  prop: K,\n  value: K extends keyof T ? T[K] : any\n): void {\n  Object.defineProperty(target, prop, {\n    value,\n    writable: true,\n    enumerable: true,\n    configurable: true,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:getElementAtPath",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "getElementAtPath",
    "startLine": 286,
    "endLine": 289,
    "text": "export function getElementAtPath(obj: any, path: (string | number)[] | null | undefined): any {\n  if (!path) return obj;\n  return path.reduce((acc, key) => acc?.[key], obj);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:promiseAllObject",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "promiseAllObject",
    "startLine": 291,
    "endLine": 302,
    "text": "export function promiseAllObject<T extends object>(promisesObj: T): Promise<{ [k in keyof T]: Awaited<T[k]> }> {\n  const keys = Object.keys(promisesObj);\n  const promises = keys.map((key) => (promisesObj as any)[key]);\n\n  return Promise.all(promises).then((results) => {\n    const resolvedObj: any = {};\n    for (let i = 0; i < keys.length; i++) {\n      resolvedObj[keys[i]!] = results[i];\n    }\n    return resolvedObj;\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:randomString",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "randomString",
    "startLine": 304,
    "endLine": 311,
    "text": "export function randomString(length = 10): string {\n  const chars = \"abcdefghijklmnopqrstuvwxyz\";\n  let str = \"\";\n  for (let i = 0; i < length; i++) {\n    str += chars[Math.floor(Math.random() * chars.length)];\n  }\n  return str;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:esc",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "esc",
    "startLine": 313,
    "endLine": 315,
    "text": "export function esc(str: string): string {\n  return JSON.stringify(str);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:isObject",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "isObject",
    "startLine": 321,
    "endLine": 323,
    "text": "export function isObject(data: any): data is Record<PropertyKey, unknown> {\n  return typeof data === \"object\" && data !== null && !Array.isArray(data);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:isPlainObject",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "isPlainObject",
    "startLine": 339,
    "endLine": 356,
    "text": "export function isPlainObject(o: any): o is Record<PropertyKey, unknown> {\n  if (isObject(o) === false) return false;\n\n  // modified constructor\n  const ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // modified prototype\n  const prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // ctor doesn't have static `isPrototypeOf`\n  if (Object.prototype.hasOwnProperty.call(prot, \"isPrototypeOf\") === false) {\n    return false;\n  }\n\n  return true;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:numKeys",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "numKeys",
    "startLine": 358,
    "endLine": 366,
    "text": "export function numKeys(data: any): number {\n  let keyCount = 0;\n  for (const key in data) {\n    if (Object.prototype.hasOwnProperty.call(data, key)) {\n      keyCount++;\n    }\n  }\n  return keyCount;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:escapeRegex",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "escapeRegex",
    "startLine": 424,
    "endLine": 426,
    "text": "export function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:clone",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "clone",
    "startLine": 429,
    "endLine": 433,
    "text": "export function clone<T extends schemas.$ZodType>(inst: T, def?: T[\"_zod\"][\"def\"], params?: { parent: boolean }): T {\n  const cl = new inst._zod.constr(def ?? inst._zod.def);\n  if (!def || params?.parent) cl._zod.parent = inst;\n  return cl as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:normalizeParams",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "normalizeParams",
    "startLine": 453,
    "endLine": 465,
    "text": "export function normalizeParams<T>(_params: T): Normalize<T> {\n  const params: any = _params;\n\n  if (!params) return {} as any;\n  if (typeof params === \"string\") return { error: () => params } as any;\n  if (params?.message !== undefined) {\n    if (params?.error !== undefined) throw new Error(\"Cannot specify both `message` and `error` params\");\n    params.error = params.message;\n  }\n  delete params.message;\n  if (typeof params.error === \"string\") return { ...params, error: () => params.error } as any;\n  return params;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:createTransparentProxy",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "createTransparentProxy",
    "startLine": 467,
    "endLine": 502,
    "text": "export function createTransparentProxy<T extends object>(getter: () => T): T {\n  let target: T;\n  return new Proxy(\n    {},\n    {\n      get(_, prop, receiver) {\n        target ??= getter();\n        return Reflect.get(target, prop, receiver);\n      },\n      set(_, prop, value, receiver) {\n        target ??= getter();\n        return Reflect.set(target, prop, value, receiver);\n      },\n      has(_, prop) {\n        target ??= getter();\n        return Reflect.has(target, prop);\n      },\n      deleteProperty(_, prop) {\n        target ??= getter();\n        return Reflect.deleteProperty(target, prop);\n      },\n      ownKeys(_) {\n        target ??= getter();\n        return Reflect.ownKeys(target);\n      },\n      getOwnPropertyDescriptor(_, prop) {\n        target ??= getter();\n        return Reflect.getOwnPropertyDescriptor(target, prop);\n      },\n      defineProperty(_, prop, descriptor) {\n        target ??= getter();\n        return Reflect.defineProperty(target, prop, descriptor);\n      },\n    }\n  ) as T;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:stringifyPrimitive",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "stringifyPrimitive",
    "startLine": 504,
    "endLine": 508,
    "text": "export function stringifyPrimitive(value: any): string {\n  if (typeof value === \"bigint\") return value.toString() + \"n\";\n  if (typeof value === \"string\") return `\"${value}\"`;\n  return `${value}`;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:optionalKeys",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "optionalKeys",
    "startLine": 510,
    "endLine": 514,
    "text": "export function optionalKeys(shape: schemas.$ZodShape): string[] {\n  return Object.keys(shape).filter((k) => {\n    return shape[k]!._zod.optin === \"optional\" && shape[k]!._zod.optout === \"optional\";\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:pick",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "pick",
    "startLine": 537,
    "endLine": 556,
    "text": "export function pick(schema: schemas.$ZodObject, mask: Record<string, unknown>): any {\n  const newShape: Writeable<schemas.$ZodShape> = {};\n  const currDef = schema._zod.def; //.shape;\n\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!mask[key]) continue;\n\n    // pick key\n    newShape[key] = currDef.shape[key]!;\n  }\n\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: [],\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:omit",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "omit",
    "startLine": 558,
    "endLine": 574,
    "text": "export function omit(schema: schemas.$ZodObject, mask: object): any {\n  const newShape: Writeable<schemas.$ZodShape> = { ...schema._zod.def.shape };\n  const currDef = schema._zod.def; //.shape;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!(mask as any)[key]) continue;\n\n    delete newShape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: [],\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:extend",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "extend",
    "startLine": 576,
    "endLine": 590,
    "text": "export function extend(schema: schemas.$ZodObject, shape: schemas.$ZodShape): any {\n  if (!isPlainObject(shape)) {\n    throw new Error(\"Invalid input to extend: expected a plain object\");\n  }\n  const def = {\n    ...schema._zod.def,\n    get shape() {\n      const _shape = { ...schema._zod.def.shape, ...shape };\n      assignProp(this, \"shape\", _shape); // self-caching\n      return _shape;\n    },\n    checks: [], // delete existing checks\n  } as any;\n  return clone(schema, def) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:merge",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "merge",
    "startLine": 592,
    "endLine": 603,
    "text": "export function merge(a: schemas.$ZodObject, b: schemas.$ZodObject): any {\n  return clone(a, {\n    ...a._zod.def,\n    get shape() {\n      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };\n      assignProp(this, \"shape\", _shape); // self-caching\n      return _shape;\n    },\n    catchall: b._zod.def.catchall,\n    checks: [], // delete existing checks\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:partial",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "partial",
    "startLine": 605,
    "endLine": 644,
    "text": "export function partial(\n  Class: SchemaClass<schemas.$ZodOptional> | null,\n  schema: schemas.$ZodObject,\n  mask: object | undefined\n): any {\n  const oldShape = schema._zod.def.shape;\n  const shape: Writeable<schemas.$ZodShape> = { ...oldShape };\n\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in oldShape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!(mask as any)[key]) continue;\n      // if (oldShape[key]!._zod.optin === \"optional\") continue;\n      shape[key] = Class\n        ? new Class({\n            type: \"optional\",\n            innerType: oldShape[key]!,\n          })\n        : oldShape[key]!;\n    }\n  } else {\n    for (const key in oldShape) {\n      // if (oldShape[key]!._zod.optin === \"optional\") continue;\n      shape[key] = Class\n        ? new Class({\n            type: \"optional\",\n            innerType: oldShape[key]!,\n          })\n        : oldShape[key]!;\n    }\n  }\n\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    checks: [],\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:required",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "required",
    "startLine": 646,
    "endLine": 682,
    "text": "export function required(\n  Class: SchemaClass<schemas.$ZodNonOptional>,\n  schema: schemas.$ZodObject,\n  mask: object | undefined\n): any {\n  const oldShape = schema._zod.def.shape;\n  const shape: Writeable<schemas.$ZodShape> = { ...oldShape };\n\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in shape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!(mask as any)[key]) continue;\n      // overwrite with non-optional\n      shape[key] = new Class({\n        type: \"nonoptional\",\n        innerType: oldShape[key]!,\n      });\n    }\n  } else {\n    for (const key in oldShape) {\n      // overwrite with non-optional\n      shape[key] = new Class({\n        type: \"nonoptional\",\n        innerType: oldShape[key]!,\n      });\n    }\n  }\n\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    // optional: [],\n    checks: [],\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:aborted",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "aborted",
    "startLine": 686,
    "endLine": 691,
    "text": "export function aborted(x: schemas.ParsePayload, startIndex = 0): boolean {\n  for (let i = startIndex; i < x.issues.length; i++) {\n    if (x.issues[i]?.continue !== true) return true;\n  }\n  return false;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:prefixIssues",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "prefixIssues",
    "startLine": 693,
    "endLine": 699,
    "text": "export function prefixIssues(path: PropertyKey, issues: errors.$ZodRawIssue[]): errors.$ZodRawIssue[] {\n  return issues.map((iss) => {\n    (iss as any).path ??= [];\n    (iss as any).path.unshift(path);\n    return iss;\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:unwrapMessage",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "unwrapMessage",
    "startLine": 701,
    "endLine": 703,
    "text": "export function unwrapMessage(message: string | { message: string } | undefined | null): string | undefined {\n  return typeof message === \"string\" ? message : message?.message;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:finalizeIssue",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "finalizeIssue",
    "startLine": 705,
    "endLine": 731,
    "text": "export function finalizeIssue(\n  iss: errors.$ZodRawIssue,\n  ctx: schemas.ParseContextInternal | undefined,\n  config: $ZodConfig\n): errors.$ZodIssue {\n  const full = { ...iss, path: iss.path ?? [] } as errors.$ZodIssue;\n\n  // for backwards compatibility\n  if (!iss.message) {\n    const message =\n      unwrapMessage(iss.inst?._zod.def?.error?.(iss as never)) ??\n      unwrapMessage(ctx?.error?.(iss as never)) ??\n      unwrapMessage(config.customError?.(iss)) ??\n      unwrapMessage(config.localeError?.(iss)) ??\n      \"Invalid input\";\n    (full as any).message = message;\n  }\n\n  // delete (full as any).def;\n  delete (full as any).inst;\n  delete (full as any).continue;\n  if (!ctx?.reportInput) {\n    delete (full as any).input;\n  }\n\n  return full;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:getSizableOrigin",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "getSizableOrigin",
    "startLine": 733,
    "endLine": 738,
    "text": "export function getSizableOrigin(input: any): \"set\" | \"map\" | \"file\" | \"unknown\" {\n  if (input instanceof Set) return \"set\";\n  if (input instanceof Map) return \"map\";\n  if (input instanceof File) return \"file\";\n  return \"unknown\";\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:getLengthableOrigin",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "getLengthableOrigin",
    "startLine": 740,
    "endLine": 744,
    "text": "export function getLengthableOrigin(input: any): \"array\" | \"string\" | \"unknown\" {\n  if (Array.isArray(input)) return \"array\";\n  if (typeof input === \"string\") return \"string\";\n  return \"unknown\";\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:issue",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "issue",
    "startLine": 747,
    "endLine": 747,
    "text": "export function issue(_iss: string, input: any, inst: any): errors.$ZodRawIssue;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:issue",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "issue",
    "startLine": 748,
    "endLine": 748,
    "text": "export function issue(_iss: errors.$ZodRawIssue): errors.$ZodRawIssue;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:issue",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "issue",
    "startLine": 749,
    "endLine": 761,
    "text": "export function issue(...args: [string | errors.$ZodRawIssue, any?, any?]): errors.$ZodRawIssue {\n  const [iss, input, inst] = args;\n  if (typeof iss === \"string\") {\n    return {\n      message: iss,\n      code: \"custom\",\n      input,\n      inst,\n    };\n  }\n\n  return { ...iss };\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:cleanEnum",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "cleanEnum",
    "startLine": 763,
    "endLine": 770,
    "text": "export function cleanEnum(obj: Record<string, EnumValue>): EnumValue[] {\n  return Object.entries(obj)\n    .filter(([k, _]) => {\n      // return true if NaN, meaning it's not a number, thus a string key\n      return Number.isNaN(Number.parseInt(k, 10));\n    })\n    .map((el) => el[1]);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts:Class",
    "file": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "symbol": "Class",
    "startLine": 773,
    "endLine": 775,
    "text": "export abstract class Class {\n  constructor(..._args: any[]) {}\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ar.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/ar.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/az.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/az.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/be.ts:getBelarusianPlural",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/be.ts",
    "symbol": "getBelarusianPlural",
    "startLine": 5,
    "endLine": 23,
    "text": "function getBelarusianPlural(count: number, one: string, few: string, many: string): string {\n  const absCount = Math.abs(count);\n  const lastDigit = absCount % 10;\n  const lastTwoDigits = absCount % 100;\n\n  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n    return many;\n  }\n\n  if (lastDigit === 1) {\n    return one;\n  }\n\n  if (lastDigit >= 2 && lastDigit <= 4) {\n    return few;\n  }\n\n  return many;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/be.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/be.ts",
    "symbol": "getSizing",
    "startLine": 69,
    "endLine": 71,
    "text": "  function getSizing(origin: string): BelarusianSizable | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ca.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/ca.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/cs.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/cs.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/de.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/de.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/en.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/en.ts",
    "symbol": "getSizing",
    "startLine": 36,
    "endLine": 38,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/eo.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/eo.ts",
    "symbol": "getSizing",
    "startLine": 36,
    "endLine": 38,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/es.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/es.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/fa.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/fa.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/fi.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/fi.ts",
    "symbol": "getSizing",
    "startLine": 17,
    "endLine": 19,
    "text": "  function getSizing(origin: string): { unit: string; subject: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/fr-CA.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/fr-CA.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/fr.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/fr.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/he.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/he.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/hu.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/hu.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/id.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/id.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/it.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/it.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ja.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/ja.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/kh.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/kh.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ko.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/ko.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/mk.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/mk.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ms.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/ms.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/nl.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/nl.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/no.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/no.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ota.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/ota.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/pl.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/pl.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ps.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/ps.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/pt.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/pt.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ru.ts:getRussianPlural",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/ru.ts",
    "symbol": "getRussianPlural",
    "startLine": 5,
    "endLine": 23,
    "text": "function getRussianPlural(count: number, one: string, few: string, many: string): string {\n  const absCount = Math.abs(count);\n  const lastDigit = absCount % 10;\n  const lastTwoDigits = absCount % 100;\n\n  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n    return many;\n  }\n\n  if (lastDigit === 1) {\n    return one;\n  }\n\n  if (lastDigit >= 2 && lastDigit <= 4) {\n    return few;\n  }\n\n  return many;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ru.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/ru.ts",
    "symbol": "getSizing",
    "startLine": 69,
    "endLine": 71,
    "text": "  function getSizing(origin: string): RussianSizable | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/sl.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/sl.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/sv.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/sv.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ta.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/ta.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/th.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/th.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/tr.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/tr.ts",
    "symbol": "getSizing",
    "startLine": 36,
    "endLine": 38,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ua.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/ua.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ur.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/ur.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/vi.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/vi.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/zh-CN.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/zh-CN.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/zh-TW.ts:getSizing",
    "file": "mcp-rag-server/node_modules/zod/src/v4/locales/zh-TW.ts",
    "symbol": "getSizing",
    "startLine": 13,
    "endLine": 15,
    "text": "  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts:string",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts",
    "symbol": "string",
    "startLine": 4,
    "endLine": 6,
    "text": "export function string<T = unknown>(params?: string | core.$ZodStringParams): schemas.ZodMiniString<T> {\n  return core._coercedString(schemas.ZodMiniString, params) as schemas.ZodMiniString<T>;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts:number",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts",
    "symbol": "number",
    "startLine": 8,
    "endLine": 10,
    "text": "export function number<T = unknown>(params?: string | core.$ZodNumberParams): schemas.ZodMiniNumber<T> {\n  return core._coercedNumber(schemas.ZodMiniNumber, params) as schemas.ZodMiniNumber<T>;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts:boolean",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts",
    "symbol": "boolean",
    "startLine": 12,
    "endLine": 14,
    "text": "export function boolean<T = unknown>(params?: string | core.$ZodBooleanParams): schemas.ZodMiniBoolean<T> {\n  return core._coercedBoolean(schemas.ZodMiniBoolean, params) as schemas.ZodMiniBoolean<T>;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts:bigint",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts",
    "symbol": "bigint",
    "startLine": 16,
    "endLine": 18,
    "text": "export function bigint<T = unknown>(params?: string | core.$ZodBigIntParams): schemas.ZodMiniBigInt<T> {\n  return core._coercedBigint(schemas.ZodMiniBigInt, params) as schemas.ZodMiniBigInt<T>;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts:date",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts",
    "symbol": "date",
    "startLine": 20,
    "endLine": 22,
    "text": "export function date<T = unknown>(params?: string | core.$ZodDateParams): schemas.ZodMiniDate<T> {\n  return core._coercedDate(schemas.ZodMiniDate, params) as schemas.ZodMiniDate<T>;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/iso.ts:datetime",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/iso.ts",
    "symbol": "datetime",
    "startLine": 15,
    "endLine": 17,
    "text": "export function datetime(params?: string | core.$ZodISODateTimeParams): ZodMiniISODateTime {\n  return core._isoDateTime(ZodMiniISODateTime, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/iso.ts:date",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/iso.ts",
    "symbol": "date",
    "startLine": 30,
    "endLine": 32,
    "text": "export function date(params?: string | core.$ZodISODateParams): ZodMiniISODate {\n  return core._isoDate(ZodMiniISODate, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/iso.ts:time",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/iso.ts",
    "symbol": "time",
    "startLine": 45,
    "endLine": 47,
    "text": "export function time(params?: string | core.$ZodISOTimeParams): ZodMiniISOTime {\n  return core._isoTime(ZodMiniISOTime, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/iso.ts:duration",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/iso.ts",
    "symbol": "duration",
    "startLine": 60,
    "endLine": 62,
    "text": "export function duration(params?: string | core.$ZodISODurationParams): ZodMiniISODuration {\n  return core._isoDuration(ZodMiniISODuration, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:string",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "string",
    "startLine": 92,
    "endLine": 94,
    "text": "export function string(params?: string | core.$ZodStringParams): ZodMiniString<string> {\n  return core._string(ZodMiniString, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:email",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "email",
    "startLine": 120,
    "endLine": 122,
    "text": "export function email(params?: string | core.$ZodEmailParams): ZodMiniEmail {\n  return core._email(ZodMiniEmail, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:guid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "guid",
    "startLine": 136,
    "endLine": 138,
    "text": "export function guid(params?: string | core.$ZodGUIDParams): ZodMiniGUID {\n  return core._guid(ZodMiniGUID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:uuid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "uuid",
    "startLine": 152,
    "endLine": 154,
    "text": "export function uuid(params?: string | core.$ZodUUIDParams): ZodMiniUUID {\n  return core._uuid(ZodMiniUUID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:uuidv4",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "uuidv4",
    "startLine": 156,
    "endLine": 158,
    "text": "export function uuidv4(params?: string | core.$ZodUUIDv4Params): ZodMiniUUID {\n  return core._uuidv4(ZodMiniUUID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:uuidv6",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "uuidv6",
    "startLine": 162,
    "endLine": 164,
    "text": "export function uuidv6(params?: string | core.$ZodUUIDv6Params): ZodMiniUUID {\n  return core._uuidv6(ZodMiniUUID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:uuidv7",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "uuidv7",
    "startLine": 168,
    "endLine": 170,
    "text": "export function uuidv7(params?: string | core.$ZodUUIDv7Params): ZodMiniUUID {\n  return core._uuidv7(ZodMiniUUID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:url",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "url",
    "startLine": 181,
    "endLine": 183,
    "text": "export function url(params?: string | core.$ZodURLParams): ZodMiniURL {\n  return core._url(ZodMiniURL, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:emoji",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "emoji",
    "startLine": 197,
    "endLine": 199,
    "text": "export function emoji(params?: string | core.$ZodEmojiParams): ZodMiniEmoji {\n  return core._emoji(ZodMiniEmoji, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:nanoid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "nanoid",
    "startLine": 213,
    "endLine": 215,
    "text": "export function nanoid(params?: string | core.$ZodNanoIDParams): ZodMiniNanoID {\n  return core._nanoid(ZodMiniNanoID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:cuid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "cuid",
    "startLine": 229,
    "endLine": 231,
    "text": "export function cuid(params?: string | core.$ZodCUIDParams): ZodMiniCUID {\n  return core._cuid(ZodMiniCUID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:cuid2",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "cuid2",
    "startLine": 245,
    "endLine": 247,
    "text": "export function cuid2(params?: string | core.$ZodCUID2Params): ZodMiniCUID2 {\n  return core._cuid2(ZodMiniCUID2, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:ulid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "ulid",
    "startLine": 261,
    "endLine": 263,
    "text": "export function ulid(params?: string | core.$ZodULIDParams): ZodMiniULID {\n  return core._ulid(ZodMiniULID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:xid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "xid",
    "startLine": 274,
    "endLine": 276,
    "text": "export function xid(params?: string | core.$ZodXIDParams): ZodMiniXID {\n  return core._xid(ZodMiniXID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:ksuid",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "ksuid",
    "startLine": 290,
    "endLine": 292,
    "text": "export function ksuid(params?: string | core.$ZodKSUIDParams): ZodMiniKSUID {\n  return core._ksuid(ZodMiniKSUID, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:ipv4",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "ipv4",
    "startLine": 306,
    "endLine": 308,
    "text": "export function ipv4(params?: string | core.$ZodIPv4Params): ZodMiniIPv4 {\n  return core._ipv4(ZodMiniIPv4, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:ipv6",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "ipv6",
    "startLine": 322,
    "endLine": 324,
    "text": "export function ipv6(params?: string | core.$ZodIPv6Params): ZodMiniIPv6 {\n  return core._ipv6(ZodMiniIPv6, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:cidrv4",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "cidrv4",
    "startLine": 338,
    "endLine": 340,
    "text": "export function cidrv4(params?: string | core.$ZodCIDRv4Params): ZodMiniCIDRv4 {\n  return core._cidrv4(ZodMiniCIDRv4, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:cidrv6",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "cidrv6",
    "startLine": 354,
    "endLine": 356,
    "text": "export function cidrv6(params?: string | core.$ZodCIDRv6Params): ZodMiniCIDRv6 {\n  return core._cidrv6(ZodMiniCIDRv6, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:base64",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "base64",
    "startLine": 369,
    "endLine": 371,
    "text": "export function base64(params?: string | core.$ZodBase64Params): ZodMiniBase64 {\n  return core._base64(ZodMiniBase64, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:base64url",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "base64url",
    "startLine": 384,
    "endLine": 386,
    "text": "export function base64url(params?: string | core.$ZodBase64URLParams): ZodMiniBase64URL {\n  return core._base64url(ZodMiniBase64URL, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:e164",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "e164",
    "startLine": 400,
    "endLine": 402,
    "text": "export function e164(params?: string | core.$ZodE164Params): ZodMiniE164 {\n  return core._e164(ZodMiniE164, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:jwt",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "jwt",
    "startLine": 413,
    "endLine": 415,
    "text": "export function jwt(params?: string | core.$ZodJWTParams): ZodMiniJWT {\n  return core._jwt(ZodMiniJWT, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:stringFormat",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "stringFormat",
    "startLine": 431,
    "endLine": 437,
    "text": "export function stringFormat<Format extends string>(\n  format: Format,\n  fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp,\n  _params: string | core.$ZodStringFormatParams = {}\n): ZodMiniCustomStringFormat<Format> {\n  return core._stringFormat(ZodMiniCustomStringFormat, format, fnOrRegex, _params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:number",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "number",
    "startLine": 456,
    "endLine": 458,
    "text": "export function number(params?: string | core.$ZodNumberParams): ZodMiniNumber<number> {\n  return core._number(ZodMiniNumber, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:int",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "int",
    "startLine": 472,
    "endLine": 474,
    "text": "export function int(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat {\n  return core._int(ZodMiniNumberFormat, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:float32",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "float32",
    "startLine": 478,
    "endLine": 480,
    "text": "export function float32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat {\n  return core._float32(ZodMiniNumberFormat, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:float64",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "float64",
    "startLine": 484,
    "endLine": 486,
    "text": "export function float64(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat {\n  return core._float64(ZodMiniNumberFormat, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:int32",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "int32",
    "startLine": 490,
    "endLine": 492,
    "text": "export function int32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat {\n  return core._int32(ZodMiniNumberFormat, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:uint32",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "uint32",
    "startLine": 496,
    "endLine": 498,
    "text": "export function uint32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat {\n  return core._uint32(ZodMiniNumberFormat, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:boolean",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "boolean",
    "startLine": 512,
    "endLine": 514,
    "text": "export function boolean(params?: string | core.$ZodBooleanParams): ZodMiniBoolean<boolean> {\n  return core._boolean(ZodMiniBoolean, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:bigint",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "bigint",
    "startLine": 528,
    "endLine": 530,
    "text": "export function bigint(params?: string | core.$ZodBigIntParams): ZodMiniBigInt<bigint> {\n  return core._bigint(ZodMiniBigInt, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:int64",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "int64",
    "startLine": 548,
    "endLine": 550,
    "text": "export function int64(params?: string | core.$ZodBigIntFormatParams): ZodMiniBigIntFormat {\n  return core._int64(ZodMiniBigIntFormat, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:uint64",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "uint64",
    "startLine": 554,
    "endLine": 556,
    "text": "export function uint64(params?: string | core.$ZodBigIntFormatParams): ZodMiniBigIntFormat {\n  return core._uint64(ZodMiniBigIntFormat, params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:symbol",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "symbol",
    "startLine": 570,
    "endLine": 572,
    "text": "export function symbol(params?: string | core.$ZodSymbolParams): ZodMiniSymbol {\n  return core._symbol(ZodMiniSymbol, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:_undefined",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "_undefined",
    "startLine": 586,
    "endLine": 588,
    "text": "function _undefined(params?: string | core.$ZodUndefinedParams): ZodMiniUndefined {\n  return core._undefined(ZodMiniUndefined, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:_null",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "_null",
    "startLine": 603,
    "endLine": 605,
    "text": "function _null(params?: string | core.$ZodNullParams): ZodMiniNull {\n  return core._null(ZodMiniNull, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:any",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "any",
    "startLine": 617,
    "endLine": 619,
    "text": "export function any(): ZodMiniAny {\n  return core._any(ZodMiniAny) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:unknown",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "unknown",
    "startLine": 633,
    "endLine": 635,
    "text": "export function unknown(): ZodMiniUnknown {\n  return core._unknown(ZodMiniUnknown) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:never",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "never",
    "startLine": 649,
    "endLine": 651,
    "text": "export function never(params?: string | core.$ZodNeverParams): ZodMiniNever {\n  return core._never(ZodMiniNever, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:_void",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "_void",
    "startLine": 665,
    "endLine": 667,
    "text": "function _void(params?: string | core.$ZodVoidParams): ZodMiniVoid {\n  return core._void(ZodMiniVoid, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:date",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "date",
    "startLine": 683,
    "endLine": 685,
    "text": "export function date(params?: string | core.$ZodDateParams): ZodMiniDate<Date> {\n  return core._date(ZodMiniDate, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:array",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "array",
    "startLine": 701,
    "endLine": 701,
    "text": "export function array<T extends SomeType>(element: T, params?: string | core.$ZodArrayParams): ZodMiniArray<T>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:array",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "array",
    "startLine": 702,
    "endLine": 708,
    "text": "export function array<T extends SomeType>(element: SomeType, params?: any): ZodMiniArray<T> {\n  return new ZodMiniArray({\n    type: \"array\",\n    element: element as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:keyof",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "keyof",
    "startLine": 711,
    "endLine": 714,
    "text": "export function keyof<T extends ZodMiniObject>(schema: T): ZodMiniLiteral<Exclude<keyof T[\"shape\"], symbol>> {\n  const shape = schema._zod.def.shape;\n  return literal(Object.keys(shape)) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:object",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "object",
    "startLine": 733,
    "endLine": 746,
    "text": "export function object<T extends core.$ZodLooseShape = Record<never, SomeType>>(\n  shape?: T,\n  params?: string | core.$ZodObjectParams\n): ZodMiniObject<T, core.$strip> {\n  const def: core.$ZodObjectDef = {\n    type: \"object\",\n    get shape() {\n      util.assignProp(this, \"shape\", { ...shape });\n      return this.shape;\n    },\n    ...util.normalizeParams(params),\n  };\n  return new ZodMiniObject(def) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:strictObject",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "strictObject",
    "startLine": 749,
    "endLine": 763,
    "text": "export function strictObject<T extends core.$ZodLooseShape>(\n  shape: T,\n  params?: string | core.$ZodObjectParams\n): ZodMiniObject<T, core.$strict> {\n  return new ZodMiniObject({\n    type: \"object\",\n    // shape: shape as core.$ZodLooseShape,\n    get shape() {\n      util.assignProp(this, \"shape\", { ...shape });\n      return this.shape;\n    },\n    catchall: never(),\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:looseObject",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "looseObject",
    "startLine": 766,
    "endLine": 783,
    "text": "export function looseObject<T extends core.$ZodLooseShape>(\n  shape: T,\n  params?: string | core.$ZodObjectParams\n): ZodMiniObject<T, core.$loose> {\n  return new ZodMiniObject({\n    type: \"object\",\n    // shape: shape as core.$ZodLooseShape,\n    get shape() {\n      util.assignProp(this, \"shape\", { ...shape });\n      return this.shape;\n    },\n    // get optional() {\n    //   return util.optionalKeys(shape);\n    // },\n    catchall: unknown(),\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:extend",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "extend",
    "startLine": 786,
    "endLine": 791,
    "text": "export function extend<T extends ZodMiniObject, U extends core.$ZodLooseShape>(\n  schema: T,\n  shape: U\n): ZodMiniObject<util.Extend<T[\"shape\"], U>, T[\"_zod\"][\"config\"]> {\n  return util.extend(schema, shape);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:merge",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "merge",
    "startLine": 794,
    "endLine": 797,
    "text": "export function merge<T extends ZodMiniObject, U extends ZodMiniObject>(\n  a: T,\n  b: U\n): ZodMiniObject<util.Extend<T[\"shape\"], U[\"shape\"]>, T[\"_zod\"][\"config\"]>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:merge",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "merge",
    "startLine": 798,
    "endLine": 800,
    "text": "export function merge(schema: ZodMiniObject, shape: any): ZodMiniObject {\n  return util.extend(schema, shape);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:pick",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "pick",
    "startLine": 802,
    "endLine": 807,
    "text": "export function pick<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(\n  schema: T,\n  mask: M\n): ZodMiniObject<util.Flatten<Pick<T[\"shape\"], keyof T[\"shape\"] & keyof M>>, T[\"_zod\"][\"config\"]> {\n  return util.pick(schema, mask as any);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:omit",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "omit",
    "startLine": 811,
    "endLine": 816,
    "text": "export function omit<T extends ZodMiniObject, const M extends util.Mask<keyof T[\"shape\"]>>(\n  schema: T,\n  mask: M\n): ZodMiniObject<util.Flatten<Omit<T[\"shape\"], keyof M>>, T[\"_zod\"][\"config\"]> {\n  return util.omit(schema, mask);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:partial",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "partial",
    "startLine": 818,
    "endLine": 825,
    "text": "export function partial<T extends ZodMiniObject>(\n  schema: T\n): ZodMiniObject<\n  {\n    [k in keyof T[\"shape\"]]: ZodMiniOptional<T[\"shape\"][k]>;\n  },\n  T[\"_zod\"][\"config\"]\n>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:partial",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "partial",
    "startLine": 826,
    "endLine": 834,
    "text": "export function partial<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(\n  schema: T,\n  mask: M\n): ZodMiniObject<\n  {\n    [k in keyof T[\"shape\"]]: k extends keyof M ? ZodMiniOptional<T[\"shape\"][k]> : T[\"shape\"][k];\n  },\n  T[\"_zod\"][\"config\"]\n>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:partial",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "partial",
    "startLine": 835,
    "endLine": 837,
    "text": "export function partial(schema: ZodMiniObject, mask?: object) {\n  return util.partial(ZodMiniOptional, schema, mask);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:required",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "required",
    "startLine": 850,
    "endLine": 857,
    "text": "export function required<T extends ZodMiniObject>(\n  schema: T\n): ZodMiniObject<\n  {\n    [k in keyof T[\"shape\"]]: ZodMiniNonOptional<T[\"shape\"][k]>;\n  },\n  T[\"_zod\"][\"config\"]\n>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:required",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "required",
    "startLine": 858,
    "endLine": 869,
    "text": "export function required<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(\n  schema: T,\n  mask: M\n): ZodMiniObject<\n  util.Extend<\n    T[\"shape\"],\n    {\n      [k in keyof M & keyof T[\"shape\"]]: ZodMiniNonOptional<T[\"shape\"][k]>;\n    }\n  >,\n  T[\"_zod\"][\"config\"]\n>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:required",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "required",
    "startLine": 870,
    "endLine": 872,
    "text": "export function required(schema: ZodMiniObject, mask?: object) {\n  return util.required(ZodMiniNonOptional, schema, mask);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:catchall",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "catchall",
    "startLine": 874,
    "endLine": 879,
    "text": "export function catchall<T extends ZodMiniObject, U extends SomeType>(\n  inst: T,\n  catchall: U\n): ZodMiniObject<T[\"shape\"], core.$catchall<U>> {\n  return inst.clone({ ...inst._zod.def, catchall: catchall as any }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:union",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "union",
    "startLine": 894,
    "endLine": 903,
    "text": "export function union<const T extends readonly SomeType[]>(\n  options: T,\n  params?: string | core.$ZodUnionParams\n): ZodMiniUnion<T> {\n  return new ZodMiniUnion({\n    type: \"union\",\n    options: options as any as core.$ZodType[],\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:discriminatedUnion",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "discriminatedUnion",
    "startLine": 918,
    "endLine": 931,
    "text": "export function discriminatedUnion<\n  Types extends readonly [core.$ZodTypeDiscriminable, ...core.$ZodTypeDiscriminable[]],\n>(\n  discriminator: string,\n  options: Types,\n  params?: string | core.$ZodDiscriminatedUnionParams\n): ZodMiniDiscriminatedUnion<Types> {\n  return new ZodMiniDiscriminatedUnion({\n    type: \"union\",\n    options,\n    discriminator,\n    ...util.normalizeParams(params),\n  }) as ZodMiniDiscriminatedUnion<Types>;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:intersection",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "intersection",
    "startLine": 946,
    "endLine": 952,
    "text": "export function intersection<T extends SomeType, U extends SomeType>(left: T, right: U): ZodMiniIntersection<T, U> {\n  return new ZodMiniIntersection({\n    type: \"intersection\",\n    left: left as any as core.$ZodType,\n    right: right as any as core.$ZodType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:tuple",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "tuple",
    "startLine": 969,
    "endLine": 972,
    "text": "export function tuple<const T extends readonly [SomeType, ...SomeType[]]>(\n  items: T,\n  params?: string | core.$ZodTupleParams\n): ZodMiniTuple<T, null>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:tuple",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "tuple",
    "startLine": 973,
    "endLine": 977,
    "text": "export function tuple<const T extends readonly [SomeType, ...SomeType[]], Rest extends SomeType>(\n  items: T,\n  rest: Rest,\n  params?: string | core.$ZodTupleParams\n): ZodMiniTuple<T, Rest>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:tuple",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "tuple",
    "startLine": 978,
    "endLine": 978,
    "text": "export function tuple(items: [], params?: string | core.$ZodTupleParams): ZodMiniTuple<[], null>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:tuple",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "tuple",
    "startLine": 979,
    "endLine": 993,
    "text": "export function tuple(\n  items: SomeType[],\n  _paramsOrRest?: string | core.$ZodTupleParams | SomeType,\n  _params?: string | core.$ZodTupleParams\n) {\n  const hasRest = _paramsOrRest instanceof core.$ZodType;\n  const params = hasRest ? _params : _paramsOrRest;\n  const rest = hasRest ? _paramsOrRest : null;\n  return new ZodMiniTuple({\n    type: \"tuple\",\n    items: items as any as core.$ZodType[],\n    rest,\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:record",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "record",
    "startLine": 1010,
    "endLine": 1021,
    "text": "export function record<Key extends core.$ZodRecordKey, Value extends SomeType>(\n  keyType: Key,\n  valueType: Value,\n  params?: string | core.$ZodRecordParams\n): ZodMiniRecord<Key, Value> {\n  return new ZodMiniRecord({\n    type: \"record\",\n    keyType,\n    valueType: valueType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:partialRecord",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "partialRecord",
    "startLine": 1022,
    "endLine": 1033,
    "text": "export function partialRecord<Key extends core.$ZodRecordKey, Value extends SomeType>(\n  keyType: Key,\n  valueType: Value,\n  params?: string | core.$ZodRecordParams\n): ZodMiniRecord<Key & core.$partial, Value> {\n  return new ZodMiniRecord({\n    type: \"record\",\n    keyType: union([keyType, never()]),\n    valueType: valueType as any,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:map",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "map",
    "startLine": 1045,
    "endLine": 1056,
    "text": "export function map<Key extends SomeType, Value extends SomeType>(\n  keyType: Key,\n  valueType: Value,\n  params?: string | core.$ZodMapParams\n): ZodMiniMap<Key, Value> {\n  return new ZodMiniMap({\n    type: \"map\",\n    keyType: keyType as any as core.$ZodType,\n    valueType: valueType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:set",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "set",
    "startLine": 1067,
    "endLine": 1073,
    "text": "export function set<Value extends SomeType>(valueType: Value, params?: string | core.$ZodSetParams): ZodMiniSet<Value> {\n  return new ZodMiniSet({\n    type: \"set\",\n    valueType: valueType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:_enum",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "_enum",
    "startLine": 1087,
    "endLine": 1090,
    "text": "function _enum<const T extends readonly string[]>(\n  values: T,\n  params?: string | core.$ZodEnumParams\n): ZodMiniEnum<util.ToEnum<T[number]>>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:_enum",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "_enum",
    "startLine": 1091,
    "endLine": 1091,
    "text": "function _enum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodMiniEnum<T>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:_enum",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "_enum",
    "startLine": 1092,
    "endLine": 1100,
    "text": "function _enum(values: any, params?: string | core.$ZodEnumParams) {\n  const entries: any = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n\n  return new ZodMiniEnum({\n    type: \"enum\",\n    entries,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:nativeEnum",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "nativeEnum",
    "startLine": 1110,
    "endLine": 1116,
    "text": "export function nativeEnum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodMiniEnum<T> {\n  return new ZodMiniEnum({\n    type: \"enum\",\n    entries,\n    ...util.normalizeParams(params),\n  }) as any as ZodMiniEnum<T>;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:literal",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "literal",
    "startLine": 1131,
    "endLine": 1134,
    "text": "export function literal<const T extends ReadonlyArray<util.Literal>>(\n  value: T,\n  params?: string | core.$ZodLiteralParams\n): ZodMiniLiteral<T[number]>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:literal",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "literal",
    "startLine": 1135,
    "endLine": 1138,
    "text": "export function literal<const T extends util.Literal>(\n  value: T,\n  params?: string | core.$ZodLiteralParams\n): ZodMiniLiteral<T>;"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:literal",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "literal",
    "startLine": 1139,
    "endLine": 1145,
    "text": "export function literal(value: any, params: any) {\n  return new ZodMiniLiteral({\n    type: \"literal\",\n    values: Array.isArray(value) ? value : [value],\n    ...util.normalizeParams(params),\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:file",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "file",
    "startLine": 1159,
    "endLine": 1161,
    "text": "export function file(params?: string | core.$ZodFileParams): ZodMiniFile {\n  return core._file(ZodMiniFile, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:transform",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "transform",
    "startLine": 1175,
    "endLine": 1182,
    "text": "export function transform<I = unknown, O = I>(\n  fn: (input: I, ctx: core.ParsePayload) => O\n): ZodMiniTransform<Awaited<O>, I> {\n  return new ZodMiniTransform({\n    type: \"transform\",\n    transform: fn as any,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:optional",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "optional",
    "startLine": 1198,
    "endLine": 1203,
    "text": "export function optional<T extends SomeType>(innerType: T): ZodMiniOptional<T> {\n  return new ZodMiniOptional({\n    type: \"optional\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:nullable",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "nullable",
    "startLine": 1218,
    "endLine": 1223,
    "text": "export function nullable<T extends SomeType>(innerType: T): ZodMiniNullable<T> {\n  return new ZodMiniNullable({\n    type: \"nullable\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:nullish",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "nullish",
    "startLine": 1226,
    "endLine": 1228,
    "text": "export function nullish<T extends SomeType>(innerType: T): ZodMiniOptional<ZodMiniNullable<T>> {\n  return optional(nullable(innerType));\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:_default",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "_default",
    "startLine": 1242,
    "endLine": 1253,
    "text": "export function _default<T extends SomeType>(\n  innerType: T,\n  defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)\n): ZodMiniDefault<T> {\n  return new ZodMiniDefault({\n    type: \"default\",\n    innerType: innerType as any as core.$ZodType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? (defaultValue as Function)() : defaultValue;\n    },\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:prefault",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "prefault",
    "startLine": 1267,
    "endLine": 1278,
    "text": "export function prefault<T extends SomeType>(\n  innerType: T,\n  defaultValue: util.NoUndefined<core.input<T>> | (() => util.NoUndefined<core.input<T>>)\n): ZodMiniPrefault<T> {\n  return new ZodMiniPrefault({\n    type: \"prefault\",\n    innerType: innerType as any as core.$ZodType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? (defaultValue as Function)() : defaultValue;\n    },\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:nonoptional",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "nonoptional",
    "startLine": 1293,
    "endLine": 1302,
    "text": "export function nonoptional<T extends SomeType>(\n  innerType: T,\n  params?: string | core.$ZodNonOptionalParams\n): ZodMiniNonOptional<T> {\n  return new ZodMiniNonOptional({\n    type: \"nonoptional\",\n    innerType: innerType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:success",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "success",
    "startLine": 1316,
    "endLine": 1321,
    "text": "export function success<T extends SomeType>(innerType: T): ZodMiniSuccess<T> {\n  return new ZodMiniSuccess({\n    type: \"success\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:_catch",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "_catch",
    "startLine": 1335,
    "endLine": 1346,
    "text": "function _catch<T extends SomeType>(\n  innerType: T,\n  catchValue: core.output<T> | ((ctx: core.$ZodCatchCtx) => core.output<T>)\n): ZodMiniCatch<T> {\n  return new ZodMiniCatch({\n    type: \"catch\",\n    innerType: innerType as any as core.$ZodType,\n    catchValue: (typeof catchValue === \"function\" ? catchValue : () => catchValue) as (\n      ctx: core.$ZodCatchCtx\n    ) => core.output<T>,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:nan",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "nan",
    "startLine": 1358,
    "endLine": 1360,
    "text": "export function nan(params?: string | core.$ZodNaNParams): ZodMiniNaN {\n  return core._nan(ZodMiniNaN, params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:pipe",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "pipe",
    "startLine": 1375,
    "endLine": 1384,
    "text": "export function pipe<\n  const A extends SomeType,\n  B extends core.$ZodType<unknown, core.output<A>> = core.$ZodType<unknown, core.output<A>>,\n>(in_: A, out: B | core.$ZodType<unknown, core.output<A>>): ZodMiniPipe<A, B> {\n  return new ZodMiniPipe({\n    type: \"pipe\",\n    in: in_ as any as core.$ZodType,\n    out: out as any as core.$ZodType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:readonly",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "readonly",
    "startLine": 1408,
    "endLine": 1413,
    "text": "export function readonly<T extends SomeType>(innerType: T): ZodMiniReadonly<T> {\n  return new ZodMiniReadonly({\n    type: \"readonly\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:templateLiteral",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "templateLiteral",
    "startLine": 1428,
    "endLine": 1437,
    "text": "export function templateLiteral<const Parts extends core.$ZodTemplateLiteralPart[]>(\n  parts: Parts,\n  params?: string | core.$ZodTemplateLiteralParams\n): ZodMiniTemplateLiteral<core.$PartsToTemplateLiteral<Parts>> {\n  return new ZodMiniTemplateLiteral({\n    type: \"template_literal\",\n    parts,\n    ...util.normalizeParams(params),\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:_lazy",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "_lazy",
    "startLine": 1454,
    "endLine": 1459,
    "text": "function _lazy<T extends SomeType>(getter: () => T): ZodMiniLazy<T> {\n  return new ZodMiniLazy({\n    type: \"lazy\",\n    getter: getter as any,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:promise",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "promise",
    "startLine": 1474,
    "endLine": 1479,
    "text": "export function promise<T extends SomeType>(innerType: T): ZodMiniPromise<T> {\n  return new ZodMiniPromise({\n    type: \"promise\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:check",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "check",
    "startLine": 1494,
    "endLine": 1502,
    "text": "export function check<O = unknown>(fn: core.CheckFn<O>, params?: string | core.$ZodCustomParams): core.$ZodCheck<O> {\n  const ch = new core.$ZodCheck({\n    check: \"custom\",\n    ...util.normalizeParams(params),\n  });\n\n  ch._zod.check = fn;\n  return ch;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:custom",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "custom",
    "startLine": 1506,
    "endLine": 1511,
    "text": "export function custom<O = unknown, I = O>(\n  fn?: (data: O) => unknown,\n  _params?: string | core.$ZodCustomParams | undefined\n): ZodMiniCustom<O, I> {\n  return core._custom(ZodMiniCustom, fn ?? (() => true), _params) as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:refine",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "refine",
    "startLine": 1514,
    "endLine": 1519,
    "text": "export function refine<T>(\n  fn: (arg: NoInfer<T>) => util.MaybeAsync<unknown>,\n  _params: string | core.$ZodCustomParams = {}\n): core.$ZodCheck<T> {\n  return core._refine(ZodMiniCustom, fn, _params);\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:Class",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "Class",
    "startLine": 1522,
    "endLine": 1524,
    "text": "abstract class Class {\n  constructor(..._args: any[]) {}\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:_instanceof",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "_instanceof",
    "startLine": 1525,
    "endLine": 1534,
    "text": "function _instanceof<T extends typeof Class>(\n  cls: T,\n  params: core.$ZodCustomParams = {\n    error: `Input not instance of ${cls.name}`,\n  }\n): ZodMiniCustom<InstanceType<T>, InstanceType<T>> {\n  const inst = custom((data) => data instanceof cls, params);\n  inst._zod.bag.Class = cls;\n  return inst as any;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts:json",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "symbol": "json",
    "startLine": 1574,
    "endLine": 1579,
    "text": "export function json(): ZodMiniJSONSchema {\n  const jsonSchema: any = _lazy(() => {\n    return union([string(), number(), boolean(), _null(), array(jsonSchema), record(string(), jsonSchema)]);\n  });\n  return jsonSchema;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/custom-paths/subfolder2/export.ts:ExportClass",
    "file": "node_modules/madge/test/typescript/custom-paths/subfolder2/export.ts",
    "symbol": "ExportClass",
    "startLine": 1,
    "endLine": 5,
    "text": "class ExportClass {\n\tstringLength(s: string) {\n\t\treturn s.length;\n\t}\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/custom-paths/subfolder2/export.ts:ExportClass.stringLength",
    "file": "node_modules/madge/test/typescript/custom-paths/subfolder2/export.ts",
    "symbol": "ExportClass.stringLength",
    "startLine": 2,
    "endLine": 4,
    "text": "\tstringLength(s: string) {\n\t\treturn s.length;\n\t}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/generics.test.ts:nest",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/generics.test.ts",
    "symbol": "nest",
    "startLine": 4,
    "endLine": 8,
    "text": "function nest<TData extends z.ZodType>(schema: TData) {\n  return z.object({\n    nested: schema,\n  });\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/generics.test.ts:stripOuter",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/generics.test.ts",
    "symbol": "stripOuter",
    "startLine": 21,
    "endLine": 30,
    "text": "  async function stripOuter<TData extends z.ZodType>(schema: TData, data: unknown) {\n    return z\n      .object({\n        nested: schema.optional(),\n      })\n      .transform((data) => {\n        return data.nested;\n      })\n      .parse({ nested: data });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/index.test.ts:A",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/index.test.ts",
    "symbol": "A",
    "startLine": 657,
    "endLine": 657,
    "text": "  class A {}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/instanceof.test.ts:Test",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/instanceof.test.ts",
    "symbol": "Test",
    "startLine": 5,
    "endLine": 5,
    "text": "  class Test {}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/instanceof.test.ts:Subtest",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/instanceof.test.ts",
    "symbol": "Subtest",
    "startLine": 6,
    "endLine": 6,
    "text": "  class Subtest extends Test {}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/instanceof.test.ts:AbstractBar",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/instanceof.test.ts",
    "symbol": "AbstractBar",
    "startLine": 7,
    "endLine": 9,
    "text": "  abstract class AbstractBar {\n    constructor(public val: string) {}\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/instanceof.test.ts:Bar",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/instanceof.test.ts",
    "symbol": "Bar",
    "startLine": 10,
    "endLine": 10,
    "text": "  class Bar extends AbstractBar {}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/object.test.ts:makeZodObj",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/object.test.ts",
    "symbol": "makeZodObj",
    "startLine": 553,
    "endLine": 557,
    "text": "  function makeZodObj<const T extends string>(key: T) {\n    return z.looseObject({\n      [key]: z.string(),\n    });\n  }"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/string.test.ts:makeJwt",
    "file": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/string.test.ts",
    "symbol": "makeJwt",
    "startLine": 267,
    "endLine": 272,
    "text": "function makeJwt(header: object, payload: object) {\n  const headerBase64 = Buffer.from(JSON.stringify(header)).toString(\"base64url\");\n  const payloadBase64 = Buffer.from(JSON.stringify(payload)).toString(\"base64url\");\n  const signature = \"signature\"; // Placeholder for the signature\n  return `${headerBase64}.${payloadBase64}.${signature}`;\n}"
  },
  {
    "id": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/tests/index.test.ts:A",
    "file": "mcp-rag-server/node_modules/zod/src/v4/mini/tests/index.test.ts",
    "symbol": "A",
    "startLine": 653,
    "endLine": 653,
    "text": "  class A {}"
  }
]