[
  {
    "path": "src/indexer.ts",
    "content": "/**\n * Indexer module responsible for scanning TypeScript projects and producing\n * structured metadata about files and symbols. The indexer traverses\n * directories recursively, parses TypeScript source files using the\n * TypeScript compiler API and extracts high‑level symbols such as\n * functions, classes and methods. The resulting metadata is persisted to\n * JSON files so that both the orchestrator and the Python semantic engine\n * have a consistent view of the codebase.\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport * as ts from 'typescript';\nimport { FileMeta, SymbolMeta, SemanticEntry } from './types';\n\n/**\n * Walk a directory recursively and return a list of absolute paths to\n * TypeScript files. Files under node_modules or hidden directories are\n * ignored. Only files ending in `.ts` or `.tsx` are considered.\n */\nfunction walkDir(dir: string): string[] {\n  const files: string[] = [];\n  const entries = fs.readdirSync(dir, { withFileTypes: true });\n  for (const entry of entries) {\n    if (entry.name.startsWith('.')) continue; // skip hidden\n    const fullPath = path.join(dir, entry.name);\n    if (entry.isDirectory()) {\n      if (entry.name === 'node_modules' || entry.name === 'dist') continue;\n      files.push(...walkDir(fullPath));\n    } else if (entry.isFile()) {\n      if (/\\.tsx?$/.test(entry.name)) {\n        files.push(fullPath);\n      }\n    }\n  }\n  return files;\n}\n\n/**\n * Extract symbol metadata from a TypeScript source file. This helper\n * traverses the AST and identifies top‑level function declarations,\n * classes and class methods. For each relevant node it records the\n * symbol name, kind and line range.\n */\nfunction extractSymbols(sourceFile: ts.SourceFile): SymbolMeta[] {\n  const symbols: SymbolMeta[] = [];\n  const visit = (node: ts.Node) => {\n    if (ts.isFunctionDeclaration(node) && node.name) {\n      // Include leading JSDoc comments when computing the start position so\n      // that documentation is part of the snippet. Without setting\n      // includeJsDocComment=true the comment lines are excluded from the\n      // node's start position.\n      const start = sourceFile.getLineAndCharacterOfPosition(node.getStart(sourceFile, true));\n      const end = sourceFile.getLineAndCharacterOfPosition(node.getEnd());\n      symbols.push({\n        name: node.name.getText(),\n        kind: 'function',\n        file: sourceFile.fileName,\n        startLine: start.line + 1,\n        endLine: end.line + 1,\n      });\n    } else if (ts.isClassDeclaration(node) && node.name) {\n      const start = sourceFile.getLineAndCharacterOfPosition(node.getStart(sourceFile, true));\n      const end = sourceFile.getLineAndCharacterOfPosition(node.getEnd());\n      symbols.push({\n        name: node.name.getText(),\n        kind: 'class',\n        file: sourceFile.fileName,\n        startLine: start.line + 1,\n        endLine: end.line + 1,\n      });\n      // Extract methods within the class\n      node.members.forEach(member => {\n        if (\n          ts.isMethodDeclaration(member) &&\n          member.name &&\n          ts.isIdentifier(member.name)\n        ) {\n          const mStart = sourceFile.getLineAndCharacterOfPosition(member.getStart(sourceFile, true));\n          const mEnd = sourceFile.getLineAndCharacterOfPosition(member.getEnd());\n          symbols.push({\n            name: `${node.name!.getText()}.${member.name.getText()}`,\n            kind: 'method',\n            file: sourceFile.fileName,\n            startLine: mStart.line + 1,\n            endLine: mEnd.line + 1,\n          });\n        }\n      });\n    }\n    ts.forEachChild(node, visit);\n  };\n  visit(sourceFile);\n  return symbols;\n}\n\n/**\n * Given a file path and its content, extract code snippets for each symbol\n * meta entry. The snippet is composed of lines from startLine to\n * endLine inclusive. The resulting SemanticEntry can then be used by\n * the semantic engine to compute embeddings.\n */\nfunction createSemanticEntries(fileMeta: FileMeta): SemanticEntry[] {\n  const lines = fileMeta.content.split(/\\r?\\n/);\n  const entries: SemanticEntry[] = [];\n  for (const sym of fileMeta.symbols) {\n    const snippetLines = lines.slice(sym.startLine - 1, sym.endLine);\n    const text = snippetLines.join('\\n');\n    entries.push({\n      id: `${fileMeta.path}:${sym.name}`,\n      file: fileMeta.path,\n      symbol: sym.name,\n      startLine: sym.startLine,\n      endLine: sym.endLine,\n      text,\n    });\n  }\n  return entries;\n}\n\n/**\n * Run the indexing process for a given root directory. It writes two JSON\n * files into the output folder: `index.json` containing file and symbol\n * metadata, and `semantic_entries.json` containing snippet‑level data.\n */\nexport function runIndexer(rootDir: string, outDir: string): void {\n  const tsFiles = walkDir(rootDir);\n  const fileMetas: FileMeta[] = [];\n  const semanticEntries: SemanticEntry[] = [];\n  for (const file of tsFiles) {\n    const content = fs.readFileSync(file, 'utf8');\n    const sourceFile = ts.createSourceFile(file, content, ts.ScriptTarget.Latest, true);\n    const symbols = extractSymbols(sourceFile);\n    const relativePath = path.relative(rootDir, file).replace(/\\\\/g, '/');\n    const fileMeta: FileMeta = {\n      path: relativePath,\n      content,\n      symbols,\n    };\n    fileMetas.push(fileMeta);\n    const entries = createSemanticEntries(fileMeta);\n    semanticEntries.push(...entries);\n  }\n  if (!fs.existsSync(outDir)) {\n    fs.mkdirSync(outDir, { recursive: true });\n  }\n  fs.writeFileSync(path.join(outDir, 'index.json'), JSON.stringify(fileMetas, null, 2), 'utf8');\n  fs.writeFileSync(\n    path.join(outDir, 'semantic_entries.json'),\n    JSON.stringify(semanticEntries, null, 2),\n    'utf8'\n  );\n}\n\n// If this script is executed directly (e.g. `npm run index`), run the\n// indexer on the repository root (one directory up from this file) and\n// output to the `data` directory under the project root.\nif (require.main === module) {\n  const projectRoot = process.cwd();\n  const outDir = path.join(projectRoot, 'data');\n  runIndexer(path.join(projectRoot, 'src'), outDir);\n  console.log('Indexing complete.');\n}\n",
    "symbols": [
      {
        "name": "walkDir",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/src/indexer.ts",
        "startLine": 21,
        "endLine": 37
      },
      {
        "name": "extractSymbols",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/src/indexer.ts",
        "startLine": 45,
        "endLine": 95
      },
      {
        "name": "createSemanticEntries",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/src/indexer.ts",
        "startLine": 103,
        "endLine": 119
      },
      {
        "name": "runIndexer",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/src/indexer.ts",
        "startLine": 126,
        "endLine": 153
      }
    ]
  },
  {
    "path": "src/orchestrator.ts",
    "content": "/**\n * The orchestrator coordinates between the local TypeScript index and the\n * Python semantic engine. It exposes simple functions for fetching file\n * contents and performing semantic searches. Results from the semantic\n * engine are combined with a lightweight lexical heuristic to improve\n * relevance. This module is used both by the HTTP server and unit tests.\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport { FileMeta, SearchResult } from './types';\nimport http from 'http';\n\ninterface EngineSearchResult {\n  file: string;\n  symbol: string;\n  startLine: number;\n  endLine: number;\n  score: number;\n  snippet: string;\n}\n\n/**\n * Orchestrator class encapsulates access to the index and remote semantic\n * engine. It reads the precomputed index from disk and exposes methods\n * for retrieving files and performing searches.\n */\nexport class Orchestrator {\n  private fileIndex: Map<string, FileMeta> = new Map();\n  private engineUrl: string;\n\n  constructor(dataDir: string, engineUrl: string = 'http://localhost:8000') {\n    this.engineUrl = engineUrl;\n    this.loadIndex(dataDir);\n  }\n\n  /**\n   * Load the file metadata index from the specified directory. The file\n   * `index.json` is expected to contain an array of FileMeta objects.\n   */\n  private loadIndex(dataDir: string) {\n    const idxPath = path.join(dataDir, 'index.json');\n    const json = fs.readFileSync(idxPath, 'utf8');\n    const files: FileMeta[] = JSON.parse(json);\n    for (const file of files) {\n      // Use relative path as key for lookup.\n      this.fileIndex.set(file.path, file);\n    }\n  }\n\n  /**\n   * Retrieve the contents of a file by its relative path. Throws if the\n   * file cannot be found in the index.\n   */\n  public getFile(filePath: string): string {\n    const fileMeta = this.fileIndex.get(filePath);\n    if (!fileMeta) {\n      throw new Error(`File not found in index: ${filePath}`);\n    }\n    return fileMeta.content;\n  }\n\n  /**\n   * Perform a semantic search through the Python engine and combine its\n   * scores with a simple lexical match. The lexical score boosts results\n   * containing the query terms within their snippet. The final score is\n   * a weighted sum of semantic (0.7) and lexical (0.3) scores.\n   */\n  public async searchCode(query: string, topK = 5): Promise<SearchResult[]> {\n    // Query the Python semantic engine via HTTP GET. URL encode the query.\n    const url = new URL('/search', this.engineUrl);\n    url.searchParams.set('q', query);\n    url.searchParams.set('top_k', topK.toString());\n\n    const engineResults: EngineSearchResult[] = await new Promise((resolve, reject) => {\n      const req = http.get(url.toString(), res => {\n        const chunks: Buffer[] = [];\n        res.on('data', chunk => chunks.push(chunk));\n        res.on('end', () => {\n          const body = Buffer.concat(chunks).toString('utf8');\n          try {\n            const parsed = JSON.parse(body);\n            resolve(parsed.results as EngineSearchResult[]);\n          } catch (err) {\n            reject(new Error(`Failed to parse engine response: ${body}`));\n          }\n        });\n      });\n      req.on('error', err => reject(err));\n    });\n\n    // Compute lexical score: proportion of query terms present in the snippet.\n    const tokens = query\n      .toLowerCase()\n      .split(/\\W+/)\n      .filter(t => t.length > 0);\n    const results: SearchResult[] = engineResults.map(er => {\n      const snippetLower = er.snippet.toLowerCase();\n      let hits = 0;\n      for (const token of tokens) {\n        if (snippetLower.includes(token)) hits++;\n      }\n      const lexicalScore = tokens.length > 0 ? hits / tokens.length : 0;\n      const finalScore = er.score * 0.7 + lexicalScore * 0.3;\n      return {\n        file: er.file,\n        symbol: er.symbol,\n        startLine: er.startLine,\n        endLine: er.endLine,\n        score: finalScore,\n        snippet: er.snippet,\n      };\n    });\n    // Sort by final score descending and return topK.\n    results.sort((a, b) => b.score - a.score);\n    return results.slice(0, topK);\n  }\n}",
    "symbols": [
      {
        "name": "Orchestrator",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/src/orchestrator.ts",
        "startLine": 28,
        "endLine": 118
      },
      {
        "name": "Orchestrator.loadIndex",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/src/orchestrator.ts",
        "startLine": 41,
        "endLine": 49
      },
      {
        "name": "Orchestrator.getFile",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/src/orchestrator.ts",
        "startLine": 55,
        "endLine": 61
      },
      {
        "name": "Orchestrator.searchCode",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/src/orchestrator.ts",
        "startLine": 69,
        "endLine": 117
      }
    ]
  },
  {
    "path": "src/server.ts",
    "content": "/**\n * HTTP server exposing the MCP functionality. This server offers two\n * endpoints: `/search_code` for semantic search and `/get_file` for\n * retrieving file contents. It delegates heavy lifting to the\n * orchestrator, which interacts with the Python semantic engine.\n */\n\nimport http from 'http';\nimport { Orchestrator } from './orchestrator';\n\nconst PORT = parseInt(process.env.PORT || '3000', 10);\nconst DATA_DIR = process.env.DATA_DIR || './data';\nconst ENGINE_URL = process.env.ENGINE_URL || 'http://localhost:8000';\n\n// Create the orchestrator. Loading the index is synchronous.\nconst orchestrator = new Orchestrator(DATA_DIR, ENGINE_URL);\n\nconst server = http.createServer((req, res) => {\n  if (!req.url) {\n    res.statusCode = 400;\n    res.end('Bad request');\n    return;\n  }\n  const url = new URL(req.url, `http://${req.headers.host}`);\n  if (req.method === 'GET' && url.pathname === '/get_file') {\n    const filePath = url.searchParams.get('path');\n    if (!filePath) {\n      res.statusCode = 400;\n      res.end(JSON.stringify({ error: 'Missing \"path\" parameter' }));\n      return;\n    }\n    try {\n      const content = orchestrator.getFile(filePath);\n      res.setHeader('Content-Type', 'application/json');\n      res.end(JSON.stringify({ path: filePath, content }));\n    } catch (err: any) {\n      res.statusCode = 404;\n      res.end(JSON.stringify({ error: err.message }));\n    }\n  } else if (req.method === 'GET' && url.pathname === '/search_code') {\n    const query = url.searchParams.get('q') || '';\n    const topKStr = url.searchParams.get('top_k') || '5';\n    const topK = parseInt(topKStr, 10);\n    orchestrator\n      .searchCode(query, topK)\n      .then(results => {\n        res.setHeader('Content-Type', 'application/json');\n        res.end(JSON.stringify({ query, results }));\n      })\n      .catch(err => {\n        res.statusCode = 500;\n        res.end(JSON.stringify({ error: err.message }));\n      });\n  } else {\n    res.statusCode = 404;\n    res.end(JSON.stringify({ error: 'Endpoint not found' }));\n  }\n});\n\nserver.listen(PORT, () => {\n  console.log(`MCP server listening on port ${PORT}`);\n});",
    "symbols": []
  },
  {
    "path": "src/types.ts",
    "content": "/**\n * Shared type definitions for the MCP project.\n */\n\n/**\n * Information about a code symbol extracted during indexing. Symbols can be\n * functions, classes or methods. The range describes the start and end\n * positions (in terms of line numbers) in the file.\n */\nexport interface SymbolMeta {\n  name: string;\n  kind: 'function' | 'class' | 'method' | 'unknown';\n  file: string;\n  startLine: number;\n  endLine: number;\n}\n\n/**\n * Metadata about a file discovered during indexing. It contains the path\n * relative to the repository root as well as its raw contents. A file can\n * reference any number of symbols.\n */\nexport interface FileMeta {\n  path: string;\n  content: string;\n  symbols: SymbolMeta[];\n}\n\n/**\n * Representation of an entry used by the semantic engine. Each entry\n * corresponds to a code snippet (usually a symbol). The engine uses the\n * `text` field to compute an embedding and the other fields for context.\n */\nexport interface SemanticEntry {\n  id: string;\n  file: string;\n  symbol: string;\n  startLine: number;\n  endLine: number;\n  text: string;\n}\n\n/**\n * Structure of a search result returned from the semantic engine. The\n * orchestrator will combine the `score` with additional heuristics to\n * determine the final ranking. The `snippet` contains a short excerpt of\n * the code around the matched symbol.\n */\nexport interface SearchResult {\n  file: string;\n  symbol: string;\n  startLine: number;\n  endLine: number;\n  score: number;\n  snippet: string;\n}",
    "symbols": []
  },
  {
    "path": "external_sample/src/hello.ts",
    "content": "export function hello(name: string) {\n  return `Hello, ${name}!`;\n}\n\n",
    "symbols": [
      {
        "name": "hello",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/external_sample/src/hello.ts",
        "startLine": 1,
        "endLine": 3
      }
    ]
  },
  {
    "path": "node_modules/cac/mod.ts",
    "content": "// For Deno\nexport * from './deno/index.ts'\n",
    "symbols": []
  },
  {
    "path": "node_modules/walkdir/test.ts",
    "content": "import * as walkdir from './walkdir';\n\nlet a = walkdir('aaa',{sync:true,return_object:true},function(path){\n    this.ignore(path)\n})\na[Object.keys(a)[0]].isDirectory()\n\nlet b = walkdir('aaa',{sync:true},function(path){\n    this.ignore(path)\n})\nb.splice(0)\n\nlet c = walkdir('bbb')\nc.emit('a')\nc.pause()\nc.resume()\nc.end()\n\n\nlet d = walkdir('ccc',{},(path)=>{\n    path.substr\n})\nd.emit('a')\n\nlet e = walkdir('ddd',(path)=>{\n    path.substr\n})\ne.emit('a')\n\n\nlet f = walkdir('bbb',{sync:true})\nf.splice(0)\n\n\nwalkdir.async(\"\").then((s)=>s.splice(0))\n\nwalkdir.async(\"\",{}).then((s)=>s.splice(0))\n\nwalkdir.async(\"\",{return_object:true}).then((a)=>{\n    a[Object.keys(a)[0]].isDirectory()\n})\n\nlet g = walkdir.find('')\ng.emit('a')\n\nlet g1 = walkdir.find('',()=>{})\ng1.emit('a')\n\nlet g2 = walkdir.find('',{},()=>{})\ng2.emit('a')\n\nlet h = walkdir.find('',{sync:true})\nh.splice(0)\n\nlet i = walkdir.find('',{sync:true,return_object:true})\ni[Object.keys(i)[0]].isDirectory()\n\n\nlet j = walkdir.sync('')\nj.splice(0)\n\nlet k = walkdir.sync('',{return_object:true})\nk[Object.keys(k)[0]].isDirectory()\n\nlet l = walkdir.sync('',(path)=>{\n    path.substr\n})\nl.splice(0)\n",
    "symbols": []
  },
  {
    "path": "packages/mcp-server/vitest.config.ts",
    "content": "import { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    include: ['tests/**/*.test.ts']\n  }\n});\n\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod-to-json-schema/createIndex.ts",
    "content": "import { readdirSync, writeFileSync, statSync } from \"fs\";\n\nconst ignore = [\"src/index.ts\"];\n\nfunction checkSrcDir(path: string): string[] {\n  const lines: string[] = [];\n\n  for (const item of readdirSync(path)) {\n    const itemPath = path + \"/\" + item;\n\n    if (ignore.includes(itemPath)) {\n      continue;\n    }\n\n    if (statSync(itemPath).isDirectory()) {\n      lines.push(...checkSrcDir(itemPath));\n    } else if (item.endsWith(\".ts\")) {\n      lines.push('export * from \"./' + itemPath.slice(4, -2) + 'js\"');\n    }\n  }\n\n  return lines;\n}\n\nconst lines = checkSrcDir(\"src\");\n\nlines.push(\n  'import { zodToJsonSchema } from \"./zodToJsonSchema.js\"',\n  \"export default zodToJsonSchema;\",\n);\n\nwriteFileSync(\"./src/index.ts\", lines.join(\";\\n\"));\n",
    "symbols": [
      {
        "name": "checkSrcDir",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod-to-json-schema/createIndex.ts",
        "startLine": 5,
        "endLine": 23
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod-to-json-schema/postcjs.ts",
    "content": "import { writeFileSync } from \"fs\";\n\nwriteFileSync(\"./dist/cjs/package.json\", '{\"type\":\"commonjs\"}', \"utf-8\");\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod-to-json-schema/postesm.ts",
    "content": "import { writeFileSync } from \"fs\";\n\nwriteFileSync(\"./dist/esm/package.json\", '{\"type\":\"module\",\"main\":\"index.js\"}', \"utf-8\");\n",
    "symbols": []
  },
  {
    "path": "node_modules/@mcp/server/vitest.config.ts",
    "content": "import { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    include: ['tests/**/*.test.ts']\n  }\n});\n\n",
    "symbols": []
  },
  {
    "path": "node_modules/cac/deno/CAC.ts",
    "content": "import { EventEmitter } from \"https://deno.land/std@0.114.0/node/events.ts\";\nimport mri from \"https://cdn.skypack.dev/mri\";\nimport Command, { GlobalCommand, CommandConfig, HelpCallback, CommandExample } from \"./Command.ts\";\nimport { OptionConfig } from \"./Option.ts\";\nimport { getMriOptions, setDotProp, setByType, getFileName, camelcaseOptionName } from \"./utils.ts\";\nimport { processArgs } from \"./deno.ts\";\ninterface ParsedArgv {\n  args: ReadonlyArray<string>;\n  options: {\n    [k: string]: any;\n  };\n}\n\nclass CAC extends EventEmitter {\n  /** The program name to display in help and version message */\n  name: string;\n  commands: Command[];\n  globalCommand: GlobalCommand;\n  matchedCommand?: Command;\n  matchedCommandName?: string;\n  /**\n   * Raw CLI arguments\n   */\n\n  rawArgs: string[];\n  /**\n   * Parsed CLI arguments\n   */\n\n  args: ParsedArgv['args'];\n  /**\n   * Parsed CLI options, camelCased\n   */\n\n  options: ParsedArgv['options'];\n  showHelpOnExit?: boolean;\n  showVersionOnExit?: boolean;\n  /**\n   * @param name The program name to display in help and version message\n   */\n\n  constructor(name = '') {\n    super();\n    this.name = name;\n    this.commands = [];\n    this.rawArgs = [];\n    this.args = [];\n    this.options = {};\n    this.globalCommand = new GlobalCommand(this);\n    this.globalCommand.usage('<command> [options]');\n  }\n  /**\n   * Add a global usage text.\n   *\n   * This is not used by sub-commands.\n   */\n\n\n  usage(text: string) {\n    this.globalCommand.usage(text);\n    return this;\n  }\n  /**\n   * Add a sub-command\n   */\n\n\n  command(rawName: string, description?: string, config?: CommandConfig) {\n    const command = new Command(rawName, description || '', config, this);\n    command.globalCommand = this.globalCommand;\n    this.commands.push(command);\n    return command;\n  }\n  /**\n   * Add a global CLI option.\n   *\n   * Which is also applied to sub-commands.\n   */\n\n\n  option(rawName: string, description: string, config?: OptionConfig) {\n    this.globalCommand.option(rawName, description, config);\n    return this;\n  }\n  /**\n   * Show help message when `-h, --help` flags appear.\n   *\n   */\n\n\n  help(callback?: HelpCallback) {\n    this.globalCommand.option('-h, --help', 'Display this message');\n    this.globalCommand.helpCallback = callback;\n    this.showHelpOnExit = true;\n    return this;\n  }\n  /**\n   * Show version number when `-v, --version` flags appear.\n   *\n   */\n\n\n  version(version: string, customFlags = '-v, --version') {\n    this.globalCommand.version(version, customFlags);\n    this.showVersionOnExit = true;\n    return this;\n  }\n  /**\n   * Add a global example.\n   *\n   * This example added here will not be used by sub-commands.\n   */\n\n\n  example(example: CommandExample) {\n    this.globalCommand.example(example);\n    return this;\n  }\n  /**\n   * Output the corresponding help message\n   * When a sub-command is matched, output the help message for the command\n   * Otherwise output the global one.\n   *\n   */\n\n\n  outputHelp() {\n    if (this.matchedCommand) {\n      this.matchedCommand.outputHelp();\n    } else {\n      this.globalCommand.outputHelp();\n    }\n  }\n  /**\n   * Output the version number.\n   *\n   */\n\n\n  outputVersion() {\n    this.globalCommand.outputVersion();\n  }\n\n  private setParsedInfo({\n    args,\n    options\n  }: ParsedArgv, matchedCommand?: Command, matchedCommandName?: string) {\n    this.args = args;\n    this.options = options;\n\n    if (matchedCommand) {\n      this.matchedCommand = matchedCommand;\n    }\n\n    if (matchedCommandName) {\n      this.matchedCommandName = matchedCommandName;\n    }\n\n    return this;\n  }\n\n  unsetMatchedCommand() {\n    this.matchedCommand = undefined;\n    this.matchedCommandName = undefined;\n  }\n  /**\n   * Parse argv\n   */\n\n\n  parse(argv = processArgs, {\n    /** Whether to run the action for matched command */\n    run = true\n  } = {}): ParsedArgv {\n    this.rawArgs = argv;\n\n    if (!this.name) {\n      this.name = argv[1] ? getFileName(argv[1]) : 'cli';\n    }\n\n    let shouldParse = true; // Search sub-commands\n\n    for (const command of this.commands) {\n      const parsed = this.mri(argv.slice(2), command);\n      const commandName = parsed.args[0];\n\n      if (command.isMatched(commandName)) {\n        shouldParse = false;\n        const parsedInfo = { ...parsed,\n          args: parsed.args.slice(1)\n        };\n        this.setParsedInfo(parsedInfo, command, commandName);\n        this.emit(`command:${commandName}`, command);\n      }\n    }\n\n    if (shouldParse) {\n      // Search the default command\n      for (const command of this.commands) {\n        if (command.name === '') {\n          shouldParse = false;\n          const parsed = this.mri(argv.slice(2), command);\n          this.setParsedInfo(parsed, command);\n          this.emit(`command:!`, command);\n        }\n      }\n    }\n\n    if (shouldParse) {\n      const parsed = this.mri(argv.slice(2));\n      this.setParsedInfo(parsed);\n    }\n\n    if (this.options.help && this.showHelpOnExit) {\n      this.outputHelp();\n      run = false;\n      this.unsetMatchedCommand();\n    }\n\n    if (this.options.version && this.showVersionOnExit && this.matchedCommandName == null) {\n      this.outputVersion();\n      run = false;\n      this.unsetMatchedCommand();\n    }\n\n    const parsedArgv = {\n      args: this.args,\n      options: this.options\n    };\n\n    if (run) {\n      this.runMatchedCommand();\n    }\n\n    if (!this.matchedCommand && this.args[0]) {\n      this.emit('command:*');\n    }\n\n    return parsedArgv;\n  }\n\n  private mri(argv: string[],\n  /** Matched command */\n  command?: Command): ParsedArgv {\n    // All added options\n    const cliOptions = [...this.globalCommand.options, ...(command ? command.options : [])];\n    const mriOptions = getMriOptions(cliOptions); // Extract everything after `--` since mri doesn't support it\n\n    let argsAfterDoubleDashes: string[] = [];\n    const doubleDashesIndex = argv.indexOf('--');\n\n    if (doubleDashesIndex > -1) {\n      argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);\n      argv = argv.slice(0, doubleDashesIndex);\n    }\n\n    let parsed = mri(argv, mriOptions);\n    parsed = Object.keys(parsed).reduce((res, name) => {\n      return { ...res,\n        [camelcaseOptionName(name)]: parsed[name]\n      };\n    }, {\n      _: []\n    });\n    const args = parsed._;\n    const options: {\n      [k: string]: any;\n    } = {\n      '--': argsAfterDoubleDashes\n    }; // Set option default value\n\n    const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;\n    let transforms = Object.create(null);\n\n    for (const cliOption of cliOptions) {\n      if (!ignoreDefault && cliOption.config.default !== undefined) {\n        for (const name of cliOption.names) {\n          options[name] = cliOption.config.default;\n        }\n      } // If options type is defined\n\n\n      if (Array.isArray(cliOption.config.type)) {\n        if (transforms[cliOption.name] === undefined) {\n          transforms[cliOption.name] = Object.create(null);\n          transforms[cliOption.name]['shouldTransform'] = true;\n          transforms[cliOption.name]['transformFunction'] = cliOption.config.type[0];\n        }\n      }\n    } // Set option values (support dot-nested property name)\n\n\n    for (const key of Object.keys(parsed)) {\n      if (key !== '_') {\n        const keys = key.split('.');\n        setDotProp(options, keys, parsed[key]);\n        setByType(options, transforms);\n      }\n    }\n\n    return {\n      args,\n      options\n    };\n  }\n\n  runMatchedCommand() {\n    const {\n      args,\n      options,\n      matchedCommand: command\n    } = this;\n    if (!command || !command.commandAction) return;\n    command.checkUnknownOptions();\n    command.checkOptionValue();\n    command.checkRequiredArgs();\n    const actionArgs: any[] = [];\n    command.args.forEach((arg, index) => {\n      if (arg.variadic) {\n        actionArgs.push(args.slice(index));\n      } else {\n        actionArgs.push(args[index]);\n      }\n    });\n    actionArgs.push(options);\n    return command.commandAction.apply(this, actionArgs);\n  }\n\n}\n\nexport default CAC;",
    "symbols": [
      {
        "name": "CAC",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts",
        "startLine": 14,
        "endLine": 329
      },
      {
        "name": "CAC.usage",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts",
        "startLine": 59,
        "endLine": 62
      },
      {
        "name": "CAC.command",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts",
        "startLine": 68,
        "endLine": 73
      },
      {
        "name": "CAC.option",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts",
        "startLine": 81,
        "endLine": 84
      },
      {
        "name": "CAC.help",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts",
        "startLine": 91,
        "endLine": 96
      },
      {
        "name": "CAC.version",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts",
        "startLine": 103,
        "endLine": 107
      },
      {
        "name": "CAC.example",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts",
        "startLine": 115,
        "endLine": 118
      },
      {
        "name": "CAC.outputHelp",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts",
        "startLine": 127,
        "endLine": 133
      },
      {
        "name": "CAC.outputVersion",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts",
        "startLine": 140,
        "endLine": 142
      },
      {
        "name": "CAC.setParsedInfo",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts",
        "startLine": 144,
        "endLine": 160
      },
      {
        "name": "CAC.unsetMatchedCommand",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts",
        "startLine": 162,
        "endLine": 165
      },
      {
        "name": "CAC.parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts",
        "startLine": 171,
        "endLine": 240
      },
      {
        "name": "CAC.mri",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts",
        "startLine": 242,
        "endLine": 305
      },
      {
        "name": "CAC.runMatchedCommand",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/CAC.ts",
        "startLine": 307,
        "endLine": 327
      }
    ]
  },
  {
    "path": "node_modules/cac/deno/Command.ts",
    "content": "import CAC from \"./CAC.ts\";\nimport Option, { OptionConfig } from \"./Option.ts\";\nimport { removeBrackets, findAllBrackets, findLongest, padRight, CACError } from \"./utils.ts\";\nimport { platformInfo } from \"./deno.ts\";\ninterface CommandArg {\n  required: boolean;\n  value: string;\n  variadic: boolean;\n}\ninterface HelpSection {\n  title?: string;\n  body: string;\n}\ninterface CommandConfig {\n  allowUnknownOptions?: boolean;\n  ignoreOptionDefaultValue?: boolean;\n}\ntype HelpCallback = (sections: HelpSection[]) => void | HelpSection[];\ntype CommandExample = ((bin: string) => string) | string;\n\nclass Command {\n  options: Option[];\n  aliasNames: string[];\n  /* Parsed command name */\n\n  name: string;\n  args: CommandArg[];\n  commandAction?: (...args: any[]) => any;\n  usageText?: string;\n  versionNumber?: string;\n  examples: CommandExample[];\n  helpCallback?: HelpCallback;\n  globalCommand?: GlobalCommand;\n\n  constructor(public rawName: string, public description: string, public config: CommandConfig = {}, public cli: CAC) {\n    this.options = [];\n    this.aliasNames = [];\n    this.name = removeBrackets(rawName);\n    this.args = findAllBrackets(rawName);\n    this.examples = [];\n  }\n\n  usage(text: string) {\n    this.usageText = text;\n    return this;\n  }\n\n  allowUnknownOptions() {\n    this.config.allowUnknownOptions = true;\n    return this;\n  }\n\n  ignoreOptionDefaultValue() {\n    this.config.ignoreOptionDefaultValue = true;\n    return this;\n  }\n\n  version(version: string, customFlags = '-v, --version') {\n    this.versionNumber = version;\n    this.option(customFlags, 'Display version number');\n    return this;\n  }\n\n  example(example: CommandExample) {\n    this.examples.push(example);\n    return this;\n  }\n  /**\n   * Add a option for this command\n   * @param rawName Raw option name(s)\n   * @param description Option description\n   * @param config Option config\n   */\n\n\n  option(rawName: string, description: string, config?: OptionConfig) {\n    const option = new Option(rawName, description, config);\n    this.options.push(option);\n    return this;\n  }\n\n  alias(name: string) {\n    this.aliasNames.push(name);\n    return this;\n  }\n\n  action(callback: (...args: any[]) => any) {\n    this.commandAction = callback;\n    return this;\n  }\n  /**\n   * Check if a command name is matched by this command\n   * @param name Command name\n   */\n\n\n  isMatched(name: string) {\n    return this.name === name || this.aliasNames.includes(name);\n  }\n\n  get isDefaultCommand() {\n    return this.name === '' || this.aliasNames.includes('!');\n  }\n\n  get isGlobalCommand(): boolean {\n    return this instanceof GlobalCommand;\n  }\n  /**\n   * Check if an option is registered in this command\n   * @param name Option name\n   */\n\n\n  hasOption(name: string) {\n    name = name.split('.')[0];\n    return this.options.find(option => {\n      return option.names.includes(name);\n    });\n  }\n\n  outputHelp() {\n    const {\n      name,\n      commands\n    } = this.cli;\n    const {\n      versionNumber,\n      options: globalOptions,\n      helpCallback\n    } = this.cli.globalCommand;\n    let sections: HelpSection[] = [{\n      body: `${name}${versionNumber ? `/${versionNumber}` : ''}`\n    }];\n    sections.push({\n      title: 'Usage',\n      body: `  $ ${name} ${this.usageText || this.rawName}`\n    });\n    const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;\n\n    if (showCommands) {\n      const longestCommandName = findLongest(commands.map(command => command.rawName));\n      sections.push({\n        title: 'Commands',\n        body: commands.map(command => {\n          return `  ${padRight(command.rawName, longestCommandName.length)}  ${command.description}`;\n        }).join('\\n')\n      });\n      sections.push({\n        title: `For more info, run any command with the \\`--help\\` flag`,\n        body: commands.map(command => `  $ ${name}${command.name === '' ? '' : ` ${command.name}`} --help`).join('\\n')\n      });\n    }\n\n    let options = this.isGlobalCommand ? globalOptions : [...this.options, ...(globalOptions || [])];\n\n    if (!this.isGlobalCommand && !this.isDefaultCommand) {\n      options = options.filter(option => option.name !== 'version');\n    }\n\n    if (options.length > 0) {\n      const longestOptionName = findLongest(options.map(option => option.rawName));\n      sections.push({\n        title: 'Options',\n        body: options.map(option => {\n          return `  ${padRight(option.rawName, longestOptionName.length)}  ${option.description} ${option.config.default === undefined ? '' : `(default: ${option.config.default})`}`;\n        }).join('\\n')\n      });\n    }\n\n    if (this.examples.length > 0) {\n      sections.push({\n        title: 'Examples',\n        body: this.examples.map(example => {\n          if (typeof example === 'function') {\n            return example(name);\n          }\n\n          return example;\n        }).join('\\n')\n      });\n    }\n\n    if (helpCallback) {\n      sections = helpCallback(sections) || sections;\n    }\n\n    console.log(sections.map(section => {\n      return section.title ? `${section.title}:\\n${section.body}` : section.body;\n    }).join('\\n\\n'));\n  }\n\n  outputVersion() {\n    const {\n      name\n    } = this.cli;\n    const {\n      versionNumber\n    } = this.cli.globalCommand;\n\n    if (versionNumber) {\n      console.log(`${name}/${versionNumber} ${platformInfo}`);\n    }\n  }\n\n  checkRequiredArgs() {\n    const minimalArgsCount = this.args.filter(arg => arg.required).length;\n\n    if (this.cli.args.length < minimalArgsCount) {\n      throw new CACError(`missing required args for command \\`${this.rawName}\\``);\n    }\n  }\n  /**\n   * Check if the parsed options contain any unknown options\n   *\n   * Exit and output error when true\n   */\n\n\n  checkUnknownOptions() {\n    const {\n      options,\n      globalCommand\n    } = this.cli;\n\n    if (!this.config.allowUnknownOptions) {\n      for (const name of Object.keys(options)) {\n        if (name !== '--' && !this.hasOption(name) && !globalCommand.hasOption(name)) {\n          throw new CACError(`Unknown option \\`${name.length > 1 ? `--${name}` : `-${name}`}\\``);\n        }\n      }\n    }\n  }\n  /**\n   * Check if the required string-type options exist\n   */\n\n\n  checkOptionValue() {\n    const {\n      options: parsedOptions,\n      globalCommand\n    } = this.cli;\n    const options = [...globalCommand.options, ...this.options];\n\n    for (const option of options) {\n      const value = parsedOptions[option.name.split('.')[0]]; // Check required option value\n\n      if (option.required) {\n        const hasNegated = options.some(o => o.negated && o.names.includes(option.name));\n\n        if (value === true || value === false && !hasNegated) {\n          throw new CACError(`option \\`${option.rawName}\\` value is missing`);\n        }\n      }\n    }\n  }\n\n}\n\nclass GlobalCommand extends Command {\n  constructor(cli: CAC) {\n    super('@@global@@', '', {}, cli);\n  }\n\n}\n\nexport type { HelpCallback, CommandExample, CommandConfig };\nexport { GlobalCommand };\nexport default Command;",
    "symbols": [
      {
        "name": "Command",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 21,
        "endLine": 258
      },
      {
        "name": "Command.usage",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 43,
        "endLine": 46
      },
      {
        "name": "Command.allowUnknownOptions",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 48,
        "endLine": 51
      },
      {
        "name": "Command.ignoreOptionDefaultValue",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 53,
        "endLine": 56
      },
      {
        "name": "Command.version",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 58,
        "endLine": 62
      },
      {
        "name": "Command.example",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 64,
        "endLine": 67
      },
      {
        "name": "Command.option",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 76,
        "endLine": 80
      },
      {
        "name": "Command.alias",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 82,
        "endLine": 85
      },
      {
        "name": "Command.action",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 87,
        "endLine": 90
      },
      {
        "name": "Command.isMatched",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 97,
        "endLine": 99
      },
      {
        "name": "Command.hasOption",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 114,
        "endLine": 119
      },
      {
        "name": "Command.outputHelp",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 121,
        "endLine": 190
      },
      {
        "name": "Command.outputVersion",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 192,
        "endLine": 203
      },
      {
        "name": "Command.checkRequiredArgs",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 205,
        "endLine": 211
      },
      {
        "name": "Command.checkUnknownOptions",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 219,
        "endLine": 232
      },
      {
        "name": "Command.checkOptionValue",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 238,
        "endLine": 256
      },
      {
        "name": "GlobalCommand",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Command.ts",
        "startLine": 260,
        "endLine": 265
      }
    ]
  },
  {
    "path": "node_modules/cac/deno/deno.ts",
    "content": "// Ignore the TypeScript errors\n// Since this file will only be used in Deno runtime\nexport const processArgs = ['deno', 'cli'].concat(Deno.args);\nexport const platformInfo = `${Deno.build.os}-${Deno.build.arch} deno-${Deno.version.deno}`;",
    "symbols": []
  },
  {
    "path": "node_modules/cac/deno/index.ts",
    "content": "import CAC from \"./CAC.ts\";\nimport Command from \"./Command.ts\";\n/**\n * @param name The program name to display in help and version message\n */\n\nconst cac = (name = '') => new CAC(name);\n\nexport default cac;\nexport { cac, CAC, Command };",
    "symbols": []
  },
  {
    "path": "node_modules/cac/deno/Option.ts",
    "content": "import { removeBrackets, camelcaseOptionName } from \"./utils.ts\";\ninterface OptionConfig {\n  default?: any;\n  type?: any[];\n}\nexport default class Option {\n  /** Option name */\n  name: string;\n  /** Option name and aliases */\n\n  names: string[];\n  isBoolean?: boolean; // `required` will be a boolean for options with brackets\n\n  required?: boolean;\n  config: OptionConfig;\n  negated: boolean;\n\n  constructor(public rawName: string, public description: string, config?: OptionConfig) {\n    this.config = Object.assign({}, config); // You may use cli.option('--env.* [value]', 'desc') to denote a dot-nested option\n\n    rawName = rawName.replace(/\\.\\*/g, '');\n    this.negated = false;\n    this.names = removeBrackets(rawName).split(',').map((v: string) => {\n      let name = v.trim().replace(/^-{1,2}/, '');\n\n      if (name.startsWith('no-')) {\n        this.negated = true;\n        name = name.replace(/^no-/, '');\n      }\n\n      return camelcaseOptionName(name);\n    }).sort((a, b) => a.length > b.length ? 1 : -1); // Sort names\n    // Use the longest name (last one) as actual option name\n\n    this.name = this.names[this.names.length - 1];\n\n    if (this.negated && this.config.default == null) {\n      this.config.default = true;\n    }\n\n    if (rawName.includes('<')) {\n      this.required = true;\n    } else if (rawName.includes('[')) {\n      this.required = false;\n    } else {\n      // No arg needed, it's boolean flag\n      this.isBoolean = true;\n    }\n  }\n\n}\nexport type { OptionConfig };",
    "symbols": [
      {
        "name": "Option",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/Option.ts",
        "startLine": 6,
        "endLine": 51
      }
    ]
  },
  {
    "path": "node_modules/cac/deno/utils.ts",
    "content": "import Option from \"./Option.ts\";\nexport const removeBrackets = (v: string) => v.replace(/[<[].+/, '').trim();\nexport const findAllBrackets = (v: string) => {\n  const ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g;\n  const SQUARE_BRACKET_RE_GLOBAL = /\\[([^\\]]+)\\]/g;\n  const res = [];\n\n  const parse = (match: string[]) => {\n    let variadic = false;\n    let value = match[1];\n\n    if (value.startsWith('...')) {\n      value = value.slice(3);\n      variadic = true;\n    }\n\n    return {\n      required: match[0].startsWith('<'),\n      value,\n      variadic\n    };\n  };\n\n  let angledMatch;\n\n  while (angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v)) {\n    res.push(parse(angledMatch));\n  }\n\n  let squareMatch;\n\n  while (squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v)) {\n    res.push(parse(squareMatch));\n  }\n\n  return res;\n};\ninterface MriOptions {\n  alias: {\n    [k: string]: string[];\n  };\n  boolean: string[];\n}\nexport const getMriOptions = (options: Option[]) => {\n  const result: MriOptions = {\n    alias: {},\n    boolean: []\n  };\n\n  for (const [index, option] of options.entries()) {\n    // We do not set default values in mri options\n    // Since its type (typeof) will be used to cast parsed arguments.\n    // Which mean `--foo foo` will be parsed as `{foo: true}` if we have `{default:{foo: true}}`\n    // Set alias\n    if (option.names.length > 1) {\n      result.alias[option.names[0]] = option.names.slice(1);\n    } // Set boolean\n\n\n    if (option.isBoolean) {\n      if (option.negated) {\n        // For negated option\n        // We only set it to `boolean` type when there's no string-type option with the same name\n        const hasStringTypeOption = options.some((o, i) => {\n          return i !== index && o.names.some(name => option.names.includes(name)) && typeof o.required === 'boolean';\n        });\n\n        if (!hasStringTypeOption) {\n          result.boolean.push(option.names[0]);\n        }\n      } else {\n        result.boolean.push(option.names[0]);\n      }\n    }\n  }\n\n  return result;\n};\nexport const findLongest = (arr: string[]) => {\n  return arr.sort((a, b) => {\n    return a.length > b.length ? -1 : 1;\n  })[0];\n};\nexport const padRight = (str: string, length: number) => {\n  return str.length >= length ? str : `${str}${' '.repeat(length - str.length)}`;\n};\nexport const camelcase = (input: string) => {\n  return input.replace(/([a-z])-([a-z])/g, (_, p1, p2) => {\n    return p1 + p2.toUpperCase();\n  });\n};\nexport const setDotProp = (obj: {\n  [k: string]: any;\n}, keys: string[], val: any) => {\n  let i = 0;\n  let length = keys.length;\n  let t = obj;\n  let x;\n\n  for (; i < length; ++i) {\n    x = t[keys[i]];\n    t = t[keys[i]] = i === length - 1 ? val : x != null ? x : !!~keys[i + 1].indexOf('.') || !(+keys[i + 1] > -1) ? {} : [];\n  }\n};\nexport const setByType = (obj: {\n  [k: string]: any;\n}, transforms: {\n  [k: string]: any;\n}) => {\n  for (const key of Object.keys(transforms)) {\n    const transform = transforms[key];\n\n    if (transform.shouldTransform) {\n      obj[key] = Array.prototype.concat.call([], obj[key]);\n\n      if (typeof transform.transformFunction === 'function') {\n        obj[key] = obj[key].map(transform.transformFunction);\n      }\n    }\n  }\n};\nexport const getFileName = (input: string) => {\n  const m = /([^\\\\\\/]+)$/.exec(input);\n  return m ? m[1] : '';\n};\nexport const camelcaseOptionName = (name: string) => {\n  // Camelcase the option name\n  // Don't camelcase anything after the dot `.`\n  return name.split('.').map((v, i) => {\n    return i === 0 ? camelcase(v) : v;\n  }).join('.');\n};\nexport class CACError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = this.constructor.name;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error(message).stack;\n    }\n  }\n\n}",
    "symbols": [
      {
        "name": "CACError",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/cac/deno/utils.ts",
        "startLine": 133,
        "endLine": 145
      }
    ]
  },
  {
    "path": "node_modules/fastq/test/example.ts",
    "content": "import * as fastq from '../'\nimport { promise as queueAsPromised } from '../'\n\n// Basic example\n\nconst queue = fastq(worker, 1)\n\nqueue.push('world', (err, result) => {\n  if (err) throw err\n  console.log('the result is', result)\n})\n\nqueue.push('push without cb')\n\nqueue.concurrency\n\nqueue.drain()\n\nqueue.empty = () => undefined\n\nconsole.log('the queue tasks are', queue.getQueue())\n\nqueue.idle()\n\nqueue.kill()\n\nqueue.killAndDrain()\n\nqueue.length\n\nqueue.pause()\n\nqueue.resume()\n\nqueue.running()\n\nqueue.saturated = () => undefined\n\nqueue.unshift('world', (err, result) => {\n  if (err) throw err\n  console.log('the result is', result)\n})\n\nqueue.unshift('unshift without cb')\n\nfunction worker(task: any, cb: fastq.done) {\n  cb(null, 'hello ' + task)\n}\n\n// Generics example\n\ninterface GenericsContext {\n  base: number;\n}\n\nconst genericsQueue = fastq<GenericsContext, number, string>({ base: 6 }, genericsWorker, 1)\n\ngenericsQueue.push(7, (err, done) => {\n  if (err) throw err\n  console.log('the result is', done)\n})\n\ngenericsQueue.unshift(7, (err, done) => {\n  if (err) throw err\n  console.log('the result is', done)\n})\n\nfunction genericsWorker(this: GenericsContext, task: number, cb: fastq.done<string>) {\n  cb(null, 'the meaning of life is ' + (this.base * task))\n}\n\nconst queue2 = queueAsPromised(asyncWorker, 1)\n\nasync function asyncWorker(task: any) {\n  return 'hello ' + task\n}\n\nasync function run () {\n  await queue.push(42)\n  await queue.unshift(42)\n}\n\nrun()\n",
    "symbols": [
      {
        "name": "worker",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/fastq/test/example.ts",
        "startLine": 46,
        "endLine": 48
      },
      {
        "name": "genericsWorker",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/fastq/test/example.ts",
        "startLine": 68,
        "endLine": 70
      },
      {
        "name": "asyncWorker",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/fastq/test/example.ts",
        "startLine": 74,
        "endLine": 76
      },
      {
        "name": "run",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/fastq/test/example.ts",
        "startLine": 78,
        "endLine": 81
      }
    ]
  },
  {
    "path": "node_modules/piscina/src/abort.ts",
    "content": "interface AbortSignalEventTargetAddOptions {\n  once: boolean;\n}\n\nexport interface AbortSignalEventTarget {\n  addEventListener: (\n    name: 'abort',\n    listener: () => void,\n    options?: AbortSignalEventTargetAddOptions\n  ) => void;\n  removeEventListener: (name: 'abort', listener: () => void) => void;\n  aborted?: boolean;\n  reason?: unknown;\n}\n\nexport interface AbortSignalEventEmitter {\n  off: (name: 'abort', listener: () => void) => void;\n  once: (name: 'abort', listener: () => void) => void;\n}\n\nexport type AbortSignalAny = AbortSignalEventTarget | AbortSignalEventEmitter;\n\nexport class AbortError extends Error {\n  constructor (reason?: AbortSignalEventTarget['reason']) {\n    // TS does not recognizes the cause clause\n    // @ts-expect-error\n    super('The task has been aborted', { cause: reason });\n  }\n\n  get name () {\n    return 'AbortError';\n  }\n}\n\nexport function onabort (abortSignal: AbortSignalAny, listener: () => void) {\n  if ('addEventListener' in abortSignal) {\n    abortSignal.addEventListener('abort', listener, { once: true });\n  } else {\n    abortSignal.once('abort', listener);\n  }\n}\n",
    "symbols": [
      {
        "name": "AbortError",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/abort.ts",
        "startLine": 23,
        "endLine": 33
      },
      {
        "name": "onabort",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/abort.ts",
        "startLine": 35,
        "endLine": 41
      }
    ]
  },
  {
    "path": "node_modules/piscina/src/common.ts",
    "content": "import type { Histogram } from 'node:perf_hooks';\nimport { fileURLToPath, URL } from 'node:url';\nimport { availableParallelism, cpus } from 'node:os';\n\nimport type { HistogramSummary } from './types';\nimport { kMovable, kTransferable, kValue } from './symbols';\n\n// States wether the worker is ready to receive tasks\nexport const READY = '_WORKER_READY';\n\n/**\n * True if the object implements the Transferable interface\n *\n * @export\n * @param {unknown} value\n * @return {*}  {boolean}\n */\nexport function isTransferable (value: unknown): boolean {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    kTransferable in value &&\n    kValue in value\n  );\n}\n\n/**\n * True if object implements Transferable and has been returned\n * by the Piscina.move() function\n *\n * TODO: narrow down the type of value\n * @export\n * @param {(unknown & PiscinaMovable)} value\n * @return {*}  {boolean}\n */\nexport function isMovable (value: any): boolean {\n  return isTransferable(value) && value[kMovable] === true;\n}\n\nexport function markMovable (value: {}): void {\n  Object.defineProperty(value, kMovable, {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: true\n  });\n}\n\n// State of Piscina pool\nexport const commonState = {\n  isWorkerThread: false,\n  workerData: undefined\n};\n\nexport function createHistogramSummary (histogram: Histogram): HistogramSummary {\n  const { mean, stddev, min, max } = histogram;\n\n  return {\n    average: mean / 1000,\n    mean: mean / 1000,\n    stddev,\n    min: min / 1000,\n    max: max / 1000,\n    p0_001: histogram.percentile(0.001) / 1000,\n    p0_01: histogram.percentile(0.01) / 1000,\n    p0_1: histogram.percentile(0.1) / 1000,\n    p1: histogram.percentile(1) / 1000,\n    p2_5: histogram.percentile(2.5) / 1000,\n    p10: histogram.percentile(10) / 1000,\n    p25: histogram.percentile(25) / 1000,\n    p50: histogram.percentile(50) / 1000,\n    p75: histogram.percentile(75) / 1000,\n    p90: histogram.percentile(90) / 1000,\n    p97_5: histogram.percentile(97.5) / 1000,\n    p99: histogram.percentile(99) / 1000,\n    p99_9: histogram.percentile(99.9) / 1000,\n    p99_99: histogram.percentile(99.99) / 1000,\n    p99_999: histogram.percentile(99.999) / 1000\n  };\n}\n\nexport function toHistogramIntegerNano (milliseconds: number): number {\n  return Math.max(1, Math.trunc(milliseconds * 1000));\n}\n\nexport function maybeFileURLToPath (filename : string) : string {\n  return filename.startsWith('file:')\n    ? fileURLToPath(new URL(filename))\n    : filename;\n}\n\n// TODO: drop on v5\nexport function getAvailableParallelism () : number {\n  if (typeof availableParallelism === 'function') {\n    return availableParallelism();\n  }\n\n  try {\n    return cpus().length;\n  } catch {\n    return 1;\n  }\n}\n",
    "symbols": [
      {
        "name": "isTransferable",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/common.ts",
        "startLine": 18,
        "endLine": 25
      },
      {
        "name": "isMovable",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/common.ts",
        "startLine": 36,
        "endLine": 38
      },
      {
        "name": "markMovable",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/common.ts",
        "startLine": 40,
        "endLine": 47
      },
      {
        "name": "createHistogramSummary",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/common.ts",
        "startLine": 55,
        "endLine": 80
      },
      {
        "name": "toHistogramIntegerNano",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/common.ts",
        "startLine": 82,
        "endLine": 84
      },
      {
        "name": "maybeFileURLToPath",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/common.ts",
        "startLine": 86,
        "endLine": 90
      },
      {
        "name": "getAvailableParallelism",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/common.ts",
        "startLine": 93,
        "endLine": 103
      }
    ]
  },
  {
    "path": "node_modules/piscina/src/errors.ts",
    "content": "export const Errors = {\n  ThreadTermination: () => new Error('Terminating worker thread'),\n  FilenameNotProvided: () =>\n    new Error('filename must be provided to run() or in options object'),\n  TaskQueueAtLimit: () => new Error('Task queue is at limit'),\n  NoTaskQueueAvailable: () =>\n    new Error('No task queue available and all Workers are busy'),\n  CloseTimeout: () => new Error('Close operation timed out')\n};\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/src/index.ts",
    "content": "import { Worker, MessageChannel, MessagePort } from 'node:worker_threads';\nimport { once, EventEmitterAsyncResource } from 'node:events';\nimport { resolve } from 'node:path';\nimport { inspect, types } from 'node:util';\nimport { RecordableHistogram, createHistogram, performance } from 'node:perf_hooks';\nimport { setTimeout as sleep } from 'node:timers/promises';\nimport assert from 'node:assert';\n\nimport { version } from '../package.json';\nimport type {\n  ResponseMessage,\n  StartupMessage,\n  Transferable,\n  ResourceLimits,\n  EnvSpecifier\n} from './types';\nimport {\n  kQueueOptions,\n  kTransferable,\n  kValue\n} from './symbols';\nimport {\n  TaskQueue,\n  isTaskQueue,\n  ArrayTaskQueue,\n  FixedQueue,\n  TaskInfo,\n  PiscinaTask,\n  TransferList,\n  TransferListItem\n} from './task_queue';\nimport {\n  WorkerInfo,\n  AsynchronouslyCreatedResourcePool\n} from './worker_pool';\nimport {\n  AbortSignalAny,\n  AbortSignalEventTarget,\n  AbortError,\n  onabort\n} from './abort';\nimport { Errors } from './errors';\nimport {\n  READY,\n  commonState,\n  isTransferable,\n  markMovable,\n  createHistogramSummary,\n  toHistogramIntegerNano,\n  getAvailableParallelism,\n  maybeFileURLToPath\n} from './common';\nconst cpuParallelism : number = getAvailableParallelism();\n\ninterface Options {\n  filename? : string | null,\n  name?: string,\n  minThreads? : number,\n  maxThreads? : number,\n  idleTimeout? : number,\n  maxQueue? : number | 'auto',\n  concurrentTasksPerWorker? : number,\n  useAtomics? : boolean,\n  resourceLimits? : ResourceLimits,\n  argv? : string[],\n  execArgv? : string[],\n  env? : EnvSpecifier,\n  workerData? : any,\n  taskQueue? : TaskQueue,\n  niceIncrement? : number,\n  trackUnmanagedFds? : boolean,\n  closeTimeout?: number,\n  recordTiming?: boolean\n}\n\ninterface FilledOptions extends Options {\n  filename : string | null,\n  name: string,\n  minThreads : number,\n  maxThreads : number,\n  idleTimeout : number,\n  maxQueue : number,\n  concurrentTasksPerWorker : number,\n  useAtomics: boolean,\n  taskQueue : TaskQueue,\n  niceIncrement : number,\n  closeTimeout : number,\n  recordTiming : boolean\n}\n\ninterface RunOptions {\n  transferList? : TransferList,\n  filename? : string | null,\n  signal? : AbortSignalAny | null,\n  name? : string | null\n}\n\ninterface FilledRunOptions extends RunOptions {\n  transferList : TransferList | never,\n  filename : string | null,\n  signal : AbortSignalAny | null,\n  name : string | null\n}\n\ninterface CloseOptions {\n  force?: boolean,\n}\n\nconst kDefaultOptions : FilledOptions = {\n  filename: null,\n  name: 'default',\n  minThreads: Math.max(Math.floor(cpuParallelism / 2), 1),\n  maxThreads: cpuParallelism * 1.5,\n  idleTimeout: 0,\n  maxQueue: Infinity,\n  concurrentTasksPerWorker: 1,\n  useAtomics: true,\n  taskQueue: new ArrayTaskQueue(),\n  niceIncrement: 0,\n  trackUnmanagedFds: true,\n  closeTimeout: 30000,\n  recordTiming: true\n};\n\nconst kDefaultRunOptions : FilledRunOptions = {\n  transferList: undefined,\n  filename: null,\n  signal: null,\n  name: null\n};\n\nconst kDefaultCloseOptions : Required<CloseOptions> = {\n  force: false\n};\n\nclass DirectlyTransferable implements Transferable {\n  #value : object;\n  constructor (value : object) {\n    this.#value = value;\n  }\n\n  get [kTransferable] () : object { return this.#value; }\n\n  get [kValue] () : object { return this.#value; }\n}\n\nclass ArrayBufferViewTransferable implements Transferable {\n  #view : ArrayBufferView;\n  constructor (view : ArrayBufferView) {\n    this.#view = view;\n  }\n\n  get [kTransferable] () : object { return this.#view.buffer; }\n\n  get [kValue] () : object { return this.#view; }\n}\n\nclass ThreadPool {\n  publicInterface : Piscina;\n  workers : AsynchronouslyCreatedResourcePool<WorkerInfo>;\n  options : FilledOptions;\n  taskQueue : TaskQueue;\n  skipQueue : TaskInfo[] = [];\n  completed : number = 0;\n  runTime? : RecordableHistogram;\n  waitTime? : RecordableHistogram;\n  needsDrain : boolean;\n  start : number = performance.now();\n  inProcessPendingMessages : boolean = false;\n  startingUp : boolean = false;\n  closingUp : boolean = false;\n  workerFailsDuringBootstrap : boolean = false;\n  destroying : boolean = false;\n\n  constructor (publicInterface : Piscina, options : Options) {\n    this.publicInterface = publicInterface;\n    this.taskQueue = options.taskQueue || new ArrayTaskQueue();\n\n    const filename =\n      options.filename ? maybeFileURLToPath(options.filename) : null;\n    this.options = { ...kDefaultOptions, ...options, filename, maxQueue: 0 };\n\n    if (this.options.recordTiming) {\n      this.runTime = createHistogram();\n      this.waitTime = createHistogram();\n    }\n\n    // The >= and <= could be > and < but this way we get 100 % coverage 🙃\n    if (options.maxThreads !== undefined &&\n        this.options.minThreads >= options.maxThreads) {\n      this.options.minThreads = options.maxThreads;\n    }\n    if (options.minThreads !== undefined &&\n        this.options.maxThreads <= options.minThreads) {\n      this.options.maxThreads = options.minThreads;\n    }\n    if (options.maxQueue === 'auto') {\n      this.options.maxQueue = this.options.maxThreads ** 2;\n    } else {\n      this.options.maxQueue = options.maxQueue ?? kDefaultOptions.maxQueue;\n    }\n\n    this.workers = new AsynchronouslyCreatedResourcePool<WorkerInfo>(\n      this.options.concurrentTasksPerWorker);\n    this.workers.onAvailable((w : WorkerInfo) => this._onWorkerAvailable(w));\n\n    this.startingUp = true;\n    this._ensureMinimumWorkers();\n    this.startingUp = false;\n    this.needsDrain = false;\n  }\n\n  _ensureMinimumWorkers () : void {\n    if (this.closingUp || this.destroying) {\n      return;\n    }\n    while (this.workers.size < this.options.minThreads) {\n      this._addNewWorker();\n    }\n  }\n\n  _addNewWorker () : void {\n    const pool = this;\n    const worker = new Worker(resolve(__dirname, 'worker.js'), {\n      env: this.options.env,\n      argv: this.options.argv,\n      execArgv: this.options.execArgv,\n      resourceLimits: this.options.resourceLimits,\n      workerData: this.options.workerData,\n      trackUnmanagedFds: this.options.trackUnmanagedFds\n    });\n\n    const { port1, port2 } = new MessageChannel();\n    const workerInfo = new WorkerInfo(worker, port1, onMessage);\n    if (this.startingUp) {\n      // There is no point in waiting for the initial set of Workers to indicate\n      // that they are ready, we just mark them as such from the start.\n      workerInfo.markAsReady();\n    }\n\n    const message : StartupMessage = {\n      filename: this.options.filename,\n      name: this.options.name,\n      port: port2,\n      sharedBuffer: workerInfo.sharedBuffer,\n      useAtomics: this.options.useAtomics,\n      niceIncrement: this.options.niceIncrement\n    };\n    worker.postMessage(message, [port2]);\n\n    function onMessage (message : ResponseMessage) {\n      const { taskId, result } = message;\n      // In case of success: Call the callback that was passed to `runTask`,\n      // remove the `TaskInfo` associated with the Worker, which marks it as\n      // free again.\n      const taskInfo = workerInfo.taskInfos.get(taskId);\n      workerInfo.taskInfos.delete(taskId);\n\n      pool.workers.maybeAvailable(workerInfo);\n\n      /* istanbul ignore if */\n      if (taskInfo === undefined) {\n        const err = new Error(\n          `Unexpected message from Worker: ${inspect(message)}`);\n        pool.publicInterface.emit('error', err);\n      } else {\n        taskInfo.done(message.error, result);\n      }\n\n      pool._processPendingMessages();\n    }\n\n    function onReady () {\n      if (workerInfo.currentUsage() === 0) {\n        workerInfo.unref();\n      }\n\n      if (!workerInfo.isReady()) {\n        workerInfo.markAsReady();\n      }\n    }\n\n    function onEventMessage (message: any) {\n      pool.publicInterface.emit('message', message);\n    }\n\n    worker.on('message', (message : any) => {\n      message instanceof Object && READY in message ? onReady() : onEventMessage(message);\n    });\n\n    worker.on('error', (err : Error) => {\n      this._onError(worker, workerInfo, err, false);\n    });\n\n    worker.on('exit', (exitCode : number) => {\n      if (this.destroying) {\n        return;\n      }\n\n      const err = new Error(`worker exited with code: ${exitCode}`);\n      // Only error unfinished tasks on process exit, since there are legitimate\n      // reasons to exit workers and we want to handle that gracefully when possible.\n      this._onError(worker, workerInfo, err, true);\n    });\n\n    worker.unref();\n    port1.on('close', () => {\n      // The port is only closed if the Worker stops for some reason, but we\n      // always .unref() the Worker itself. We want to receive e.g. 'error'\n      // events on it, so we ref it once we know it's going to exit anyway.\n      worker.ref();\n    });\n\n    this.workers.add(workerInfo);\n  }\n\n  _onError (worker: Worker, workerInfo: WorkerInfo, err: Error, onlyErrorUnfinishedTasks: boolean) {\n    // Work around the bug in https://github.com/nodejs/node/pull/33394\n    worker.ref = () => {};\n\n    const taskInfos = [...workerInfo.taskInfos.values()];\n    workerInfo.taskInfos.clear();\n\n    // Remove the worker from the list and potentially start a new Worker to\n    // replace the current one.\n    this._removeWorker(workerInfo);\n\n    if (workerInfo.isReady() && !this.workerFailsDuringBootstrap) {\n      this._ensureMinimumWorkers();\n    } else {\n      // Do not start new workers over and over if they already fail during\n      // bootstrap, there's no point.\n      this.workerFailsDuringBootstrap = true;\n    }\n\n    if (taskInfos.length > 0) {\n      // If there are remaining unfinished tasks, call the callback that was\n      // passed to `postTask` with the error\n      for (const taskInfo of taskInfos) {\n        taskInfo.done(err, null);\n      }\n    } else if (!onlyErrorUnfinishedTasks) {\n      // If there are no unfinished tasks, instead emit an 'error' event\n      this.publicInterface.emit('error', err);\n    }\n  }\n\n  _processPendingMessages () {\n    if (this.inProcessPendingMessages || !this.options.useAtomics) {\n      return;\n    }\n\n    this.inProcessPendingMessages = true;\n    try {\n      for (const workerInfo of this.workers) {\n        workerInfo.processPendingMessages();\n      }\n    } finally {\n      this.inProcessPendingMessages = false;\n    }\n  }\n\n  _removeWorker (workerInfo : WorkerInfo) : void {\n    workerInfo.destroy();\n\n    this.workers.delete(workerInfo);\n  }\n\n  _onWorkerAvailable (workerInfo : WorkerInfo) : void {\n    while ((this.taskQueue.size > 0 || this.skipQueue.length > 0) &&\n      workerInfo.currentUsage() < this.options.concurrentTasksPerWorker) {\n      // The skipQueue will have tasks that we previously shifted off\n      // the task queue but had to skip over... we have to make sure\n      // we drain that before we drain the taskQueue.\n      const taskInfo = this.skipQueue.shift() ||\n                       this.taskQueue.shift() as TaskInfo;\n      // If the task has an abortSignal and the worker has any other\n      // tasks, we cannot distribute the task to it. Skip for now.\n      if (taskInfo.abortSignal && workerInfo.taskInfos.size > 0) {\n        this.skipQueue.push(taskInfo);\n        break;\n      }\n      const now = performance.now();\n      this.waitTime?.record(toHistogramIntegerNano(now - taskInfo.created));\n      taskInfo.started = now;\n      workerInfo.postTask(taskInfo);\n      this._maybeDrain();\n      return;\n    }\n\n    // If Infinity was sent as a parameter, we skip setting the Timeout that clears the worker\n    if (this.options.idleTimeout === Infinity) {\n      return;\n    }\n\n    if (workerInfo.taskInfos.size === 0 &&\n        this.workers.size > this.options.minThreads) {\n      workerInfo.idleTimeout = setTimeout(() => {\n        assert.strictEqual(workerInfo.taskInfos.size, 0);\n        if (this.workers.size > this.options.minThreads) {\n          this._removeWorker(workerInfo);\n        }\n      }, this.options.idleTimeout).unref();\n    }\n  }\n\n  runTask (\n    task : any,\n    options : RunOptions) : Promise<any> {\n    let {\n      filename,\n      name\n    } = options;\n    const {\n      transferList = []\n    } = options;\n    if (filename == null) {\n      filename = this.options.filename;\n    }\n    if (name == null) {\n      name = this.options.name;\n    }\n    if (typeof filename !== 'string') {\n      return Promise.reject(Errors.FilenameNotProvided());\n    }\n    filename = maybeFileURLToPath(filename);\n\n    let signal: AbortSignalAny | null;\n    if (this.closingUp) {\n      const closingUpAbortController = new AbortController();\n      closingUpAbortController.abort('queue is closing up');\n\n      signal = closingUpAbortController.signal;\n    } else {\n      signal = options.signal ?? null;\n    }\n\n    let resolve : (result : any) => void;\n    let reject : (err : Error) => void;\n    // eslint-disable-next-line\n    const ret = new Promise((res, rej) => { resolve = res; reject = rej; });\n    const taskInfo = new TaskInfo(\n      task,\n      transferList,\n      filename,\n      name,\n      (err : Error | null, result : any) => {\n        this.completed++;\n        if (taskInfo.started) {\n          this.runTime?.record(toHistogramIntegerNano(performance.now() - taskInfo.started));\n        }\n        if (err !== null) {\n          reject(err);\n        } else {\n          resolve(result);\n        }\n\n        this._maybeDrain();\n      },\n      signal,\n      this.publicInterface.asyncResource.asyncId());\n\n    if (signal !== null) {\n      // If the AbortSignal has an aborted property and it's truthy,\n      // reject immediately.\n      if ((signal as AbortSignalEventTarget).aborted) {\n        return Promise.reject(new AbortError((signal as AbortSignalEventTarget).reason));\n      }\n      taskInfo.abortListener = () => {\n        // Call reject() first to make sure we always reject with the AbortError\n        // if the task is aborted, not with an Error from the possible\n        // thread termination below.\n        reject(new AbortError((signal as AbortSignalEventTarget).reason));\n\n        if (taskInfo.workerInfo !== null) {\n          // Already running: We cancel the Worker this is running on.\n          this._removeWorker(taskInfo.workerInfo);\n          this._ensureMinimumWorkers();\n        } else {\n          // Not yet running: Remove it from the queue.\n          this.taskQueue.remove(taskInfo);\n        }\n      };\n      onabort(signal, taskInfo.abortListener);\n    }\n\n    // If there is a task queue, there's no point in looking for an available\n    // Worker thread. Add this task to the queue, if possible.\n    if (this.taskQueue.size > 0) {\n      const totalCapacity = this.options.maxQueue + this.pendingCapacity();\n      if (this.taskQueue.size >= totalCapacity) {\n        if (this.options.maxQueue === 0) {\n          return Promise.reject(Errors.NoTaskQueueAvailable());\n        } else {\n          return Promise.reject(Errors.TaskQueueAtLimit());\n        }\n      } else {\n        if (this.workers.size < this.options.maxThreads) {\n          this._addNewWorker();\n        }\n        this.taskQueue.push(taskInfo);\n      }\n\n      this._maybeDrain();\n      return ret;\n    }\n\n    // Look for a Worker with a minimum number of tasks it is currently running.\n    let workerInfo : WorkerInfo | null = this.workers.findAvailable();\n\n    // If we want the ability to abort this task, use only workers that have\n    // no running tasks.\n    if (workerInfo !== null && workerInfo.currentUsage() > 0 && signal) {\n      workerInfo = null;\n    }\n\n    // If no Worker was found, or that Worker was handling another task in some\n    // way, and we still have the ability to spawn new threads, do so.\n    let waitingForNewWorker = false;\n    if ((workerInfo === null || workerInfo.currentUsage() > 0) &&\n        this.workers.size < this.options.maxThreads) {\n      this._addNewWorker();\n      waitingForNewWorker = true;\n    }\n\n    // If no Worker is found, try to put the task into the queue.\n    if (workerInfo === null) {\n      if (this.options.maxQueue <= 0 && !waitingForNewWorker) {\n        return Promise.reject(Errors.NoTaskQueueAvailable());\n      } else {\n        this.taskQueue.push(taskInfo);\n      }\n\n      this._maybeDrain();\n      return ret;\n    }\n\n    // TODO(addaleax): Clean up the waitTime/runTime recording.\n    const now = performance.now();\n    this.waitTime?.record(toHistogramIntegerNano(now - taskInfo.created));\n    taskInfo.started = now;\n    workerInfo.postTask(taskInfo);\n    this._maybeDrain();\n    return ret;\n  }\n\n  pendingCapacity () : number {\n    return this.workers.pendingItems.size *\n      this.options.concurrentTasksPerWorker;\n  }\n\n  _maybeDrain () {\n    const totalCapacity = this.options.maxQueue + this.pendingCapacity();\n    const totalQueueSize = this.taskQueue.size + this.skipQueue.length;\n\n    if (totalQueueSize === 0) {\n      this.needsDrain = false;\n      this.publicInterface.emit('drain');\n    }\n\n    if (totalQueueSize >= totalCapacity) {\n      this.needsDrain = true;\n      this.publicInterface.emit('needsDrain');\n    }\n  }\n\n  async destroy () {\n    this.destroying = true;\n    while (this.skipQueue.length > 0) {\n      const taskInfo : TaskInfo = this.skipQueue.shift() as TaskInfo;\n      taskInfo.done(new Error('Terminating worker thread'));\n    }\n    while (this.taskQueue.size > 0) {\n      const taskInfo : TaskInfo = this.taskQueue.shift() as TaskInfo;\n      taskInfo.done(new Error('Terminating worker thread'));\n    }\n\n    const exitEvents : Promise<any[]>[] = [];\n    while (this.workers.size > 0) {\n      const [workerInfo] = this.workers;\n      exitEvents.push(once(workerInfo.worker, 'exit'));\n      this._removeWorker(workerInfo);\n    }\n\n    try {\n      await Promise.all(exitEvents);\n    } finally {\n      this.destroying = false;\n    }\n  }\n\n  async close (options : Required<CloseOptions>) {\n    this.closingUp = true;\n\n    if (options.force) {\n      const skipQueueLength = this.skipQueue.length;\n      for (let i = 0; i < skipQueueLength; i++) {\n        const taskInfo : TaskInfo = this.skipQueue.shift() as TaskInfo;\n        if (taskInfo.workerInfo === null) {\n          taskInfo.done(new AbortError('pool is closed'));\n        } else {\n          this.skipQueue.push(taskInfo);\n        }\n      }\n\n      const taskQueueLength = this.taskQueue.size;\n      for (let i = 0; i < taskQueueLength; i++) {\n        const taskInfo : TaskInfo = this.taskQueue.shift() as TaskInfo;\n        if (taskInfo.workerInfo === null) {\n          taskInfo.done(new AbortError('pool is closed'));\n        } else {\n          this.taskQueue.push(taskInfo);\n        }\n      }\n    }\n\n    const onPoolFlushed = () => new Promise<void>((resolve) => {\n      const numberOfWorkers = this.workers.size;\n\n      if (numberOfWorkers === 0) {\n        resolve();\n        return;\n      }\n\n      let numberOfWorkersDone = 0;\n\n      const checkIfWorkerIsDone = (workerInfo: WorkerInfo) => {\n        if (workerInfo.taskInfos.size === 0) {\n          numberOfWorkersDone++;\n        }\n\n        if (numberOfWorkers === numberOfWorkersDone) {\n          resolve();\n        }\n      };\n\n      for (const workerInfo of this.workers) {\n        checkIfWorkerIsDone(workerInfo);\n\n        workerInfo.port.on('message', () => checkIfWorkerIsDone(workerInfo));\n      }\n    });\n\n    const throwOnTimeOut = async (timeout: number) => {\n      await sleep(timeout);\n      throw Errors.CloseTimeout();\n    };\n\n    try {\n      await Promise.race([\n        onPoolFlushed(),\n        throwOnTimeOut(this.options.closeTimeout)\n      ]);\n    } catch (error) {\n      this.publicInterface.emit('error', error);\n    } finally {\n      await this.destroy();\n      this.publicInterface.emit('close');\n      this.closingUp = false;\n    }\n  }\n}\n\nexport default class Piscina<T = any, R = any> extends EventEmitterAsyncResource {\n  #pool : ThreadPool;\n\n  constructor (options : Options = {}) {\n    super({ ...options, name: 'Piscina' });\n\n    if (typeof options.filename !== 'string' && options.filename != null) {\n      throw new TypeError('options.filename must be a string or null');\n    }\n    if (typeof options.name !== 'string' && options.name != null) {\n      throw new TypeError('options.name must be a string or null');\n    }\n    if (options.minThreads !== undefined &&\n        (typeof options.minThreads !== 'number' || options.minThreads < 0)) {\n      throw new TypeError('options.minThreads must be a non-negative integer');\n    }\n    if (options.maxThreads !== undefined &&\n        (typeof options.maxThreads !== 'number' || options.maxThreads < 1)) {\n      throw new TypeError('options.maxThreads must be a positive integer');\n    }\n    if (options.minThreads !== undefined && options.maxThreads !== undefined &&\n        options.minThreads > options.maxThreads) {\n      throw new RangeError('options.minThreads and options.maxThreads must not conflict');\n    }\n    if (options.idleTimeout !== undefined &&\n        (typeof options.idleTimeout !== 'number' || options.idleTimeout < 0)) {\n      throw new TypeError('options.idleTimeout must be a non-negative integer');\n    }\n    if (options.maxQueue !== undefined &&\n        options.maxQueue !== 'auto' &&\n          (typeof options.maxQueue !== 'number' || options.maxQueue < 0)) {\n      throw new TypeError('options.maxQueue must be a non-negative integer');\n    }\n    if (options.concurrentTasksPerWorker !== undefined &&\n        (typeof options.concurrentTasksPerWorker !== 'number' ||\n         options.concurrentTasksPerWorker < 1)) {\n      throw new TypeError(\n        'options.concurrentTasksPerWorker must be a positive integer');\n    }\n    if (options.useAtomics !== undefined &&\n        typeof options.useAtomics !== 'boolean') {\n      throw new TypeError('options.useAtomics must be a boolean value');\n    }\n    if (options.resourceLimits !== undefined &&\n        (typeof options.resourceLimits !== 'object' ||\n         options.resourceLimits === null)) {\n      throw new TypeError('options.resourceLimits must be an object');\n    }\n    if (options.taskQueue !== undefined && !isTaskQueue(options.taskQueue)) {\n      throw new TypeError('options.taskQueue must be a TaskQueue object');\n    }\n    if (options.niceIncrement !== undefined &&\n        (typeof options.niceIncrement !== 'number' || (options.niceIncrement < 0 && process.platform !== 'win32'))) {\n      throw new TypeError('options.niceIncrement must be a non-negative integer on Unix systems');\n    }\n    if (options.trackUnmanagedFds !== undefined &&\n        typeof options.trackUnmanagedFds !== 'boolean') {\n      throw new TypeError('options.trackUnmanagedFds must be a boolean value');\n    }\n    if (options.closeTimeout !== undefined && (typeof options.closeTimeout !== 'number' || options.closeTimeout < 0)) {\n      throw new TypeError('options.closeTimeout must be a non-negative integer');\n    }\n\n    this.#pool = new ThreadPool(this, options);\n  }\n\n  /** @deprecated Use run(task, options) instead **/\n  runTask (task : T, transferList? : TransferList, filename? : string, abortSignal? : AbortSignalAny) : Promise<R>;\n\n  /** @deprecated Use run(task, options) instead **/\n  runTask (task : T, transferList? : TransferList, filename? : AbortSignalAny, abortSignal? : undefined) : Promise<R>;\n\n  /** @deprecated Use run(task, options) instead **/\n  runTask (task : T, transferList? : string, filename? : AbortSignalAny, abortSignal? : undefined) : Promise<R>;\n\n  /** @deprecated Use run(task, options) instead **/\n  runTask (task : T, transferList? : AbortSignalAny, filename? : undefined, abortSignal? : undefined) : Promise<R>;\n\n  /** @deprecated Use run(task, options) instead **/\n  runTask (task : T, transferList? : any, filename? : any, signal? : any): Promise<R> {\n    // If transferList is a string or AbortSignal, shift it.\n    if ((typeof transferList === 'object' && !Array.isArray(transferList)) ||\n        typeof transferList === 'string') {\n      signal = filename as (AbortSignalAny | undefined);\n      filename = transferList;\n      transferList = undefined;\n    }\n    // If filename is an AbortSignal, shift it.\n    if (typeof filename === 'object' && !Array.isArray(filename)) {\n      signal = filename;\n      filename = undefined;\n    }\n\n    if (transferList !== undefined && !Array.isArray(transferList)) {\n      return Promise.reject(\n        new TypeError('transferList argument must be an Array'));\n    }\n    if (filename !== undefined && typeof filename !== 'string') {\n      return Promise.reject(\n        new TypeError('filename argument must be a string'));\n    }\n    if (signal !== undefined && typeof signal !== 'object') {\n      return Promise.reject(\n        new TypeError('signal argument must be an object'));\n    }\n    return this.#pool.runTask(\n      task, {\n        transferList,\n        filename: filename || null,\n        name: 'default',\n        signal: signal || null\n      });\n  }\n\n  run (task : T, options : RunOptions = kDefaultRunOptions): Promise<R> {\n    if (options === null || typeof options !== 'object') {\n      return Promise.reject(\n        new TypeError('options must be an object'));\n    }\n    const {\n      transferList,\n      filename,\n      name,\n      signal\n    } = options;\n    if (transferList !== undefined && !Array.isArray(transferList)) {\n      return Promise.reject(\n        new TypeError('transferList argument must be an Array'));\n    }\n    if (filename != null && typeof filename !== 'string') {\n      return Promise.reject(\n        new TypeError('filename argument must be a string'));\n    }\n    if (name != null && typeof name !== 'string') {\n      return Promise.reject(new TypeError('name argument must be a string'));\n    }\n    if (signal != null && typeof signal !== 'object') {\n      return Promise.reject(\n        new TypeError('signal argument must be an object'));\n    }\n    return this.#pool.runTask(task, { transferList, filename, name, signal });\n  }\n\n  async close (options : CloseOptions = kDefaultCloseOptions) {\n    if (options === null || typeof options !== 'object') {\n      throw TypeError('options must be an object');\n    }\n\n    let { force } = options;\n\n    if (force !== undefined && typeof force !== 'boolean') {\n      return Promise.reject(\n        new TypeError('force argument must be a boolean'));\n    }\n    force ??= kDefaultCloseOptions.force;\n\n    return this.#pool.close({\n      force\n    });\n  }\n\n  destroy () {\n    return this.#pool.destroy();\n  }\n\n  get maxThreads (): number {\n    return this.#pool.options.maxThreads;\n  }\n\n  get minThreads (): number {\n    return this.#pool.options.minThreads;\n  }\n\n  get options () : FilledOptions {\n    return this.#pool.options;\n  }\n\n  get threads () : Worker[] {\n    const ret : Worker[] = [];\n    for (const workerInfo of this.#pool.workers) { ret.push(workerInfo.worker); }\n    return ret;\n  }\n\n  get queueSize () : number {\n    const pool = this.#pool;\n    return Math.max(pool.taskQueue.size - pool.pendingCapacity(), 0);\n  }\n\n  get completed () : number {\n    return this.#pool.completed;\n  }\n\n  get waitTime () : any {\n    if (!this.#pool.waitTime) {\n      return null;\n    }\n\n    return createHistogramSummary(this.#pool.waitTime);\n  }\n\n  get runTime () : any {\n    if (!this.#pool.runTime) {\n      return null;\n    }\n\n    return createHistogramSummary(this.#pool.runTime);\n  }\n\n  get utilization () : number {\n    if (!this.#pool.runTime) {\n      return 0;\n    }\n\n    // count is available as of Node.js v16.14.0 but not present in the types\n    const count = (this.#pool.runTime as RecordableHistogram & { count: number}).count;\n    if (count === 0) {\n      return 0;\n    }\n\n    // The capacity is the max compute time capacity of the\n    // pool to this point in time as determined by the length\n    // of time the pool has been running multiplied by the\n    // maximum number of threads.\n    const capacity = this.duration * this.#pool.options.maxThreads;\n    const totalMeanRuntime = (this.#pool.runTime.mean / 1000) * count;\n\n    // We calculate the appoximate pool utilization by multiplying\n    // the mean run time of all tasks by the number of runtime\n    // samples taken and dividing that by the capacity. The\n    // theory here is that capacity represents the absolute upper\n    // limit of compute time this pool could ever attain (but\n    // never will for a variety of reasons. Multiplying the\n    // mean run time by the number of tasks sampled yields an\n    // approximation of the realized compute time. The utilization\n    // then becomes a point-in-time measure of how active the\n    // pool is.\n    return totalMeanRuntime / capacity;\n  }\n\n  get duration () : number {\n    return performance.now() - this.#pool.start;\n  }\n\n  get needsDrain () : boolean {\n    return this.#pool.needsDrain;\n  }\n\n  static get isWorkerThread () : boolean {\n    return commonState.isWorkerThread;\n  }\n\n  static get workerData () : any {\n    return commonState.workerData;\n  }\n\n  static get version () : string {\n    return version;\n  }\n\n  static get Piscina () {\n    return Piscina;\n  }\n\n  static get FixedQueue () {\n    return FixedQueue;\n  }\n\n  static get ArrayTaskQueue () {\n    return ArrayTaskQueue;\n  }\n\n  static move (val : Transferable | TransferListItem | ArrayBufferView | ArrayBuffer | MessagePort) {\n    if (val != null && typeof val === 'object' && typeof val !== 'function') {\n      if (!isTransferable(val)) {\n        if ((types as any).isArrayBufferView(val)) {\n          val = new ArrayBufferViewTransferable(val as ArrayBufferView);\n        } else {\n          val = new DirectlyTransferable(val);\n        }\n      }\n      markMovable(val);\n    }\n    return val;\n  }\n\n  static get transferableSymbol () { return kTransferable; }\n\n  static get valueSymbol () { return kValue; }\n\n  static get queueOptionsSymbol () { return kQueueOptions; }\n}\n\nexport const move = Piscina.move;\nexport const isWorkerThread = Piscina.isWorkerThread;\nexport const workerData = Piscina.workerData;\n\nexport {\n  Piscina,\n  PiscinaTask,\n  TaskQueue,\n  kTransferable as transferableSymbol,\n  kValue as valueSymbol,\n  kQueueOptions as queueOptionsSymbol,\n  version,\n  FixedQueue\n};\n",
    "symbols": [
      {
        "name": "DirectlyTransferable",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 136,
        "endLine": 145
      },
      {
        "name": "ArrayBufferViewTransferable",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 147,
        "endLine": 156
      },
      {
        "name": "ThreadPool",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 158,
        "endLine": 662
      },
      {
        "name": "ThreadPool._ensureMinimumWorkers",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 213,
        "endLine": 220
      },
      {
        "name": "ThreadPool._addNewWorker",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 222,
        "endLine": 315
      },
      {
        "name": "ThreadPool._onError",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 317,
        "endLine": 346
      },
      {
        "name": "ThreadPool._processPendingMessages",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 348,
        "endLine": 361
      },
      {
        "name": "ThreadPool._removeWorker",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 363,
        "endLine": 367
      },
      {
        "name": "ThreadPool._onWorkerAvailable",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 369,
        "endLine": 405
      },
      {
        "name": "ThreadPool.runTask",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 407,
        "endLine": 545
      },
      {
        "name": "ThreadPool.pendingCapacity",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 547,
        "endLine": 550
      },
      {
        "name": "ThreadPool._maybeDrain",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 552,
        "endLine": 565
      },
      {
        "name": "ThreadPool.destroy",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 567,
        "endLine": 590
      },
      {
        "name": "ThreadPool.close",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 592,
        "endLine": 661
      },
      {
        "name": "onMessage",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 251,
        "endLine": 271
      },
      {
        "name": "onReady",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 273,
        "endLine": 281
      },
      {
        "name": "onEventMessage",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 283,
        "endLine": 285
      },
      {
        "name": "Piscina",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 664,
        "endLine": 954
      },
      {
        "name": "Piscina.runTask",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 743,
        "endLine": 776
      },
      {
        "name": "Piscina.run",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 778,
        "endLine": 805
      },
      {
        "name": "Piscina.close",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 807,
        "endLine": 823
      },
      {
        "name": "Piscina.destroy",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 825,
        "endLine": 827
      },
      {
        "name": "Piscina.move",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/index.ts",
        "startLine": 935,
        "endLine": 947
      }
    ]
  },
  {
    "path": "node_modules/piscina/src/main.ts",
    "content": "import Piscina from './index';\n\n// Used as the require() entry point to maintain existing behavior\nexport = Piscina;\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/src/symbols.ts",
    "content": "// Internal symbol used to mark Transferable objects returned\n// by the Piscina.move() function\nexport const kMovable = Symbol('Piscina.kMovable');\nexport const kTransferable = Symbol.for('Piscina.transferable');\nexport const kValue = Symbol.for('Piscina.valueOf');\nexport const kQueueOptions = Symbol.for('Piscina.queueOptions');\nexport const kRequestCountField = 0;\nexport const kResponseCountField = 1;\nexport const kFieldCount = 2;\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/src/types.ts",
    "content": "import type { MessagePort, Worker } from 'node:worker_threads';\n\nimport type { READY } from './common';\nimport type { kTransferable, kValue } from './symbols';\n\nexport interface StartupMessage {\n  filename: string | null\n  name: string\n  port: MessagePort\n  sharedBuffer: Int32Array\n  useAtomics: boolean\n  niceIncrement: number\n}\n\nexport interface RequestMessage {\n  taskId: number\n  task: any\n  filename: string\n  name: string\n}\n\nexport interface ReadyMessage {\n  [READY]: true\n}\n\nexport interface ResponseMessage {\n  taskId: number\n  result: any\n  error: Error | null\n}\nexport const commonState = {\n  isWorkerThread: false,\n  workerData: undefined\n};\n\nexport interface Transferable {\n  readonly [kTransferable]: object;\n  readonly [kValue]: object;\n}\n\n/* eslint-disable camelcase */\nexport interface HistogramSummary {\n  average: number;\n  mean: number;\n  stddev: number;\n  min: number;\n  max: number;\n  p0_001: number;\n  p0_01: number;\n  p0_1: number;\n  p1: number;\n  p2_5: number;\n  p10: number;\n  p25: number;\n  p50: number;\n  p75: number;\n  p90: number;\n  p97_5: number;\n  p99: number;\n  p99_9: number;\n  p99_99: number;\n  p99_999: number;\n}\n/* eslint-enable camelcase */\n\nexport type ResourceLimits = Worker extends {\n  resourceLimits?: infer T;\n}\n  ? T\n  : {};\nexport type EnvSpecifier = typeof Worker extends {\n  new (filename: never, options?: { env: infer T }): Worker;\n}\n  ? T\n  : never;\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/src/worker.ts",
    "content": "import { parentPort, MessagePort, receiveMessageOnPort, workerData } from 'node:worker_threads';\nimport { pathToFileURL } from 'node:url';\n\nimport type {\n  ReadyMessage,\n  RequestMessage,\n  ResponseMessage,\n  StartupMessage\n} from './types';\nimport {\n  kResponseCountField,\n  kRequestCountField,\n  kTransferable,\n  kValue\n} from './symbols';\nimport {\n  READY,\n  commonState,\n  isMovable\n} from './common';\n\ncommonState.isWorkerThread = true;\ncommonState.workerData = workerData;\n\nconst handlerCache : Map<string, Function> = new Map();\nlet useAtomics : boolean = process.env.PISCINA_DISABLE_ATOMICS !== '1';\n\n// Get `import(x)` as a function that isn't transpiled to `require(x)` by\n// TypeScript for dual ESM/CJS support.\n// Load this lazily, so that there is no warning about the ESM loader being\n// experimental (on Node v12.x) until we actually try to use it.\nlet importESMCached : (specifier : string) => Promise<any> | undefined;\nfunction getImportESM () {\n  if (importESMCached === undefined) {\n    // eslint-disable-next-line no-new-func\n    importESMCached = new Function('specifier', 'return import(specifier)') as typeof importESMCached;\n  }\n  return importESMCached;\n}\n\n// Look up the handler function that we call when a task is posted.\n// This is either going to be \"the\" export from a file, or the default export.\nasync function getHandler (filename : string, name : string) : Promise<Function | null> {\n  let handler = handlerCache.get(`${filename}/${name}`);\n  if (handler !== undefined) {\n    return handler;\n  }\n\n  try {\n    // With our current set of TypeScript options, this is transpiled to\n    // `require(filename)`.\n    handler = await import(filename);\n    if (typeof handler !== 'function') {\n      handler = await ((handler as any)[name]);\n    }\n  } catch {}\n  if (typeof handler !== 'function') {\n    handler = await getImportESM()(pathToFileURL(filename).href);\n    if (typeof handler !== 'function') {\n      handler = await ((handler as any)[name]);\n    }\n  }\n  if (typeof handler !== 'function') {\n    return null;\n  }\n\n  // Limit the handler cache size. This should not usually be an issue and is\n  // only provided for pathological cases.\n  if (handlerCache.size > 1000) {\n    const [[key]] = handlerCache;\n    handlerCache.delete(key);\n  }\n\n  handlerCache.set(`${filename}/${name}`, handler);\n  return handler;\n}\n\n// We should only receive this message once, when the Worker starts. It gives\n// us the MessagePort used for receiving tasks, a SharedArrayBuffer for fast\n// communication using Atomics, and the name of the default filename for tasks\n// (so we can pre-load and cache the handler).\nparentPort!.on('message', (message: StartupMessage) => {\n  useAtomics = process.env.PISCINA_DISABLE_ATOMICS === '1' ? false : message.useAtomics;\n  const { port, sharedBuffer, filename, name, niceIncrement } = message;\n  (async function () {\n    try {\n      if (niceIncrement !== 0) {\n        (await import('@napi-rs/nice')).nice(niceIncrement);\n      }\n    } catch {}\n\n    if (filename !== null) {\n      await getHandler(filename, name);\n    }\n\n    const readyMessage : ReadyMessage = { [READY]: true };\n    parentPort!.postMessage(readyMessage);\n\n    port.on('message', onMessage.bind(null, port, sharedBuffer));\n    atomicsWaitLoop(port, sharedBuffer);\n  })().catch(throwInNextTick);\n});\n\nlet currentTasks : number = 0;\nlet lastSeenRequestCount : number = 0;\nfunction atomicsWaitLoop (port : MessagePort, sharedBuffer : Int32Array) {\n  if (!useAtomics) return;\n\n  // This function is entered either after receiving the startup message, or\n  // when we are done with a task. In those situations, the *only* thing we\n  // expect to happen next is a 'message' on `port`.\n  // That call would come with the overhead of a C++ → JS boundary crossing,\n  // including async tracking. So, instead, if there is no task currently\n  // running, we wait for a signal from the parent thread using Atomics.wait(),\n  // and read the message from the port instead of generating an event,\n  // in order to avoid that overhead.\n  // The one catch is that this stops asynchronous operations that are still\n  // running from proceeding. Generally, tasks should not spawn asynchronous\n  // operations without waiting for them to finish, though.\n  while (currentTasks === 0) {\n    // Check whether there are new messages by testing whether the current\n    // number of requests posted by the parent thread matches the number of\n    // requests received.\n    Atomics.wait(sharedBuffer, kRequestCountField, lastSeenRequestCount);\n    lastSeenRequestCount = Atomics.load(sharedBuffer, kRequestCountField);\n\n    // We have to read messages *after* updating lastSeenRequestCount in order\n    // to avoid race conditions.\n    let entry;\n    while ((entry = receiveMessageOnPort(port)) !== undefined) {\n      onMessage(port, sharedBuffer, entry.message);\n    }\n  }\n}\n\nfunction onMessage (\n  port : MessagePort,\n  sharedBuffer : Int32Array,\n  message : RequestMessage) {\n  currentTasks++;\n  const { taskId, task, filename, name } = message;\n\n  (async function () {\n    let response : ResponseMessage;\n    let transferList : any[] = [];\n    try {\n      const handler = await getHandler(filename, name);\n      if (handler === null) {\n        throw new Error(`No handler function exported from ${filename}`);\n      }\n      let result = await handler(task);\n      if (isMovable(result)) {\n        transferList = transferList.concat(result[kTransferable]);\n        result = result[kValue];\n      }\n      response = {\n        taskId,\n        result: result,\n        error: null\n      };\n\n      // If the task used e.g. console.log(), wait for the stream to drain\n      // before potentially entering the `Atomics.wait()` loop, and before\n      // returning the result so that messages will always be printed even\n      // if the process would otherwise be ready to exit.\n      if (process.stdout.writableLength > 0) {\n        await new Promise((resolve) => process.stdout.write('', resolve));\n      }\n      if (process.stderr.writableLength > 0) {\n        await new Promise((resolve) => process.stderr.write('', resolve));\n      }\n    } catch (error) {\n      response = {\n        taskId,\n        result: null,\n        // It may be worth taking a look at the error cloning algorithm we\n        // use in Node.js core here, it's quite a bit more flexible\n        error: <Error>error\n      };\n    }\n    currentTasks--;\n\n    // Post the response to the parent thread, and let it know that we have\n    // an additional message available. If possible, use Atomics.wait()\n    // to wait for the next message.\n    port.postMessage(response, transferList);\n    Atomics.add(sharedBuffer, kResponseCountField, 1);\n    atomicsWaitLoop(port, sharedBuffer);\n  })().catch(throwInNextTick);\n}\n\nfunction throwInNextTick (error : Error) {\n  process.nextTick(() => { throw error; });\n}\n",
    "symbols": [
      {
        "name": "getImportESM",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker.ts",
        "startLine": 33,
        "endLine": 39
      },
      {
        "name": "getHandler",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker.ts",
        "startLine": 43,
        "endLine": 76
      },
      {
        "name": "atomicsWaitLoop",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker.ts",
        "startLine": 106,
        "endLine": 134
      },
      {
        "name": "onMessage",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker.ts",
        "startLine": 136,
        "endLine": 190
      },
      {
        "name": "throwInNextTick",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker.ts",
        "startLine": 192,
        "endLine": 194
      }
    ]
  },
  {
    "path": "node_modules/piscina/test/abort-task.ts",
    "content": "import { EventEmitter } from 'events';\nimport Piscina from '..';\nimport { test } from 'tap';\nimport { resolve } from 'path';\n\ntest('tasks can be aborted through AbortController while running', async ({ equal, rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/notify-then-sleep.ts')\n  });\n\n  const buf = new Int32Array(new SharedArrayBuffer(4));\n  const abortController = new AbortController();\n  rejects(pool.runTask(buf, abortController.signal),\n    /The task has been aborted/);\n\n  Atomics.wait(buf, 0, 0);\n  equal(Atomics.load(buf, 0), 1);\n\n  abortController.abort();\n});\n\ntest('tasks can be aborted through EventEmitter while running', async ({ equal, rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/notify-then-sleep.ts')\n  });\n\n  const buf = new Int32Array(new SharedArrayBuffer(4));\n  const ee = new EventEmitter();\n  rejects(pool.runTask(buf, ee), /The task has been aborted/);\n  rejects(pool.run(buf, { signal: ee }), /The task has been aborted/);\n\n  Atomics.wait(buf, 0, 0);\n  equal(Atomics.load(buf, 0), 1);\n\n  ee.emit('abort');\n});\n\ntest('tasks can be aborted through EventEmitter before running', async ({ equal, rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/wait-for-notify.ts'),\n    maxThreads: 1\n  });\n\n  const bufs = [\n    new Int32Array(new SharedArrayBuffer(4)),\n    new Int32Array(new SharedArrayBuffer(4))\n  ];\n  const task1 = pool.runTask(bufs[0]);\n  const ee = new EventEmitter();\n  rejects(pool.runTask(bufs[1], ee), /The task has been aborted/);\n  rejects(pool.run(bufs[1], { signal: ee }), /The task has been aborted/);\n  equal(pool.queueSize, 2);\n\n  ee.emit('abort');\n\n  // Wake up the thread handling the first task.\n  Atomics.store(bufs[0], 0, 1);\n  Atomics.notify(bufs[0], 0, 1);\n  await task1;\n});\n\ntest('abortable tasks will not share workers (abortable posted second)', async ({ equal, rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/wait-for-notify.ts'),\n    maxThreads: 1,\n    concurrentTasksPerWorker: 2\n  });\n\n  const bufs = [\n    new Int32Array(new SharedArrayBuffer(4)),\n    new Int32Array(new SharedArrayBuffer(4))\n  ];\n  const task1 = pool.runTask(bufs[0]);\n  const ee = new EventEmitter();\n  rejects(pool.runTask(bufs[1], ee), /The task has been aborted/);\n  equal(pool.queueSize, 1);\n\n  ee.emit('abort');\n\n  // Wake up the thread handling the first task.\n  Atomics.store(bufs[0], 0, 1);\n  Atomics.notify(bufs[0], 0, 1);\n  await task1;\n});\n\ntest('abortable tasks will not share workers (abortable posted first)', async ({ equal, rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    maxThreads: 1,\n    concurrentTasksPerWorker: 2\n  });\n\n  const ee = new EventEmitter();\n  rejects(pool.runTask('while(true);', ee), /The task has been aborted/);\n  const task2 = pool.runTask('42');\n  equal(pool.queueSize, 1);\n\n  ee.emit('abort');\n\n  // Wake up the thread handling the second task.\n  equal(await task2, 42);\n});\n\ntest('abortable tasks will not share workers (on worker available)', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/sleep.js'),\n    maxThreads: 1,\n    concurrentTasksPerWorker: 2\n  });\n\n  // Task 1 will sleep 100 ms then complete,\n  // Task 2 will sleep 300 ms then complete.\n  // Abortable task 3 should still be in the queue\n  // when Task 1 completes, but should not be selected\n  // until after Task 2 completes because it is abortable.\n\n  const ret = await Promise.all([\n    pool.runTask({ time: 100, a: 1 }),\n    pool.runTask({ time: 300, a: 2 }),\n    pool.runTask({ time: 100, a: 3 }, new EventEmitter())\n  ]);\n\n  equal(ret[0], 0);\n  equal(ret[1], 1);\n  equal(ret[2], 2);\n});\n\ntest('abortable tasks will not share workers (destroy workers)', async ({ rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/sleep.js'),\n    maxThreads: 1,\n    concurrentTasksPerWorker: 2\n  });\n\n  // Task 1 will sleep 100 ms then complete,\n  // Task 2 will sleep 300 ms then complete.\n  // Abortable task 3 should still be in the queue\n  // when Task 1 completes, but should not be selected\n  // until after Task 2 completes because it is abortable.\n\n  pool.runTask({ time: 100, a: 1 }).then(() => {\n    pool.destroy();\n  });\n\n  rejects(pool.runTask({ time: 300, a: 2 }), /Terminating worker thread/);\n  rejects(pool.runTask({ time: 100, a: 3 }, new EventEmitter()),\n    /Terminating worker thread/);\n});\n\ntest('aborted AbortSignal rejects task immediately', async ({ rejects, equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/move.ts')\n  });\n\n  const controller = new AbortController();\n  // Abort the controller early\n  controller.abort();\n  equal(controller.signal.aborted, true);\n\n  // The data won't be moved because the task will abort immediately.\n  const data = new Uint8Array(new SharedArrayBuffer(4));\n  rejects(pool.runTask(data, [data.buffer], controller.signal),\n    /The task has been aborted/);\n\n  equal(data.length, 4);\n});\n\ntest('task with AbortSignal cleans up properly', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  const ee = new EventEmitter();\n\n  await pool.runTask('1+1', ee);\n\n  const { getEventListeners } = EventEmitter as any;\n  if (typeof getEventListeners === 'function') {\n    equal(getEventListeners(ee, 'abort').length, 0);\n  }\n\n  const controller = new AbortController();\n\n  await pool.runTask('1+1', controller.signal);\n});\n\ntest('aborted AbortSignal rejects task immediately (with reason)', async ({ match, equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/move.ts')\n  });\n  const customReason = new Error('custom reason');\n\n  const controller = new AbortController();\n  controller.abort(customReason);\n  equal(controller.signal.aborted, true);\n  equal(controller.signal.reason, customReason);\n\n  // The data won't be moved because the task will abort immediately.\n  const data = new Uint8Array(new SharedArrayBuffer(4));\n\n  try {\n    await pool.run(data, { transferList: [data.buffer], signal: controller.signal });\n  } catch (error) {\n    equal(error.message, 'The task has been aborted');\n    match(error.cause, customReason);\n  }\n\n  equal(data.length, 4);\n});\n\ntest('tasks can be aborted through AbortController while running', async ({ equal, match }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/notify-then-sleep.ts')\n  });\n  const reason = new Error('custom reason');\n\n  const buf = new Int32Array(new SharedArrayBuffer(4));\n  const abortController = new AbortController();\n\n  try {\n    const promise = pool.run(buf, { signal: abortController.signal });\n\n    Atomics.wait(buf, 0, 0);\n    equal(Atomics.load(buf, 0), 1);\n\n    abortController.abort(reason);\n\n    await promise;\n  } catch (error) {\n    equal(error.message, 'The task has been aborted');\n    match(error.cause, reason);\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/async-context.ts",
    "content": "import { createHook, executionAsyncId } from 'async_hooks';\nimport Piscina from '..';\nimport { test } from 'tap';\nimport { resolve } from 'path';\n\ntest('postTask() calls the correct async hooks', async ({ equal }) => {\n  let taskId;\n  let initCalls = 0;\n  let beforeCalls = 0;\n  let afterCalls = 0;\n  let resolveCalls = 0;\n\n  const hook = createHook({\n    init (id, type) {\n      if (type === 'Piscina.Task') {\n        initCalls++;\n        taskId = id;\n      }\n    },\n    before (id) {\n      if (id === taskId) beforeCalls++;\n    },\n    after (id) {\n      if (id === taskId) afterCalls++;\n    },\n    promiseResolve () {\n      if (executionAsyncId() === taskId) resolveCalls++;\n    }\n  });\n  hook.enable();\n\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  await pool.runTask('42');\n\n  hook.disable();\n  equal(initCalls, 1);\n  equal(beforeCalls, 1);\n  equal(afterCalls, 1);\n  equal(resolveCalls, 1);\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/atomics-optimization.ts",
    "content": "import Piscina from '..';\nimport { test } from 'tap';\nimport { resolve } from 'path';\n\ntest('coverage test for Atomics optimization', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/notify-then-sleep-or.js'),\n    minThreads: 2,\n    maxThreads: 2,\n    concurrentTasksPerWorker: 2\n  });\n\n  const tasks = [];\n  let v : number;\n\n  // Post 4 tasks, and wait for all of them to be ready.\n  const i32array = new Int32Array(new SharedArrayBuffer(4));\n  for (let index = 0; index < 4; index++) {\n    tasks.push(pool.runTask({ i32array, index }));\n  }\n\n  // Wait for 2 tasks to enter 'wait' state.\n  do {\n    v = Atomics.load(i32array, 0);\n    if (popcount8(v) >= 2) break;\n    Atomics.wait(i32array, 0, v);\n  } while (true);\n\n  // The check above could also be !== 2 but it's hard to get things right\n  // sometimes and this gives us a nice assertion. Basically, at this point\n  // exactly 2 tasks should be in Atomics.wait() state.\n  equal(popcount8(v), 2);\n  // Wake both tasks up as simultaneously as possible. The other 2 tasks should\n  // then start executing.\n  Atomics.store(i32array, 0, 0);\n  Atomics.notify(i32array, 0, Infinity);\n\n  // Wait for the other 2 tasks to enter 'wait' state.\n  do {\n    v = Atomics.load(i32array, 0);\n    if (popcount8(v) >= 2) break;\n    Atomics.wait(i32array, 0, v);\n  } while (true);\n\n  // At this point, the first two tasks are definitely finished and have\n  // definitely posted results back to the main thread, and the main thread\n  // has definitely not received them yet, meaning that the Atomics check will\n  // be used. Making sure that that works is the point of this test.\n\n  // Wake up the remaining 2 tasks in order to make sure that the test finishes.\n  // Do the same consistency check beforehand as above.\n  equal(popcount8(v), 2);\n  Atomics.store(i32array, 0, 0);\n  Atomics.notify(i32array, 0, Infinity);\n\n  await Promise.all(tasks);\n});\n\n// Inefficient but straightforward 8-bit popcount\nfunction popcount8 (v : number) : number {\n  v &= 0xff;\n  if (v & 0b11110000) return popcount8(v >>> 4) + popcount8(v & 0xb00001111);\n  if (v & 0b00001100) return popcount8(v >>> 2) + popcount8(v & 0xb00000011);\n  if (v & 0b00000010) return popcount8(v >>> 1) + popcount8(v & 0xb00000001);\n  return v;\n}\n\ntest('avoids unbounded recursion', async () => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/simple-isworkerthread.ts'),\n    minThreads: 2,\n    maxThreads: 2\n  });\n\n  const tasks = [];\n  for (let i = 1; i <= 10000; i++) {\n    tasks.push(pool.runTask(null));\n  }\n\n  await Promise.all(tasks);\n});\n",
    "symbols": [
      {
        "name": "popcount8",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/atomics-optimization.ts",
        "startLine": 60,
        "endLine": 66
      }
    ]
  },
  {
    "path": "node_modules/piscina/test/console-log.ts",
    "content": "import concat from 'concat-stream';\nimport { spawn } from 'child_process';\nimport { resolve } from 'path';\nimport { test } from 'tap';\n\ntest('console.log() calls are not blocked by Atomics.wait()', async ({ equal }) => {\n  const proc = spawn(process.execPath, [\n    ...process.execArgv, resolve(__dirname, 'fixtures/console-log.ts')\n  ], {\n    stdio: ['inherit', 'pipe', 'inherit']\n  });\n\n  const data = await new Promise((resolve) => {\n    proc.stdout.setEncoding('utf8').pipe(concat(resolve));\n  });\n  equal(data, 'A\\nB\\n');\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/fixed-queue.ts",
    "content": "import { test } from 'tap';\nimport { kQueueOptions } from '../dist/symbols';\nimport { Piscina, FixedQueue, PiscinaTask as Task } from '..';\nimport { resolve } from 'node:path';\n\n// @ts-expect-error - it misses several properties, but it's enough for the test\nclass QueueTask implements Task {\n  get [kQueueOptions] () {\n    return null;\n  }\n}\n\ntest('queue length', async ({ equal }) => {\n  const queue = new FixedQueue();\n\n  equal(queue.size, 0);\n\n  queue.push(new QueueTask());\n\n  equal(queue.size, 1);\n\n  queue.shift();\n\n  equal(queue.size, 0);\n});\n\ntest('queue length should not become negative', async ({ equal }) => {\n  const queue = new FixedQueue();\n\n  equal(queue.size, 0);\n\n  queue.shift();\n\n  equal(queue.size, 0);\n});\n\ntest('queue remove', async ({ equal }) => {\n  const queue = new FixedQueue();\n\n  const task = new QueueTask();\n\n  equal(queue.size, 0, 'should be empty on start');\n\n  queue.push(task);\n\n  equal(queue.size, 1, 'should contain single task after push');\n\n  queue.remove(task);\n\n  equal(queue.size, 0, 'should be empty after task removal');\n});\n\ntest('remove not queued task should not lead to errors', async ({ equal }) => {\n  const queue = new FixedQueue();\n\n  const task = new QueueTask();\n\n  equal(queue.size, 0, 'should be empty on start');\n\n  queue.remove(task);\n\n  equal(queue.size, 0, 'should be empty after task removal');\n});\n\ntest('removing elements from intermediate CircularBuffer should not lead to issues', async ({ equal, same }) => {\n  /*\n      The test intends to check following scenario:\n      1) We fill the queue with 3 full circular buffers amount of items.\n      2) Empty the middle circular buffer with remove().\n      3) This should lead to the removal of the middle buffer from the queue:\n         - Before emptying: tail buffer -> middle buffer -> head buffer.\n         - After emptying: tail buffer -> head buffer.\n   */\n\n  const queue = new FixedQueue();\n\n  // size of single circular buffer\n  const batchSize = 2047;\n\n  const firstBatch = Array.from({ length: batchSize }, () => new QueueTask());\n  const secondBatch = Array.from({ length: batchSize }, () => new QueueTask());\n  const thirdBatch = Array.from({ length: batchSize }, () => new QueueTask());\n\n  const tasks = firstBatch.concat(secondBatch, thirdBatch);\n\n  for (const task of tasks) {\n    queue.push(task);\n  }\n  equal(queue.size, tasks.length, `should contain ${batchSize} * 3 items`);\n\n  let size = queue.size;\n  for (const task of secondBatch) {\n    queue.remove(task);\n    equal(queue.size, --size, `should contain ${size} items`);\n  }\n\n  const expected = firstBatch.concat(thirdBatch);\n  const actual = [];\n  while (!queue.isEmpty()) {\n    const task = queue.shift();\n    actual.push(task);\n  }\n  same(actual, expected);\n});\n\ntest('removing elements from first CircularBuffer should not lead to issues', async ({ equal, same }) => {\n  /*\n      The test intends to check following scenario:\n      1) We fill the queue with 3 full circular buffers amount of items.\n      2) Empty the first circular buffer with remove().\n      3) This should lead to the removal of the tail buffer from the queue:\n         - Before emptying: tail buffer -> middle buffer -> head buffer.\n         - After emptying: tail buffer (previously middle) -> head buffer.\n   */\n  const queue = new FixedQueue();\n\n  // size of single circular buffer\n  const batchSize = 2047;\n\n  const firstBatch = Array.from({ length: batchSize }, () => new QueueTask());\n  const secondBatch = Array.from({ length: batchSize }, () => new QueueTask());\n  const thirdBatch = Array.from({ length: batchSize }, () => new QueueTask());\n\n  const tasks = firstBatch.concat(secondBatch, thirdBatch);\n\n  for (const task of tasks) {\n    queue.push(task);\n  }\n  equal(queue.size, tasks.length, `should contain ${batchSize} * 3 items`);\n\n  let size = queue.size;\n  for (const task of firstBatch) {\n    queue.remove(task);\n    equal(queue.size, --size, `should contain ${size} items`);\n  }\n\n  const expected = secondBatch.concat(thirdBatch);\n  const actual = [];\n  while (!queue.isEmpty()) {\n    const task = queue.shift();\n    actual.push(task);\n  }\n  same(actual, expected);\n});\n\ntest('removing elements from last CircularBuffer should not lead to issues', async ({ equal, same }) => {\n  /*\n      The test intends to check following scenario:\n      1) We fill the queue with 3 full circular buffers amount of items.\n      2) Empty the last circular buffer with remove().\n      3) This should lead to the removal of the head buffer from the queue:\n         - Before emptying: tail buffer -> middle buffer -> head buffer.\n         - After emptying: tail buffer -> head buffer (previously middle).\n   */\n  const queue = new FixedQueue();\n\n  // size of single circular buffer\n  const batchSize = 2047;\n\n  const firstBatch = Array.from({ length: batchSize }, () => new QueueTask());\n  const secondBatch = Array.from({ length: batchSize }, () => new QueueTask());\n  const thirdBatch = Array.from({ length: batchSize }, () => new QueueTask());\n\n  const tasks = firstBatch.concat(secondBatch, thirdBatch);\n\n  for (const task of tasks) {\n    queue.push(task);\n  }\n  equal(queue.size, tasks.length, `should contain ${batchSize} * 3 items`);\n\n  let size = queue.size;\n  for (const task of thirdBatch) {\n    queue.remove(task);\n    equal(queue.size, --size, `should contain ${size} items`);\n  }\n\n  const expected = firstBatch.concat(secondBatch);\n  const actual = [];\n  while (!queue.isEmpty()) {\n    const task = queue.shift();\n    actual.push(task);\n  }\n  same(actual, expected);\n});\n\ntest('simple integraion with Piscina', async ({ equal }) => {\n  const queue = new FixedQueue();\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/simple-isworkerthread-named-import.ts'),\n    taskQueue: queue\n  });\n\n  const result = await pool.runTask(null);\n  equal(result, 'done');\n});\n\ntest('concurrent calls with Piscina', async ({ same }) => {\n  const queue = new FixedQueue();\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval-async.js'),\n    taskQueue: queue\n  });\n\n  const tasks = ['1+1', '2+2', '3+3'];\n  const results = await Promise.all(tasks.map((task) => pool.runTask(task)));\n  // eslint-disable-next-line\n  const expected = tasks.map(eval);\n\n  same(results, expected);\n});\n",
    "symbols": [
      {
        "name": "QueueTask",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/fixed-queue.ts",
        "startLine": 7,
        "endLine": 11
      }
    ]
  },
  {
    "path": "node_modules/piscina/test/generics.ts",
    "content": "import { resolve } from 'path';\nimport Piscina from '..';\nimport { test } from 'tap';\n\ntest('Piscina<T , R> works', async ({ equal }) => {\n  const worker = new Piscina<string, number>({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  const result: number = await worker.run('Promise.resolve(42)');\n  equal(result, 42);\n});\n\ntest('Piscina with no generic works', async ({ equal }) => {\n  const worker = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  const result = await worker.run('Promise.resolve(\"Hello, world!\")');\n  equal(result, 'Hello, world!');\n});\n\ntest('Piscina<T, R> typescript complains when invalid Task is supplied as wrong type', async ({ equal }) => {\n  const worker = new Piscina<string, number>({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  // @ts-expect-error complains due to invalid Task being number when expecting string\n  const result = await worker.run(42);\n\n  equal(result, 42);\n});\n\ntest('Piscina<T, R> typescript complains when assigning Result to wrong type', async ({ equal }) => {\n  const worker = new Piscina<string, number>({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  // @ts-expect-error complains due to expecting a number but being assigned to a string\n  const result: string = await worker.run('Promise.resolve(42)');\n  equal(result, 42);\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/histogram.ts",
    "content": "import Piscina from '..';\nimport { test } from 'tap';\nimport { resolve } from 'path';\n\ntest('pool will maintain run and wait time histograms by default', async ({ equal, ok }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  const tasks = [];\n  for (let n = 0; n < 10; n++) {\n    tasks.push(pool.runTask('42'));\n  }\n  await Promise.all(tasks);\n\n  const waitTime = pool.waitTime as any;\n  ok(waitTime);\n  equal(typeof waitTime.average, 'number');\n  equal(typeof waitTime.mean, 'number');\n  equal(typeof waitTime.stddev, 'number');\n  equal(typeof waitTime.min, 'number');\n  equal(typeof waitTime.max, 'number');\n\n  const runTime = pool.runTime as any;\n  ok(runTime);\n  equal(typeof runTime.average, 'number');\n  equal(typeof runTime.mean, 'number');\n  equal(typeof runTime.stddev, 'number');\n  equal(typeof runTime.min, 'number');\n  equal(typeof runTime.max, 'number');\n});\n\ntest('pool will maintain run and wait time histograms when recordTiming is true', async ({ ok }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    recordTiming: true\n  });\n\n  const tasks = [];\n  for (let n = 0; n < 10; n++) {\n    tasks.push(pool.runTask('42'));\n  }\n  await Promise.all(tasks);\n\n  const waitTime = pool.waitTime as any;\n  ok(waitTime);\n\n  const runTime = pool.runTime as any;\n  ok(runTime);\n});\n\ntest('pool does not maintain run and wait time histograms when recordTiming is false', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    recordTiming: false\n  });\n\n  const tasks = [];\n  for (let n = 0; n < 10; n++) {\n    tasks.push(pool.runTask('42'));\n  }\n  await Promise.all(tasks);\n\n  equal(pool.waitTime, null);\n  equal(pool.runTime, null);\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/idle-timeout.ts",
    "content": "import Piscina from '..';\nimport { test } from 'tap';\nimport { resolve } from 'path';\nimport { promisify } from 'util';\n\nconst delay = promisify(setTimeout);\n\ntest('idle timeout will let go of threads early', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/wait-for-others.ts'),\n    idleTimeout: 500,\n    minThreads: 1,\n    maxThreads: 2\n  });\n\n  equal(pool.threads.length, 1);\n  const buffer = new Int32Array(new SharedArrayBuffer(4));\n\n  const firstTasks = [\n    pool.runTask([buffer, 2]),\n    pool.runTask([buffer, 2])\n  ];\n  equal(pool.threads.length, 2);\n\n  const earlyThreadIds = await Promise.all(firstTasks);\n  equal(pool.threads.length, 2);\n\n  await delay(2000);\n  equal(pool.threads.length, 1);\n\n  const secondTasks = [\n    pool.runTask([buffer, 4]),\n    pool.runTask([buffer, 4])\n  ];\n  equal(pool.threads.length, 2);\n\n  const lateThreadIds = await Promise.all(secondTasks);\n\n  // One thread should have been idle in between and exited, one should have\n  // been reused.\n  equal(earlyThreadIds.length, 2);\n  equal(lateThreadIds.length, 2);\n  equal(new Set([...earlyThreadIds, ...lateThreadIds]).size, 3);\n});\n\ntest('idle timeout will not let go of threads if Infinity is used as the value', async ({ deepEqual, equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/wait-for-others.ts'),\n    idleTimeout: Infinity,\n    minThreads: 1,\n    maxThreads: 2\n  });\n  equal(pool.threads.length, 1);\n  const buffer = new Int32Array(new SharedArrayBuffer(4));\n\n  const firstTasks = [\n    pool.run([buffer, 2]),\n    pool.run([buffer, 2])\n  ];\n  equal(pool.threads.length, 2);\n\n  const earlyThreadIds = await Promise.all(firstTasks);\n  equal(pool.threads.length, 2);\n\n  await delay(2000);\n  equal(pool.threads.length, 2);\n\n  const secondTasks = [\n    pool.run([buffer, 4]),\n    pool.run([buffer, 4])\n  ];\n  equal(pool.threads.length, 2);\n\n  const lateThreadIds = await Promise.all(secondTasks);\n  deepEqual(earlyThreadIds, lateThreadIds);\n\n  await Promise.all([pool.run([buffer, 6]), pool.run([buffer, 6]), pool.run([buffer, 6])]);\n  equal(pool.threads.length, 2);\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/issue-513.ts",
    "content": "import Piscina from '..';\nimport { test } from 'tap';\nimport { resolve } from 'path';\n\ntest('pool will maintain run and wait time histograms', async ({\n  equal,\n  fail\n}) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/vm.js')\n  });\n\n  try {\n    await pool.run({ payload: 'throw new Error(\"foo\")' });\n    fail('Expected an error');\n  } catch (error) {\n    equal(error.message, 'foo');\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/load-with-esm.ts",
    "content": "import { test } from 'tap';\n\nconst importESM : (specifier : string) => Promise<any> =\n  // eslint-disable-next-line no-eval\n  eval('(specifier) => import(specifier)');\n\ntest('Piscina is default export', {}, async ({ equal }) => {\n  equal((await importESM('piscina')).default, require('../'));\n});\n\ntest('Exports match own property names', {}, async ({ strictSame }) => {\n  // Check that version, workerData, etc. are re-exported.\n  const exported = new Set(Object.getOwnPropertyNames(await importESM('piscina')));\n  const required = new Set(Object.getOwnPropertyNames(require('../')));\n\n  // Remove constructor properties + default export.\n  for (const k of ['prototype', 'length', 'name']) required.delete(k);\n  exported.delete('default');\n\n  strictSame(exported, required);\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/messages.ts",
    "content": "import Piscina from '..';\nimport { test } from 'tap';\nimport { resolve } from 'path';\nimport { once } from 'events';\n\ntest('Pool receive message from workers', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  const messagePromise = once(pool, 'message');\n\n  const taskResult = pool.runTask(`\n        require('worker_threads').parentPort.postMessage(\"some message\");\n        42\n    `);\n  equal(await taskResult, 42);\n  equal((await messagePromise)[0], 'some message');\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/move-test.ts",
    "content": "import Piscina from '..';\nimport {\n  isMovable,\n  markMovable,\n  isTransferable\n} from '../dist/common';\nimport { test } from 'tap';\nimport { types } from 'util';\nimport { MessageChannel, MessagePort } from 'worker_threads';\nimport { resolve } from 'path';\n\nconst {\n  transferableSymbol,\n  valueSymbol\n} = Piscina;\n\ntest('Marking an object as movable works as expected', async ({ ok }) => {\n  const obj : any = {\n    get [transferableSymbol] () : object { return {}; },\n    get [valueSymbol] () : object { return {}; }\n  };\n  ok(isTransferable(obj));\n  ok(!isMovable(obj)); // It's not movable initially\n  markMovable(obj);\n  ok(isMovable(obj)); // It is movable now\n});\n\ntest('Marking primitives and null works as expected', async ({ equal }) => {\n  equal(Piscina.move(null), null);\n  equal(Piscina.move(1 as any), 1);\n  equal(Piscina.move(false as any), false);\n  equal(Piscina.move('test' as any), 'test');\n});\n\ntest('Using Piscina.move() returns a movable object', async ({ ok }) => {\n  const obj : any = {\n    get [transferableSymbol] () : object { return {}; },\n    get [valueSymbol] () : object { return {}; }\n  };\n  ok(!isMovable(obj)); // It's not movable initially\n  const movable = Piscina.move(obj);\n  ok(isMovable(movable)); // It is movable now\n});\n\ntest('Using ArrayBuffer works as expected', async ({ ok, equal }) => {\n  const ab = new ArrayBuffer(5);\n  const movable = Piscina.move(ab);\n  ok(isMovable(movable));\n  ok(types.isAnyArrayBuffer(movable[valueSymbol]));\n  ok(types.isAnyArrayBuffer(movable[transferableSymbol]));\n  equal(movable[transferableSymbol], ab);\n});\n\ntest('Using TypedArray works as expected', async ({ ok, equal }) => {\n  const ab = new Uint8Array(5);\n  const movable = Piscina.move(ab);\n  ok(isMovable(movable));\n  ok((types as any).isArrayBufferView(movable[valueSymbol]));\n  ok(types.isAnyArrayBuffer(movable[transferableSymbol]));\n  equal(movable[transferableSymbol], ab.buffer);\n});\n\ntest('Using MessagePort works as expected', async ({ ok, equal }) => {\n  const mc = new MessageChannel();\n  const movable = Piscina.move(mc.port1);\n  ok(isMovable(movable));\n  ok(movable[valueSymbol] instanceof MessagePort);\n  ok(movable[transferableSymbol] instanceof MessagePort);\n  equal(movable[transferableSymbol], mc.port1);\n});\n\ntest('Moving works', async ({ equal, ok }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/move.ts')\n  });\n\n  {\n    const ab = new ArrayBuffer(10);\n    const ret = await pool.runTask(Piscina.move(ab));\n    equal(ab.byteLength, 0); // It was moved\n    ok(types.isAnyArrayBuffer(ret));\n  }\n\n  {\n    // Test with empty transferList\n    const ab = new ArrayBuffer(10);\n    const ret = await pool.runTask(Piscina.move(ab), []);\n    equal(ab.byteLength, 0); // It was moved\n    ok(types.isAnyArrayBuffer(ret));\n  }\n\n  {\n    // Test with empty transferList\n    const ab = new ArrayBuffer(10);\n    const ret = await pool.run(Piscina.move(ab));\n    equal(ab.byteLength, 0); // It was moved\n    ok(types.isAnyArrayBuffer(ret));\n  }\n\n  {\n    // Test with empty transferList\n    const ab = new ArrayBuffer(10);\n    const ret = await pool.run(Piscina.move(ab), { transferList: [] });\n    equal(ab.byteLength, 0); // It was moved\n    ok(types.isAnyArrayBuffer(ret));\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/nice.ts",
    "content": "import Piscina from '..';\nimport { getCurrentProcessPriority, WindowsThreadPriority } from '@napi-rs/nice';\nimport { resolve } from 'path';\nimport { test } from 'tap';\n\ntest('can set niceness for threads on Linux', {\n  skip: process.platform !== 'linux'\n}, async ({ equal }) => {\n  const worker = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    niceIncrement: 5\n  });\n\n  const currentNiceness = getCurrentProcessPriority();\n  const result = await worker.runTask('require(\"@napi-rs/nice\").getCurrentProcessPriority()');\n\n  // niceness is capped to 19 on Linux.\n  const expected = Math.min(currentNiceness + 5, 19);\n  equal(result, expected);\n});\n\ntest('can set niceness for threads on Windows', {\n  skip: process.platform !== 'win32'\n}, async ({ equal }) => {\n  const worker = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    niceIncrement: WindowsThreadPriority.ThreadPriorityAboveNormal\n  });\n\n  const result = await worker.runTask('require(\"@napi-rs/nice\").getCurrentProcessPriority()');\n\n  equal(result, WindowsThreadPriority.ThreadPriorityAboveNormal);\n});\n\ntest('setting niceness never does anything bad', async ({ equal }) => {\n  const worker = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    niceIncrement: 5\n  });\n\n  const result = await worker.runTask('42');\n  equal(result, 42);\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/option-validation.ts",
    "content": "import Piscina from '..';\nimport { test } from 'tap';\n\ntest('filename cannot be non-null/non-string', async ({ throws }) => {\n  throws(() => new Piscina(({\n    filename: 12\n  }) as any), /options.filename must be a string or null/);\n});\n\ntest('name cannot be non-null/non-string', async ({ throws }) => {\n  throws(() => new Piscina(({\n    name: 12\n  }) as any), /options.name must be a string or null/);\n});\n\ntest('minThreads must be non-negative integer', async ({ throws }) => {\n  throws(() => new Piscina(({\n    minThreads: -1\n  }) as any), /options.minThreads must be a non-negative integer/);\n\n  throws(() => new Piscina(({\n    minThreads: 'string'\n  }) as any), /options.minThreads must be a non-negative integer/);\n});\n\ntest('maxThreads must be positive integer', async ({ throws }) => {\n  throws(() => new Piscina(({\n    maxThreads: -1\n  }) as any), /options.maxThreads must be a positive integer/);\n\n  throws(() => new Piscina(({\n    maxThreads: 0\n  }) as any), /options.maxThreads must be a positive integer/);\n\n  throws(() => new Piscina(({\n    maxThreads: 'string'\n  }) as any), /options.maxThreads must be a positive integer/);\n});\n\ntest('concurrentTasksPerWorker must be positive integer', async ({ throws }) => {\n  throws(() => new Piscina(({\n    concurrentTasksPerWorker: -1\n  }) as any), /options.concurrentTasksPerWorker must be a positive integer/);\n\n  throws(() => new Piscina(({\n    concurrentTasksPerWorker: 0\n  }) as any), /options.concurrentTasksPerWorker must be a positive integer/);\n\n  throws(() => new Piscina(({\n    concurrentTasksPerWorker: 'string'\n  }) as any), /options.concurrentTasksPerWorker must be a positive integer/);\n});\n\ntest('idleTimeout must be non-negative integer', async ({ throws }) => {\n  throws(() => new Piscina(({\n    idleTimeout: -1\n  }) as any), /options.idleTimeout must be a non-negative integer/);\n\n  throws(() => new Piscina(({\n    idleTimeout: 'string'\n  }) as any), /options.idleTimeout must be a non-negative integer/);\n});\n\ntest('maxQueue must be non-negative integer', async ({ throws, equal }) => {\n  throws(() => new Piscina(({\n    maxQueue: -1\n  }) as any), /options.maxQueue must be a non-negative integer/);\n\n  throws(() => new Piscina(({\n    maxQueue: 'string'\n  }) as any), /options.maxQueue must be a non-negative integer/);\n\n  const p = new Piscina({ maxQueue: 'auto', maxThreads: 2 });\n  equal(p.options.maxQueue, 4);\n});\n\ntest('useAtomics must be a boolean', async ({ throws }) => {\n  throws(() => new Piscina(({\n    useAtomics: -1\n  }) as any), /options.useAtomics must be a boolean/);\n\n  throws(() => new Piscina(({\n    useAtomics: 'string'\n  }) as any), /options.useAtomics must be a boolean/);\n});\n\ntest('resourceLimits must be an object', async ({ throws }) => {\n  throws(() => new Piscina(({\n    resourceLimits: 0\n  }) as any), /options.resourceLimits must be an object/);\n});\n\ntest('taskQueue must be a TaskQueue object', async ({ throws }) => {\n  throws(() => new Piscina(({\n    taskQueue: 0\n  }) as any), /options.taskQueue must be a TaskQueue object/);\n  throws(() => new Piscina(({\n    taskQueue: 'test'\n  }) as any), /options.taskQueue must be a TaskQueue object/);\n  throws(() => new Piscina(({\n    taskQueue: null\n  }) as any), /options.taskQueue must be a TaskQueue object/);\n  throws(() => new Piscina(({\n    taskQueue: new Date()\n  }) as any), /options.taskQueue must be a TaskQueue object/);\n  throws(() => new Piscina(({\n    taskQueue: { } as any\n  }) as any), /options.taskQueue must be a TaskQueue object/);\n});\n\ntest('niceIncrement must be non-negative integer on Unix', {\n  skip: process.platform === 'win32' ? 'Unix options validate' : false\n}, async ({ throws }) => {\n  throws(() => new Piscina(({\n    niceIncrement: -1\n  }) as any), /options.niceIncrement must be a non-negative integer/);\n\n  throws(() => new Piscina(({\n    niceIncrement: 'string'\n  }) as any), /options.niceIncrement must be a non-negative integer/);\n});\n\ntest('trackUnmanagedFds must be a boolean', async ({ throws }) => {\n  throws(() => new Piscina(({\n    trackUnmanagedFds: -1\n  }) as any), /options.trackUnmanagedFds must be a boolean/);\n\n  throws(() => new Piscina(({\n    trackUnmanagedFds: 'string'\n  }) as any), /options.trackUnmanagedFds must be a boolean/);\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/pool-close.ts",
    "content": "import { test } from 'tap';\nimport Piscina from '..';\nimport { resolve } from 'path';\nimport { once } from 'events';\n\ntest('close()', async (t) => {\n  t.test('no pending tasks', async (t) => {\n    const pool = new Piscina({ filename: resolve(__dirname, 'fixtures/sleep.js') });\n    await pool.close();\n    t.pass('pool closed successfully');\n  });\n\n  t.test('no pending tasks (with minThreads=0)', async (t) => {\n    const pool = new Piscina({ filename: resolve(__dirname, 'fixtures/sleep.js'), minThreads: 0 });\n    await pool.close();\n    t.pass('pool closed successfully');\n  });\n\n  t.test('queued tasks waits for all tasks to complete', async (t) => {\n    const pool = new Piscina({ filename: resolve(__dirname, 'fixtures/sleep.js'), maxThreads: 1 });\n\n    const task1 = pool.run({ time: 100 });\n    const task2 = pool.run({ time: 100 });\n\n    setImmediate(() => t.resolves(pool.close(), 'close is resolved when all running tasks are completed'));\n\n    await Promise.all([\n      t.resolves(once(pool, 'close'), 'handler is called when pool is closed'),\n      t.resolves(task1, 'complete running task'),\n      t.resolves(task2, 'complete running task')\n    ]);\n  });\n\n  t.test('abort any task enqueued during closing up', async (t) => {\n    const pool = new Piscina({ filename: resolve(__dirname, 'fixtures/sleep.js'), maxThreads: 1 });\n\n    setImmediate(() => {\n      t.resolves(pool.close(), 'close is resolved when running tasks are completed');\n      t.resolves(pool.run({ time: 1000 }).then(null, err => {\n        t.equal(err.message, 'The task has been aborted');\n        t.equal(err.cause, 'queue is closing up');\n      }));\n    });\n\n    await t.resolves(pool.run({ time: 100 }), 'complete running task');\n  });\n});\n\ntest('close({force: true})', async (t) => {\n  t.test('queued tasks waits for all tasks already running and aborts tasks that are not started yet', async (t) => {\n    const pool = new Piscina({ filename: resolve(__dirname, 'fixtures/sleep.js'), maxThreads: 1, concurrentTasksPerWorker: 1 });\n\n    const task1 = pool.run({ time: 1000 });\n    const task2 = pool.run({ time: 200 });\n\n    setImmediate(() => t.resolves(pool.close({ force: true }), 'close is resolved when all running tasks are completed'));\n\n    await Promise.all([\n      t.resolves(once(pool, 'close'), 'handler is called when pool is closed'),\n      t.resolves(task1, 'complete running task'),\n      t.resolves(task2.then(null, err => {\n        t.equal(err.message, 'The task has been aborted');\n        t.equal(err.cause, 'pool is closed');\n      }))\n    ]);\n  });\n\n  t.test('queued tasks waits for all tasks already running and aborts tasks that are not started yet', async (t) => {\n    const pool = new Piscina({ filename: resolve(__dirname, 'fixtures/sleep.js'), maxThreads: 1, concurrentTasksPerWorker: 2 });\n\n    const task1 = pool.run({ time: 500 });\n    const task2 = pool.run({ time: 100 });\n    const task3 = pool.run({ time: 100 });\n    const task4 = pool.run({ time: 100 });\n\n    setImmediate(() => t.resolves(pool.close({ force: true }), 'close is resolved when all running tasks are completed'));\n\n    await Promise.all([\n      t.resolves(once(pool, 'close'), 'handler is called when pool is closed'),\n      t.resolves(task1, 'complete running task'),\n      t.resolves(task2, 'complete running task'),\n      t.rejects(task3, /The task has been aborted/, 'abort task that are not started yet'),\n      t.rejects(task4, /The task has been aborted/, 'abort task that are not started yet')\n    ]);\n  });\n});\n\ntest('timed out close operation destroys the pool', async (t) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/sleep.js'),\n    maxThreads: 1,\n    closeTimeout: 500\n  });\n\n  const task1 = pool.run({ time: 5000 });\n  const task2 = pool.run({ time: 5000 });\n\n  setImmediate(() => t.resolves(pool.close(), 'close is resolved on timeout'));\n\n  await Promise.all([\n    t.resolves(once(pool, 'error'), 'error handler is called on timeout'),\n    t.rejects(task1, /Terminating worker thread/, 'task is aborted due to timeout'),\n    t.rejects(task2, /Terminating worker thread/, 'task is aborted due to timeout')\n  ]);\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/pool-destroy.ts",
    "content": "import Piscina from '..';\nimport { test } from 'tap';\nimport { resolve } from 'path';\n\ntest('can destroy pool while tasks are running', async ({ rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n  setImmediate(() => pool.destroy());\n  await rejects(pool.runTask('while(1){}'), /Terminating worker thread/);\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/post-task.ts",
    "content": "import { MessageChannel } from 'worker_threads';\nimport { getAvailableParallelism } from '../dist/common';\nimport Piscina from '..';\nimport { test } from 'tap';\nimport { resolve } from 'path';\n\ntest('postTask() can transfer ArrayBuffer instances', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/simple-isworkerthread.ts')\n  });\n\n  const ab = new ArrayBuffer(40);\n  await pool.runTask({ ab }, [ab]);\n  equal(pool.completed, 1);\n  equal(ab.byteLength, 0);\n});\n\ntest('postTask() can transfer ArrayBuffer instances', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/simple-isworkerthread.ts')\n  });\n\n  const ab = new ArrayBuffer(40);\n  await pool.run({ ab }, { transferList: [ab] });\n  equal(pool.completed, 1);\n  equal(ab.byteLength, 0);\n});\n\ntest('postTask() cannot clone build-in objects', async ({ rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/simple-isworkerthread.ts')\n  });\n\n  const obj = new MessageChannel().port1;\n  rejects(pool.runTask({ obj }));\n});\n\ntest('postTask() resolves with a rejection when the handler rejects', async ({ rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  rejects(pool.runTask('Promise.reject(new Error(\"foo\"))'), /foo/);\n});\n\ntest('postTask() resolves with a rejection when the handler throws', async ({ rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  rejects(pool.runTask('throw new Error(\"foo\")'), /foo/);\n});\n\ntest('postTask() validates transferList', async ({ rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  rejects(pool.runTask('0', 42 as any),\n    /transferList argument must be an Array/);\n\n  rejects(pool.run('0', { transferList: 42 as any }),\n    /transferList argument must be an Array/);\n});\n\ntest('postTask() validates filename', async ({ rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  rejects(pool.runTask('0', [], 42 as any),\n    /filename argument must be a string/);\n\n  rejects(pool.run('0', { filename: 42 as any }),\n    /filename argument must be a string/);\n});\n\ntest('postTask() validates name', async ({ rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  rejects(pool.run('0', { name: 42 as any }),\n    /name argument must be a string/);\n});\n\ntest('postTask() validates abortSignal', async ({ rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  rejects(pool.runTask('0', [], undefined, 42 as any),\n    /signal argument must be an object/);\n\n  rejects(pool.run('0', { signal: 42 as any }),\n    /signal argument must be an object/);\n});\n\ntest('Piscina emits drain', async ({ ok, notOk }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  let drained = false;\n  let needsDrain = true;\n  pool.on('drain', () => {\n    drained = true;\n    needsDrain = pool.needsDrain;\n  });\n\n  await Promise.all([pool.run('123'), pool.run('123')]);\n\n  ok(drained);\n  notOk(needsDrain);\n});\n\ntest('Piscina exposes/emits needsDrain to true when capacity is exceeded', async ({ ok }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    maxQueue: 3,\n    maxThreads: 1\n  });\n\n  let triggered = false;\n  let drained = false;\n  pool.once('drain', () => {\n    drained = true;\n  });\n  pool.once('needsDrain', () => {\n    triggered = true;\n  });\n\n  pool.run('123');\n  pool.run('123');\n  pool.run('123');\n  pool.run('123');\n\n  ok(pool.needsDrain);\n  ok(triggered);\n  ok(drained);\n});\n\ntest('Piscina can use async loaded workers', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval-async.js')\n  });\n  equal(await pool.runTask('1'), 1);\n});\n\ntest('Piscina can use async loaded esm workers', {}, async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/esm-async.mjs')\n  });\n  equal(await pool.runTask('1'), 1);\n});\n\ntest('Piscina.run options is correct type', async ({ rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  rejects(pool.run(42, 1 as any), /options must be an object/);\n});\n\ntest('Piscina.maxThreads should return the max number of threads to be used (default)', ({ equal, plan }) => {\n  plan(1);\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  const maxThreads = getAvailableParallelism() * 1.5;\n\n  equal(pool.maxThreads, maxThreads);\n});\n\ntest('Piscina.minThreads should return the max number of threads to be used (custom)', ({ equal, plan }) => {\n  const maxThreads = 3;\n  const pool = new Piscina({\n    maxThreads,\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  plan(1);\n\n  equal(pool.maxThreads, maxThreads);\n});\n\ntest('Piscina.minThreads should return the max number of threads to be used (default)', ({ equal, plan }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n  const minThreads = Math.max(Math.floor(getAvailableParallelism() / 2), 1);\n\n  plan(1);\n  equal(pool.minThreads, minThreads);\n});\n\ntest('Piscina.minThreads should return the max number of threads to be used (custom)', ({ equal, plan }) => {\n  const minThreads = 2;\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    minThreads\n  });\n  plan(1);\n\n  equal(pool.minThreads, minThreads);\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/simple-test.ts",
    "content": "import Piscina from '..';\nimport { test } from 'tap';\nimport { version } from '../package.json';\nimport { pathToFileURL } from 'url';\nimport { resolve } from 'path';\nimport { EventEmitter } from 'events';\n\ntest('Piscina is exposed on export', async ({ equal }) => {\n  equal(Piscina.version, version);\n});\n\ntest('Piscina is exposed on itself', async ({ equal }) => {\n  equal(Piscina.Piscina, Piscina);\n});\n\ntest('Piscina.isWorkerThread has the correct value', async ({ equal }) => {\n  equal(Piscina.isWorkerThread, false);\n});\n\ntest('Piscina.isWorkerThread has the correct value (worker)', async ({ equal }) => {\n  const worker = new Piscina({\n    filename: resolve(__dirname, 'fixtures/simple-isworkerthread.ts')\n  });\n  const result = await worker.runTask(null);\n  equal(result, 'done');\n});\n\ntest('Piscina.isWorkerThread has the correct value (worker) with named import', async ({ equal }) => {\n  const worker = new Piscina({\n    filename: resolve(__dirname, 'fixtures/simple-isworkerthread-named-import.ts')\n  });\n  const result = await worker.runTask(null);\n  equal(result, 'done');\n});\n\ntest('Piscina instance is an EventEmitter', async ({ ok }) => {\n  const piscina = new Piscina();\n  ok(piscina instanceof EventEmitter);\n});\n\ntest('Piscina constructor options are correctly set', async ({ equal }) => {\n  const piscina = new Piscina({\n    minThreads: 10,\n    maxThreads: 20,\n    maxQueue: 30\n  });\n\n  equal(piscina.options.minThreads, 10);\n  equal(piscina.options.maxThreads, 20);\n  equal(piscina.options.maxQueue, 30);\n});\n\ntest('trivial eval() handler works', async ({ equal }) => {\n  const worker = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n  const result = await worker.runTask('42');\n  equal(result, 42);\n});\n\ntest('async eval() handler works', async ({ equal }) => {\n  const worker = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n  const result = await worker.runTask('Promise.resolve(42)');\n  equal(result, 42);\n});\n\ntest('filename can be provided while posting', async ({ equal }) => {\n  const worker = new Piscina();\n  const result = await worker.runTask(\n    'Promise.resolve(42)',\n    resolve(__dirname, 'fixtures/eval.js'));\n  equal(result, 42);\n});\n\ntest('filename can be null when initially provided', async ({ equal }) => {\n  const worker = new Piscina({ filename: null });\n  const result = await worker.runTask(\n    'Promise.resolve(42)',\n    resolve(__dirname, 'fixtures/eval.js'));\n  equal(result, 42);\n});\n\ntest('filename must be provided while posting', async ({ rejects }) => {\n  const worker = new Piscina();\n  rejects(worker.runTask('doesn’t matter'),\n    /filename must be provided to run\\(\\) or in options object/);\n});\n\ntest('passing env to workers works', async ({ same }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    env: { A: 'foo' }\n  });\n\n  const env = await pool.runTask('({...process.env})');\n  same(env, { A: 'foo' });\n});\n\ntest('passing argv to workers works', async ({ same }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    argv: ['a', 'b', 'c']\n  });\n\n  const env = await pool.runTask('process.argv.slice(2)');\n  same(env, ['a', 'b', 'c']);\n});\n\ntest('passing execArgv to workers works', async ({ same }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    execArgv: ['--no-warnings']\n  });\n\n  const env = await pool.runTask('process.execArgv');\n  same(env, ['--no-warnings']);\n});\n\ntest('passing valid workerData works', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/simple-workerdata.ts'),\n    workerData: 'ABC'\n  });\n  equal(Piscina.workerData, undefined);\n\n  await pool.runTask(null);\n});\n\ntest('passing valid workerData works with named import', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/simple-workerdata-named-import.ts'),\n    workerData: 'ABC'\n  });\n  equal(Piscina.workerData, undefined);\n\n  await pool.runTask(null);\n});\n\ntest('passing invalid workerData does not work', async ({ throws }) => {\n  throws(() => new Piscina(({\n    filename: resolve(__dirname, 'fixtures/simple-workerdata.ts'),\n    workerData: {\n      hello () {}\n    }\n  }) as any), /could not be cloned./);\n});\n\ntest('filename can be a file:// URL', async ({ equal }) => {\n  const worker = new Piscina({\n    filename: pathToFileURL(resolve(__dirname, 'fixtures/eval.js')).href\n  });\n  const result = await worker.runTask('42');\n  equal(result, 42);\n});\n\ntest('filename can be a file:// URL to an ESM module', {}, async ({ equal }) => {\n  const worker = new Piscina({\n    filename: pathToFileURL(resolve(__dirname, 'fixtures/esm-export.mjs')).href\n  });\n  const result = await worker.runTask('42');\n  equal(result, 42);\n});\n\ntest('duration and utilization calculations work', async ({ equal, ok }) => {\n  const worker = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  // Initial utilization is always 0\n  equal(worker.utilization, 0);\n\n  await Promise.all([\n    worker.runTask('42'),\n    worker.runTask('41'),\n    worker.runTask('40')\n  ]);\n\n  // utilization is going to be some non-deterministic value\n  // between 0 and 1. It should not be zero at this point\n  // because tasks have run, but it should also never be 1\n  ok(worker.utilization > 0);\n  ok(worker.utilization < 1);\n\n  // Duration must be non-zero.\n  ok(worker.duration > 0);\n});\n\ntest('run works also', async () => {\n  const worker = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n\n  await worker.run(42);\n});\n\ntest('named tasks work', async ({ equal }) => {\n  const worker = new Piscina({\n    filename: resolve(__dirname, 'fixtures/multiple.js')\n  });\n\n  equal(await worker.run({}, { name: 'a' }), 'a');\n  equal(await worker.run({}, { name: 'b' }), 'b');\n  equal(await worker.run({}), 'a');\n});\n\ntest('named tasks work', async ({ equal }) => {\n  const worker = new Piscina({\n    filename: resolve(__dirname, 'fixtures/multiple.js'),\n    name: 'b'\n  });\n\n  equal(await worker.run({}, { name: 'a' }), 'a');\n  equal(await worker.run({}, { name: 'b' }), 'b');\n  equal(await worker.run({}), 'b');\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/task-queue.ts",
    "content": "import Piscina, { PiscinaTask, TaskQueue } from '..';\nimport { test } from 'tap';\nimport { resolve } from 'path';\n\ntest('will put items into a task queue until they can run', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/wait-for-notify.ts'),\n    minThreads: 2,\n    maxThreads: 3\n  });\n\n  equal(pool.threads.length, 2);\n  equal(pool.queueSize, 0);\n\n  const buffers = [\n    new Int32Array(new SharedArrayBuffer(4)),\n    new Int32Array(new SharedArrayBuffer(4)),\n    new Int32Array(new SharedArrayBuffer(4)),\n    new Int32Array(new SharedArrayBuffer(4))\n  ];\n\n  const results = [];\n\n  results.push(pool.runTask(buffers[0]));\n  equal(pool.threads.length, 2);\n  equal(pool.queueSize, 0);\n\n  results.push(pool.runTask(buffers[1]));\n  equal(pool.threads.length, 2);\n  equal(pool.queueSize, 0);\n\n  results.push(pool.runTask(buffers[2]));\n  equal(pool.threads.length, 3);\n  equal(pool.queueSize, 0);\n\n  results.push(pool.runTask(buffers[3]));\n  equal(pool.threads.length, 3);\n  equal(pool.queueSize, 1);\n\n  for (const buffer of buffers) {\n    Atomics.store(buffer, 0, 1);\n    Atomics.notify(buffer, 0, 1);\n  }\n\n  await results[0];\n  equal(pool.queueSize, 0);\n\n  await Promise.all(results);\n});\n\ntest('will reject items over task queue limit', async ({ equal, rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    minThreads: 0,\n    maxThreads: 1,\n    maxQueue: 2\n  });\n\n  equal(pool.threads.length, 0);\n  equal(pool.queueSize, 0);\n\n  rejects(pool.runTask('while (true) {}'), /Terminating worker thread/);\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 0);\n\n  rejects(pool.runTask('while (true) {}'), /Terminating worker thread/);\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 1);\n\n  rejects(pool.runTask('while (true) {}'), /Terminating worker thread/);\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 2);\n\n  rejects(pool.runTask('while (true) {}'), /Task queue is at limit/);\n  await pool.destroy();\n});\n\ntest('will reject items when task queue is unavailable', async ({ equal, rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    minThreads: 0,\n    maxThreads: 1,\n    maxQueue: 0\n  });\n\n  equal(pool.threads.length, 0);\n  equal(pool.queueSize, 0);\n\n  rejects(pool.runTask('while (true) {}'), /Terminating worker thread/);\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 0);\n\n  rejects(pool.runTask('while (true) {}'), /No task queue available and all Workers are busy/);\n  await pool.destroy();\n});\n\ntest('will reject items when task queue is unavailable (fixed thread count)', async ({ equal, rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    minThreads: 1,\n    maxThreads: 1,\n    maxQueue: 0\n  });\n\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 0);\n\n  rejects(pool.runTask('while (true) {}'), /Terminating worker thread/);\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 0);\n\n  rejects(pool.runTask('while (true) {}'), /No task queue available and all Workers are busy/);\n  await pool.destroy();\n});\n\ntest('tasks can share a Worker if requested (both tests blocking)', async ({ equal, rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/wait-for-notify.ts'),\n    minThreads: 0,\n    maxThreads: 1,\n    maxQueue: 0,\n    concurrentTasksPerWorker: 2\n  });\n\n  equal(pool.threads.length, 0);\n  equal(pool.queueSize, 0);\n\n  rejects(pool.runTask(new Int32Array(new SharedArrayBuffer(4))));\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 0);\n\n  rejects(pool.runTask(new Int32Array(new SharedArrayBuffer(4))));\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 0);\n\n  await pool.destroy();\n});\n\ntest('tasks can share a Worker if requested (one test finishes)', async ({ equal, rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/wait-for-notify.ts'),\n    minThreads: 0,\n    maxThreads: 1,\n    maxQueue: 0,\n    concurrentTasksPerWorker: 2\n  });\n\n  const buffers = [\n    new Int32Array(new SharedArrayBuffer(4)),\n    new Int32Array(new SharedArrayBuffer(4))\n  ];\n\n  equal(pool.threads.length, 0);\n  equal(pool.queueSize, 0);\n\n  const firstTask = pool.runTask(buffers[0]);\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 0);\n\n  rejects(pool.runTask(\n    'new Promise((resolve) => setTimeout(resolve, 1000000))',\n    resolve(__dirname, 'fixtures/eval.js')), /Terminating worker thread/);\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 0);\n\n  Atomics.store(buffers[0], 0, 1);\n  Atomics.notify(buffers[0], 0, 1);\n\n  await firstTask;\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 0);\n\n  await pool.destroy();\n});\n\ntest('tasks can share a Worker if requested (both tests finish)', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/wait-for-notify.ts'),\n    minThreads: 1,\n    maxThreads: 1,\n    maxQueue: 0,\n    concurrentTasksPerWorker: 2\n  });\n\n  const buffers = [\n    new Int32Array(new SharedArrayBuffer(4)),\n    new Int32Array(new SharedArrayBuffer(4))\n  ];\n\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 0);\n\n  const firstTask = pool.runTask(buffers[0]);\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 0);\n\n  const secondTask = pool.runTask(buffers[1]);\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 0);\n\n  Atomics.store(buffers[0], 0, 1);\n  Atomics.store(buffers[1], 0, 1);\n  Atomics.notify(buffers[0], 0, 1);\n  Atomics.notify(buffers[1], 0, 1);\n  Atomics.wait(buffers[0], 0, 1);\n  Atomics.wait(buffers[1], 0, 1);\n\n  await firstTask;\n  equal(buffers[0][0], -1);\n  await secondTask;\n  equal(buffers[1][0], -1);\n\n  equal(pool.threads.length, 1);\n  equal(pool.queueSize, 0);\n});\n\ntest('custom task queue works', async ({ equal, ok }) => {\n  let sizeCalled : boolean = false;\n  let shiftCalled : boolean = false;\n  let pushCalled : boolean = false;\n\n  class CustomTaskPool implements TaskQueue {\n    tasks: PiscinaTask[] = [];\n\n    get size () : number {\n      sizeCalled = true;\n      return this.tasks.length;\n    }\n\n    shift () : PiscinaTask | null {\n      shiftCalled = true;\n      return this.tasks.length > 0 ? this.tasks.shift() as PiscinaTask : null;\n    }\n\n    push (task : PiscinaTask) : void {\n      pushCalled = true;\n      this.tasks.push(task);\n\n      ok(Piscina.queueOptionsSymbol in task);\n      if ((task as any).task.a === 3) {\n        equal(task[Piscina.queueOptionsSymbol], null);\n      } else {\n        equal(task[Piscina.queueOptionsSymbol].option,\n          (task as any).task.a);\n      }\n    }\n\n    remove (task : PiscinaTask) : void {\n      const index = this.tasks.indexOf(task);\n      this.tasks.splice(index, 1);\n    }\n  };\n\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    taskQueue: new CustomTaskPool(),\n    // Setting maxThreads low enough to ensure we queue\n    maxThreads: 1,\n    minThreads: 1\n  });\n\n  function makeTask (task, option) {\n    return { ...task, [Piscina.queueOptionsSymbol]: { option } };\n  }\n\n  const ret = await Promise.all([\n    pool.runTask(makeTask({ a: 1 }, 1)),\n    pool.runTask(makeTask({ a: 2 }, 2)),\n    pool.runTask({ a: 3 }) // No queueOptionsSymbol attached\n  ]);\n\n  equal(ret[0].a, 1);\n  equal(ret[1].a, 2);\n  equal(ret[2].a, 3);\n\n  ok(sizeCalled);\n  ok(pushCalled);\n  ok(shiftCalled);\n});\n",
    "symbols": [
      {
        "name": "CustomTaskPool",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/task-queue.ts",
        "startLine": 222,
        "endLine": 252
      },
      {
        "name": "CustomTaskPool.shift",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/task-queue.ts",
        "startLine": 230,
        "endLine": 233
      },
      {
        "name": "CustomTaskPool.push",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/task-queue.ts",
        "startLine": 235,
        "endLine": 246
      },
      {
        "name": "CustomTaskPool.remove",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/task-queue.ts",
        "startLine": 248,
        "endLine": 251
      },
      {
        "name": "makeTask",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/task-queue.ts",
        "startLine": 262,
        "endLine": 264
      }
    ]
  },
  {
    "path": "node_modules/piscina/test/test-is-buffer-transferred.ts",
    "content": "import Piscina from '..';\nimport { test } from 'tap';\nimport { resolve } from 'path';\n\nfunction wait () {\n  return new Promise((resolve) => setTimeout(resolve, 1500));\n}\n\ntest('transferable objects must be transferred', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/send-buffer-then-get-length.js'),\n    useAtomics: false\n  });\n  await pool.run({}, { name: 'send' });\n  await wait();\n  const after = await pool.run({}, { name: 'get' });\n  equal(after, 0);\n});\n\ntest('objects that implement transferable must be transferred', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/send-transferrable-then-get-length.js'),\n    useAtomics: false\n  });\n  await pool.run({}, { name: 'send' });\n  await wait();\n  const after = await pool.run({}, { name: 'get' });\n  equal(after, 0);\n});\n",
    "symbols": [
      {
        "name": "wait",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/test/test-is-buffer-transferred.ts",
        "startLine": 5,
        "endLine": 7
      }
    ]
  },
  {
    "path": "node_modules/piscina/test/test-resourcelimits.ts",
    "content": "import Piscina from '..';\nimport { test } from 'tap';\nimport { resolve } from 'path';\n\ntest('resourceLimits causes task to reject', async ({ equal, rejects }) => {\n  const worker = new Piscina({\n    filename: resolve(__dirname, 'fixtures/resource-limits.js'),\n    resourceLimits: {\n      maxOldGenerationSizeMb: 16,\n      maxYoungGenerationSizeMb: 4,\n      codeRangeSizeMb: 16\n    }\n  });\n  worker.on('error', () => {\n    // Ignore any additional errors that may occur.\n    // This may happen because when the Worker is\n    // killed a new worker is created that may hit\n    // the memory limits immediately. When that\n    // happens, there is no associated Promise to\n    // reject so we emit an error event instead.\n    // We don't care so much about that here. We\n    // could potentially avoid the issue by setting\n    // higher limits above but rather than try to\n    // guess at limits that may work consistently,\n    // let's just ignore the additional error for\n    // now.\n  });\n  const limits : any = worker.options.resourceLimits;\n  equal(limits.maxOldGenerationSizeMb, 16);\n  equal(limits.maxYoungGenerationSizeMb, 4);\n  equal(limits.codeRangeSizeMb, 16);\n  rejects(worker.runTask(null),\n    /Worker terminated due to reaching memory limit: JS heap out of memory/);\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/test-uncaught-exception-from-handler.ts",
    "content": "import Piscina from '..';\nimport { test } from 'tap';\nimport { resolve } from 'path';\nimport { once } from 'events';\n\ntest('uncaught exception resets Worker', async ({ rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n  await rejects(pool.runTask('throw new Error(\"not_caught\")'), /not_caught/);\n});\n\ntest('uncaught exception in immediate resets Worker', async ({ rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js')\n  });\n  await rejects(\n    pool.runTask(`\n      setImmediate(() => { throw new Error(\"not_caught\") });\n      new Promise(() => {}) /* act as if we were doing some work */\n    `), /not_caught/);\n});\n\ntest('uncaught exception in immediate after task yields error event', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    maxThreads: 1,\n    useAtomics: false\n  });\n\n  const errorEvent : Promise<Error[]> = once(pool, 'error');\n\n  const taskResult = pool.runTask(`\n    setTimeout(() => { throw new Error(\"not_caught\") }, 500);\n    42\n  `);\n\n  equal(await taskResult, 42);\n\n  // Hack a bit to make sure we get the 'exit'/'error' events.\n  equal(pool.threads.length, 1);\n  pool.threads[0].ref();\n\n  // This is the main assertion here.\n  equal((await errorEvent)[0].message, 'not_caught');\n});\n\ntest('exiting process resets worker', async ({ not, rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    minThreads: 1\n  });\n  const originalThreadId = pool.threads[0].threadId;\n  await rejects(pool.runTask('process.exit(1);'), /worker exited with code: 1/);\n  const newThreadId = pool.threads[0].threadId;\n  not(originalThreadId, newThreadId);\n});\n\ntest('exiting process in immediate after task errors next task and resets worker', async ({ equal, not, rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval-async.js'),\n    minThreads: 1\n  });\n\n  const originalThreadId = pool.threads[0].threadId;\n  const taskResult = await pool.runTask(`\n    setTimeout(() => { process.exit(1); }, 50);\n    42\n  `);\n  equal(taskResult, 42);\n\n  await rejects(pool.runTask(`\n  'use strict';\n\n  const { promisify } = require('util');\n  const sleep = promisify(setTimeout);\n  async function _() {\n    await sleep(1000);\n    return 42\n  }\n  _();\n  `), /worker exited with code: 1/);\n  const secondThreadId = pool.threads[0].threadId;\n\n  not(originalThreadId, secondThreadId);\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/thread-count.ts",
    "content": "import Piscina from '..';\nimport { cpus } from 'os';\nimport { test } from 'tap';\nimport { resolve } from 'path';\n\ntest('will start with minThreads and max out at maxThreads', async ({ equal, rejects }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    minThreads: 2,\n    maxThreads: 4\n  });\n  equal(pool.threads.length, 2);\n  rejects(pool.runTask('while(true) {}'));\n  equal(pool.threads.length, 2);\n  rejects(pool.runTask('while(true) {}'));\n  equal(pool.threads.length, 2);\n  rejects(pool.runTask('while(true) {}'));\n  equal(pool.threads.length, 3);\n  rejects(pool.runTask('while(true) {}'));\n  equal(pool.threads.length, 4);\n  rejects(pool.runTask('while(true) {}'));\n  equal(pool.threads.length, 4);\n  await pool.destroy();\n});\n\ntest('low maxThreads sets minThreads', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    maxThreads: 1\n  });\n  equal(pool.threads.length, 1);\n  equal(pool.options.minThreads, 1);\n  equal(pool.options.maxThreads, 1);\n});\n\ntest('high minThreads sets maxThreads', {\n  skip: cpus().length > 8\n}, async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    minThreads: 16\n  });\n  equal(pool.threads.length, 16);\n  equal(pool.options.minThreads, 16);\n  equal(pool.options.maxThreads, 16);\n});\n\ntest('conflicting min/max threads is error', async ({ throws }) => {\n  throws(() => new Piscina({\n    minThreads: 16,\n    maxThreads: 8\n  }), /options.minThreads and options.maxThreads must not conflict/);\n});\n\ntest('thread count should be 0 upon destruction', async ({ equal }) => {\n  const pool = new Piscina({\n    filename: resolve(__dirname, 'fixtures/eval.js'),\n    minThreads: 2,\n    maxThreads: 4\n  });\n  equal(pool.threads.length, 2);\n  await pool.destroy();\n  equal(pool.threads.length, 0);\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/tsconfig-paths/src/config-loader.ts",
    "content": "import * as TsConfigLoader2 from \"./tsconfig-loader\";\nimport * as path from \"path\";\nimport { options } from \"./options\";\n\nexport interface ExplicitParams {\n  baseUrl: string;\n  paths: { [key: string]: Array<string> };\n  mainFields?: Array<string>;\n  addMatchAll?: boolean;\n}\n\nexport type TsConfigLoader = (\n  params: TsConfigLoader2.TsConfigLoaderParams\n) => TsConfigLoader2.TsConfigLoaderResult;\n\nexport interface ConfigLoaderParams {\n  cwd: string;\n  explicitParams?: ExplicitParams;\n  tsConfigLoader?: TsConfigLoader;\n}\n\nexport interface ConfigLoaderSuccessResult {\n  resultType: \"success\";\n  configFileAbsolutePath: string;\n  baseUrl: string;\n  absoluteBaseUrl: string;\n  paths: { [key: string]: Array<string> };\n  mainFields?: Array<string>;\n  addMatchAll?: boolean;\n}\n\nexport interface ConfigLoaderFailResult {\n  resultType: \"failed\";\n  message: string;\n}\n\nexport type ConfigLoaderResult =\n  | ConfigLoaderSuccessResult\n  | ConfigLoaderFailResult;\n\nexport function loadConfig(cwd: string = options.cwd): ConfigLoaderResult {\n  return configLoader({ cwd: cwd });\n}\n\nexport function configLoader({\n  cwd,\n  explicitParams,\n  tsConfigLoader = TsConfigLoader2.tsConfigLoader,\n}: ConfigLoaderParams): ConfigLoaderResult {\n  if (explicitParams) {\n    // tslint:disable-next-line:no-shadowed-variable\n    const absoluteBaseUrl = path.isAbsolute(explicitParams.baseUrl)\n      ? explicitParams.baseUrl\n      : path.join(cwd, explicitParams.baseUrl);\n\n    return {\n      resultType: \"success\",\n      configFileAbsolutePath: \"\",\n      baseUrl: explicitParams.baseUrl,\n      absoluteBaseUrl,\n      paths: explicitParams.paths,\n      mainFields: explicitParams.mainFields,\n      addMatchAll: explicitParams.addMatchAll,\n    };\n  }\n\n  // Load tsconfig and create path matching function\n  const loadResult = tsConfigLoader({\n    cwd,\n    getEnv: (key: string) => process.env[key],\n  });\n\n  if (!loadResult.tsConfigPath) {\n    return {\n      resultType: \"failed\",\n      message: \"Couldn't find tsconfig.json\",\n    };\n  }\n\n  if (!loadResult.baseUrl) {\n    return {\n      resultType: \"failed\",\n      message: \"Missing baseUrl in compilerOptions\",\n    };\n  }\n\n  const tsConfigDir = path.dirname(loadResult.tsConfigPath);\n  const absoluteBaseUrl = path.join(tsConfigDir, loadResult.baseUrl);\n\n  return {\n    resultType: \"success\",\n    configFileAbsolutePath: loadResult.tsConfigPath,\n    baseUrl: loadResult.baseUrl,\n    absoluteBaseUrl,\n    paths: loadResult.paths || {},\n  };\n}\n",
    "symbols": [
      {
        "name": "loadConfig",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/config-loader.ts",
        "startLine": 41,
        "endLine": 43
      },
      {
        "name": "configLoader",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/config-loader.ts",
        "startLine": 45,
        "endLine": 97
      }
    ]
  },
  {
    "path": "node_modules/tsconfig-paths/src/filesystem.ts",
    "content": "import * as fs from \"fs\";\n\n/**\n * Typing for the fields of package.json we care about\n */\nexport interface PackageJson {\n  [key: string]: string;\n}\n\n/**\n * A function that json from a file\n */\nexport interface ReadJsonSync {\n  // tslint:disable-next-line:no-any\n  (packageJsonPath: string): any | undefined;\n}\n\nexport interface FileExistsSync {\n  (name: string): boolean;\n}\n\nexport interface FileExistsAsync {\n  (path: string, callback: (err?: Error, exists?: boolean) => void): void;\n}\n\nexport interface ReadJsonAsyncCallback {\n  // tslint:disable-next-line:no-any\n  (err?: Error, content?: any): void;\n}\n\nexport interface ReadJsonAsync {\n  (path: string, callback: ReadJsonAsyncCallback): void;\n}\n\nexport function fileExistsSync(path: string): boolean {\n  try {\n    const stats = fs.statSync(path);\n    return stats.isFile();\n  } catch (err) {\n    // If error, assume file did not exist\n    return false;\n  }\n}\n\n/**\n * Reads package.json from disk\n * @param file Path to package.json\n */\n// tslint:disable-next-line:no-any\nexport function readJsonFromDiskSync(packageJsonPath: string): any | undefined {\n  if (!fs.existsSync(packageJsonPath)) {\n    return undefined;\n  }\n  return require(packageJsonPath);\n}\n\nexport function readJsonFromDiskAsync(\n  path: string,\n  // tslint:disable-next-line:no-any\n  callback: (err?: Error, content?: any) => void\n): void {\n  fs.readFile(path, \"utf8\", (err, result) => {\n    // If error, assume file did not exist\n    if (err || !result) {\n      return callback();\n    }\n    const json = JSON.parse(result);\n    return callback(undefined, json);\n  });\n}\n\nexport function fileExistsAsync(\n  path2: string,\n  callback2: (err?: Error, exists?: boolean) => void\n): void {\n  fs.stat(path2, (err: Error, stats: fs.Stats) => {\n    if (err) {\n      // If error assume file does not exist\n      return callback2(undefined, false);\n    }\n    callback2(undefined, stats ? stats.isFile() : false);\n  });\n}\n\nexport function removeExtension(path: string): string {\n  return path.substring(0, path.lastIndexOf(\".\")) || path;\n}\n",
    "symbols": [
      {
        "name": "fileExistsSync",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/filesystem.ts",
        "startLine": 35,
        "endLine": 43
      },
      {
        "name": "readJsonFromDiskSync",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/filesystem.ts",
        "startLine": 50,
        "endLine": 55
      },
      {
        "name": "readJsonFromDiskAsync",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/filesystem.ts",
        "startLine": 57,
        "endLine": 70
      },
      {
        "name": "fileExistsAsync",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/filesystem.ts",
        "startLine": 72,
        "endLine": 83
      },
      {
        "name": "removeExtension",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/filesystem.ts",
        "startLine": 85,
        "endLine": 87
      }
    ]
  },
  {
    "path": "node_modules/tsconfig-paths/src/index.ts",
    "content": "// register is used from register.js in root dir\nexport {\n  createMatchPath,\n  matchFromAbsolutePaths,\n  MatchPath,\n} from \"./match-path-sync\";\nexport {\n  createMatchPathAsync,\n  matchFromAbsolutePathsAsync,\n  MatchPathAsync,\n} from \"./match-path-async\";\nexport { register } from \"./register\";\nexport {\n  loadConfig,\n  ConfigLoaderResult,\n  ConfigLoaderSuccessResult,\n  ConfigLoaderFailResult,\n} from \"./config-loader\";\nexport {\n  ReadJsonSync,\n  ReadJsonAsync,\n  FileExistsSync,\n  FileExistsAsync,\n} from \"./filesystem\";\n",
    "symbols": []
  },
  {
    "path": "node_modules/tsconfig-paths/src/mapping-entry.ts",
    "content": "import * as path from \"path\";\n\nexport interface MappingEntry {\n  readonly pattern: string;\n  readonly paths: ReadonlyArray<string>;\n}\n\nexport interface Paths {\n  readonly [key: string]: ReadonlyArray<string>;\n}\n\n/**\n * Converts an absolute baseUrl and paths to an array of absolute mapping entries.\n * The array is sorted by longest prefix.\n * Having an array with entries allows us to keep a sorting order rather than\n * sort by keys each time we use the mappings.\n * @param absoluteBaseUrl\n * @param paths\n * @param addMatchAll\n */\nexport function getAbsoluteMappingEntries(\n  absoluteBaseUrl: string,\n  paths: Paths,\n  addMatchAll: boolean\n): ReadonlyArray<MappingEntry> {\n  // Resolve all paths to absolute form once here, and sort them by\n  // longest prefix once here, this saves time on each request later.\n  // We need to put them in an array to preserve the sorting order.\n  const sortedKeys = sortByLongestPrefix(Object.keys(paths));\n  const absolutePaths: Array<MappingEntry> = [];\n  for (const key of sortedKeys) {\n    absolutePaths.push({\n      pattern: key,\n      paths: paths[key].map((pathToResolve) =>\n        path.join(absoluteBaseUrl, pathToResolve)\n      ),\n    });\n  }\n  // If there is no match-all path specified in the paths section of tsconfig, then try to match\n  // all paths relative to baseUrl, this is how typescript works.\n  if (!paths[\"*\"] && addMatchAll) {\n    absolutePaths.push({\n      pattern: \"*\",\n      paths: [`${absoluteBaseUrl.replace(/\\/$/, \"\")}/*`],\n    });\n  }\n\n  return absolutePaths;\n}\n\n/**\n * Sort path patterns.\n * If a module name can be matched with multiple patterns then pattern with the longest prefix will be picked.\n */\nfunction sortByLongestPrefix(arr: Array<string>): Array<string> {\n  return arr\n    .concat()\n    .sort((a: string, b: string) => getPrefixLength(b) - getPrefixLength(a));\n}\n\nfunction getPrefixLength(pattern: string): number {\n  const prefixLength = pattern.indexOf(\"*\");\n  return pattern.substr(0, prefixLength).length;\n}\n",
    "symbols": [
      {
        "name": "getAbsoluteMappingEntries",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/mapping-entry.ts",
        "startLine": 21,
        "endLine": 49
      },
      {
        "name": "sortByLongestPrefix",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/mapping-entry.ts",
        "startLine": 55,
        "endLine": 59
      },
      {
        "name": "getPrefixLength",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/mapping-entry.ts",
        "startLine": 61,
        "endLine": 64
      }
    ]
  },
  {
    "path": "node_modules/tsconfig-paths/src/match-path-async.ts",
    "content": "import * as path from \"path\";\nimport * as TryPath from \"./try-path\";\nimport * as MappingEntry from \"./mapping-entry\";\nimport * as Filesystem from \"./filesystem\";\n\n/**\n * Function that can match a path async\n */\nexport interface MatchPathAsync {\n  (\n    requestedModule: string,\n    readJson: Filesystem.ReadJsonAsync | undefined,\n    fileExists: Filesystem.FileExistsAsync | undefined,\n    extensions: ReadonlyArray<string> | undefined,\n    callback: MatchPathAsyncCallback\n  ): void;\n}\n\nexport interface MatchPathAsyncCallback {\n  (err?: Error, path?: string): void;\n}\n\n/**\n * See the sync version for docs.\n */\nexport function createMatchPathAsync(\n  absoluteBaseUrl: string,\n  paths: { [key: string]: Array<string> },\n  mainFields: string[] = [\"main\"],\n  addMatchAll: boolean = true\n): MatchPathAsync {\n  const absolutePaths = MappingEntry.getAbsoluteMappingEntries(\n    absoluteBaseUrl,\n    paths,\n    addMatchAll\n  );\n\n  return (\n    requestedModule: string,\n    readJson: Filesystem.ReadJsonAsync | undefined,\n    fileExists: Filesystem.FileExistsAsync | undefined,\n    extensions: ReadonlyArray<string> | undefined,\n    callback: MatchPathAsyncCallback\n  ) =>\n    matchFromAbsolutePathsAsync(\n      absolutePaths,\n      requestedModule,\n      readJson,\n      fileExists,\n      extensions,\n      callback,\n      mainFields\n    );\n}\n\n/**\n * See the sync version for docs.\n */\nexport function matchFromAbsolutePathsAsync(\n  absolutePathMappings: ReadonlyArray<MappingEntry.MappingEntry>,\n  requestedModule: string,\n  readJson: Filesystem.ReadJsonAsync = Filesystem.readJsonFromDiskAsync,\n  fileExists: Filesystem.FileExistsAsync = Filesystem.fileExistsAsync,\n  extensions: ReadonlyArray<string> = Object.keys(require.extensions),\n  callback: MatchPathAsyncCallback,\n  mainFields: string[] = [\"main\"]\n): void {\n  const tryPaths = TryPath.getPathsToTry(\n    extensions,\n    absolutePathMappings,\n    requestedModule\n  );\n\n  if (!tryPaths) {\n    return callback();\n  }\n\n  findFirstExistingPath(\n    tryPaths,\n    readJson,\n    fileExists,\n    callback,\n    0,\n    mainFields\n  );\n}\n\nfunction findFirstExistingMainFieldMappedFile(\n  packageJson: Filesystem.PackageJson,\n  mainFields: string[],\n  packageJsonPath: string,\n  fileExistsAsync: Filesystem.FileExistsAsync,\n  doneCallback: (err?: Error, filepath?: string) => void,\n  index: number = 0\n): void {\n  if (index >= mainFields.length) {\n    return doneCallback(undefined, undefined);\n  }\n\n  const tryNext = () =>\n    findFirstExistingMainFieldMappedFile(\n      packageJson,\n      mainFields,\n      packageJsonPath,\n      fileExistsAsync,\n      doneCallback,\n      index + 1\n    );\n\n  const mainFieldMapping = packageJson[mainFields[index]];\n  if (typeof mainFieldMapping !== \"string\") {\n    // Skip mappings that are not pointers to replacement files\n    return tryNext();\n  }\n\n  const mappedFilePath = path.join(\n    path.dirname(packageJsonPath),\n    mainFieldMapping\n  );\n  fileExistsAsync(mappedFilePath, (err?: Error, exists?: boolean) => {\n    if (err) {\n      return doneCallback(err);\n    }\n    if (exists) {\n      return doneCallback(undefined, mappedFilePath);\n    }\n    return tryNext();\n  });\n}\n\n// Recursive loop to probe for physical files\nfunction findFirstExistingPath(\n  tryPaths: ReadonlyArray<TryPath.TryPath>,\n  readJson: Filesystem.ReadJsonAsync,\n  fileExists: Filesystem.FileExistsAsync,\n  doneCallback: MatchPathAsyncCallback,\n  index: number = 0,\n  mainFields: string[] = [\"main\"]\n): void {\n  const tryPath = tryPaths[index];\n  if (\n    tryPath.type === \"file\" ||\n    tryPath.type === \"extension\" ||\n    tryPath.type === \"index\"\n  ) {\n    fileExists(tryPath.path, (err: Error, exists: boolean) => {\n      if (err) {\n        return doneCallback(err);\n      }\n      if (exists) {\n        return doneCallback(undefined, TryPath.getStrippedPath(tryPath));\n      }\n      if (index === tryPaths.length - 1) {\n        return doneCallback();\n      }\n      // Continue with the next path\n      return findFirstExistingPath(\n        tryPaths,\n        readJson,\n        fileExists,\n        doneCallback,\n        index + 1,\n        mainFields\n      );\n    });\n  } else if (tryPath.type === \"package\") {\n    readJson(tryPath.path, (err, packageJson) => {\n      if (err) {\n        return doneCallback(err);\n      }\n      if (packageJson) {\n        return findFirstExistingMainFieldMappedFile(\n          packageJson,\n          mainFields,\n          tryPath.path,\n          fileExists,\n          (mainFieldErr?: Error, mainFieldMappedFile?: string) => {\n            if (mainFieldErr) {\n              return doneCallback(mainFieldErr);\n            }\n            if (mainFieldMappedFile) {\n              return doneCallback(undefined, mainFieldMappedFile);\n            }\n\n            // No field in package json was a valid option. Continue with the next path.\n            return findFirstExistingPath(\n              tryPaths,\n              readJson,\n              fileExists,\n              doneCallback,\n              index + 1,\n              mainFields\n            );\n          }\n        );\n      }\n\n      // This is async code, we need to return unconditionally, otherwise the code still falls\n      // through and keeps recursing. While this might work in general, libraries that use neo-async\n      // like Webpack will actually not allow you to call the same callback twice.\n      //\n      // An example of where this caused issues:\n      // https://github.com/dividab/tsconfig-paths-webpack-plugin/issues/11\n      //\n      // Continue with the next path\n      return findFirstExistingPath(\n        tryPaths,\n        readJson,\n        fileExists,\n        doneCallback,\n        index + 1,\n        mainFields\n      );\n    });\n  } else {\n    TryPath.exhaustiveTypeException(tryPath.type);\n  }\n}\n",
    "symbols": [
      {
        "name": "createMatchPathAsync",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-async.ts",
        "startLine": 26,
        "endLine": 54
      },
      {
        "name": "matchFromAbsolutePathsAsync",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-async.ts",
        "startLine": 59,
        "endLine": 86
      },
      {
        "name": "findFirstExistingMainFieldMappedFile",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-async.ts",
        "startLine": 88,
        "endLine": 129
      },
      {
        "name": "findFirstExistingPath",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-async.ts",
        "startLine": 132,
        "endLine": 218
      }
    ]
  },
  {
    "path": "node_modules/tsconfig-paths/src/match-path-sync.ts",
    "content": "import * as path from \"path\";\nimport * as Filesystem from \"./filesystem\";\nimport * as MappingEntry from \"./mapping-entry\";\nimport * as TryPath from \"./try-path\";\n\n/**\n * Function that can match a path\n */\nexport interface MatchPath {\n  (\n    requestedModule: string,\n    readJson?: Filesystem.ReadJsonSync,\n    fileExists?: (name: string) => boolean,\n    extensions?: ReadonlyArray<string>\n  ): string | undefined;\n}\n\n/**\n * Creates a function that can resolve paths according to tsconfig paths property.\n * @param absoluteBaseUrl Absolute version of baseUrl as specified in tsconfig.\n * @param paths The paths as specified in tsconfig.\n * @param mainFields A list of package.json field names to try when resolving module files.\n * @param addMatchAll Add a match-all \"*\" rule if none is present\n * @returns a function that can resolve paths.\n */\nexport function createMatchPath(\n  absoluteBaseUrl: string,\n  paths: { [key: string]: Array<string> },\n  mainFields: string[] = [\"main\"],\n  addMatchAll: boolean = true\n): MatchPath {\n  const absolutePaths = MappingEntry.getAbsoluteMappingEntries(\n    absoluteBaseUrl,\n    paths,\n    addMatchAll\n  );\n\n  return (\n    requestedModule: string,\n    readJson?: Filesystem.ReadJsonSync,\n    fileExists?: Filesystem.FileExistsSync,\n    extensions?: Array<string>\n  ) =>\n    matchFromAbsolutePaths(\n      absolutePaths,\n      requestedModule,\n      readJson,\n      fileExists,\n      extensions,\n      mainFields\n    );\n}\n\n/**\n * Finds a path from tsconfig that matches a module load request.\n * @param absolutePathMappings The paths to try as specified in tsconfig but resolved to absolute form.\n * @param requestedModule The required module name.\n * @param readJson Function that can read json from a path (useful for testing).\n * @param fileExists Function that checks for existence of a file at a path (useful for testing).\n * @param extensions File extensions to probe for (useful for testing).\n * @param mainFields A list of package.json field names to try when resolving module files.\n * @returns the found path, or undefined if no path was found.\n */\nexport function matchFromAbsolutePaths(\n  absolutePathMappings: ReadonlyArray<MappingEntry.MappingEntry>,\n  requestedModule: string,\n  readJson: Filesystem.ReadJsonSync = Filesystem.readJsonFromDiskSync,\n  fileExists: Filesystem.FileExistsSync = Filesystem.fileExistsSync,\n  extensions: Array<string> = Object.keys(require.extensions),\n  mainFields: string[] = [\"main\"]\n): string | undefined {\n  const tryPaths = TryPath.getPathsToTry(\n    extensions,\n    absolutePathMappings,\n    requestedModule\n  );\n\n  if (!tryPaths) {\n    return undefined;\n  }\n\n  return findFirstExistingPath(tryPaths, readJson, fileExists, mainFields);\n}\n\nfunction findFirstExistingMainFieldMappedFile(\n  packageJson: Filesystem.PackageJson,\n  mainFields: string[],\n  packageJsonPath: string,\n  fileExists: Filesystem.FileExistsSync\n): string | undefined {\n  for (let index = 0; index < mainFields.length; index++) {\n    const mainFieldName = mainFields[index];\n    const candidateMapping = packageJson[mainFieldName];\n    if (candidateMapping && typeof candidateMapping === \"string\") {\n      const candidateFilePath = path.join(\n        path.dirname(packageJsonPath),\n        candidateMapping\n      );\n      if (fileExists(candidateFilePath)) {\n        return candidateFilePath;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction findFirstExistingPath(\n  tryPaths: ReadonlyArray<TryPath.TryPath>,\n  readJson: Filesystem.ReadJsonSync = Filesystem.readJsonFromDiskSync,\n  fileExists: Filesystem.FileExistsSync,\n  mainFields: string[] = [\"main\"]\n): string | undefined {\n  for (const tryPath of tryPaths) {\n    if (\n      tryPath.type === \"file\" ||\n      tryPath.type === \"extension\" ||\n      tryPath.type === \"index\"\n    ) {\n      if (fileExists(tryPath.path)) {\n        return TryPath.getStrippedPath(tryPath);\n      }\n    } else if (tryPath.type === \"package\") {\n      const packageJson: Filesystem.PackageJson = readJson(tryPath.path);\n      if (packageJson) {\n        const mainFieldMappedFile = findFirstExistingMainFieldMappedFile(\n          packageJson,\n          mainFields,\n          tryPath.path,\n          fileExists\n        );\n        if (mainFieldMappedFile) {\n          return mainFieldMappedFile;\n        }\n      }\n    } else {\n      TryPath.exhaustiveTypeException(tryPath.type);\n    }\n  }\n  return undefined;\n}\n",
    "symbols": [
      {
        "name": "createMatchPath",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-sync.ts",
        "startLine": 26,
        "endLine": 52
      },
      {
        "name": "matchFromAbsolutePaths",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-sync.ts",
        "startLine": 64,
        "endLine": 83
      },
      {
        "name": "findFirstExistingMainFieldMappedFile",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-sync.ts",
        "startLine": 85,
        "endLine": 106
      },
      {
        "name": "findFirstExistingPath",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/match-path-sync.ts",
        "startLine": 108,
        "endLine": 141
      }
    ]
  },
  {
    "path": "node_modules/tsconfig-paths/src/options.ts",
    "content": "import * as minimist from \"minimist\";\n\nconst argv = minimist(process.argv.slice(2), {\n  string: [\"project\"],\n  alias: {\n    project: [\"P\"],\n  },\n});\n\nconst project = argv && argv.project;\n\nexport interface Options {\n  cwd: string;\n}\n\nexport const options: Options = {\n  cwd: project || process.cwd(),\n};\n",
    "symbols": []
  },
  {
    "path": "node_modules/tsconfig-paths/src/register.ts",
    "content": "import { createMatchPath } from \"./match-path-sync\";\nimport { configLoader, ExplicitParams } from \"./config-loader\";\nimport { options } from \"./options\";\n\nconst noOp = (): void => void 0;\n\nfunction getCoreModules(\n  builtinModules: string[] | undefined\n): { [key: string]: boolean } {\n  builtinModules = builtinModules || [\n    \"assert\",\n    \"buffer\",\n    \"child_process\",\n    \"cluster\",\n    \"crypto\",\n    \"dgram\",\n    \"dns\",\n    \"domain\",\n    \"events\",\n    \"fs\",\n    \"http\",\n    \"https\",\n    \"net\",\n    \"os\",\n    \"path\",\n    \"punycode\",\n    \"querystring\",\n    \"readline\",\n    \"stream\",\n    \"string_decoder\",\n    \"tls\",\n    \"tty\",\n    \"url\",\n    \"util\",\n    \"v8\",\n    \"vm\",\n    \"zlib\",\n  ];\n\n  const coreModules: { [key: string]: boolean } = {};\n  for (let module of builtinModules) {\n    coreModules[module] = true;\n  }\n\n  return coreModules;\n}\n\n/**\n * Installs a custom module load function that can adhere to paths in tsconfig.\n * Returns a function to undo paths registration.\n */\nexport function register(explicitParams: ExplicitParams): () => void {\n  const configLoaderResult = configLoader({\n    cwd: options.cwd,\n    explicitParams,\n  });\n\n  if (configLoaderResult.resultType === \"failed\") {\n    console.warn(\n      `${configLoaderResult.message}. tsconfig-paths will be skipped`\n    );\n\n    return noOp;\n  }\n\n  const matchPath = createMatchPath(\n    configLoaderResult.absoluteBaseUrl,\n    configLoaderResult.paths,\n    configLoaderResult.mainFields,\n    configLoaderResult.addMatchAll\n  );\n\n  // Patch node's module loading\n  // tslint:disable-next-line:no-require-imports variable-name\n  const Module = require(\"module\");\n  const originalResolveFilename = Module._resolveFilename;\n  const coreModules = getCoreModules(Module.builtinModules);\n  // tslint:disable-next-line:no-any\n  Module._resolveFilename = function (request: string, _parent: any): string {\n    const isCoreModule = coreModules.hasOwnProperty(request);\n    if (!isCoreModule) {\n      const found = matchPath(request);\n      if (found) {\n        const modifiedArguments = [found, ...[].slice.call(arguments, 1)]; // Passes all arguments. Even those that is not specified above.\n        // tslint:disable-next-line:no-invalid-this\n        return originalResolveFilename.apply(this, modifiedArguments);\n      }\n    }\n    // tslint:disable-next-line:no-invalid-this\n    return originalResolveFilename.apply(this, arguments);\n  };\n\n  return () => {\n    // Return node's module loading to original state.\n    Module._resolveFilename = originalResolveFilename;\n  };\n}\n",
    "symbols": [
      {
        "name": "getCoreModules",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/register.ts",
        "startLine": 7,
        "endLine": 46
      },
      {
        "name": "register",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/register.ts",
        "startLine": 52,
        "endLine": 97
      }
    ]
  },
  {
    "path": "node_modules/tsconfig-paths/src/try-path.ts",
    "content": "import * as path from \"path\";\nimport { MappingEntry } from \"./mapping-entry\";\nimport { dirname } from \"path\";\nimport { removeExtension } from \"./filesystem\";\n\nexport interface TryPath {\n  readonly type: \"file\" | \"extension\" | \"index\" | \"package\";\n  readonly path: string;\n}\n\n/**\n * Builds a list of all physical paths to try by:\n * 1. Check for file named exactly as request.\n * 2. Check for files named as request ending in any of the extensions.\n * 3. Check for file specified in package.json's main property.\n * 4. Check for files named as request ending in \"index\" with any of the extensions.\n */\nexport function getPathsToTry(\n  extensions: ReadonlyArray<string>,\n  absolutePathMappings: ReadonlyArray<MappingEntry>,\n  requestedModule: string\n): ReadonlyArray<TryPath> | undefined {\n  if (!absolutePathMappings || !requestedModule || requestedModule[0] === \".\") {\n    return undefined;\n  }\n\n  const pathsToTry: Array<TryPath> = [];\n  for (const entry of absolutePathMappings) {\n    const starMatch =\n      entry.pattern === requestedModule\n        ? \"\"\n        : matchStar(entry.pattern, requestedModule);\n    if (starMatch !== undefined) {\n      for (const physicalPathPattern of entry.paths) {\n        const physicalPath = physicalPathPattern.replace(\"*\", starMatch);\n        pathsToTry.push({ type: \"file\", path: physicalPath });\n        pathsToTry.push(\n          ...extensions.map(\n            (e) => ({ type: \"extension\", path: physicalPath + e } as TryPath)\n          )\n        );\n        pathsToTry.push({\n          type: \"package\",\n          path: path.join(physicalPath, \"/package.json\"),\n        });\n        const indexPath = path.join(physicalPath, \"/index\");\n        pathsToTry.push(\n          ...extensions.map(\n            (e) => ({ type: \"index\", path: indexPath + e } as TryPath)\n          )\n        );\n      }\n    }\n  }\n  return pathsToTry.length === 0 ? undefined : pathsToTry;\n}\n\n// Not sure why we don't just return the full found path?\nexport function getStrippedPath(tryPath: TryPath): string {\n  return tryPath.type === \"index\"\n    ? dirname(tryPath.path)\n    : tryPath.type === \"file\"\n    ? tryPath.path\n    : tryPath.type === \"extension\"\n    ? removeExtension(tryPath.path)\n    : tryPath.type === \"package\"\n    ? tryPath.path\n    : exhaustiveTypeException(tryPath.type);\n}\n\nexport function exhaustiveTypeException(check: never): never {\n  throw new Error(`Unknown type ${check}`);\n}\n\n/**\n * Matches pattern with a single star against search.\n * Star must match at least one character to be considered a match.\n * @param patttern for example \"foo*\"\n * @param search for example \"fooawesomebar\"\n * @returns the part of search that * matches, or undefined if no match.\n */\nfunction matchStar(pattern: string, search: string): string | undefined {\n  if (search.length < pattern.length) {\n    return undefined;\n  }\n  if (pattern === \"*\") {\n    return search;\n  }\n  const star = pattern.indexOf(\"*\");\n  if (star === -1) {\n    return undefined;\n  }\n  const part1 = pattern.substring(0, star);\n  const part2 = pattern.substring(star + 1);\n  if (search.substr(0, star) !== part1) {\n    return undefined;\n  }\n  if (search.substr(search.length - part2.length) !== part2) {\n    return undefined;\n  }\n  return search.substr(star, search.length - part2.length);\n}\n",
    "symbols": [
      {
        "name": "getPathsToTry",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/try-path.ts",
        "startLine": 18,
        "endLine": 56
      },
      {
        "name": "getStrippedPath",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/try-path.ts",
        "startLine": 59,
        "endLine": 69
      },
      {
        "name": "exhaustiveTypeException",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/try-path.ts",
        "startLine": 71,
        "endLine": 73
      },
      {
        "name": "matchStar",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/try-path.ts",
        "startLine": 82,
        "endLine": 102
      }
    ]
  },
  {
    "path": "node_modules/tsconfig-paths/src/tsconfig-loader.ts",
    "content": "import * as path from \"path\";\nimport * as fs from \"fs\";\n// tslint:disable:no-require-imports\nimport JSON5 = require(\"json5\");\nimport StripBom = require(\"strip-bom\");\n// tslint:enable:no-require-imports\n\n/**\n * Typing for the parts of tsconfig that we care about\n */\nexport interface Tsconfig {\n  extends?: string | string[];\n  compilerOptions?: {\n    baseUrl?: string;\n    paths?: { [key: string]: Array<string> };\n    strict?: boolean;\n  };\n}\n\nexport interface TsConfigLoaderResult {\n  tsConfigPath: string | undefined;\n  baseUrl: string | undefined;\n  paths: { [key: string]: Array<string> } | undefined;\n}\n\nexport interface TsConfigLoaderParams {\n  getEnv: (key: string) => string | undefined;\n  cwd: string;\n  loadSync?(\n    cwd: string,\n    filename?: string,\n    baseUrl?: string\n  ): TsConfigLoaderResult;\n}\n\nexport function tsConfigLoader({\n  getEnv,\n  cwd,\n  loadSync = loadSyncDefault,\n}: TsConfigLoaderParams): TsConfigLoaderResult {\n  const TS_NODE_PROJECT = getEnv(\"TS_NODE_PROJECT\");\n  const TS_NODE_BASEURL = getEnv(\"TS_NODE_BASEURL\");\n\n  // tsconfig.loadSync handles if TS_NODE_PROJECT is a file or directory\n  // and also overrides baseURL if TS_NODE_BASEURL is available.\n  const loadResult = loadSync(cwd, TS_NODE_PROJECT, TS_NODE_BASEURL);\n  return loadResult;\n}\n\nfunction loadSyncDefault(\n  cwd: string,\n  filename?: string,\n  baseUrl?: string\n): TsConfigLoaderResult {\n  // Tsconfig.loadSync uses path.resolve. This is why we can use an absolute path as filename\n\n  const configPath = resolveConfigPath(cwd, filename);\n\n  if (!configPath) {\n    return {\n      tsConfigPath: undefined,\n      baseUrl: undefined,\n      paths: undefined,\n    };\n  }\n  const config = loadTsconfig(configPath);\n\n  return {\n    tsConfigPath: configPath,\n    baseUrl:\n      baseUrl ||\n      (config && config.compilerOptions && config.compilerOptions.baseUrl),\n    paths: config && config.compilerOptions && config.compilerOptions.paths,\n  };\n}\n\nfunction resolveConfigPath(cwd: string, filename?: string): string | undefined {\n  if (filename) {\n    const absolutePath = fs.lstatSync(filename).isDirectory()\n      ? path.resolve(filename, \"./tsconfig.json\")\n      : path.resolve(cwd, filename);\n\n    return absolutePath;\n  }\n\n  if (fs.statSync(cwd).isFile()) {\n    return path.resolve(cwd);\n  }\n\n  const configAbsolutePath = walkForTsConfig(cwd);\n  return configAbsolutePath ? path.resolve(configAbsolutePath) : undefined;\n}\n\nexport function walkForTsConfig(\n  directory: string,\n  existsSync: (path: string) => boolean = fs.existsSync\n): string | undefined {\n  const configPath = path.join(directory, \"./tsconfig.json\");\n  if (existsSync(configPath)) {\n    return configPath;\n  }\n\n  const parentDirectory = path.join(directory, \"../\");\n\n  // If we reached the top\n  if (directory === parentDirectory) {\n    return undefined;\n  }\n\n  return walkForTsConfig(parentDirectory, existsSync);\n}\n\nexport function loadTsconfig(\n  configFilePath: string,\n  existsSync: (path: string) => boolean = fs.existsSync,\n  readFileSync: (filename: string) => string = (filename: string) =>\n    fs.readFileSync(filename, \"utf8\")\n): Tsconfig | undefined {\n  if (!existsSync(configFilePath)) {\n    return undefined;\n  }\n\n  const configString = readFileSync(configFilePath);\n  const cleanedJson = StripBom(configString);\n  let config: Tsconfig;\n  try {\n    config = JSON5.parse(cleanedJson);\n  } catch (e) {\n    throw new Error(`${configFilePath} is malformed ${e.message}`);\n  }\n\n  let extendedConfig = config.extends;\n  if (extendedConfig) {\n    let base: Tsconfig;\n\n    if (Array.isArray(extendedConfig)) {\n      base = extendedConfig.reduce(\n        (currBase, extendedConfigElement) =>\n          mergeTsconfigs(\n            currBase,\n            loadTsconfigFromExtends(\n              configFilePath,\n              extendedConfigElement,\n              existsSync,\n              readFileSync\n            )\n          ),\n        {}\n      );\n    } else {\n      base = loadTsconfigFromExtends(\n        configFilePath,\n        extendedConfig,\n        existsSync,\n        readFileSync\n      );\n    }\n\n    return mergeTsconfigs(base, config);\n  }\n  return config;\n}\n\n/**\n * Intended to be called only from loadTsconfig.\n * Parameters don't have defaults because they should use the same as loadTsconfig.\n */\nfunction loadTsconfigFromExtends(\n  configFilePath: string,\n  extendedConfigValue: string,\n  // eslint-disable-next-line no-shadow\n  existsSync: (path: string) => boolean,\n  readFileSync: (filename: string) => string\n): Tsconfig {\n  if (\n    typeof extendedConfigValue === \"string\" &&\n    extendedConfigValue.indexOf(\".json\") === -1\n  ) {\n    extendedConfigValue += \".json\";\n  }\n  const currentDir = path.dirname(configFilePath);\n  let extendedConfigPath = path.join(currentDir, extendedConfigValue);\n  if (\n    extendedConfigValue.indexOf(\"/\") !== -1 &&\n    extendedConfigValue.indexOf(\".\") !== -1 &&\n    !existsSync(extendedConfigPath)\n  ) {\n    extendedConfigPath = path.join(\n      currentDir,\n      \"node_modules\",\n      extendedConfigValue\n    );\n  }\n\n  const config =\n    loadTsconfig(extendedConfigPath, existsSync, readFileSync) || {};\n\n  // baseUrl should be interpreted as relative to extendedConfigPath,\n  // but we need to update it so it is relative to the original tsconfig being loaded\n  if (config.compilerOptions?.baseUrl) {\n    const extendsDir = path.dirname(extendedConfigValue);\n    config.compilerOptions.baseUrl = path.join(\n      extendsDir,\n      config.compilerOptions.baseUrl\n    );\n  }\n\n  return config;\n}\n\nfunction mergeTsconfigs(\n  base: Tsconfig | undefined,\n  config: Tsconfig | undefined\n): Tsconfig {\n  base = base || {};\n  config = config || {};\n\n  return {\n    ...base,\n    ...config,\n    compilerOptions: {\n      ...base.compilerOptions,\n      ...config.compilerOptions,\n    },\n  };\n}\n",
    "symbols": [
      {
        "name": "tsConfigLoader",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/tsconfig-loader.ts",
        "startLine": 36,
        "endLine": 48
      },
      {
        "name": "loadSyncDefault",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/tsconfig-loader.ts",
        "startLine": 50,
        "endLine": 75
      },
      {
        "name": "resolveConfigPath",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/tsconfig-loader.ts",
        "startLine": 77,
        "endLine": 92
      },
      {
        "name": "walkForTsConfig",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/tsconfig-loader.ts",
        "startLine": 94,
        "endLine": 111
      },
      {
        "name": "loadTsconfig",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/tsconfig-loader.ts",
        "startLine": 113,
        "endLine": 162
      },
      {
        "name": "loadTsconfigFromExtends",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/tsconfig-loader.ts",
        "startLine": 168,
        "endLine": 209
      },
      {
        "name": "mergeTsconfigs",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/tsconfig-paths/src/tsconfig-loader.ts",
        "startLine": 211,
        "endLine": 226
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/cache.ts",
    "content": "import Redis from 'ioredis';\n\nexport class QueryCache {\n  private redis?: Redis;\n  private mem = new Map<string, { v: any; exp: number }>();\n  constructor(url?: string) {\n    if (url) {\n      try { this.redis = new Redis(url); } catch { this.redis = undefined; }\n    }\n  }\n  async get(key: string): Promise<any | undefined> {\n    if (this.redis) {\n      const v = await this.redis.get(key);\n      return v ? JSON.parse(v) : undefined;\n    }\n    const e = this.mem.get(key);\n    if (!e) return undefined;\n    if (Date.now() > e.exp) { this.mem.delete(key); return undefined; }\n    return e.v;\n  }\n  async set(key: string, value: any, ttlSec: number) {\n    if (this.redis) {\n      await this.redis.set(key, JSON.stringify(value), 'EX', ttlSec);\n      return;\n    }\n    this.mem.set(key, { v: value, exp: Date.now() + ttlSec * 1000 });\n  }\n}\n",
    "symbols": [
      {
        "name": "QueryCache",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/cache.ts",
        "startLine": 3,
        "endLine": 28
      },
      {
        "name": "QueryCache.get",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/cache.ts",
        "startLine": 11,
        "endLine": 20
      },
      {
        "name": "QueryCache.set",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/cache.ts",
        "startLine": 21,
        "endLine": 27
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/context_profiler.ts",
    "content": "export type ContextIntent = 'refactor' | 'test' | 'performance' | 'docs' | 'dataflow' | 'general';\n\nexport interface ContextProfile {\n  intent: ContextIntent;\n  tokenBudget: number;\n  requestedTopK: number;\n  effectiveTopK: number;\n  notes: string[];\n}\n\nconst KEYWORDS: Array<{ intent: ContextIntent; words: RegExp[]; budget: number; topK: number; note: string }> = [\n  {\n    intent: 'refactor',\n    words: [/refactor/i, /rename/i, /cleanup/i, /architecture/i],\n    budget: 1400,\n    topK: 8,\n    note: 'Refactor intent detected; widen snippet allocation.',\n  },\n  {\n    intent: 'dataflow',\n    words: [/data[\\s-]?flow/i, /dependency/i, /graph/i, /call tree/i, /topolog/i],\n    budget: 1300,\n    topK: 7,\n    note: 'Dataflow intent; prioritize dependency graph context.',\n  },\n  {\n    intent: 'test',\n    words: [/test/i, /assert/i, /coverage/i, /unit/i],\n    budget: 900,\n    topK: 6,\n    note: 'Testing intent; focus on functions and call sites.',\n  },\n  {\n    intent: 'performance',\n    words: [/perf/i, /performance/i, /slow/i, /latenc/i, /optimi[sz]e/i],\n    budget: 1100,\n    topK: 7,\n    note: 'Performance audit; include dependency graph context.',\n  },\n  {\n    intent: 'docs',\n    words: [/doc/i, /explain/i, /usage/i, /readme/i],\n    budget: 700,\n    topK: 5,\n    note: 'Docs intent; concise summaries are sufficient.',\n  },\n];\n\nexport function profileContext(query: string, requestedTopK: number): ContextProfile {\n  const trimmed = query.trim();\n  for (const candidate of KEYWORDS) {\n    if (candidate.words.some(re => re.test(trimmed))) {\n      return {\n        intent: candidate.intent,\n        tokenBudget: candidate.budget,\n        requestedTopK,\n        effectiveTopK: Math.max(1, Math.min(candidate.topK, requestedTopK || candidate.topK)),\n        notes: [candidate.note],\n      };\n    }\n  }\n  return {\n    intent: 'general',\n    tokenBudget: 600,\n    requestedTopK,\n    effectiveTopK: Math.max(1, Math.min(requestedTopK || 5, 5)),\n    notes: ['General search; apply balanced context selection.'],\n  };\n}\n",
    "symbols": [
      {
        "name": "profileContext",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/context_profiler.ts",
        "startLine": 49,
        "endLine": 69
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/generate_telemetry.ts",
    "content": "import path from 'path';\nimport process from 'process';\nimport { generate_telemetry_panel } from './tools';\n\nfunction parseArgs(argv: string[]): { root?: string; output?: string } {\n  const result: { root?: string; output?: string } = {};\n  for (let i = 0; i < argv.length; i++) {\n    const arg = argv[i];\n    if (arg.startsWith('--root=')) {\n      result.root = arg.slice('--root='.length);\n    } else if (arg === '--root' && argv[i + 1]) {\n      result.root = argv[++i];\n    } else if (arg.startsWith('--output=')) {\n      result.output = arg.slice('--output='.length);\n    } else if (arg === '--output' && argv[i + 1]) {\n      result.output = argv[++i];\n    }\n  }\n  return result;\n}\n\nfunction main() {\n  const args = parseArgs(process.argv.slice(2));\n  const repoRoot = args.root ? path.resolve(args.root) : process.cwd();\n  const result = generate_telemetry_panel(repoRoot, args.output);\n  // eslint-disable-next-line no-console\n  console.log(JSON.stringify(result, null, 2));\n}\n\nmain();\n\n",
    "symbols": [
      {
        "name": "parseArgs",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/generate_telemetry.ts",
        "startLine": 5,
        "endLine": 20
      },
      {
        "name": "main",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/generate_telemetry.ts",
        "startLine": 22,
        "endLine": 28
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/graph_store.ts",
    "content": "import Database from 'better-sqlite3';\nimport path from 'path';\n\nexport class GraphStore {\n  private db: Database.Database;\n  constructor(dbPath: string) {\n    const resolved = path.resolve(dbPath);\n    this.db = new Database(resolved);\n    this.bootstrap();\n  }\n  private bootstrap() {\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS files (\n        id INTEGER PRIMARY KEY,\n        path TEXT UNIQUE\n      );\n      CREATE TABLE IF NOT EXISTS symbols (\n        id INTEGER PRIMARY KEY,\n        file_id INTEGER,\n        name TEXT,\n        kind TEXT,\n        start_line INTEGER,\n        end_line INTEGER,\n        FOREIGN KEY(file_id) REFERENCES files(id)\n      );\n      CREATE TABLE IF NOT EXISTS edges (\n        from_file INTEGER,\n        to_file INTEGER,\n        kind TEXT,\n        UNIQUE(from_file, to_file, kind)\n      );\n    `);\n  }\n  listSymbols(file?: string) {\n    if (file) {\n      const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(file) as any;\n      if (!row) return [] as any[];\n      return this.db.prepare('SELECT name, kind, start_line AS startLine, end_line AS endLine FROM symbols WHERE file_id=?').all(row.id) as any[];\n    }\n    return this.db.prepare('SELECT f.path AS file, s.name, s.kind, s.start_line AS startLine, s.end_line AS endLine FROM symbols s JOIN files f ON s.file_id=f.id').all() as any[];\n  }\n  listImports(filePath: string): string[] {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return [];\n    const rows = this.db\n      .prepare('SELECT f.path AS path FROM edges e JOIN files f ON e.to_file=f.id WHERE e.from_file=?')\n      .all(row.id) as Array<{ path: string }>;\n    return rows.map(r => r.path);\n  }\n  listDependents(filePath: string): string[] {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return [];\n    const rows = this.db\n      .prepare('SELECT f.path AS path FROM edges e JOIN files f ON e.from_file=f.id WHERE e.to_file=?')\n      .all(row.id) as Array<{ path: string }>;\n    return rows.map(r => r.path);\n  }\n  findRefs(symbol: string) {\n    // Simple heuristic: return files that import the file containing the symbol\n    const fileRows = this.db.prepare('SELECT f.id, f.path, s.name FROM symbols s JOIN files f ON s.file_id=f.id WHERE s.name LIKE ?').all(`%${symbol}%`);\n    if (fileRows.length === 0) return [];\n    const fileIds = fileRows.map((r: any) => r.id);\n    const placeholders = fileIds.map(() => '?').join(',');\n    const refRows = this.db.prepare(`SELECT DISTINCT f2.path AS file FROM edges e JOIN files f1 ON e.to_file=f1.id JOIN files f2 ON e.from_file=f2.id WHERE e.kind='import' AND e.to_file IN (${placeholders})`).all(...fileIds) as any[];\n    return refRows as any[];\n  }\n  degree(filePath: string) {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return 0;\n    const out = this.db.prepare('SELECT COUNT(*) AS c FROM edges WHERE from_file=?').get(row.id) as any;\n    const inn = this.db.prepare('SELECT COUNT(*) AS c FROM edges WHERE to_file=?').get(row.id) as any;\n    return (out?.c || 0) + (inn?.c || 0);\n  }\n}\n",
    "symbols": [
      {
        "name": "GraphStore",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/graph_store.ts",
        "startLine": 4,
        "endLine": 74
      },
      {
        "name": "GraphStore.bootstrap",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/graph_store.ts",
        "startLine": 11,
        "endLine": 33
      },
      {
        "name": "GraphStore.listSymbols",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/graph_store.ts",
        "startLine": 34,
        "endLine": 41
      },
      {
        "name": "GraphStore.listImports",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/graph_store.ts",
        "startLine": 42,
        "endLine": 49
      },
      {
        "name": "GraphStore.listDependents",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/graph_store.ts",
        "startLine": 50,
        "endLine": 57
      },
      {
        "name": "GraphStore.findRefs",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/graph_store.ts",
        "startLine": 58,
        "endLine": 66
      },
      {
        "name": "GraphStore.degree",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/graph_store.ts",
        "startLine": 67,
        "endLine": 73
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/indexer.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport { Project, SyntaxKind } from 'ts-morph';\nimport madge from 'madge';\nimport { FileMeta, SymbolMeta, SemanticEntry } from '@mcp/shared';\nimport Database from 'better-sqlite3';\n\nfunction writeSQLite(dbPath: string, files: FileMeta[], imports: Array<{ from: string; to: string }>) {\n  // Ensure directory and file exist\n  try {\n    const dir = path.dirname(dbPath);\n    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n    if (!fs.existsSync(dbPath)) {\n      const fd = fs.openSync(dbPath, 'a');\n      fs.closeSync(fd);\n    }\n  } catch {}\n  const db = new Database(dbPath);\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS files (\n      id INTEGER PRIMARY KEY,\n      path TEXT UNIQUE\n    );\n    CREATE TABLE IF NOT EXISTS symbols (\n      id INTEGER PRIMARY KEY,\n      file_id INTEGER,\n      name TEXT,\n      kind TEXT,\n      start_line INTEGER,\n      end_line INTEGER,\n      FOREIGN KEY(file_id) REFERENCES files(id)\n    );\n    CREATE TABLE IF NOT EXISTS edges (\n      from_file INTEGER,\n      to_file INTEGER,\n      kind TEXT,\n      UNIQUE(from_file, to_file, kind)\n    );\n  `);\n  db.exec('BEGIN');\n  db.exec('DELETE FROM edges; DELETE FROM symbols; DELETE FROM files;');\n  const insertFile = db.prepare('INSERT OR IGNORE INTO files(path) VALUES (?)');\n  const getFileId = db.prepare('SELECT id FROM files WHERE path=?');\n  const insertSym = db.prepare('INSERT INTO symbols(file_id,name,kind,start_line,end_line) VALUES (?,?,?,?,?)');\n  for (const f of files) {\n    insertFile.run(f.path);\n    const row = getFileId.get(f.path) as any;\n    for (const s of f.symbols) insertSym.run(row.id, s.name, s.kind, s.startLine, s.endLine);\n  }\n  const insertEdge = db.prepare('INSERT OR IGNORE INTO edges(from_file,to_file,kind) VALUES (?,?,?)');\n  for (const e of imports) {\n    const fromRow = getFileId.get(e.from) as any;\n    const toRow = getFileId.get(e.to) as any;\n    if (fromRow && toRow) insertEdge.run(fromRow.id, toRow.id, 'import');\n  }\n  db.exec('COMMIT');\n  db.close();\n}\n\nfunction buildEdgesWithTsMorph(project: Project, rootDir: string): Array<{ from: string; to: string }> {\n  const edges: Array<{ from: string; to: string }> = [];\n  const files = project.getSourceFiles();\n  // Debug root info if needed\n  try {\n    const info = `rootDir=${rootDir}\\nfirstFile=${files[0]?.getFilePath()}`;\n    const out = path.join(process.cwd(), 'data', 'edges_info.txt');\n    fs.mkdirSync(path.dirname(out), { recursive: true });\n    fs.writeFileSync(out, info, 'utf8');\n  } catch {}\n  for (const sf of files) {\n    const fromAbs = sf.getFilePath();\n    const fromRel = path.relative(rootDir, fromAbs).replace(/\\\\/g, '/');\n    // import declarations\n    for (const imp of sf.getImportDeclarations()) {\n      const target = imp.getModuleSpecifierSourceFile();\n      if (!target) continue;\n      const toAbs = target.getFilePath();\n      if (!toAbs.startsWith(rootDir)) continue;\n      const toRel = path.relative(rootDir, toAbs).replace(/\\\\/g, '/');\n      if (fromRel !== toRel) edges.push({ from: fromRel, to: toRel });\n    }\n    // export declarations (re-exports)\n    for (const exp of sf.getExportDeclarations()) {\n      const target = exp.getModuleSpecifierSourceFile();\n      if (!target) continue;\n      const toAbs = target.getFilePath();\n      if (!toAbs.startsWith(rootDir)) continue;\n      const toRel = path.relative(rootDir, toAbs).replace(/\\\\/g, '/');\n      if (fromRel !== toRel) edges.push({ from: fromRel, to: toRel });\n    }\n  }\n  // de-duplicate\n  const key = (e: { from: string; to: string }) => `${e.from}=>${e.to}`;\n  const map = new Map<string, { from: string; to: string }>();\n  for (const e of edges) map.set(key(e), e);\n  return Array.from(map.values());\n}\n\nfunction resolveTsConfig(): string | undefined {\n  const envPath = process.env.TS_CONFIG_PATH;\n  if (envPath && fs.existsSync(envPath)) return envPath;\n  // Prefer the package-local tsconfig to avoid relying on process.cwd()\n  const pkgTs = path.resolve(__dirname, '..', 'tsconfig.json');\n  if (fs.existsSync(pkgTs)) return pkgTs;\n  // Next, try repository root tsconfig relative to this file\n  const repoRootTs = path.resolve(__dirname, '..', '..', '..', 'tsconfig.json');\n  if (fs.existsSync(repoRootTs)) return repoRootTs;\n  // Finally, try current working directory only if it actually exists\n  const cwdTs = path.resolve(process.cwd(), 'tsconfig.json');\n  if (fs.existsSync(cwdTs)) return cwdTs;\n  return undefined;\n}\n\nexport async function runIndexer(rootDir: string, outDir: string, sqlitePath?: string) {\n  const tsConfigPath = resolveTsConfig();\n  let project: Project;\n  try {\n    project = tsConfigPath\n      ? new Project({ tsConfigFilePath: tsConfigPath })\n      : new Project({ skipAddingFilesFromTsConfig: true });\n  } catch {\n    // Fall back to a minimal config that avoids reading any tsconfig\n    project = new Project({ skipAddingFilesFromTsConfig: true });\n  }\n  const tsFiles = project.addSourceFilesAtPaths([path.join(rootDir, '**/*.ts'), '!' + path.join(rootDir, '**/*.d.ts')]);\n  const fileMetas: FileMeta[] = [];\n  const semanticEntries: SemanticEntry[] = [];\n  for (const sf of tsFiles) {\n    const fullPath = sf.getFilePath();\n    const content = sf.getFullText();\n    const symbols: SymbolMeta[] = [];\n    sf.forEachDescendant(node => {\n      if (node.getKind() === SyntaxKind.FunctionDeclaration) {\n        const fn = node.asKind(SyntaxKind.FunctionDeclaration)!;\n        const name = fn.getName();\n        if (name) {\n          const start = fn.getStartLineNumber();\n          const end = fn.getEndLineNumber();\n          symbols.push({ name, kind: 'function', file: fullPath, startLine: start, endLine: end });\n        }\n      } else if (node.getKind() === SyntaxKind.ClassDeclaration) {\n        const cls = node.asKind(SyntaxKind.ClassDeclaration)!;\n        const name = cls.getName();\n        if (name) {\n          const start = cls.getStartLineNumber();\n          const end = cls.getEndLineNumber();\n          symbols.push({ name, kind: 'class', file: fullPath, startLine: start, endLine: end });\n          for (const m of cls.getMethods()) {\n            symbols.push({ name: `${name}.${m.getName()}`, kind: 'method', file: fullPath, startLine: m.getStartLineNumber(), endLine: m.getEndLineNumber() });\n          }\n        }\n      }\n    });\n    const relativePath = path.relative(rootDir, fullPath).replace(/\\\\/g, '/');\n    const fm: FileMeta = { path: relativePath, content, symbols };\n    fileMetas.push(fm);\n    const lines = content.split(/\\r?\\n/);\n    for (const s of symbols) {\n      const snippet = lines.slice(s.startLine - 1, s.endLine).join('\\n');\n      semanticEntries.push({ id: `${s.file}:${s.name}`, file: relativePath, symbol: s.name, startLine: s.startLine, endLine: s.endLine, text: snippet });\n    }\n  }\n  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });\n  fs.writeFileSync(path.join(outDir, 'index.json'), JSON.stringify(fileMetas, null, 2), 'utf8');\n  fs.writeFileSync(path.join(outDir, 'semantic_entries.json'), JSON.stringify(semanticEntries, null, 2), 'utf8');\n\n  // Build edges via madge (best-effort)\n  let edges: Array<{ from: string; to: string }> = [];\n  try {\n    const result = await madge(rootDir, {\n      fileExtensions: ['ts', 'tsx', 'js', 'jsx'],\n      // Provide a stable tsconfig path that actually exists\n      tsConfig: (tsConfigPath && fs.existsSync(tsConfigPath))\n        ? tsConfigPath\n        : path.resolve(__dirname, '..', 'tsconfig.json'),\n      detectiveOptions: { ts: { skipTypeImports: true } } as any,\n      includeNpm: false,\n      baseDir: rootDir,\n    } as any);\n    const graph = await result.obj();\n    for (const [from, tos] of Object.entries(graph)) {\n      const fromAbs = path.isAbsolute(from) ? from : path.resolve(rootDir, from);\n      const fromRel = path.relative(rootDir, fromAbs).replace(/\\\\/g, '/');\n      for (const to of tos as string[]) {\n        const toAbs = path.isAbsolute(to) ? to : path.resolve(rootDir, to);\n        const toRel = path.relative(rootDir, toAbs).replace(/\\\\/g, '/');\n        if (fromRel && toRel && fromRel !== toRel) edges.push({ from: fromRel, to: toRel });\n      }\n    }\n  } catch {\n    // ignore madge errors; fallback to ts-morph\n  }\n\n  // Fallback/union with ts-morph derived edges\n  const morphEdges = buildEdgesWithTsMorph(project, rootDir);\n  const existing = new Set(edges.map(e => `${e.from}=>${e.to}`));\n  for (const e of morphEdges) if (!existing.has(`${e.from}=>${e.to}`)) edges.push(e);\n  // Debug: dump edges\n  try { fs.writeFileSync(path.join(outDir, 'edges.json'), JSON.stringify(edges, null, 2), 'utf8'); } catch {}\n  if (sqlitePath) writeSQLite(sqlitePath, fileMetas, edges);\n}\n\nif (require.main === module) {\n  const rootDir = path.join(process.cwd(), 'src');\n  const outDir = path.join(process.cwd(), 'data');\n  const sqlite = path.join(outDir, 'graph.db');\n  runIndexer(rootDir, outDir, sqlite).then(() => console.log('Indexing (monorepo) complete.'));\n}\n",
    "symbols": [
      {
        "name": "writeSQLite",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/indexer.ts",
        "startLine": 8,
        "endLine": 58
      },
      {
        "name": "buildEdgesWithTsMorph",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/indexer.ts",
        "startLine": 60,
        "endLine": 97
      },
      {
        "name": "resolveTsConfig",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/indexer.ts",
        "startLine": 99,
        "endLine": 112
      },
      {
        "name": "runIndexer",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/indexer.ts",
        "startLine": 114,
        "endLine": 201
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/index_cli.ts",
    "content": "import path from 'path';\nimport fs from 'fs';\nimport { runIndexer } from './indexer';\n\nasync function main() {\n  const envRoot = process.env.INDEX_ROOT || process.env.MCP_INDEX_ROOT || process.env.WORKSPACE_ROOT;\n  const envData = process.env.DATA_DIR || process.env.MCP_DATA_DIR;\n  const rootDir = envRoot ? path.resolve(envRoot) : process.cwd();\n  const outDir = envData ? path.resolve(envData) : path.join(process.cwd(), 'data');\n  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });\n  const sqlite = path.join(outDir, 'graph.db');\n  await runIndexer(rootDir, outDir, sqlite);\n  // Also set env so any subsequent child tools could reuse\n  process.env.DATA_DIR = outDir;\n  process.env.SQLITE_DB = sqlite;\n}\n\nmain().then(() => console.log('Indexing complete.'), err => { console.error(err?.message || String(err)); process.exit(1); });\n\n",
    "symbols": [
      {
        "name": "main",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/index_cli.ts",
        "startLine": 5,
        "endLine": 16
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/job_queue.ts",
    "content": "import { Queue, Worker, JobsOptions } from 'bullmq';\nimport IORedis from 'ioredis';\nimport { runIndexer } from './indexer';\n\nexport function createQueue(name = 'mcp-jobs', connection?: string) {\n  const conn = connection ? new IORedis(connection) : undefined;\n  const queue = new Queue(name, { connection: conn as any });\n  return queue;\n}\n\nexport function startWorker(name = 'mcp-jobs', connection?: string) {\n  const conn = connection ? new IORedis(connection) : undefined;\n  const worker = new Worker(name, async job => {\n    if (job.name === 'reindex') {\n      const { rootDir, outDir, sqlite } = job.data as { rootDir: string; outDir: string; sqlite: string };\n      await runIndexer(rootDir, outDir, sqlite);\n    }\n  }, { connection: conn as any });\n  return worker;\n}\n\nexport async function enqueueReindex(queue: Queue, payload: { rootDir: string; outDir: string; sqlite: string }, opts?: JobsOptions) {\n  await queue.add('reindex', payload, opts);\n}\n\n",
    "symbols": [
      {
        "name": "createQueue",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/job_queue.ts",
        "startLine": 5,
        "endLine": 9
      },
      {
        "name": "startWorker",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/job_queue.ts",
        "startLine": 11,
        "endLine": 20
      },
      {
        "name": "enqueueReindex",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/job_queue.ts",
        "startLine": 22,
        "endLine": 24
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/langchain_bridge.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\ninterface SemanticEntry {\n  id: string;\n  file: string;\n  symbol: string;\n  text: string;\n}\n\ninterface BridgeResult {\n  id: string;\n  file: string;\n  symbol: string;\n  score: number;\n  snippet: string;\n}\n\nexport class LangChainBridge {\n  private entries: SemanticEntry[] = [];\n  private available = false;\n  private reason = 'langchain package not detected';\n\n  constructor(private dataDir: string) {\n    this.loadEntries();\n    this.detectLangChain();\n  }\n\n  private loadEntries() {\n    const semanticPath = path.join(this.dataDir, 'semantic_entries.json');\n    if (!fs.existsSync(semanticPath)) return;\n    try {\n      const parsed = JSON.parse(fs.readFileSync(semanticPath, 'utf8')) as Array<any>;\n      this.entries = parsed.map(e => ({\n        id: String(e.id ?? `${e.file}:${e.symbol}`),\n        file: String(e.file),\n        symbol: String(e.symbol),\n        text: String(e.text ?? ''),\n      }));\n    } catch {\n      this.entries = [];\n    }\n  }\n\n  private detectLangChain() {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      require.resolve('langchain');\n      this.available = true;\n      this.reason = '';\n    } catch {\n      this.available = false;\n    }\n  }\n\n  private lexicalQuery(query: string, topK: number): BridgeResult[] {\n    const tokens = query\n      .toLowerCase()\n      .split(/\\W+/)\n      .filter(Boolean);\n    const scored = this.entries.map(entry => {\n      const text = entry.text.toLowerCase();\n      let hits = 0;\n      for (const token of tokens) {\n        if (text.includes(token)) hits += 1;\n      }\n      const score = tokens.length ? hits / tokens.length : 0;\n      return {\n        id: entry.id,\n        file: entry.file,\n        symbol: entry.symbol,\n        score,\n        snippet: entry.text.slice(0, 200),\n      };\n    });\n    return scored\n      .sort((a, b) => b.score - a.score)\n      .slice(0, Math.max(1, Math.min(topK, scored.length)));\n  }\n\n  async query(query: string, topK: number): Promise<{ available: boolean; provider: 'langchain' | 'fallback'; reason?: string; results: BridgeResult[] }> {\n    if (!this.entries.length) {\n      return {\n        available: this.available,\n        provider: this.available ? 'langchain' : 'fallback',\n        reason: this.entries.length ? undefined : 'semantic_entries.json not found or empty',\n        results: [],\n      };\n    }\n\n    if (!this.available) {\n      return {\n        available: false,\n        provider: 'fallback',\n        reason: this.reason,\n        results: this.lexicalQuery(query, topK),\n      };\n    }\n\n    // Placeholder for real LangChain integration. Until dependencies are present,\n    // fall back to lexical scoring while reporting availability.\n    return {\n      available: true,\n      provider: 'langchain',\n      reason: 'LangChain detected but no vector store configured; using lexical fallback.',\n      results: this.lexicalQuery(query, topK),\n    };\n  }\n}\n\n",
    "symbols": [
      {
        "name": "LangChainBridge",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/langchain_bridge.ts",
        "startLine": 19,
        "endLine": 109
      },
      {
        "name": "LangChainBridge.loadEntries",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/langchain_bridge.ts",
        "startLine": 29,
        "endLine": 43
      },
      {
        "name": "LangChainBridge.detectLangChain",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/langchain_bridge.ts",
        "startLine": 45,
        "endLine": 54
      },
      {
        "name": "LangChainBridge.lexicalQuery",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/langchain_bridge.ts",
        "startLine": 56,
        "endLine": 79
      },
      {
        "name": "LangChainBridge.query",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/langchain_bridge.ts",
        "startLine": 81,
        "endLine": 108
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/launch_mcp.ts",
    "content": "import path from 'path';\nimport fs from 'fs';\nimport http from 'http';\nimport net from 'net';\nimport type { FSWatcher } from 'chokidar';\nimport { spawn, execSync } from 'child_process';\nimport { runIndexer } from './indexer';\nimport { startWatcher } from './watcher';\n\nasync function ensureIndex(rootDir: string, outDir: string, sqlite: string) {\n  await runIndexer(rootDir, outDir, sqlite);\n}\n\nfunction tryStartMemurai() {\n  try {\n    // Start Memurai service if installed; ignore failures.\n    if (process.platform === 'win32') {\n      execSync('powershell -NoProfile -Command \"$s=Get-Service -Name Memurai* -ErrorAction SilentlyContinue | Select-Object -First 1; if ($s -and $s.Status -ne \\\"Running\\\") { Start-Service -InputObject $s }\"', { stdio: 'ignore' });\n    }\n  } catch {}\n}\n\nfunction checkPortFree(port: number): Promise<boolean> {\n  return new Promise(resolve => {\n    const srv = net.createServer();\n    srv.once('error', () => resolve(false));\n    srv.once('listening', () => { srv.close(() => resolve(true)); });\n    srv.listen(port, '127.0.0.1');\n  });\n}\n\nasync function findFreePort(start: number, max: number): Promise<number> {\n  for (let p = start; p <= max; p++) {\n    // eslint-disable-next-line no-await-in-loop\n    if (await checkPortFree(p)) return p;\n  }\n  return start;\n}\n\nfunction waitForHealth(url: string, attempts = 30, delayMs = 500): Promise<void> {\n  return new Promise((resolve, reject) => {\n    let tries = 0;\n    const tick = () => {\n      tries++;\n      const req = http.get(url, res => {\n        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\n          res.resume();\n          resolve();\n        } else {\n          res.resume();\n          if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health timeout'));\n        }\n      });\n      req.on('error', () => { if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health error')); });\n    };\n    tick();\n  });\n}\n\nasync function startFastApi(dataDir: string, port: number) {\n  const script = path.join(process.cwd(), 'packages', 'semantic-engine', 'semantic_engine_fastapi.py');\n  const env = { ...process.env, DATA_DIR: dataDir, ENGINE_PORT: String(port) };\n  // Quick preflight to ensure python + fastapi are usable; if not, throw and fallback\n  try {\n    execSync('python -V', { stdio: 'ignore' });\n    execSync('python -c \"import fastapi,uvicorn\"', { stdio: 'ignore' });\n  } catch {\n    throw new Error('python or fastapi/uvicorn not available');\n  }\n  const proc = spawn('python', [script], { env, stdio: 'ignore', windowsHide: true });\n  await waitForHealth(`http://127.0.0.1:${port}/health`, 40, 500);\n  return proc;\n}\n\nfunction startLocalNodeEngine(dataDir: string, port: number) {\n  // Minimal in-process engine with /health and /search using naive scoring\n  const entriesPath = path.join(dataDir, 'semantic_entries.json');\n  let entries: Array<{ id: string; file: string; symbol: string; startLine: number; endLine: number; text: string }> = [];\n  try {\n    const raw = fs.readFileSync(entriesPath, 'utf8');\n    entries = JSON.parse(raw);\n  } catch {\n    entries = [];\n  }\n  const server = http.createServer((req, res) => {\n    try {\n      const url = new URL(req.url || '/', `http://127.0.0.1:${port}`);\n      if (url.pathname === '/health') {\n        res.writeHead(200, { 'content-type': 'application/json' });\n        res.end(JSON.stringify({ ok: true }));\n        return;\n      }\n      if (url.pathname === '/search') {\n        const q = (url.searchParams.get('q') || '').toLowerCase();\n        const topK = Math.max(1, Math.min(50, Number(url.searchParams.get('top_k') || '5')));\n        const scored = entries.map(e => {\n          const text = (e.text || '').toLowerCase();\n          let score = 0;\n          if (q) {\n            // naive: frequency of query tokens present\n            const tokens = q.split(/\\s+/).filter(Boolean);\n            for (const t of tokens) {\n              if (!t) continue;\n              const matches = text.split(t).length - 1;\n              score += matches;\n            }\n          }\n          return { file: e.file, symbol: e.symbol, startLine: e.startLine, endLine: e.endLine, score, snippet: e.text?.slice(0, 200) || '' };\n        }).sort((a, b) => b.score - a.score).slice(0, topK);\n        res.writeHead(200, { 'content-type': 'application/json' });\n        res.end(JSON.stringify({ query: q, results: scored }));\n        return;\n      }\n      res.writeHead(404);\n      res.end();\n    } catch (e) {\n      res.writeHead(500);\n      res.end();\n    }\n  });\n  server.listen(port, '127.0.0.1');\n  return server;\n}\n\n(async () => {\n  if (process.env.MCP_STDOUT_LOGS !== '1') {\n    const passThrough = (stream: 'log' | 'info' | 'warn') => (...args: unknown[]) =>\n      console.error(`[${stream}]`, ...args);\n    console.log = passThrough('log');\n    console.info = passThrough('info');\n    console.warn = passThrough('warn');\n  }\n\n  const fastStart = (process.env.MCP_FAST_START === '1' || process.env.FAST_START === '1');\n  tryStartMemurai();\n\n  const envRoot = process.env.INDEX_ROOT || process.env.MCP_INDEX_ROOT;\n  const envData = process.env.DATA_DIR || process.env.MCP_DATA_DIR;\n  const rootDir = envRoot ? path.resolve(envRoot) : path.join(__dirname, '..', 'src');\n  const dataDir = envData ? path.resolve(envData) : path.join(__dirname, '..', 'data');\n  const sqlitePath = path.join(dataDir, 'graph.db');\n  process.env.DATA_DIR = dataDir;\n  process.env.SQLITE_DB = sqlitePath;\n\n  const port = await findFreePort(8010, 8020);\n  let engineCleanup: (() => void) | null = null;\n  const engineUrl = `http://127.0.0.1:${port}`;\n  let watcher: FSWatcher | null = null;\n\n  const startIndexWatcher = () => {\n    if (!watcher) {\n      try {\n        watcher = startWatcher(rootDir, dataDir, sqlitePath);\n      } catch (err) {\n        if (process.env.DEBUG_WATCHER) {\n          // eslint-disable-next-line no-console\n          console.warn('[mcp] watcher failed to start', err);\n        }\n      }\n    }\n  };\n  const ensureFreshIndex = async () => {\n    await ensureIndex(rootDir, dataDir, sqlitePath);\n  };\n\n  if (fastStart) {\n    // Start local engine immediately and bind adapter without waiting for index\n    const srv = startLocalNodeEngine(dataDir, port);\n    engineCleanup = () => { try { srv.close(); } catch {} };\n    process.env.ENGINE_URL = engineUrl;\n\n    // Bind stdio adapter ASAP\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    require('./mcp_adapter');\n\n    startIndexWatcher();\n\n    // Index in background\n    setImmediate(async () => { try { await ensureFreshIndex(); } catch {} });\n  } else {\n    await ensureFreshIndex();\n    startIndexWatcher();\n    try {\n      const engineProc = await startFastApi(dataDir, port);\n      engineCleanup = () => { try { engineProc.kill(); } catch {} };\n    } catch {\n      const srv = startLocalNodeEngine(dataDir, port);\n      engineCleanup = () => { try { srv.close(); } catch {} };\n    }\n    process.env.ENGINE_URL = engineUrl;\n\n    // Bind stdio adapter\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    require('./mcp_adapter');\n  }\n\n  const shutdown = () => {\n    try { engineCleanup && engineCleanup(); } catch {}\n    try {\n      if (watcher) {\n        watcher.close().catch(() => undefined);\n      }\n    } catch {}\n    process.exit(0);\n  };\n  process.on('SIGINT', shutdown);\n  process.on('SIGTERM', shutdown);\n})();\n",
    "symbols": [
      {
        "name": "ensureIndex",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp.ts",
        "startLine": 10,
        "endLine": 12
      },
      {
        "name": "tryStartMemurai",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp.ts",
        "startLine": 14,
        "endLine": 21
      },
      {
        "name": "checkPortFree",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp.ts",
        "startLine": 23,
        "endLine": 30
      },
      {
        "name": "findFreePort",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp.ts",
        "startLine": 32,
        "endLine": 38
      },
      {
        "name": "waitForHealth",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp.ts",
        "startLine": 40,
        "endLine": 58
      },
      {
        "name": "startFastApi",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp.ts",
        "startLine": 60,
        "endLine": 73
      },
      {
        "name": "startLocalNodeEngine",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp.ts",
        "startLine": 75,
        "endLine": 123
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/launch_mcp_http.ts",
    "content": "import path from 'path';\nimport { spawn, execSync } from 'child_process';\nimport http from 'http';\nimport { runIndexer } from './indexer';\nimport { startMcpHttpBridge } from './mcp_http_bridge';\n\nasync function ensureIndex() {\n  const envRoot = process.env.INDEX_ROOT || process.env.MCP_INDEX_ROOT;\n  const envData = process.env.DATA_DIR;\n  const rootDir = envRoot ? path.resolve(envRoot) : path.join(__dirname, '..', 'src');\n  const outDir = envData ? path.resolve(envData) : path.join(__dirname, '..', 'data');\n  const sqlite = path.join(outDir, 'graph.db');\n  await runIndexer(rootDir, outDir, sqlite);\n}\n\nfunction waitForHealth(url: string, attempts = 30, delayMs = 500): Promise<void> {\n  return new Promise((resolve, reject) => {\n    let tries = 0;\n    const tick = () => {\n      tries++;\n      const req = http.get(url, res => {\n        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\n          res.resume(); resolve();\n        } else { res.resume(); if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health timeout')); }\n      });\n      req.on('error', () => { if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health error')); });\n    };\n    tick();\n  });\n}\n\nasync function startFastApi(dataDir: string, port: number) {\n  const script = path.join(process.cwd(), 'packages', 'semantic-engine', 'semantic_engine_fastapi.py');\n  const env = { ...process.env, DATA_DIR: dataDir, ENGINE_PORT: String(port) };\n  try { execSync('python -V', { stdio: 'ignore' }); execSync('python -c \"import fastapi,uvicorn\"', { stdio: 'ignore' }); }\n  catch { throw new Error('python or fastapi/uvicorn not available'); }\n  const proc = spawn('python', [script], { env, stdio: 'ignore', windowsHide: true });\n  await waitForHealth(`http://127.0.0.1:${port}/health`, 40, 500);\n  return proc;\n}\n\n(async () => {\n  await ensureIndex();\n  const dataDir = process.env.DATA_DIR ? path.resolve(process.env.DATA_DIR) : path.join(__dirname, '..', 'data');\n  // Start engine or proceed (fallback handled by orchestrator if not reachable)\n  let engineCleanup: (() => void) | null = null;\n  try {\n    const engineProc = await startFastApi(dataDir, 8010);\n    engineCleanup = () => { try { engineProc.kill(); } catch {} };\n    process.env.ENGINE_URL = `http://127.0.0.1:8010`;\n  } catch {\n    process.env.ENGINE_URL = process.env.ENGINE_URL || 'http://127.0.0.1:8000';\n  }\n  process.env.DATA_DIR = dataDir;\n  process.env.SQLITE_DB = path.join(dataDir, 'graph.db');\n\n  const port = parseInt(process.env.MCP_HTTP_PORT || '7450', 10);\n  const { server, child } = startMcpHttpBridge(port);\n  // eslint-disable-next-line no-console\n  console.log(`MCP HTTP bridge listening at http://127.0.0.1:${port}/mcp`);\n\n  const shutdown = () => {\n    try { server.close(); } catch {}\n    try { child.kill(); } catch {}\n    try { engineCleanup && engineCleanup(); } catch {}\n    process.exit(0);\n  };\n  process.on('SIGINT', shutdown);\n  process.on('SIGTERM', shutdown);\n})();\n",
    "symbols": [
      {
        "name": "ensureIndex",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp_http.ts",
        "startLine": 7,
        "endLine": 14
      },
      {
        "name": "waitForHealth",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp_http.ts",
        "startLine": 16,
        "endLine": 30
      },
      {
        "name": "startFastApi",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/launch_mcp_http.ts",
        "startLine": 32,
        "endLine": 40
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/mcp.ts",
    "content": "/**\n * Minimal MCP JSON-RPC (stdio) server exposing core tools.\n * Methods:\n *  - search_code(q: string, top_k?: number)\n *  - get_file(path: string)\n *  - list_symbols(file?: string)\n */\nimport readline from 'readline';\nimport path from 'path';\nimport { Orchestrator } from './orchestrator';\nimport { GraphStore } from './graph_store';\nimport { startTimer } from './telemetry';\nimport {\n  summarize_architecture,\n  detect_smells,\n  suggest_tests,\n  plan_refactor,\n  generate_patch,\n  apply_patch as applyPatchOperations,\n  analyze_performance,\n  compare_versions,\n  auto_docs,\n  run_tests,\n  run_task,\n  generate_telemetry_panel,\n  langchain_query,\n  open_telemetry_webview,\n} from './tools';\nimport { set_weights } from './ranker';\nimport { WeightManager } from './weights';\n\nconst DATA_DIR = process.env.DATA_DIR || process.cwd() + '/data';\nconst ENGINE_URL = process.env.ENGINE_URL || 'http://localhost:8000';\nconst orchestrator = new Orchestrator(DATA_DIR, ENGINE_URL);\nconst graph = new GraphStore(process.env.SQLITE_DB || (process.cwd() + '/data/graph.db'));\nconst wm = new WeightManager();\nset_weights(wm.get());\n\ntype Json = any;\n\ninterface RpcRequest {\n  jsonrpc: '2.0';\n  id: string | number | null;\n  method: string;\n  params?: Json;\n}\n\nfunction respond(id: RpcRequest['id'], result?: Json, error?: { code: number; message: string }) {\n  const payload: any = { jsonrpc: '2.0', id };\n  if (error) payload.error = error; else payload.result = result ?? null;\n  process.stdout.write(JSON.stringify(payload) + '\\n');\n}\n\nasync function handle(req: RpcRequest) {\n  try {\n    switch (req.method) {\n      case 'search_code': {\n        const stop = startTimer('search_code', { source: 'mcp:tools' });\n        const q = String(req.params?.q ?? '');\n        const topK = Number(req.params?.top_k ?? 5);\n        const results = await orchestrator.searchCode(q, topK);\n        const profile = orchestrator.getLastProfile();\n        respond(req.id, { query: q, profile, results });\n        stop({ query_length: q.length, result_count: results.length, top_k: topK, intent: profile?.intent });\n        return;\n      }\n      case 'get_file': {\n        const stop = startTimer('get_file', { source: 'mcp:tools' });\n        const filePath = String(req.params?.path ?? '');\n        const content = orchestrator.getFile(filePath);\n        respond(req.id, { path: filePath, content });\n        stop({ path: filePath, content_length: content.length });\n        return;\n      }\n      case 'list_symbols': {\n        const file = req.params?.file ? String(req.params.file) : undefined;\n        const symbols = graph.listSymbols(file);\n        respond(req.id, symbols);\n        return;\n      }\n      case 'find_refs': {\n        const symbol = String(req.params?.symbol ?? '');\n        const refs = graph.findRefs(symbol);\n        respond(req.id, refs);\n        return;\n      }\n      case 'plan_refactor': {\n        const file = req.params?.file ? String(req.params.file) : undefined;\n        const symbol = req.params?.symbol ? String(req.params.symbol) : undefined;\n        const goal = req.params?.goal ? String(req.params.goal) : undefined;\n        const plan = plan_refactor(orchestrator, graph, process.cwd(), { file, symbol, goal });\n        respond(req.id, plan);\n        return;\n      }\n      case 'gen_patch': {\n        const file = String(req.params?.path ?? '');\n        const operations = Array.isArray(req.params?.operations) ? (req.params.operations as any[]) : [];\n        const patch = generate_patch(process.cwd(), file, operations);\n        respond(req.id, patch);\n        return;\n      }\n      case 'apply_patch': {\n        const file = String(req.params?.path ?? '');\n        const operations = Array.isArray(req.params?.operations) ? (req.params.operations as any[]) : [];\n        const result = applyPatchOperations(process.cwd(), file, operations);\n        respond(req.id, result);\n        return;\n      }\n      case 'analyze_performance': {\n        const file = String(req.params?.path ?? '');\n        const insight = analyze_performance(process.cwd(), file);\n        respond(req.id, insight);\n        return;\n      }\n      case 'compare_versions': {\n        const pathA = String(req.params?.pathA ?? '');\n        const pathB = String(req.params?.pathB ?? '');\n        const diff = compare_versions(process.cwd(), pathA, pathB);\n        respond(req.id, diff);\n        return;\n      }\n      case 'auto_docs': {\n        const file = String(req.params?.path ?? '');\n        const docs = auto_docs(orchestrator, graph, process.cwd(), file);\n        respond(req.id, docs);\n        return;\n      }\n      case 'run_tests': {\n        const command = req.params?.command ? String(req.params.command) : 'npm test';\n        const outcome = run_tests(process.cwd(), command);\n        respond(req.id, outcome);\n        return;\n      }\n      case 'run_task': {\n        const script = String(req.params?.script ?? '');\n        const outcome = run_task(process.cwd(), script);\n        respond(req.id, outcome);\n        return;\n      }\n      case 'generate_telemetry_panel': {\n        const output = req.params?.output ? String(req.params.output) : undefined;\n        const panel = generate_telemetry_panel(process.cwd(), output);\n        respond(req.id, panel);\n        return;\n      }\n      case 'open_telemetry_webview': {\n        const regenerate = req.params?.regenerate === true;\n        const output = req.params?.output ? String(req.params.output) : undefined;\n        const webview = open_telemetry_webview(process.cwd(), { regenerate, output });\n        respond(req.id, webview);\n        return;\n      }\n      case 'langchain_query': {\n        const query = String(req.params?.q ?? '');\n        const topK = Number(req.params?.top_k ?? 5);\n        const dataDir = process.env.DATA_DIR || path.join(process.cwd(), 'data');\n        langchain_query(dataDir, query, topK)\n          .then(result => respond(req.id, result))\n          .catch(err => respond(req.id, undefined, { code: -32000, message: err?.message || 'LangChain query failed' }));\n        return;\n      }\n      case 'summarize_architecture': {\n        const summary = summarize_architecture(graph);\n        respond(req.id, summary);\n        return;\n      }\n      case 'detect_smells': {\n        const repo = String(req.params?.root ?? process.cwd());\n        const res = detect_smells(repo);\n        respond(req.id, res);\n        return;\n      }\n      case 'suggest_tests': {\n        const symbols = (req.params?.symbols ?? []) as Array<{ file: string; name: string }>;\n        const suggestions = suggest_tests(symbols);\n        respond(req.id, suggestions);\n        return;\n      }\n      case 'submit_feedback': {\n        const kind = String(req.params?.kind ?? 'up');\n        wm.feedback(kind === 'down' ? 'down' : 'up');\n        set_weights(wm.get());\n        respond(req.id, { ok: true, weights: wm.get() });\n        return;\n      }\n      case 'get_weights': {\n        respond(req.id, wm.get());\n        return;\n      }\n      default:\n        respond(req.id, undefined, { code: -32601, message: 'Method not found' });\n    }\n  } catch (e: any) {\n    respond(req.id, undefined, { code: -32000, message: e?.message || 'Internal error' });\n  }\n}\n\nconst rl = readline.createInterface({ input: process.stdin, output: process.stdout, terminal: false });\nrl.on('line', line => {\n  if (!line.trim()) return;\n  try {\n    const req = JSON.parse(line) as RpcRequest;\n    if (req && req.jsonrpc === '2.0' && req.method) {\n      handle(req);\n    }\n  } catch {\n    // ignore\n  }\n});\n\nprocess.on('SIGINT', () => process.exit(0));\n",
    "symbols": [
      {
        "name": "respond",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp.ts",
        "startLine": 48,
        "endLine": 52
      },
      {
        "name": "handle",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp.ts",
        "startLine": 54,
        "endLine": 196
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/mcp_adapter.ts",
    "content": "/**\n * Minimal MCP adapter implementing a subset of the Model Context Protocol\n * over stdio using JSON-RPC 2.0. Exposes tools via tools/list and tools/call.\n */\nimport readline from 'readline';\nimport fs from 'fs';\nimport path from 'path';\nimport { Orchestrator } from './orchestrator';\nimport { GraphStore } from './graph_store';\nimport {\n  summarize_architecture,\n  detect_smells,\n  suggest_tests,\n  plan_refactor,\n  generate_patch,\n  apply_patch as applyPatchOperations,\n  analyze_performance,\n  compare_versions,\n  auto_docs,\n  run_tests,\n  run_task,\n  generate_telemetry_panel,\n  langchain_query,\n  open_telemetry_webview,\n} from './tools';\nimport { allowPath } from './policy';\nimport { set_weights } from './ranker';\nimport { WeightManager } from './weights';\n\nconst DATA_DIR = process.env.DATA_DIR || process.cwd() + '/data';\nconst ENGINE_URL = process.env.ENGINE_URL || 'http://localhost:8000';\nconst SQLITE_DB = process.env.SQLITE_DB || (process.cwd() + '/data/graph.db');\n\nlet orchestrator: Orchestrator | null = null;\nlet graph: GraphStore | null = null;\nconst wm = new WeightManager();\nset_weights(wm.get());\n\nfunction getOrchestrator(): Orchestrator {\n  if (!orchestrator) {\n    const dir = process.env.DATA_DIR || DATA_DIR;\n    const url = process.env.ENGINE_URL || ENGINE_URL;\n    orchestrator = new Orchestrator(dir, url);\n  }\n  return orchestrator;\n}\n\nfunction getGraph(): GraphStore {\n  if (!graph) {\n    const db = process.env.SQLITE_DB || SQLITE_DB;\n    graph = new GraphStore(db);\n  }\n  return graph;\n}\n\ntype Json = any;\ninterface RpcRequest { \n  jsonrpc: '2.0'; \n  id: string | number | null; \n  method: string; \n  params?: Json;\n  msg?: {\n    type: string;\n    kind: string;\n    message: string;\n  };\n}\n\nfunction write(obj: any) { process.stdout.write(JSON.stringify(obj) + '\\n'); }\nfunction ok(id: RpcRequest['id'], result: any) { write({ jsonrpc: '2.0', id, result }); }\nfunction err(id: RpcRequest['id'], code: number, message: string, data?: any) {\n  const e: any = { code, message };\n  if (data) e.data = data;\n  write({ jsonrpc: '2.0', id, error: e });\n}\n\nconst INDEX_ROOT = process.env.INDEX_ROOT || process.env.MCP_INDEX_ROOT;\nconst ROOTS: string[] = Array.from(new Set([\n  process.cwd(),\n  path.resolve(DATA_DIR),\n  ...(INDEX_ROOT ? [path.resolve(INDEX_ROOT)] as string[] : [])\n]));\n\nfunction toFileUri(p: string): string {\n  const abs = path.resolve(p);\n  const withSlashes = abs.replace(/\\\\/g, '/');\n  // Ensure file:/// prefix with Windows drive support\n  if (/^[A-Za-z]:\\//.test(withSlashes)) {\n    return `file:///${withSlashes}`;\n  }\n  return `file://${withSlashes.startsWith('/') ? '' : '/'}${withSlashes}`;\n}\n\nfunction fromFileUri(u: string): string {\n  try {\n    if (!u.startsWith('file://')) return u;\n    const url = new URL(u);\n    let p = decodeURIComponent(url.pathname);\n    // Windows path like /C:/...\n    if (process.platform === 'win32' && /^\\/[A-Za-z]:\\//.test(p)) {\n      p = p.slice(1);\n    }\n    return path.normalize(p);\n  } catch {\n    return u;\n  }\n}\n\nfunction safeJoin(root: string, rel: string): string | null {\n  const p = path.resolve(root, rel);\n  if (!p.startsWith(path.resolve(root))) return null;\n  return p;\n}\n\nfunction listFiles(root: string, max = 200): string[] {\n  const out: string[] = [];\n  const stack: string[] = [root];\n  while (stack.length && out.length < max) {\n    const cur = stack.pop()!;\n    try {\n      const st = fs.statSync(cur);\n      if (st.isDirectory()) {\n        for (const name of fs.readdirSync(cur)) {\n          const full = path.join(cur, name);\n          try {\n            const s2 = fs.statSync(full);\n            if (s2.isDirectory()) stack.push(full);\n            else if (s2.isFile() && allowPath(full)) out.push(full);\n          } catch { }\n          if (out.length >= max) break;\n        }\n      } else if (st.isFile() && allowPath(cur)) out.push(cur);\n    } catch { }\n  }\n  return out;\n}\n\nconst MAX_PROMPT_SNIPPET_LINES = 40;\n\nfunction normalizeRepoPath(p: string): string {\n  return p.replace(/\\\\/g, '/');\n}\n\nfunction uniqueList(values: string[]): string[] {\n  const seen = new Set<string>();\n  const result: string[] = [];\n  for (const value of values) {\n    const normalized = normalizeRepoPath(value);\n    if (!seen.has(normalized)) {\n      seen.add(normalized);\n      result.push(normalized);\n    }\n  }\n  return result;\n}\n\nfunction filePreview(file: string, maxLines = MAX_PROMPT_SNIPPET_LINES): string {\n  try {\n    const content = getOrchestrator().getFile(file);\n    const lines = content.split(/\\r?\\n/).slice(0, maxLines);\n    return lines.join('\\n').trimEnd();\n  } catch {\n    return '';\n  }\n}\n\nfunction formatList(label: string, items: string[]): string {\n  const list = uniqueList(items).slice(0, 8);\n  if (!list.length) return '';\n  return `${label}:\\n${list.map(item => `- ${item}`).join('\\n')}`;\n}\n\nfunction buildPromptContext(args: { file?: string; symbol?: string; extraNote?: string }): string {\n  const segments: string[] = [];\n  const graph = getGraph();\n  const file = args.file ? normalizeRepoPath(String(args.file)) : undefined;\n  const symbol = args.symbol ? String(args.symbol) : undefined;\n\n  if (file) {\n    segments.push(`File Scope: ${file}`);\n    const symbols = graph.listSymbols(file).slice(0, 8).map((s: any) => `${s.kind}:${s.name} (L${s.startLine}-${s.endLine})`);\n    const imports = graph.listImports(file);\n    const dependents = graph.listDependents(file);\n    const preview = filePreview(file);\n    if (symbols.length) segments.push(formatList('Local symbols', symbols));\n    const importBlock = formatList('Imports', imports);\n    if (importBlock) segments.push(importBlock);\n    const dependentsBlock = formatList('Referenced by', dependents);\n    if (dependentsBlock) segments.push(dependentsBlock);\n    if (preview) {\n      const previewLines = preview.split(/\\r?\\n/).length;\n      segments.push(`File preview (first ${Math.min(previewLines, MAX_PROMPT_SNIPPET_LINES)} lines):\\n${preview}`);\n    }\n  }\n\n  if (symbol) {\n    segments.push(`Focus symbol: ${symbol}`);\n    const refs = (graph.findRefs(symbol) as Array<{ file?: string }> | undefined) ?? [];\n    const refList = uniqueList(refs.map(r => r.file || '').filter(Boolean));\n    if (refList.length) segments.push(formatList('Referenced in', refList));\n  }\n\n  if (args.extraNote) {\n    segments.push(`Additional notes: ${args.extraNote}`);\n  }\n\n  return segments.filter(Boolean).join('\\n\\n');\n}\n\nfunction buildPromptText(name: string, args: Record<string, unknown>): string | null {\n  const fileArg = typeof args.file === 'string' ? args.file : undefined;\n  const symbolArg = typeof args.symbol === 'string' ? args.symbol : undefined;\n  const userContext = typeof args.context === 'string' ? args.context : undefined;\n  const extra = typeof args.notes === 'string' ? args.notes : undefined;\n  const baseContext = buildPromptContext({ file: fileArg, symbol: symbolArg, extraNote: extra });\n\n  const sections: string[] = [];\n  switch (name) {\n    case 'refactor': {\n      sections.push('Goal: Refactor the target code to improve readability and maintainability without altering behaviour.');\n      if (baseContext) sections.push(`Context:\\n${baseContext}`);\n      if (userContext) sections.push(`Caller notes:\\n${userContext}`);\n      sections.push('Guidelines:\\n- Preserve public contracts and side-effects.\\n- Identify technical debt hotspots and propose concise fixes.\\n- Provide updated code excerpts with rationale for each change.');\n      break;\n    }\n    case 'test': {\n      const subject = symbolArg || fileArg || 'the specified module';\n      sections.push(`Goal: Design a focused test strategy for ${subject}.`);\n      if (baseContext) sections.push(`Context:\\n${baseContext}`);\n      if (userContext) sections.push(`Caller notes:\\n${userContext}`);\n      sections.push('Checklist:\\n- Enumerate critical behaviours and edge cases.\\n- Recommend unit/integration test boundaries.\\n- Suggest fixtures or mocks and expected assertions.');\n      break;\n    }\n    case 'perf': {\n      const scope = fileArg || symbolArg || 'the target codebase';\n      sections.push(`Goal: Investigate potential performance issues in ${scope}.`);\n      if (baseContext) sections.push(`Context:\\n${baseContext}`);\n      if (userContext) sections.push(`Caller notes:\\n${userContext}`);\n      sections.push('Focus:\\n- Highlight expensive code paths or dependency hot spots.\\n- Suggest measurement approaches (profilers, metrics).\\n- Recommend optimisation tactics while keeping clarity.');\n      break;\n    }\n    default:\n      return null;\n  }\n  return sections.filter(Boolean).join('\\n\\n');\n}\n\nconst tools = [\n  {\n    name: 'search_code',\n    description: 'Semantic code search with hybrid ranking',\n    inputSchema: {\n      type: 'object',\n      properties: { q: { type: 'string' }, top_k: { type: 'number' } },\n      required: ['q']\n    }\n  },\n  {\n    name: 'get_file',\n    description: 'Get file content from index',\n    inputSchema: {\n      type: 'object',\n      properties: { path: { type: 'string' } },\n      required: ['path']\n    }\n  },\n  {\n    name: 'list_symbols',\n    description: 'List symbols, optionally filtered by file',\n    inputSchema: {\n      type: 'object',\n      properties: { file: { type: 'string' } },\n      required: []\n    }\n  },\n  {\n    name: 'find_refs',\n    description: 'Find references via import graph',\n    inputSchema: {\n      type: 'object',\n      properties: { symbol: { type: 'string' } },\n      required: ['symbol']\n    }\n  },\n  {\n    name: 'plan_refactor',\n    description: 'Drafts a refactor plan for a target file or symbol',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        file: { type: 'string' },\n        symbol: { type: 'string' },\n        goal: { type: 'string' }\n      },\n      required: []\n    }\n  },\n  {\n    name: 'gen_patch',\n    description: 'Generates a dry-run find/replace patch preview',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        path: { type: 'string' },\n        operations: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              find: { type: 'string' },\n              replace: { type: 'string' },\n              occurrences: { type: 'number' }\n            },\n            required: ['find', 'replace']\n          }\n        }\n      },\n      required: ['path', 'operations']\n    }\n  },\n  {\n    name: 'apply_patch',\n    description: 'Applies an approved find/replace patch to disk',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        path: { type: 'string' },\n        operations: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              find: { type: 'string' },\n              replace: { type: 'string' },\n              occurrences: { type: 'number' }\n            },\n            required: ['find', 'replace']\n          }\n        }\n      },\n      required: ['path', 'operations']\n    }\n  },\n  {\n    name: 'analyze_performance',\n    description: 'Runs lightweight static heuristics for performance risks',\n    inputSchema: {\n      type: 'object',\n      properties: { path: { type: 'string' } },\n      required: ['path']\n    }\n  },\n  {\n    name: 'compare_versions',\n    description: 'Compares two files line-by-line for quick diffing',\n    inputSchema: {\n      type: 'object',\n      properties: { pathA: { type: 'string' }, pathB: { type: 'string' } },\n      required: ['pathA', 'pathB']\n    }\n  },\n  {\n    name: 'auto_docs',\n    description: 'Produces an automated documentation summary for a file',\n    inputSchema: {\n      type: 'object',\n      properties: { path: { type: 'string' } },\n      required: ['path']\n    }\n  },\n  {\n    name: 'run_tests',\n    description: 'Executes a repository-defined test command',\n    inputSchema: {\n      type: 'object',\n      properties: { command: { type: 'string' } },\n      required: []\n    }\n  },\n  {\n    name: 'run_task',\n    description: 'Runs an npm script defined in package.json',\n    inputSchema: {\n      type: 'object',\n      properties: { script: { type: 'string' } },\n      required: ['script']\n    }\n  },\n  {\n    name: 'generate_telemetry_panel',\n    description: 'Generates an HTML telemetry dashboard from logs',\n    inputSchema: {\n      type: 'object',\n      properties: { output: { type: 'string' } },\n      required: []\n    }\n  },\n  {\n    name: 'open_telemetry_webview',\n    description: 'Returns the telemetry dashboard HTML for rendering in a webview',\n    inputSchema: {\n      type: 'object',\n      properties: { file: { type: 'string' } },\n      required: ['file']\n    }\n  },\n  {\n    name: 'langchain_query',\n    description: 'Queries the LangChain bridge (falls back to lexical search)',\n    inputSchema: {\n      type: 'object',\n      properties: { q: { type: 'string' }, top_k: { type: 'number' } },\n      required: ['q']\n    }\n  },\n  {\n    name: 'summarize_architecture',\n    description: 'Summarize codebase topology from graph store',\n    inputSchema: { type: 'object', properties: {}, required: [] }\n  },\n  {\n    name: 'detect_smells',\n    description: 'Detect simple code smells (TODO/long lines)',\n    inputSchema: {\n      type: 'object',\n      properties: { root: { type: 'string' } },\n      required: []\n    }\n  },\n  {\n    name: 'suggest_tests',\n    description: 'Suggest unit tests for symbols',\n    inputSchema: {\n      type: 'object',\n      properties: { symbols: { type: 'array' } },\n      required: ['symbols']\n    }\n  },\n  {\n    name: 'submit_feedback',\n    description: 'Submit feedback to adapt ranker weights (kind: up|down)',\n    inputSchema: {\n      type: 'object',\n      properties: { kind: { type: 'string', enum: ['up', 'down'] } },\n      required: ['kind']\n    }\n  },\n  {\n    name: 'get_weights',\n    description: 'Get current hybrid ranker weights',\n    inputSchema: { type: 'object', properties: {}, required: [] }\n  },\n  {\n    name: 'resources-list',\n    description: 'List files under allowed roots (policy filtered)',\n    inputSchema: { type: 'object', properties: { root: { type: 'string' }, max: { type: 'number' } }, required: [] }\n  },\n  {\n    name: 'resources-read',\n    description: 'Read a single file (policy filtered)',\n    inputSchema: { type: 'object', properties: { path: { type: 'string' }, maxChars: { type: 'number' } }, required: ['path'] }\n  },\n  {\n    name: 'roots-list',\n    description: 'List allowed roots for resources',\n    inputSchema: { type: 'object', properties: {}, required: [] }\n  },\n  {\n    name: 'prompts-list',\n    description: 'List available prompts',\n    inputSchema: { type: 'object', properties: {}, required: [] }\n  },\n  {\n    name: 'prompts-call',\n    description: 'Call a prompt template',\n    inputSchema: { type: 'object', properties: { name: { type: 'string' }, args: { type: 'object' } }, required: ['name'] }\n  }\n];\n\nconst PROMPT_DESCRIPTORS = [\n  {\n    name: 'refactor',\n    description: 'Refactor guidance with repository context',\n    arguments: [\n      { name: 'file', description: 'Relative file path to focus on', required: false },\n      { name: 'symbol', description: 'Specific symbol or class to prioritise', required: false },\n      { name: 'context', description: 'Additional human-provided notes', required: false },\n      { name: 'notes', description: 'Inline hints or concerns to surface', required: false },\n    ],\n  },\n  {\n    name: 'test',\n    description: 'Unit/integration test planning for a module or symbol',\n    arguments: [\n      { name: 'file', description: 'Relative file path for test scope', required: false },\n      { name: 'symbol', description: 'Specific function/class to cover', required: false },\n      { name: 'context', description: 'Known behaviours or regressions to consider', required: false },\n    ],\n  },\n  {\n    name: 'perf',\n    description: 'Performance review with dependency awareness',\n    arguments: [\n      { name: 'file', description: 'File/module suspected to be a bottleneck', required: false },\n      { name: 'symbol', description: 'Critical symbol or method to profile', required: false },\n      { name: 'target', description: 'Custom target description (default derived from file/symbol)', required: false },\n      { name: 'context', description: 'Observed latency or memory symptoms', required: false },\n    ],\n  },\n];\n\nasync function handle(req: RpcRequest) {\n  try {\n    // Ignore notifications (JSON-RPC without id). MCP may send sessionConfigured, etc.\n    if (req.id === null || typeof req.id === 'undefined') {\n      // Known MCP notifications we can safely ignore\n      if (req.method === 'sessionConfigured' || req.method === 'ping' || req.method === 'initialized') {\n        return; // no response for notifications\n      }\n      return; // silently ignore unknown notifications per JSON-RPC\n    }\n    if (req.method === 'initialize') {\n      return ok(req.id, {\n        protocolVersion: '2024-11-05',\n        capabilities: { tools: {}, resources: {}, prompts: {} },\n        serverInfo: { name: 'mcp-local', version: '1.0.0' }\n      });\n    }\n    if (req.method === 'ping') {\n      return ok(req.id, { ok: true });\n    }\n    if (req.method === 'shutdown') {\n      ok(req.id, { ok: true });\n      process.exit(0);\n      return;\n    }\n    if (req.method === 'tools/list') {\n      return ok(req.id, { tools });\n    }\n    if (req.method === 'tools/call') {\n      const name = String(req.params?.name || '');\n      const args = (req.params?.arguments as any) || {};\n      switch (name) {\n        case 'search_code': {\n          const orchestrator = getOrchestrator();\n          const q = String(args.q || '');\n          const topK = Number.isFinite(args.top_k) ? Number(args.top_k) : 5;\n          const results = await orchestrator.searchCode(q, topK);\n          const profile = orchestrator.getLastProfile();\n          return ok(req.id, {\n            content: [{\n              type: 'text',\n              text: JSON.stringify({ query: q, profile, results }),\n            }],\n          });\n        }\n        case 'get_file': {\n          const p = String(args.path || '');\n          const content = getOrchestrator().getFile(p);\n          return ok(req.id, { content: [{ type: 'text', text: content }] });\n        }\n        case 'list_symbols': {\n          const file = args.file ? String(args.file) : undefined;\n          const syms = getGraph().listSymbols(file);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(syms) }] });\n        }\n        case 'find_refs': {\n          const sym = String(args.symbol || '');\n          const refs = getGraph().findRefs(sym);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(refs) }] });\n        }\n        case 'plan_refactor': {\n          const file = args.file ? String(args.file) : undefined;\n          const symbol = args.symbol ? String(args.symbol) : undefined;\n          const goal = args.goal ? String(args.goal) : undefined;\n          const plan = plan_refactor(getOrchestrator(), getGraph(), process.cwd(), { file, symbol, goal });\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(plan) }] });\n        }\n        case 'gen_patch': {\n          const file = String(args.path || '');\n          const operations = Array.isArray(args.operations) ? args.operations as any[] : [];\n          const patch = generate_patch(process.cwd(), file, operations);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(patch) }] });\n        }\n        case 'apply_patch': {\n          const file = String(args.path || '');\n          const operations = Array.isArray(args.operations) ? args.operations as any[] : [];\n          const res = applyPatchOperations(process.cwd(), file, operations);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(res) }] });\n        }\n        case 'analyze_performance': {\n          const file = String(args.path || '');\n          const insight = analyze_performance(process.cwd(), file);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(insight) }] });\n        }\n        case 'compare_versions': {\n          const pathA = String(args.pathA || '');\n          const pathB = String(args.pathB || '');\n          const cmp = compare_versions(process.cwd(), pathA, pathB);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(cmp) }] });\n        }\n        case 'auto_docs': {\n          const file = String(args.path || '');\n          const docs = auto_docs(getOrchestrator(), getGraph(), process.cwd(), file);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(docs) }] });\n        }\n        case 'run_tests': {\n          const command = args.command ? String(args.command) : 'npm test';\n          const outcome = run_tests(process.cwd(), command);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(outcome) }] });\n        }\n        case 'run_task': {\n          const script = String(args.script || '');\n          const outcome = run_task(process.cwd(), script);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(outcome) }] });\n        }\n        case 'generate_telemetry_panel': {\n          const output = args.output ? String(args.output) : undefined;\n          const panel = generate_telemetry_panel(process.cwd(), output);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(panel) }] });\n        }\n        case 'open_telemetry_webview': {\n          const regenerate = args.regenerate === true;\n          const output = args.output ? String(args.output) : undefined;\n          const webview = open_telemetry_webview(process.cwd(), { regenerate, output });\n          return ok(req.id, {\n            content: [{\n              type: 'text',\n              text: webview.html,\n              mimeType: 'text/html',\n              metadata: { path: webview.path },\n            }],\n          });\n        }\n        case 'langchain_query': {\n          const q = String(args.q || '');\n          const topK = Number.isFinite(args.top_k) ? Number(args.top_k) : 5;\n          const dataDir = process.env.DATA_DIR || DATA_DIR;\n          const result = await langchain_query(dataDir, q, topK);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(result) }] });\n        }\n        case 'summarize_architecture': {\n          const s = summarize_architecture(getGraph());\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(s) }] });\n        }\n        case 'detect_smells': {\n          const root = String(args.root || process.cwd());\n          const res = detect_smells(root);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(res) }] });\n        }\n        case 'suggest_tests': {\n          const symbols = (args.symbols as Array<{ file: string; name: string }>) || [];\n          const sugg = suggest_tests(symbols);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(sugg) }] });\n        }\n        case 'submit_feedback': {\n          const kind = String(args.kind || 'up');\n          wm.feedback(kind === 'down' ? 'down' : 'up');\n          set_weights(wm.get());\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify({ ok: true, weights: wm.get() }) }] });\n        }\n        case 'get_weights': {\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(wm.get()) }] });\n        }\n        case 'resources-list': {\n          const root = args.root ? String(args.root) : ROOTS[0];\n          const max = Number.isFinite(args.max) ? Number(args.max) : 200;\n          if (!ROOTS.some(r => path.resolve(root).startsWith(path.resolve(r)))) {\n            return err(req.id, -32001, 'Root not allowed', { root, allowed: ROOTS });\n          }\n          const files = listFiles(root, max).map(f => path.normalize(f));\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(files) }] });\n        }\n        case 'resources-read': {\n          const p = String(args.path || '');\n          const maxChars = Number.isFinite(args.maxChars) ? Number(args.maxChars) : 200_000;\n          if (!ROOTS.some(r => path.resolve(p).startsWith(path.resolve(r)))) {\n            return err(req.id, -32001, 'Path not under allowed roots', { path: p, allowed: ROOTS });\n          }\n          if (!allowPath(p)) return err(req.id, -32002, 'Path not allowed by policy', { path: p });\n          try {\n            const buf = fs.readFileSync(p, 'utf8');\n            const text = buf.slice(0, maxChars);\n            return ok(req.id, { content: [{ type: 'text', text }] });\n          } catch (e: any) {\n            return err(req.id, -32003, 'Failed to read file', { path: p, error: e?.message });\n          }\n        }\n        case 'roots-list': {\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(ROOTS) }] });\n        }\n        case 'prompts-list': {\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(PROMPT_DESCRIPTORS) }] });\n        }\n        case 'prompts-call': {\n          const pname = String(args.name || '');\n          const a = (args.args || {}) as Record<string, unknown>;\n          const text = buildPromptText(pname, a);\n          if (!text) return err(req.id, -32601, 'Prompt not found', { name: pname });\n          return ok(req.id, { content: [{ type: 'text', text }] });\n        }\n        default:\n          return err(req.id, -32601, 'Tool not found');\n      }\n    }\n    // Expose top-level MCP resource/prompt methods for IDE panels\n    if (req.method === 'resources/list') {\n      const args = (req.params as any) || {};\n      const rootArg = String(args.root || args.uri || ROOTS[0]);\n      const root = rootArg.startsWith('file://') ? fromFileUri(rootArg) : rootArg;\n      const max = Number.isFinite(args.max) ? Number(args.max) : 200;\n      if (!ROOTS.some(r => path.resolve(root).startsWith(path.resolve(r)))) {\n        return err(req.id, -32001, 'Root not allowed', { root, allowed: ROOTS });\n      }\n      const files = listFiles(root, max).map(f => path.normalize(f));\n      return ok(req.id, { resources: files.map(f => ({ uri: toFileUri(f), name: path.basename(f) })) });\n    }\n    if (req.method === 'resources/read') {\n      const args = (req.params as any) || {};\n      const raw = String(args.path || args.uri || '');\n      const p = raw.startsWith('file://') ? fromFileUri(raw) : raw;\n      const maxChars = Number.isFinite(args.maxChars) ? Number(args.maxChars) : 200_000;\n      if (!ROOTS.some(r => path.resolve(p).startsWith(path.resolve(r)))) {\n        return err(req.id, -32001, 'Path not under allowed roots', { path: p, allowed: ROOTS });\n      }\n      if (!allowPath(p)) return err(req.id, -32002, 'Path not allowed by policy', { path: p });\n      try {\n        const buf = fs.readFileSync(p, 'utf8');\n        const text = buf.slice(0, maxChars);\n        const mimeType = p.endsWith('.html') ? 'text/html' : 'text/plain';\n        return ok(req.id, { contents: [{ uri: toFileUri(p), mimeType, text }] });\n      } catch (e: any) {\n        return err(req.id, -32003, 'Failed to read file', { path: p, error: e?.message });\n      }\n    }\n    if (req.method === 'roots/list') {\n      return ok(req.id, { roots: ROOTS.map(r => ({ uri: toFileUri(r), name: r })) });\n    }\n    if (req.method === 'prompts/list') {\n      return ok(req.id, { prompts: PROMPT_DESCRIPTORS });\n    }\n    if (req.method === 'prompts/call') {\n      const args = (req.params as any) || {};\n      const pname = String(args.name || '');\n      const a = (args.args || {}) as Record<string, unknown>;\n      const text = buildPromptText(pname, a);\n      if (!text) return err(req.id, -32601, 'Prompt not found', { name: pname });\n      return ok(req.id, { content: [{ type: 'text', text }] });\n    }\n    return err(req.id, -32601, 'Method not found');\n  } catch (e: any) {\n    return err(req.id, -32000, e?.message || 'Internal error');\n  }\n}\n\nconst rl = readline.createInterface({ input: process.stdin, output: process.stdout, terminal: false });\nrl.on('line', line => {\n  const s = line.trim(); if (!s) return;\n  try { \n    const req = JSON.parse(s) as RpcRequest; \n    if (req.msg?.type === 'user_message') {\n      if (req.msg.kind === 'environment_context') {\n        const contextObj = parseEnvironmentContext(req.msg.message);\n        process.env.MCP_CWD = contextObj.cwd;\n        process.env.MCP_APPROVAL_POLICY = contextObj.approval_policy;\n        process.env.MCP_SANDBOX_MODE = contextObj.sandbox_mode;\n        write({\n          jsonrpc: '2.0',\n          id: req.id,\n          result: { status: 'ok' }\n        });\n        return;\n      }\n    }\n    handle(req); \n  } catch (e) { \n    console.error('Error handling message:', e);\n  }\n});\n\nfunction parseEnvironmentContext(xmlStr: string): any {\n  const matches = {\n    cwd: xmlStr.match(/<cwd>(.*?)<\\/cwd>/)?.[1] || '',\n    approval_policy: xmlStr.match(/<approval_policy>(.*?)<\\/approval_policy>/)?.[1] || 'on-request',\n    sandbox_mode: xmlStr.match(/<sandbox_mode>(.*?)<\\/sandbox_mode>/)?.[1] || 'workspace-write'\n  };\n  return matches;\n}\n\nprocess.on('SIGINT', () => process.exit(0));\n",
    "symbols": [
      {
        "name": "getOrchestrator",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 39,
        "endLine": 46
      },
      {
        "name": "getGraph",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 48,
        "endLine": 54
      },
      {
        "name": "write",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 69,
        "endLine": 69
      },
      {
        "name": "ok",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 70,
        "endLine": 70
      },
      {
        "name": "err",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 71,
        "endLine": 75
      },
      {
        "name": "toFileUri",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 84,
        "endLine": 92
      },
      {
        "name": "fromFileUri",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 94,
        "endLine": 107
      },
      {
        "name": "safeJoin",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 109,
        "endLine": 113
      },
      {
        "name": "listFiles",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 115,
        "endLine": 136
      },
      {
        "name": "normalizeRepoPath",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 140,
        "endLine": 142
      },
      {
        "name": "uniqueList",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 144,
        "endLine": 155
      },
      {
        "name": "filePreview",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 157,
        "endLine": 165
      },
      {
        "name": "formatList",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 167,
        "endLine": 171
      },
      {
        "name": "buildPromptContext",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 173,
        "endLine": 208
      },
      {
        "name": "buildPromptText",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 210,
        "endLine": 246
      },
      {
        "name": "handle",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 512,
        "endLine": 754
      },
      {
        "name": "parseEnvironmentContext",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_adapter.ts",
        "startLine": 781,
        "endLine": 788
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/mcp_http_bridge.ts",
    "content": "import http from 'http';\nimport { spawn, ChildProcessByStdio } from 'child_process';\nimport { Readable, Writable } from 'stream';\nimport path from 'path';\nimport readline from 'readline';\n\ntype Json = any;\ninterface RpcRequest { jsonrpc: '2.0'; id: string | number | null; method: string; params?: Json }\n\nexport function startMcpHttpBridge(port: number) {\n  const adapterPath = path.join(__dirname, 'mcp_adapter.js');\n  const child: ChildProcessByStdio<Writable, Readable, Readable> = spawn(process.execPath, [adapterPath], {\n    stdio: ['pipe', 'pipe', 'pipe'],\n    env: process.env,\n  });\n\n  const rl = readline.createInterface({ input: child.stdout });\n  const pending = new Map<string, (resp: any) => void>();\n\n  rl.on('line', line => {\n    try {\n      const obj = JSON.parse(line);\n      const id = String(obj.id);\n      const resolve = pending.get(id);\n      if (resolve) {\n        pending.delete(id);\n        resolve(obj);\n      }\n    } catch { /* ignore non-JSON lines */ }\n  });\n\n  const server = http.createServer(async (req, res) => {\n    try {\n      if (req.method !== 'POST' || !req.url) { res.writeHead(405); return res.end(); }\n      const url = new URL(req.url, `http://${req.headers.host}`);\n      if (url.pathname !== '/mcp') { res.writeHead(404); return res.end(); }\n      const chunks: Buffer[] = [];\n      req.on('data', c => chunks.push(c));\n      req.on('end', async () => {\n        try {\n          const body = Buffer.concat(chunks).toString('utf8');\n          const payload = JSON.parse(body);\n          const handleOne = (p: RpcRequest) => new Promise<any>((resolveOne, rejectOne) => {\n            if (p.id === null || typeof p.id === 'undefined') {\n              // notification: just forward and return 204 later\n              child.stdin.write(JSON.stringify(p) + '\\n');\n              resolveOne(undefined);\n              return;\n            }\n            const key = String(p.id);\n            pending.set(key, resp => resolveOne(resp));\n            child.stdin.write(JSON.stringify(p) + '\\n');\n            // Optionally add a timeout\n            setTimeout(() => {\n              if (pending.has(key)) { pending.delete(key); rejectOne(new Error('timeout')); }\n            }, 30000);\n          });\n\n          if (Array.isArray(payload)) {\n            const responses = await Promise.all(payload.map(p => handleOne(p)));\n            const filtered = responses.filter(r => r !== undefined);\n            res.writeHead(200, { 'content-type': 'application/json' });\n            res.end(JSON.stringify(filtered));\n          } else {\n            const response = await handleOne(payload);\n            if (response === undefined) { res.writeHead(204); res.end(); }\n            else { res.writeHead(200, { 'content-type': 'application/json' }); res.end(JSON.stringify(response)); }\n          }\n        } catch (e: any) {\n          res.writeHead(400, { 'content-type': 'application/json' });\n          res.end(JSON.stringify({ error: e?.message || 'bad request' }));\n        }\n      });\n    } catch {\n      res.writeHead(500); res.end();\n    }\n  });\n\n  server.listen(port, '127.0.0.1');\n  return { server, child };\n}\n",
    "symbols": [
      {
        "name": "startMcpHttpBridge",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/mcp_http_bridge.ts",
        "startLine": 10,
        "endLine": 81
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/orchestrator.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport http from 'http';\nimport { FileMeta, SearchResult } from '@mcp/shared';\nimport { rank_hybrid, pack_tokens } from './ranker';\nimport { GraphStore } from './graph_store';\nimport { profileContext, ContextProfile } from './context_profiler';\n\ninterface EngineSearchResult {\n  file: string;\n  symbol: string;\n  startLine: number;\n  endLine: number;\n  score: number;\n  snippet: string;\n}\n\nexport class Orchestrator {\n  private fileIndex: Map<string, FileMeta> = new Map();\n  private engineUrl: string;\n  private graph?: GraphStore;\n  private lastProfile: ContextProfile | null = null;\n\n  constructor(dataDir: string, engineUrl: string = 'http://localhost:8000', graph?: GraphStore) {\n    this.engineUrl = engineUrl;\n    this.loadIndex(dataDir);\n    this.graph = graph;\n  }\n\n  private loadIndex(dataDir: string) {\n    const idxPath = path.join(dataDir, 'index.json');\n    const json = fs.readFileSync(idxPath, 'utf8');\n    const files: FileMeta[] = JSON.parse(json);\n    for (const file of files) {\n      this.fileIndex.set(file.path, file);\n    }\n  }\n\n  public getFile(filePath: string): string {\n    const fileMeta = this.fileIndex.get(filePath);\n    if (!fileMeta) throw new Error(`File not found in index: ${filePath}`);\n    return fileMeta.content;\n  }\n\n  public getLastProfile(): ContextProfile | null {\n    return this.lastProfile ? { ...this.lastProfile } : null;\n  }\n\n  public async searchCode(query: string, topK = 5): Promise<SearchResult[]> {\n    const url = new URL('/search', this.engineUrl);\n    url.searchParams.set('q', query);\n    url.searchParams.set('top_k', topK.toString());\n    const engineResults: EngineSearchResult[] = await new Promise((resolve, reject) => {\n      const req = http.get(url.toString(), res => {\n        const chunks: Buffer[] = [];\n        res.on('data', c => chunks.push(c));\n        res.on('end', () => {\n          try {\n            const parsed = JSON.parse(Buffer.concat(chunks).toString('utf8'));\n            resolve(parsed.results as EngineSearchResult[]);\n          } catch (err) {\n            reject(err);\n          }\n        });\n      });\n      req.on('error', err => reject(err));\n    });\n    const initial: SearchResult[] = engineResults.map(er => ({ ...er } as SearchResult));\n    const profile = profileContext(query, topK);\n    const ranked = rank_hybrid(initial, query, this.graph ? (f => this.graph!.degree(f)) : undefined);\n    let curated = pack_tokens(ranked, profile.tokenBudget);\n    if (!curated.length) {\n      curated = ranked.slice(0, Math.max(1, profile.effectiveTopK));\n    }\n    if (curated.length > profile.effectiveTopK) {\n      curated = curated.slice(0, profile.effectiveTopK);\n    }\n    this.lastProfile = profile;\n    return curated;\n  }\n}\n",
    "symbols": [
      {
        "name": "Orchestrator",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/orchestrator.ts",
        "startLine": 18,
        "endLine": 81
      },
      {
        "name": "Orchestrator.loadIndex",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/orchestrator.ts",
        "startLine": 30,
        "endLine": 37
      },
      {
        "name": "Orchestrator.getFile",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/orchestrator.ts",
        "startLine": 39,
        "endLine": 43
      },
      {
        "name": "Orchestrator.getLastProfile",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/orchestrator.ts",
        "startLine": 45,
        "endLine": 47
      },
      {
        "name": "Orchestrator.searchCode",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/orchestrator.ts",
        "startLine": 49,
        "endLine": 80
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/policy.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\nexport function allowPath(p: string): boolean {\n  const basename = path.basename(p).toLowerCase();\n  if (basename.endsWith('.env') || basename.endsWith('.key') || basename.endsWith('.pem')) return false;\n  try {\n    const stat = fs.statSync(p);\n    if (stat.size > 50 * 1024 * 1024) return false;\n  } catch {\n    // ignore\n  }\n  return true;\n}\n\nexport function filterPaths(paths: string[]): string[] {\n  return paths.filter(allowPath);\n}\n\n",
    "symbols": [
      {
        "name": "allowPath",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/policy.ts",
        "startLine": 4,
        "endLine": 14
      },
      {
        "name": "filterPaths",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/policy.ts",
        "startLine": 16,
        "endLine": 18
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/ranker.ts",
    "content": "import { SearchResult } from '@mcp/shared';\n\nexport interface HybridSignals {\n  semantic: number; // engine score [0..1]\n  lexical: number;  // token hit ratio [0..1]\n  graph: number;    // normalized degree [0..1]\n}\n\nlet weights = { semantic: 0.6, lexical: 0.25, graph: 0.15 };\nexport function set_weights(w: { semantic: number; lexical: number; graph: number }) {\n  const s = w.semantic + w.lexical + w.graph;\n  weights = { semantic: w.semantic / s, lexical: w.lexical / s, graph: w.graph / s };\n}\n\nexport function rank_hybrid(results: SearchResult[], query: string, fileDegree?: (file: string) => number): SearchResult[] {\n  const tokens = query.toLowerCase().split(/\\W+/).filter(Boolean);\n  const degrees = new Map<string, number>();\n  let maxDeg = 1;\n  if (fileDegree) {\n    for (const r of results) {\n      const d = fileDegree(r.file) || 0;\n      degrees.set(r.file, d);\n      if (d > maxDeg) maxDeg = d;\n    }\n  }\n  return results.map(r => {\n    const snippetLower = r.snippet.toLowerCase();\n    let hits = 0;\n    for (const t of tokens) if (snippetLower.includes(t)) hits++;\n    const lexical = tokens.length ? hits / tokens.length : 0;\n    const graph = degrees.has(r.file) ? (degrees.get(r.file)! / maxDeg) : 0;\n    const semantic = r.score; // assume engine score in [0..1]\n    const score = semantic * weights.semantic + lexical * weights.lexical + graph * weights.graph;\n    return { ...r, score };\n  }).sort((a, b) => b.score - a.score);\n}\n\nexport function pack_tokens(results: SearchResult[], budgetTokens: number): SearchResult[] {\n  // naive token estimate: ~1 token per 4 chars\n  const estimate = (s: string) => Math.ceil(s.length / 4);\n  const selected: SearchResult[] = [];\n  let used = 0;\n  // MMR-like greedy selection with diversity by file\n  const usedFiles = new Set<string>();\n  for (const r of results) {\n    const cost = estimate(r.snippet);\n    if (used + cost > budgetTokens) continue;\n    if (usedFiles.has(r.file)) continue; // diversity: one per file first\n    selected.push(r);\n    used += cost;\n    usedFiles.add(r.file);\n  }\n  // fill remaining budget regardless of file if space left\n  if (used < budgetTokens) {\n    for (const r of results) {\n      if (selected.includes(r)) continue;\n      const cost = estimate(r.snippet);\n      if (used + cost > budgetTokens) continue;\n      selected.push(r);\n      used += cost;\n    }\n  }\n  return selected;\n}\n",
    "symbols": [
      {
        "name": "set_weights",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/ranker.ts",
        "startLine": 10,
        "endLine": 13
      },
      {
        "name": "rank_hybrid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/ranker.ts",
        "startLine": 15,
        "endLine": 36
      },
      {
        "name": "pack_tokens",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/ranker.ts",
        "startLine": 38,
        "endLine": 64
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/server.ts",
    "content": "import http from 'http';\nimport { Orchestrator } from './orchestrator';\n\nconst PORT = parseInt(process.env.PORT || '3000', 10);\nconst DATA_DIR = process.env.DATA_DIR || './data';\nconst ENGINE_URL = process.env.ENGINE_URL || 'http://localhost:8000';\n\nconst orchestrator = new Orchestrator(DATA_DIR, ENGINE_URL);\nconst server = http.createServer((req, res) => {\n  if (!req.url) { res.statusCode = 400; return res.end('Bad request'); }\n  const url = new URL(req.url, `http://${req.headers.host}`);\n  if (req.method === 'GET' && url.pathname === '/get_file') {\n    const filePath = url.searchParams.get('path');\n    if (!filePath) { res.statusCode = 400; return res.end(JSON.stringify({ error: 'Missing path' })); }\n    try {\n      const content = orchestrator.getFile(filePath);\n      res.setHeader('Content-Type', 'application/json');\n      res.end(JSON.stringify({ path: filePath, content }));\n    } catch (e: any) {\n      res.statusCode = 404; res.end(JSON.stringify({ error: e.message }));\n    }\n  } else if (req.method === 'GET' && url.pathname === '/search_code') {\n    const q = url.searchParams.get('q') || '';\n    const topK = parseInt(url.searchParams.get('top_k') || '5', 10);\n    orchestrator.searchCode(q, topK).then(results => {\n      res.setHeader('Content-Type', 'application/json');\n      res.end(JSON.stringify({ query: q, results }));\n    }).catch(err => { res.statusCode = 500; res.end(JSON.stringify({ error: err.message })); });\n  } else { res.statusCode = 404; res.end(JSON.stringify({ error: 'Not found' })); }\n});\n\nserver.listen(PORT, () => console.log(`MCP HTTP debug server on ${PORT}`));\n\n",
    "symbols": []
  },
  {
    "path": "packages/mcp-server/src/telemetry.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\ntype MetricPayload = Record<string, unknown> & {\n  name: string;\n  duration_ms: number;\n  ts: string;\n};\n\ntype AggregateKey = string;\n\nconst LOG_DIR = path.join(process.cwd(), 'logs');\nconst JSON_LOG_FILE = path.join(LOG_DIR, 'telemetry.log');\nlet promFile = process.env.TELEMETRY_PROM_FILE\n  ? path.resolve(process.cwd(), process.env.TELEMETRY_PROM_FILE)\n  : path.join(LOG_DIR, 'telemetry.prom');\nlet jsonSnapshotFile = process.env.TELEMETRY_JSON_SNAPSHOT\n  ? path.resolve(process.cwd(), process.env.TELEMETRY_JSON_SNAPSHOT)\n  : path.join(LOG_DIR, 'telemetry_latest.json');\n\nconst aggregates = new Map<AggregateKey, { count: number; total: number; max: number; min: number }>();\nlet promEnabled = true;\nlet jsonSnapshotEnabled = true;\n\nexport function configureTelemetry(options: { promFile?: string; jsonSnapshotFile?: string; disableProm?: boolean; disableSnapshot?: boolean } = {}) {\n  if (options.promFile) {\n    promFile = path.resolve(process.cwd(), options.promFile);\n  }\n  if (options.jsonSnapshotFile) {\n    jsonSnapshotFile = path.resolve(process.cwd(), options.jsonSnapshotFile);\n  }\n  if (typeof options.disableProm === 'boolean') promEnabled = !options.disableProm;\n  if (typeof options.disableSnapshot === 'boolean') jsonSnapshotEnabled = !options.disableSnapshot;\n}\n\nexport function startTimer(name: string, attributes: Record<string, unknown> = {}) {\n  const start = Date.now();\n  return (extra: Record<string, unknown> = {}) => {\n    const dur = Date.now() - start;\n    const payload: MetricPayload = {\n      name,\n      duration_ms: dur,\n      ts: new Date().toISOString(),\n      ...attributes,\n      ...extra,\n    };\n    writeMetric(payload);\n  };\n}\n\nfunction ensureDir(filePath: string) {\n  fs.mkdirSync(path.dirname(filePath), { recursive: true });\n}\n\nfunction writeMetric(m: MetricPayload) {\n  try {\n    ensureDir(JSON_LOG_FILE);\n    fs.appendFileSync(JSON_LOG_FILE, JSON.stringify(m) + '\\n', 'utf8');\n  } catch (err) {\n    if (process.env.DEBUG_TELEMETRY) {\n      // eslint-disable-next-line no-console\n      console.warn('[telemetry] failed to write JSON log', err);\n    }\n  }\n  updateAggregates(m);\n  if (promEnabled) emitPrometheus();\n  if (jsonSnapshotEnabled) emitJsonSnapshot();\n}\n\nfunction aggregateKey(m: MetricPayload): AggregateKey {\n  return `${m.name}:${m.source ?? 'unknown'}`;\n}\n\nfunction updateAggregates(m: MetricPayload) {\n  const key = aggregateKey(m);\n  const entry = aggregates.get(key) ?? { count: 0, total: 0, max: Number.MIN_SAFE_INTEGER, min: Number.MAX_SAFE_INTEGER };\n  entry.count += 1;\n  entry.total += m.duration_ms;\n  entry.max = Math.max(entry.max, m.duration_ms);\n  entry.min = Math.min(entry.min, m.duration_ms);\n  aggregates.set(key, entry);\n}\n\nfunction emitPrometheus() {\n  try {\n    ensureDir(promFile);\n    const lines: string[] = [\n      '# HELP mcp_request_duration_ms MCP request durations in milliseconds.',\n      '# TYPE mcp_request_duration_ms summary',\n    ];\n    for (const [key, stats] of aggregates.entries()) {\n      const [name, source] = key.split(':');\n      const avg = stats.count ? stats.total / stats.count : 0;\n      lines.push(`mcp_request_duration_ms_count{name=\"${name}\",source=\"${source}\"} ${stats.count}`);\n      lines.push(`mcp_request_duration_ms_sum{name=\"${name}\",source=\"${source}\"} ${stats.total}`);\n      lines.push(`mcp_request_duration_ms_avg{name=\"${name}\",source=\"${source}\"} ${avg.toFixed(2)}`);\n      lines.push(`mcp_request_duration_ms_max{name=\"${name}\",source=\"${source}\"} ${stats.max}`);\n      lines.push(`mcp_request_duration_ms_min{name=\"${name}\",source=\"${source}\"} ${stats.min}`);\n    }\n    fs.writeFileSync(promFile, lines.join('\\n') + '\\n', 'utf8');\n  } catch (err) {\n    if (process.env.DEBUG_TELEMETRY) {\n      // eslint-disable-next-line no-console\n      console.warn('[telemetry] failed to write Prometheus output', err);\n    }\n  }\n}\n\nfunction emitJsonSnapshot() {\n  try {\n    ensureDir(jsonSnapshotFile);\n    const snapshot = Array.from(aggregates.entries()).map(([key, stats]) => {\n      const [name, source] = key.split(':');\n      const avg = stats.count ? stats.total / stats.count : 0;\n      return { name, source, count: stats.count, total: stats.total, avg, max: stats.max, min: stats.min };\n    });\n    fs.writeFileSync(jsonSnapshotFile, JSON.stringify(snapshot, null, 2), 'utf8');\n  } catch (err) {\n    if (process.env.DEBUG_TELEMETRY) {\n      // eslint-disable-next-line no-console\n      console.warn('[telemetry] failed to write JSON snapshot', err);\n    }\n  }\n}\n",
    "symbols": [
      {
        "name": "configureTelemetry",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts",
        "startLine": 25,
        "endLine": 34
      },
      {
        "name": "startTimer",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts",
        "startLine": 36,
        "endLine": 49
      },
      {
        "name": "ensureDir",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts",
        "startLine": 51,
        "endLine": 53
      },
      {
        "name": "writeMetric",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts",
        "startLine": 55,
        "endLine": 68
      },
      {
        "name": "aggregateKey",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts",
        "startLine": 70,
        "endLine": 72
      },
      {
        "name": "updateAggregates",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts",
        "startLine": 74,
        "endLine": 82
      },
      {
        "name": "emitPrometheus",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts",
        "startLine": 84,
        "endLine": 107
      },
      {
        "name": "emitJsonSnapshot",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/telemetry.ts",
        "startLine": 109,
        "endLine": 124
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/tools.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport { spawnSync } from 'child_process';\nimport { GraphStore } from './graph_store';\nimport { Orchestrator } from './orchestrator';\nimport { SearchResult } from '@mcp/shared';\nimport { LangChainBridge } from './langchain_bridge';\n\nexport interface RefactorPlanInput {\n  file?: string;\n  symbol?: string;\n  goal?: string;\n}\n\nexport interface RefactorPlan {\n  intent: string;\n  summary: string;\n  steps: string[];\n  risks: string[];\n  impact: {\n    imports: string[];\n    dependents: string[];\n  };\n}\n\nexport interface PatchOperation {\n  find: string;\n  replace: string;\n  occurrences?: number;\n}\n\nexport interface GeneratedPatch {\n  path: string;\n  operations: PatchOperation[];\n  preview: {\n    before: string[];\n    after: string[];\n  };\n}\n\nexport interface PatchResult {\n  path: string;\n  applied: number;\n  total: number;\n}\n\nexport interface PerformanceInsight {\n  file: string;\n  issues: string[];\n  suggestions: string[];\n}\n\nexport interface VersionComparison {\n  fileA: string;\n  fileB: string;\n  added: string[];\n  removed: string[];\n  changed: string[];\n}\n\nexport interface AutoDoc {\n  file: string;\n  summary: string;\n  exports: Array<{ name: string; kind: string; range: string }>;\n  deps: {\n    imports: string[];\n    dependents: string[];\n  };\n}\n\nexport interface TestRunResult {\n  command: string;\n  status: number | null;\n  stdout: string;\n  stderr: string;\n}\n\nexport interface LangChainHit {\n  id: string;\n  file: string;\n  symbol: string;\n  score: number;\n  snippet: string;\n}\n\nexport interface LangChainQueryResult {\n  available: boolean;\n  provider: 'langchain' | 'fallback';\n  reason?: string;\n  results: LangChainHit[];\n}\n\nexport interface TelemetryPanelResult {\n  output: string;\n  entries: number;\n}\n\nexport interface TelemetryWebview {\n  path: string;\n  html: string;\n}\nconst MAX_PREVIEW_LINES = 12;\n\nfunction safeRelative(root: string, target: string) {\n  return path.relative(root, target).replace(/\\\\/g, '/');\n}\n\nfunction slicePreview(lines: string[], startLine: number, endLine: number): string[] {\n  const start = Math.max(0, startLine - 1);\n  const end = Math.min(lines.length, endLine);\n  return lines.slice(start, Math.min(end, start + MAX_PREVIEW_LINES));\n}\n\nfunction applyOperations(content: string, operations: PatchOperation[]): { updated: string; applied: number } {\n  let current = content;\n  let applied = 0;\n  for (const op of operations) {\n    const occurrences = typeof op.occurrences === 'number' && op.occurrences > 0 ? op.occurrences : 1;\n    let count = 0;\n    let idx = current.indexOf(op.find);\n    while (idx !== -1 && count < occurrences) {\n      current = current.slice(0, idx) + op.replace + current.slice(idx + op.find.length);\n      applied += 1;\n      count += 1;\n      idx = current.indexOf(op.find, idx + op.replace.length);\n    }\n  }\n  return { updated: current, applied };\n}\n\nexport function plan_refactor(orchestrator: Orchestrator, graph: GraphStore, repoRoot: string, input: RefactorPlanInput): RefactorPlan {\n  const targetFile = input.file ?? '';\n  let summary = 'High level refactor plan for the repository';\n  const steps: string[] = [];\n  const risks: string[] = [];\n  let imports: string[] = [];\n  let dependents: string[] = [];\n\n  if (targetFile) {\n    try {\n      const content = orchestrator.getFile(targetFile);\n      const lines = content.split(/\\r?\\n/);\n      const symbols = graph.listSymbols(targetFile) as Array<{ name: string; kind: string; startLine: number; endLine: number }> | [];\n\n      if (input.symbol) {\n        const sym = symbols.find(s => s.name === input.symbol);\n        if (sym) {\n          summary = `Targeted refactor plan for ${input.symbol}`;\n          const preview = slicePreview(lines, sym.startLine, sym.endLine);\n          steps.push(`Review ${input.symbol} (${sym.kind}) lines ${sym.startLine}-${sym.endLine}`);\n          steps.push(`Update dependent tests and call sites for ${input.symbol}`);\n          if (input.goal) steps.push(`Apply requested goal: ${input.goal}`);\n          risks.push('Run existing tests to catch regressions');\n          risks.push('Update documentation if the public API changes');\n          if (preview.length) {\n            steps.push(`Current snippet:\\n${preview.join('\\n')}`);\n          }\n        } else {\n          summary = `${input.symbol} symbol not found in GraphStore`;\n          steps.push(`Inspect ${targetFile} and verify symbol naming`);\n        }\n      } else {\n        summary = `High level refactor plan for ${targetFile}`;\n        const topSymbols = symbols.slice(0, 5).map(s => `${s.name} (${s.kind})`);\n        if (topSymbols.length) steps.push(`Review structure: ${topSymbols.join(', ')}`);\n        if (input.goal) steps.push(`Focus goal: ${input.goal}`);\n        steps.push('Simplify dependencies and deduplicate logic');\n      }\n\n      imports = graph.listImports(targetFile);\n      dependents = graph.listDependents(targetFile);\n\n      if (!imports.length && !dependents.length) {\n        risks.push('File is isolated in the dependency graph; check downstream impact manually');\n      } else {\n        if (imports.length) risks.push(`${imports.length} imports must remain coherent`);\n        if (dependents.length) risks.push(`${dependents.length} files depend on this module; plan regression tests`);\n      }\n    } catch (err: any) {\n      summary = `Failed to produce refactor plan for ${targetFile} (${err?.message ?? 'unknown error'})`;\n      steps.push('Verify that the file is indexed (run build and index tasks)');\n    }\n  } else {\n    steps.push('No target file or symbol supplied; outline global refactor goals');\n    steps.push('Use GraphStore metadata to pick high-impact modules');\n  }\n\n  if (!steps.length) steps.push('Additional context required to craft actionable steps');\n  if (!risks.length) risks.push('Follow standard code review and regression testing workflow');\n\n  return {\n    intent: input.goal ?? (input.symbol ? 'targeted-refactor' : 'structural-refactor'),\n    summary,\n    steps,\n    risks,\n    impact: {\n      imports,\n      dependents,\n    },\n  };\n}\n\nexport function generate_patch(repoRoot: string, filePath: string, operations: PatchOperation[]): GeneratedPatch {\n  const abs = path.resolve(repoRoot, filePath);\n  const content = fs.readFileSync(abs, 'utf8');\n  const { updated } = applyOperations(content, operations);\n  const originalPreview = slicePreview(content.split(/\\r?\\n/), 1, MAX_PREVIEW_LINES);\n  const updatedPreview = slicePreview(updated.split(/\\r?\\n/), 1, MAX_PREVIEW_LINES);\n  return {\n    path: safeRelative(repoRoot, abs),\n    operations,\n    preview: {\n      before: originalPreview,\n      after: updatedPreview,\n    },\n  };\n}\n\nexport function apply_patch(repoRoot: string, filePath: string, operations: PatchOperation[]): PatchResult {\n  const abs = path.resolve(repoRoot, filePath);\n  const content = fs.readFileSync(abs, 'utf8');\n  const { updated, applied } = applyOperations(content, operations);\n  fs.writeFileSync(abs, updated, 'utf8');\n  return {\n    path: safeRelative(repoRoot, abs),\n    applied,\n    total: operations.length,\n  };\n}\n\nexport function analyze_performance(repoRoot: string, filePath: string): PerformanceInsight {\n  const abs = path.resolve(repoRoot, filePath);\n  const content = fs.readFileSync(abs, 'utf8');\n  const issues: string[] = [];\n  const suggestions: string[] = [];\n\n  if (/for\\s*\\([^)]*\\)[\\s\\S]*for\\s*\\(/.test(content) || /for\\s*\\([^)]*\\)[\\s\\S]*while\\s*\\(/.test(content)) {\n    issues.push('Nested loops detected');\n    suggestions.push('Flatten or refactor nested loops to reduce complexity');\n  }\n  if (/JSON\\.stringify\\(.{400,}\\)/.test(content)) {\n    issues.push('Large JSON.stringify usage may impact performance');\n    suggestions.push('Stream or chunk large JSON payloads');\n  }\n  if (/fs\\.(readFileSync|writeFileSync|readdirSync)/.test(content)) {\n    issues.push('Synchronous fs calls detected');\n    suggestions.push('Prefer async fs APIs to avoid blocking the event loop');\n  }\n  if (/await\\s+.*\\.map\\(/.test(content) && !/await\\s+Promise\\.all\\([^)]*map\\(/.test(content)) {\n    issues.push('Await inside Array.map without Promise.all');\n    suggestions.push('Wrap async map calls with Promise.all for parallel execution');\n  }\n  if (!issues.length) {\n    suggestions.push('No obvious performance smells detected; capture runtime metrics to confirm');\n  }\n  return { file: safeRelative(repoRoot, abs), issues, suggestions };\n}\n\nfunction diffLines(a: string[], b: string[]) {\n  const removed: string[] = [];\n  const added: string[] = [];\n  const changed: string[] = [];\n  const len = Math.max(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    const left = a[i];\n    const right = b[i];\n    if (left === undefined) {\n      added.push(`${i + 1}: ${right}`);\n    } else if (right === undefined) {\n      removed.push(`${i + 1}: ${left}`);\n    } else if (left !== right) {\n      changed.push(`${i + 1}: ${left} -> ${right}`);\n    }\n  }\n  return { added, removed, changed };\n}\n\nexport function compare_versions(repoRoot: string, fileA: string, fileB: string): VersionComparison {\n  const absA = path.resolve(repoRoot, fileA);\n  const absB = path.resolve(repoRoot, fileB);\n  const contentA = fs.readFileSync(absA, 'utf8').split(/\\r?\\n/);\n  const contentB = fs.readFileSync(absB, 'utf8').split(/\\r?\\n/);\n  const diff = diffLines(contentA, contentB);\n  return {\n    fileA: safeRelative(repoRoot, absA),\n    fileB: safeRelative(repoRoot, absB),\n    added: diff.added,\n    removed: diff.removed,\n    changed: diff.changed,\n  };\n}\n\nexport function auto_docs(orchestrator: Orchestrator, graph: GraphStore, repoRoot: string, filePath: string): AutoDoc {\n  const abs = path.resolve(repoRoot, filePath);\n  const rel = safeRelative(repoRoot, abs);\n  const content = orchestrator.getFile(rel);\n  const lines = content.split(/\\r?\\n/);\n  const symbols = graph.listSymbols(rel) as Array<{ name: string; kind: string; startLine: number; endLine: number }>;\n  const exports = symbols.map(s => ({\n    name: s.name,\n    kind: s.kind,\n    range: `${s.startLine}-${s.endLine}`,\n  }));\n  const summary = `${rel} contains ${symbols.length} symbols across ${lines.length} lines.`;\n  return {\n    file: rel,\n    summary,\n    exports,\n    deps: {\n      imports: graph.listImports(rel),\n      dependents: graph.listDependents(rel),\n    },\n  };\n}\n\nexport function run_tests(repoRoot: string, testCommand = 'npm test'): TestRunResult {\n  const [cmd, ...args] = testCommand.split(/\\s+/).filter(Boolean);\n  const binary = process.platform === 'win32' && cmd === 'npm' ? 'npm.cmd' : cmd;\n  const result = spawnSync(binary, args, {\n    cwd: repoRoot,\n    encoding: 'utf8',\n  });\n  return {\n    command: testCommand,\n    status: result.status,\n    stdout: result.stdout ?? '',\n    stderr: result.stderr ?? '',\n  };\n}\n\nexport function run_task(repoRoot: string, scriptName: string): TestRunResult {\n  const pkgPath = path.join(repoRoot, 'package.json');\n  if (!fs.existsSync(pkgPath)) {\n    throw new Error(`package.json not found under ${repoRoot}`);\n  }\n  const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));\n  const scripts = pkg.scripts || {};\n  if (!scripts[scriptName]) {\n    throw new Error(`Script \"${scriptName}\" is not defined in package.json`);\n  }\n  const scriptCommand = String(scripts[scriptName]);\n  const bin = process.platform === 'win32' ? 'npm.cmd' : 'npm';\n  const result = spawnSync(bin, ['run', scriptName], {\n    cwd: repoRoot,\n    encoding: 'utf8',\n  });\n  const status =\n    typeof result.status === 'number'\n      ? result.status\n      : result.error\n      ? -1\n      : 0;\n  let finalStatus = status;\n  let stdout = result.stdout ?? '';\n  let stderr = result.stderr ?? '';\n  if (finalStatus !== 0) {\n    const fallback = spawnSync(scriptCommand, {\n      cwd: repoRoot,\n      encoding: 'utf8',\n      shell: true,\n    });\n    finalStatus =\n      typeof fallback.status === 'number'\n        ? fallback.status\n        : fallback.error\n        ? -1\n        : 0;\n    stdout += fallback.stdout ?? '';\n    stderr += fallback.stderr ?? '';\n  }\n  return {\n    command: `npm run ${scriptName}`,\n    status: finalStatus,\n    stdout,\n    stderr,\n  };\n}\n\nexport function summarize_architecture(graph: GraphStore) {\n  const files = graph['db'].prepare('SELECT COUNT(*) AS c FROM files').get() as any;\n  const symbols = graph['db'].prepare('SELECT COUNT(*) AS c FROM symbols').get() as any;\n  const edges = graph['db'].prepare('SELECT COUNT(*) AS c FROM edges').get() as any;\n  return { files: files?.c || 0, symbols: symbols?.c || 0, edges: edges?.c || 0 };\n}\n\nexport function detect_smells(repoRoot: string) {\n  const smells: Array<{ file: string; issue: string }> = [];\n  const walk = (dir: string) => {\n    for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {\n      const full = path.join(dir, entry.name);\n      if (entry.isDirectory()) {\n        if (entry.name === 'node_modules' || entry.name === 'dist' || entry.name.startsWith('.')) continue;\n        walk(full);\n      } else if (entry.isFile() && (entry.name.endsWith('.ts') || entry.name.endsWith('.tsx'))) {\n        const content = fs.readFileSync(full, 'utf8');\n        if (/TODO|FIXME/.test(content)) smells.push({ file: safeRelative(repoRoot, full), issue: 'TODO/FIXME marker present' });\n        if (content.split(/\\r?\\n/).some(line => line.length > 200)) {\n          smells.push({ file: safeRelative(repoRoot, full), issue: 'Line longer than 200 chars' });\n        }\n      }\n    }\n  };\n  walk(repoRoot);\n  return smells;\n}\n\nexport function suggest_tests(symbols: Array<{ file: string; name: string }>) {\n  return symbols.map(s => ({ symbol: s.name, suggestion: `Add unit test for ${s.name} in ${s.file}` }));\n}\n\nexport async function langchain_query(dataDir: string, query: string, topK = 5): Promise<LangChainQueryResult> {\n  const bridge = new LangChainBridge(dataDir);\n  return bridge.query(query, topK);\n}\n\nexport function generate_telemetry_panel(repoRoot: string, outputPath?: string): TelemetryPanelResult {\n  const logsDir = path.join(repoRoot, 'logs');\n  const snapshotPath = path.join(logsDir, 'telemetry_latest.json');\n  let entries: Array<{ name: string; source: string; count: number; total: number; avg: number; max: number; min: number }> = [];\n  if (fs.existsSync(snapshotPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(snapshotPath, 'utf8'));\n    } catch {\n      entries = [];\n    }\n  }\n  const outFile = outputPath ? path.resolve(repoRoot, outputPath) : path.join(logsDir, 'telemetry_panel.html');\n  fs.mkdirSync(path.dirname(outFile), { recursive: true });\n  const rows = entries\n    .map(\n      entry =>\n        `<tr><td>${entry.name}</td><td>${entry.source}</td><td>${entry.count}</td><td>${entry.total}</td><td>${entry.avg.toFixed(\n          2\n        )}</td><td>${entry.max}</td><td>${entry.min}</td></tr>`\n    )\n    .join('');\n  const html = `<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\" />\n  <title>MCP Telemetry Panel</title>\n  <style>\n    body { font-family: Arial, sans-serif; margin: 2rem; background: #111; color: #eee; }\n    table { border-collapse: collapse; width: 100%; }\n    th, td { border: 1px solid #444; padding: 0.5rem; text-align: left; }\n    th { background: #222; }\n    tbody tr:nth-child(even) { background: #1a1a1a; }\n  </style>\n</head>\n<body>\n  <h1>Telemetry Metrics</h1>\n  <p>Generated at ${new Date().toISOString()}</p>\n  <table>\n    <thead>\n      <tr>\n        <th>Name</th>\n        <th>Source</th>\n        <th>Count</th>\n        <th>Total (ms)</th>\n        <th>Avg (ms)</th>\n        <th>Max (ms)</th>\n        <th>Min (ms)</th>\n      </tr>\n    </thead>\n    <tbody>\n      ${rows || '<tr><td colspan=\"7\">No telemetry entries recorded.</td></tr>'}\n    </tbody>\n  </table>\n</body>\n</html>`;\n  fs.writeFileSync(outFile, html, 'utf8');\n  return { output: safeRelative(repoRoot, outFile), entries: entries.length };\n}\n\nexport function open_telemetry_webview(repoRoot: string, options: { regenerate?: boolean; output?: string } = {}): TelemetryWebview {\n  const shouldRegenerate = options.regenerate ?? false;\n  const preferredPath = options.output\n    ? path.resolve(repoRoot, options.output)\n    : path.join(repoRoot, 'logs', 'telemetry_panel.html');\n\n  let htmlPath = preferredPath;\n  if (shouldRegenerate || !fs.existsSync(preferredPath)) {\n    const generated = generate_telemetry_panel(repoRoot, options.output);\n    htmlPath = path.resolve(repoRoot, generated.output);\n  }\n\n  const html = fs.readFileSync(htmlPath, 'utf8');\n  return { path: safeRelative(repoRoot, htmlPath), html };\n}\n\nexport function select_context(results: SearchResult[], budgetTokens: number) {\n  if (!results.length) return results;\n  if (budgetTokens <= 0) return results;\n  const approxTokens = (snippet: string) => Math.ceil(snippet.length / 4);\n  const selected: SearchResult[] = [];\n  let used = 0;\n  for (const res of results) {\n    const cost = approxTokens(res.snippet);\n    if (used + cost > budgetTokens) continue;\n    selected.push(res);\n    used += cost;\n  }\n  return selected.length ? selected : results.slice(0, Math.max(1, Math.min(results.length, 3)));\n}\n",
    "symbols": [
      {
        "name": "safeRelative",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 104,
        "endLine": 106
      },
      {
        "name": "slicePreview",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 108,
        "endLine": 112
      },
      {
        "name": "applyOperations",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 114,
        "endLine": 129
      },
      {
        "name": "plan_refactor",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 131,
        "endLine": 201
      },
      {
        "name": "generate_patch",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 203,
        "endLine": 217
      },
      {
        "name": "apply_patch",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 219,
        "endLine": 229
      },
      {
        "name": "analyze_performance",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 231,
        "endLine": 257
      },
      {
        "name": "diffLines",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 259,
        "endLine": 276
      },
      {
        "name": "compare_versions",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 278,
        "endLine": 291
      },
      {
        "name": "auto_docs",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 293,
        "endLine": 314
      },
      {
        "name": "run_tests",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 316,
        "endLine": 329
      },
      {
        "name": "run_task",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 331,
        "endLine": 377
      },
      {
        "name": "summarize_architecture",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 379,
        "endLine": 384
      },
      {
        "name": "detect_smells",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 386,
        "endLine": 405
      },
      {
        "name": "suggest_tests",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 407,
        "endLine": 409
      },
      {
        "name": "langchain_query",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 411,
        "endLine": 414
      },
      {
        "name": "generate_telemetry_panel",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 416,
        "endLine": 473
      },
      {
        "name": "open_telemetry_webview",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 475,
        "endLine": 489
      },
      {
        "name": "select_context",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/tools.ts",
        "startLine": 491,
        "endLine": 504
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/watcher.ts",
    "content": "import chokidar from 'chokidar';\nimport path from 'path';\nimport { runIndexer } from './indexer';\nimport { createQueue, enqueueReindex } from './job_queue';\n\nexport function startWatcher(rootDir: string, outDir: string, sqlitePath: string) {\n  const watcher = chokidar.watch([path.join(rootDir, '**/*.ts'), path.join(rootDir, '**/*.tsx')], {\n    ignored: [/node_modules/, /dist/, /(^|[/\\\\])\\../],\n    ignoreInitial: true,\n  });\n  const redisUrl = process.env.REDIS_URL;\n  const queue = redisUrl ? createQueue('mcp-jobs', redisUrl) : undefined;\n  const schedule = debounce(async () => {\n    if (queue) {\n      await enqueueReindex(queue, { rootDir, outDir, sqlite: sqlitePath });\n    } else {\n      await runIndexer(rootDir, outDir, sqlitePath);\n    }\n    console.log('Incremental index scheduled');\n  }, 500);\n  watcher.on('add', schedule).on('change', schedule).on('unlink', schedule);\n  return watcher;\n}\n\nfunction debounce(fn: () => void | Promise<void>, ms: number) {\n  let t: any;\n  return () => {\n    clearTimeout(t);\n    t = setTimeout(fn, ms);\n  };\n}\n\nif (require.main === module) {\n  const envRoot = process.env.INDEX_ROOT || process.env.MCP_INDEX_ROOT || process.env.WORKSPACE_ROOT;\n  const envData = process.env.DATA_DIR || process.env.MCP_DATA_DIR;\n  const rootDir = envRoot ? path.resolve(envRoot) : path.join(process.cwd(), 'src');\n  const outDir = envData ? path.resolve(envData) : path.join(process.cwd(), 'data');\n  const sqlite = path.join(outDir, 'graph.db');\n  console.log(`[mcp-watch] rootDir=${rootDir}`);\n  console.log(`[mcp-watch] outDir=${outDir}`);\n  startWatcher(rootDir, outDir, sqlite);\n}\n",
    "symbols": [
      {
        "name": "startWatcher",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/watcher.ts",
        "startLine": 6,
        "endLine": 23
      },
      {
        "name": "debounce",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/watcher.ts",
        "startLine": 25,
        "endLine": 31
      }
    ]
  },
  {
    "path": "packages/mcp-server/src/weights.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\nexport interface Weights { semantic: number; lexical: number; graph: number; }\nconst defaultWeights: Weights = { semantic: 0.6, lexical: 0.25, graph: 0.15 };\n\nfunction clamp01(x: number) { return Math.max(0, Math.min(1, x)); }\n\nexport class WeightManager {\n  private file: string;\n  private w: Weights;\n  constructor(file = path.join(process.cwd(), 'weights.json')) {\n    this.file = file;\n    this.w = this.load();\n  }\n  private load(): Weights {\n    try {\n      const data = JSON.parse(fs.readFileSync(this.file, 'utf8'));\n      return { semantic: data.semantic, lexical: data.lexical, graph: data.graph } as Weights;\n    } catch { return { ...defaultWeights }; }\n  }\n  private save() { fs.writeFileSync(this.file, JSON.stringify(this.w, null, 2), 'utf8'); }\n  get(): Weights { return { ...this.w }; }\n  feedback(kind: 'up' | 'down') {\n    const delta = kind === 'up' ? 0.01 : -0.01;\n    // simple strategy: increase semantic on up, lexical on down toggles towards balance\n    this.w.semantic = clamp01(this.w.semantic + delta);\n    this.w.lexical = clamp01(this.w.lexical + (kind === 'up' ? -delta/2 : +delta/2));\n    // normalize\n    const s = this.w.semantic + this.w.lexical + this.w.graph;\n    this.w.semantic /= s; this.w.lexical /= s; this.w.graph /= s;\n    this.save();\n  }\n}\n\n",
    "symbols": [
      {
        "name": "clamp01",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/weights.ts",
        "startLine": 7,
        "endLine": 7
      },
      {
        "name": "WeightManager",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/weights.ts",
        "startLine": 9,
        "endLine": 34
      },
      {
        "name": "WeightManager.load",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/weights.ts",
        "startLine": 16,
        "endLine": 21
      },
      {
        "name": "WeightManager.save",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/weights.ts",
        "startLine": 22,
        "endLine": 22
      },
      {
        "name": "WeightManager.get",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/weights.ts",
        "startLine": 23,
        "endLine": 23
      },
      {
        "name": "WeightManager.feedback",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/packages/mcp-server/src/weights.ts",
        "startLine": 24,
        "endLine": 33
      }
    ]
  },
  {
    "path": "packages/mcp-server/tests/ranker.test.ts",
    "content": "import { describe, it, expect } from 'vitest';\nimport { rank_hybrid, set_weights } from '../src/ranker';\nimport type { SearchResult } from '@mcp/shared';\n\ndescribe('rank_hybrid', () => {\n  it('combines signals and sorts', () => {\n    set_weights({ semantic: 0.6, lexical: 0.3, graph: 0.1 });\n    const res: SearchResult[] = [\n      { file: 'a.ts', symbol: 'A.fn', startLine: 1, endLine: 5, score: 0.6, snippet: 'alpha beta' },\n      { file: 'b.ts', symbol: 'B.fn', startLine: 1, endLine: 5, score: 0.5, snippet: 'beta gamma' }\n    ];\n    const ranked = rank_hybrid(res, 'beta', f => (f === 'b.ts' ? 2 : 1));\n    expect(ranked[0].file).toBe('a.ts');\n  });\n});\n",
    "symbols": []
  },
  {
    "path": "packages/mcp-server/tests/tools.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport fs from 'fs';\nimport os from 'os';\nimport path from 'path';\nimport {\n  plan_refactor,\n  generate_patch,\n  apply_patch,\n  analyze_performance,\n  compare_versions,\n  auto_docs,\n  run_tests,\n  run_task,\n  generate_telemetry_panel,\n  open_telemetry_webview,\n  langchain_query,\n} from '../src/tools';\nimport type { Orchestrator } from '../src/orchestrator';\nimport type { GraphStore } from '../src/graph_store';\n\nconst sampleCode = `export class Sample {\n  items: number[] = [];\n\n  addItem(value: number) {\n    for (let i = 0; i < this.items.length; i++) {\n      for (let j = 0; j < this.items.length; j++) {\n        this.items[j] += value;\n      }\n    }\n    return this.items.length;\n  }\n}\n`;\n\nconst fakeOrchestrator = {\n  getFile: () => sampleCode,\n} as unknown as Orchestrator;\n\nconst fakeGraph = {\n  listSymbols: () => [\n    { name: 'Sample', kind: 'class', startLine: 1, endLine: 11 },\n    { name: 'Sample.addItem', kind: 'method', startLine: 4, endLine: 10 },\n  ],\n  listImports: () => ['utils/logger.ts'],\n  listDependents: () => ['services/consumer.ts'],\n} as unknown as GraphStore;\n\ndescribe('tools helpers', () => {\n  let tempDir: string;\n\n  beforeEach(() => {\n    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'mcp-tools-'));\n  });\n\n  afterEach(() => {\n    fs.rmSync(tempDir, { recursive: true, force: true });\n  });\n\n  it('plans refactor with symbol focus', () => {\n    const plan = plan_refactor(fakeOrchestrator, fakeGraph, tempDir, { file: 'sample.ts', symbol: 'Sample.addItem', goal: 'reduce loop count' });\n    expect(plan.summary).toContain('Sample.addItem');\n    expect(plan.steps.some(step => step.includes('Sample.addItem'))).toBe(true);\n    expect(plan.impact.imports).toEqual(['utils/logger.ts']);\n  });\n\n  it('generates and applies patches', () => {\n    const filePath = path.join(tempDir, 'demo.ts');\n    fs.writeFileSync(filePath, 'const value = 1;\\n', 'utf8');\n    const patch = generate_patch(tempDir, 'demo.ts', [{ find: '1', replace: '2' }]);\n    expect(patch.preview.after.join('\\n')).toContain('2');\n    const result = apply_patch(tempDir, 'demo.ts', [{ find: '1', replace: '2' }]);\n    expect(result.applied).toBe(1);\n    const updated = fs.readFileSync(filePath, 'utf8');\n    expect(updated).toContain('2');\n  });\n\n  it('detects basic performance smells', () => {\n    const filePath = path.join(tempDir, 'perf.ts');\n    fs.writeFileSync(filePath, sampleCode, 'utf8');\n    const insight = analyze_performance(tempDir, 'perf.ts');\n    expect(insight.issues.some(issue => issue.includes('Nested'))).toBe(true);\n  });\n\n  it('compares versions line by line', () => {\n    const a = path.join(tempDir, 'a.ts');\n    const b = path.join(tempDir, 'b.ts');\n    fs.writeFileSync(a, 'const a = 1;\\n', 'utf8');\n    fs.writeFileSync(b, 'const a = 2;\\n', 'utf8');\n    const diff = compare_versions(tempDir, 'a.ts', 'b.ts');\n    expect(diff.changed.length).toBeGreaterThan(0);\n  });\n\n  it('produces auto docs summary', () => {\n    const docs = auto_docs(fakeOrchestrator, fakeGraph, tempDir, 'sample.ts');\n    expect(docs.summary).toContain('sample.ts');\n    expect(docs.exports.length).toBe(2);\n  });\n\n  it('runs provided test command', () => {\n    const result = run_tests(tempDir, 'node -e process.exit(0)');\n    expect(result.status).toBe(0);\n  });\n\n  it('runs an npm script via run_task', () => {\n    const pkg = {\n      name: 'fixture',\n      version: '1.0.0',\n      scripts: {\n        exit0: 'node -e \"process.exit(0)\"',\n      },\n    };\n    fs.writeFileSync(path.join(tempDir, 'package.json'), JSON.stringify(pkg, null, 2), 'utf8');\n    const result = run_task(tempDir, 'exit0');\n    expect(result.status).toBe(0);\n    expect(result.command).toBe('npm run exit0');\n  });\n\n  it('generates telemetry panel html', () => {\n    const logsDir = path.join(tempDir, 'logs');\n    fs.mkdirSync(logsDir, { recursive: true });\n    const snapshot = [\n      { name: 'search_code', source: 'mcp:tools', count: 2, total: 40, avg: 20, max: 30, min: 10 },\n    ];\n    fs.writeFileSync(path.join(logsDir, 'telemetry_latest.json'), JSON.stringify(snapshot), 'utf8');\n    const result = generate_telemetry_panel(tempDir);\n    const htmlPath = path.join(tempDir, result.output);\n    const html = fs.readFileSync(htmlPath, 'utf8');\n    expect(html).toContain('Telemetry Metrics');\n    expect(html).toContain('search_code');\n  });\n\n  it('opens telemetry webview html', () => {\n    const logsDir = path.join(tempDir, 'logs');\n    fs.mkdirSync(logsDir, { recursive: true });\n    const snapshot = [\n      { name: 'search_code', source: 'mcp:tools', count: 1, total: 10, avg: 10, max: 10, min: 10 },\n    ];\n    fs.writeFileSync(path.join(logsDir, 'telemetry_latest.json'), JSON.stringify(snapshot), 'utf8');\n    generate_telemetry_panel(tempDir);\n    const webview = open_telemetry_webview(tempDir);\n    expect(webview.html).toContain('<html');\n    expect(webview.path.endsWith('.html')).toBe(true);\n  });\n\n  it('provides langchain bridge fallback results', async () => {\n    const dataDir = path.join(tempDir, 'data');\n    fs.mkdirSync(dataDir, { recursive: true });\n    const entries = [\n      {\n        id: 'demo:add',\n        file: 'demo.ts',\n        symbol: 'add',\n        text: 'export function add(a: number, b: number) { return a + b; }',\n      },\n      {\n        id: 'demo:sub',\n        file: 'demo.ts',\n        symbol: 'sub',\n        text: 'export function sub(a: number, b: number) { return a - b; }',\n      },\n    ];\n    fs.writeFileSync(path.join(dataDir, 'semantic_entries.json'), JSON.stringify(entries), 'utf8');\n    const result = await langchain_query(dataDir, 'add numbers', 2);\n    expect(result.results.length).toBeGreaterThan(0);\n    expect(result.results[0].symbol.toLowerCase()).toContain('add');\n  });\n});\n",
    "symbols": []
  },
  {
    "path": "packages/shared/src/index.ts",
    "content": "export interface SymbolMeta {\n  name: string;\n  kind: 'function' | 'class' | 'method' | 'unknown';\n  file: string;\n  startLine: number;\n  endLine: number;\n}\n\nexport interface FileMeta {\n  path: string;\n  content: string;\n  symbols: SymbolMeta[];\n}\n\nexport interface SemanticEntry {\n  id: string;\n  file: string;\n  symbol: string;\n  startLine: number;\n  endLine: number;\n  text: string;\n}\n\nexport interface SearchResult {\n  file: string;\n  symbol: string;\n  startLine: number;\n  endLine: number;\n  score: number;\n  snippet: string;\n}\n\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/eventsource/src/errors.ts",
    "content": "/**\n * An extended version of the `Event` emitted by the `EventSource` object when an error occurs.\n * While the spec does not include any additional properties, we intentionally go beyond the spec\n * and provide some (minimal) additional information to aid in debugging.\n *\n * @public\n */\nexport class ErrorEvent extends Event {\n  /**\n   * HTTP status code, if this was triggered by an HTTP error\n   * Note: this is not part of the spec, but is included for better error handling.\n   *\n   * @public\n   */\n  public code?: number | undefined\n\n  /**\n   * Optional message attached to the error.\n   * Note: this is not part of the spec, but is included for better error handling.\n   *\n   * @public\n   */\n  public message?: string | undefined\n\n  /**\n   * Constructs a new `ErrorEvent` instance. This is typically not called directly,\n   * but rather emitted by the `EventSource` object when an error occurs.\n   *\n   * @param type - The type of the event (should be \"error\")\n   * @param errorEventInitDict - Optional properties to include in the error event\n   */\n  constructor(\n    type: string,\n    errorEventInitDict?: {message?: string | undefined; code?: number | undefined},\n  ) {\n    super(type)\n    this.code = errorEventInitDict?.code ?? undefined\n    this.message = errorEventInitDict?.message ?? undefined\n  }\n\n  /**\n   * Node.js \"hides\" the `message` and `code` properties of the `ErrorEvent` instance,\n   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,\n   * we explicitly include the properties in the `inspect` method.\n   *\n   * This is automatically called by Node.js when you `console.log` an instance of this class.\n   *\n   * @param _depth - The current depth\n   * @param options - The options passed to `util.inspect`\n   * @param inspect - The inspect function to use (prevents having to import it from `util`)\n   * @returns A string representation of the error\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](\n    _depth: number,\n    options: {colors: boolean},\n    inspect: (obj: unknown, inspectOptions: {colors: boolean}) => string,\n  ): string {\n    return inspect(inspectableError(this), options)\n  }\n\n  /**\n   * Deno \"hides\" the `message` and `code` properties of the `ErrorEvent` instance,\n   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,\n   * we explicitly include the properties in the `inspect` method.\n   *\n   * This is automatically called by Deno when you `console.log` an instance of this class.\n   *\n   * @param inspect - The inspect function to use (prevents having to import it from `util`)\n   * @param options - The options passed to `Deno.inspect`\n   * @returns A string representation of the error\n   */\n  [Symbol.for('Deno.customInspect')](\n    inspect: (obj: unknown, inspectOptions: {colors: boolean}) => string,\n    options: {colors: boolean},\n  ): string {\n    return inspect(inspectableError(this), options)\n  }\n}\n\n/**\n * For environments where DOMException may not exist, we will use a SyntaxError instead.\n * While this isn't strictly according to spec, it is very close.\n *\n * @param message - The message to include in the error\n * @returns A `DOMException` or `SyntaxError` instance\n * @internal\n */\nexport function syntaxError(message: string): SyntaxError {\n  // If someone can figure out a way to make this work without depending on DOM/Node.js typings,\n  // and without casting to `any`, please send a PR 🙏\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const DomException = (globalThis as any).DOMException\n  if (typeof DomException === 'function') {\n    return new DomException(message, 'SyntaxError')\n  }\n\n  return new SyntaxError(message)\n}\n\n/**\n * Flatten an error into a single error message string.\n * Unwraps nested errors and joins them with a comma.\n *\n * @param err - The error to flatten\n * @returns A string representation of the error\n * @internal\n */\nexport function flattenError(err: unknown): string {\n  if (!(err instanceof Error)) {\n    return `${err}`\n  }\n\n  if ('errors' in err && Array.isArray(err.errors)) {\n    return err.errors.map(flattenError).join(', ')\n  }\n\n  if ('cause' in err && err.cause instanceof Error) {\n    return `${err}: ${flattenError(err.cause)}`\n  }\n\n  return err.message\n}\n\n/**\n * Convert an `ErrorEvent` instance into a plain object for inspection.\n *\n * @param err - The `ErrorEvent` instance to inspect\n * @returns A plain object representation of the error\n * @internal\n */\nfunction inspectableError(err: ErrorEvent) {\n  return {\n    type: err.type,\n    message: err.message,\n    code: err.code,\n    defaultPrevented: err.defaultPrevented,\n    cancelable: err.cancelable,\n    timeStamp: err.timeStamp,\n  }\n}\n",
    "symbols": [
      {
        "name": "ErrorEvent",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/errors.ts",
        "startLine": 8,
        "endLine": 78
      },
      {
        "name": "ErrorEvent.[Symbol.for('nodejs.util.inspect.custom')]",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/errors.ts",
        "startLine": 53,
        "endLine": 59
      },
      {
        "name": "ErrorEvent.[Symbol.for('Deno.customInspect')]",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/errors.ts",
        "startLine": 72,
        "endLine": 77
      },
      {
        "name": "syntaxError",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/errors.ts",
        "startLine": 88,
        "endLine": 99
      },
      {
        "name": "flattenError",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/errors.ts",
        "startLine": 109,
        "endLine": 123
      },
      {
        "name": "inspectableError",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/errors.ts",
        "startLine": 132,
        "endLine": 141
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
    "content": "import {createParser, type EventSourceMessage, type EventSourceParser} from 'eventsource-parser'\n\nimport {ErrorEvent, flattenError, syntaxError} from './errors.js'\nimport type {\n  AddEventListenerOptions,\n  EventListenerOptions,\n  EventListenerOrEventListenerObject,\n  EventSourceEventMap,\n  EventSourceFetchInit,\n  EventSourceInit,\n  FetchLike,\n  FetchLikeResponse,\n} from './types.js'\n\n/**\n * An `EventSource` instance opens a persistent connection to an HTTP server, which sends events\n * in `text/event-stream` format. The connection remains open until closed by calling `.close()`.\n *\n * @public\n * @example\n * ```js\n * const eventSource = new EventSource('https://example.com/stream')\n * eventSource.addEventListener('error', (error) => {\n *   console.error(error)\n * })\n * eventSource.addEventListener('message', (event) => {\n *  console.log('Received message:', event.data)\n * })\n * ```\n */\nexport class EventSource extends EventTarget {\n  /**\n   * ReadyState representing an EventSource currently trying to connect\n   *\n   * @public\n   */\n  static CONNECTING = 0 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is open (eg connected)\n   *\n   * @public\n   */\n  static OPEN = 1 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is closed (eg disconnected)\n   *\n   * @public\n   */\n  static CLOSED = 2 as const\n\n  /**\n   * ReadyState representing an EventSource currently trying to connect\n   *\n   * @public\n   */\n  readonly CONNECTING = 0 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is open (eg connected)\n   *\n   * @public\n   */\n  readonly OPEN = 1 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is closed (eg disconnected)\n   *\n   * @public\n   */\n  readonly CLOSED = 2 as const\n\n  /**\n   * Returns the state of this EventSource object's connection. It can have the values described below.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)\n   *\n   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,\n   * defined in the TypeScript `dom` library.\n   *\n   * @public\n   */\n  public get readyState(): number {\n    return this.#readyState\n  }\n\n  /**\n   * Returns the URL providing the event stream.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)\n   *\n   * @public\n   */\n  public get url(): string {\n    return this.#url.href\n  }\n\n  /**\n   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to \"include\", and false otherwise.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)\n   */\n  public get withCredentials(): boolean {\n    return this.#withCredentials\n  }\n\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */\n  public get onerror(): ((ev: ErrorEvent) => unknown) | null {\n    return this.#onError\n  }\n  public set onerror(value: ((ev: ErrorEvent) => unknown) | null) {\n    this.#onError = value\n  }\n\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */\n  public get onmessage(): ((ev: MessageEvent) => unknown) | null {\n    return this.#onMessage\n  }\n  public set onmessage(value: ((ev: MessageEvent) => unknown) | null) {\n    this.#onMessage = value\n  }\n\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */\n  public get onopen(): ((ev: Event) => unknown) | null {\n    return this.#onOpen\n  }\n  public set onopen(value: ((ev: Event) => unknown) | null) {\n    this.#onOpen = value\n  }\n\n  override addEventListener<K extends keyof EventSourceEventMap>(\n    type: K,\n    listener: (this: EventSource, ev: EventSourceEventMap[K]) => unknown,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  override addEventListener(\n    type: string,\n    listener: (this: EventSource, event: MessageEvent) => unknown,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  override addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  override addEventListener(\n    type: string,\n    listener:\n      | ((this: EventSource, event: MessageEvent) => unknown)\n      | EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    const listen = listener as (this: EventSource, event: Event) => unknown\n    super.addEventListener(type, listen, options)\n  }\n\n  override removeEventListener<K extends keyof EventSourceEventMap>(\n    type: K,\n    listener: (this: EventSource, ev: EventSourceEventMap[K]) => unknown,\n    options?: boolean | EventListenerOptions,\n  ): void\n  override removeEventListener(\n    type: string,\n    listener: (this: EventSource, event: MessageEvent) => unknown,\n    options?: boolean | EventListenerOptions,\n  ): void\n  override removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void\n  override removeEventListener(\n    type: string,\n    listener:\n      | ((this: EventSource, event: MessageEvent) => unknown)\n      | EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void {\n    const listen = listener as (this: EventSource, event: Event) => unknown\n    super.removeEventListener(type, listen, options)\n  }\n\n  constructor(url: string | URL, eventSourceInitDict?: EventSourceInit) {\n    super()\n\n    try {\n      if (url instanceof URL) {\n        this.#url = url\n      } else if (typeof url === 'string') {\n        this.#url = new URL(url, getBaseURL())\n      } else {\n        throw new Error('Invalid URL')\n      }\n    } catch (err) {\n      throw syntaxError('An invalid or illegal string was specified')\n    }\n\n    this.#parser = createParser({\n      onEvent: this.#onEvent,\n      onRetry: this.#onRetryChange,\n    })\n\n    this.#readyState = this.CONNECTING\n    this.#reconnectInterval = 3000\n    this.#fetch = eventSourceInitDict?.fetch ?? globalThis.fetch\n    this.#withCredentials = eventSourceInitDict?.withCredentials ?? false\n\n    this.#connect()\n  }\n\n  /**\n   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)\n   *\n   * @public\n   */\n  close(): void {\n    if (this.#reconnectTimer) clearTimeout(this.#reconnectTimer)\n    if (this.#readyState === this.CLOSED) return\n    if (this.#controller) this.#controller.abort()\n    this.#readyState = this.CLOSED\n    this.#controller = undefined\n  }\n\n  // PRIVATES FOLLOW\n\n  /**\n   * Current connection state\n   *\n   * @internal\n   */\n  #readyState: number\n\n  /**\n   * Original URL used to connect.\n   *\n   * Note that this will stay the same even after a redirect.\n   *\n   * @internal\n   */\n  #url: URL\n\n  /**\n   * The destination URL after a redirect. Is reset on reconnection.\n   *\n   * @internal\n   */\n  #redirectUrl: URL | undefined\n\n  /**\n   * Whether to include credentials in the request\n   *\n   * @internal\n   */\n  #withCredentials: boolean\n\n  /**\n   * The fetch implementation to use\n   *\n   * @internal\n   */\n  #fetch: FetchLike\n\n  /**\n   * The reconnection time in milliseconds\n   *\n   * @internal\n   */\n  #reconnectInterval: number\n\n  /**\n   * Reference to an ongoing reconnect attempt, if any\n   *\n   * @internal\n   */\n  #reconnectTimer: ReturnType<typeof setTimeout> | undefined\n\n  /**\n   * The last event ID seen by the EventSource, which will be sent as `Last-Event-ID` in the\n   * request headers on a reconnection attempt.\n   *\n   * @internal\n   */\n  #lastEventId: string | null = null\n\n  /**\n   * The AbortController instance used to abort the fetch request\n   *\n   * @internal\n   */\n  #controller: AbortController | undefined\n\n  /**\n   * Instance of an EventSource parser (`eventsource-parser` npm module)\n   *\n   * @internal\n   */\n  #parser: EventSourceParser\n\n  /**\n   * Holds the current error handler, attached through `onerror` property directly.\n   * Note that `addEventListener('error', …)` will not be stored here.\n   *\n   * @internal\n   */\n  #onError: ((ev: ErrorEvent) => unknown) | null = null\n\n  /**\n   * Holds the current message handler, attached through `onmessage` property directly.\n   * Note that `addEventListener('message', …)` will not be stored here.\n   *\n   * @internal\n   */\n  #onMessage: ((ev: MessageEvent) => unknown) | null = null\n\n  /**\n   * Holds the current open handler, attached through `onopen` property directly.\n   * Note that `addEventListener('open', …)` will not be stored here.\n   *\n   * @internal\n   */\n  #onOpen: ((ev: Event) => unknown) | null = null\n\n  /**\n   * Connect to the given URL and start receiving events\n   *\n   * @internal\n   */\n  #connect() {\n    this.#readyState = this.CONNECTING\n    this.#controller = new AbortController()\n\n    // Browser tests are failing if we directly call `this.#fetch()`, thus the indirection.\n    const fetch = this.#fetch\n    fetch(this.#url, this.#getRequestOptions())\n      .then(this.#onFetchResponse)\n      .catch(this.#onFetchError)\n  }\n\n  /**\n   * Handles the fetch response\n   *\n   * @param response - The Fetch(ish) response\n   * @internal\n   */\n  #onFetchResponse = async (response: FetchLikeResponse) => {\n    this.#parser.reset()\n\n    const {body, redirected, status, headers} = response\n\n    // [spec] a client can be told to stop reconnecting using the HTTP 204 No Content response code.\n    if (status === 204) {\n      // We still need to emit an error event - this mirrors the browser behavior,\n      // and without it there is no way to tell the user that the connection was closed.\n      this.#failConnection('Server sent HTTP 204, not reconnecting', 204)\n      this.close()\n      return\n    }\n\n    // [spec] …Event stream requests can be redirected using HTTP 301 and 307 redirects as with\n    // [spec] normal HTTP requests.\n    // Spec does not say anything about other redirect codes (302, 308), but this seems an\n    // unintended omission, rather than a feature. Browsers will happily redirect on other 3xxs's.\n    if (redirected) {\n      this.#redirectUrl = new URL(response.url)\n    } else {\n      this.#redirectUrl = undefined\n    }\n\n    // [spec] if res's status is not 200, …, then fail the connection.\n    if (status !== 200) {\n      this.#failConnection(`Non-200 status code (${status})`, status)\n      return\n    }\n\n    // [spec] …or if res's `Content-Type` is not `text/event-stream`, then fail the connection.\n    const contentType = headers.get('content-type') || ''\n    if (!contentType.startsWith('text/event-stream')) {\n      this.#failConnection('Invalid content type, expected \"text/event-stream\"', status)\n      return\n    }\n\n    // [spec] …if the readyState attribute is set to a value other than CLOSED…\n    if (this.#readyState === this.CLOSED) {\n      return\n    }\n\n    // [spec] …sets the readyState attribute to OPEN and fires an event\n    // [spec] …named open at the EventSource object.\n    this.#readyState = this.OPEN\n\n    const openEvent = new Event('open')\n    this.#onOpen?.(openEvent)\n    this.dispatchEvent(openEvent)\n\n    // Ensure that the response stream is a web stream\n    if (typeof body !== 'object' || !body || !('getReader' in body)) {\n      this.#failConnection('Invalid response body, expected a web ReadableStream', status)\n      this.close() // This should only happen if `fetch` provided is \"faulty\" - don't reconnect\n      return\n    }\n\n    const decoder = new TextDecoder()\n\n    const reader = body.getReader()\n    let open = true\n\n    do {\n      const {done, value} = await reader.read()\n      if (value) {\n        this.#parser.feed(decoder.decode(value, {stream: !done}))\n      }\n\n      if (!done) {\n        continue\n      }\n\n      open = false\n      this.#parser.reset()\n\n      this.#scheduleReconnect()\n    } while (open)\n  }\n\n  /**\n   * Handles rejected requests for the EventSource endpoint\n   *\n   * @param err - The error from `fetch()`\n   * @internal\n   */\n  #onFetchError = (err: Error & {type?: string}) => {\n    this.#controller = undefined\n\n    // We expect abort errors when the user manually calls `close()` - ignore those\n    if (err.name === 'AbortError' || err.type === 'aborted') {\n      return\n    }\n\n    this.#scheduleReconnect(flattenError(err))\n  }\n\n  /**\n   * Get request options for the `fetch()` request\n   *\n   * @returns The request options\n   * @internal\n   */\n  #getRequestOptions(): EventSourceFetchInit {\n    const lastEvent = this.#lastEventId ? {'Last-Event-ID': this.#lastEventId} : undefined\n\n    const init: EventSourceFetchInit = {\n      // [spec] Let `corsAttributeState` be `Anonymous`…\n      // [spec] …will have their mode set to \"cors\"…\n      mode: 'cors',\n      redirect: 'follow',\n      headers: {Accept: 'text/event-stream', ...lastEvent},\n      cache: 'no-store',\n      signal: this.#controller?.signal,\n    }\n\n    // Some environments crash if attempting to set `credentials` where it is not supported,\n    // eg on Cloudflare Workers. To avoid this, we only set it in browser-like environments.\n    if ('window' in globalThis) {\n      // [spec] …and their credentials mode set to \"same-origin\"\n      // [spec] …if the `withCredentials` attribute is `true`, set the credentials mode to \"include\"…\n      init.credentials = this.withCredentials ? 'include' : 'same-origin'\n    }\n\n    return init\n  }\n\n  /**\n   * Called by EventSourceParser instance when an event has successfully been parsed\n   * and is ready to be processed.\n   *\n   * @param event - The parsed event\n   * @internal\n   */\n  #onEvent = (event: EventSourceMessage) => {\n    if (typeof event.id === 'string') {\n      this.#lastEventId = event.id\n    }\n\n    const messageEvent = new MessageEvent(event.event || 'message', {\n      data: event.data,\n      origin: this.#redirectUrl ? this.#redirectUrl.origin : this.#url.origin,\n      lastEventId: event.id || '',\n    })\n\n    // The `onmessage` property of the EventSource instance only triggers on messages without an\n    // `event` field, or ones that explicitly set `message`.\n    if (this.#onMessage && (!event.event || event.event === 'message')) {\n      this.#onMessage(messageEvent)\n    }\n\n    this.dispatchEvent(messageEvent)\n  }\n\n  /**\n   * Called by EventSourceParser instance when a new reconnection interval is received\n   * from the EventSource endpoint.\n   *\n   * @param value - The new reconnection interval in milliseconds\n   * @internal\n   */\n  #onRetryChange = (value: number) => {\n    this.#reconnectInterval = value\n  }\n\n  /**\n   * Handles the process referred to in the EventSource specification as \"failing a connection\".\n   *\n   * @param error - The error causing the connection to fail\n   * @param code - The HTTP status code, if available\n   * @internal\n   */\n  #failConnection(message?: string, code?: number) {\n    // [spec] …if the readyState attribute is set to a value other than CLOSED,\n    // [spec] sets the readyState attribute to CLOSED…\n    if (this.#readyState !== this.CLOSED) {\n      this.#readyState = this.CLOSED\n    }\n\n    // [spec] …and fires an event named `error` at the `EventSource` object.\n    // [spec] Once the user agent has failed the connection, it does not attempt to reconnect.\n    // [spec] > Implementations are especially encouraged to report detailed information\n    // [spec] > to their development consoles whenever an error event is fired, since little\n    // [spec] > to no information can be made available in the events themselves.\n    // Printing to console is not very programatically helpful, though, so we emit a custom event.\n    const errorEvent = new ErrorEvent('error', {code, message})\n\n    this.#onError?.(errorEvent)\n    this.dispatchEvent(errorEvent)\n  }\n\n  /**\n   * Schedules a reconnection attempt against the EventSource endpoint.\n   *\n   * @param message - The error causing the connection to fail\n   * @param code - The HTTP status code, if available\n   * @internal\n   */\n  #scheduleReconnect(message?: string, code?: number) {\n    // [spec] If the readyState attribute is set to CLOSED, abort the task.\n    if (this.#readyState === this.CLOSED) {\n      return\n    }\n\n    // [spec] Set the readyState attribute to CONNECTING.\n    this.#readyState = this.CONNECTING\n\n    // [spec] Fire an event named `error` at the EventSource object.\n    const errorEvent = new ErrorEvent('error', {code, message})\n    this.#onError?.(errorEvent)\n    this.dispatchEvent(errorEvent)\n\n    // [spec] Wait a delay equal to the reconnection time of the event source.\n    this.#reconnectTimer = setTimeout(this.#reconnect, this.#reconnectInterval)\n  }\n\n  /**\n   * Reconnects to the EventSource endpoint after a disconnect/failure\n   *\n   * @internal\n   */\n  #reconnect = () => {\n    this.#reconnectTimer = undefined\n\n    // [spec] If the EventSource's readyState attribute is not set to CONNECTING, then return.\n    if (this.#readyState !== this.CONNECTING) {\n      return\n    }\n\n    this.#connect()\n  }\n}\n\n/**\n * According to spec, when constructing a URL:\n * > 1. Let baseURL be environment's base URL, if environment is a Document object\n * > 2. Return the result of applying the URL parser to url, with baseURL.\n *\n * Thus we should use `document.baseURI` if available, since it can be set through a base tag.\n *\n * @returns The base URL, if available - otherwise `undefined`\n * @internal\n */\nfunction getBaseURL(): string | undefined {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const doc = 'document' in globalThis ? (globalThis as any).document : undefined\n  return doc && typeof doc === 'object' && 'baseURI' in doc && typeof doc.baseURI === 'string'\n    ? doc.baseURI\n    : undefined\n}\n",
    "symbols": [
      {
        "name": "EventSource",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
        "startLine": 31,
        "endLine": 578
      },
      {
        "name": "EventSource.addEventListener",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
        "startLine": 147,
        "endLine": 156
      },
      {
        "name": "EventSource.removeEventListener",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
        "startLine": 173,
        "endLine": 182
      },
      {
        "name": "EventSource.close",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
        "startLine": 219,
        "endLine": 225
      },
      {
        "name": "EventSource.#connect",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
        "startLine": 331,
        "endLine": 340
      },
      {
        "name": "EventSource.#getRequestOptions",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
        "startLine": 450,
        "endLine": 472
      },
      {
        "name": "EventSource.#failConnection",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
        "startLine": 519,
        "endLine": 536
      },
      {
        "name": "EventSource.#scheduleReconnect",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
        "startLine": 545,
        "endLine": 561
      },
      {
        "name": "getBaseURL",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource/src/EventSource.ts",
        "startLine": 590,
        "endLine": 596
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/eventsource/src/index.ts",
    "content": "export {ErrorEvent} from './errors.js'\nexport {EventSource} from './EventSource.js'\nexport type * from './types.js'\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/eventsource/src/types.ts",
    "content": "import type {ErrorEvent} from './errors.js'\n\n/**\n * Stripped down version of `fetch()`, only defining the parts we care about.\n * This ensures it should work with \"most\" fetch implementations.\n *\n * @public\n */\nexport type FetchLike = (\n  url: string | URL,\n  init: EventSourceFetchInit,\n) => Promise<FetchLikeResponse>\n\n/**\n * Subset of `RequestInit` used for `fetch()` calls made by the `EventSource` class.\n * As we know that we will be passing certain values, we can be more specific and have\n * users not have to do optional chaining and similar for things that will always be there.\n *\n * @public\n */\nexport interface EventSourceFetchInit {\n  /** An AbortSignal to set request's signal. Typed as `any` because of polyfill inconsistencies. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  signal: {aborted: boolean} | any\n\n  /** A Headers object, an object literal, or an array of two-item arrays to set request's headers. */\n  headers: {\n    [key: string]: string\n    Accept: 'text/event-stream'\n  }\n\n  /** A string to indicate whether the request will use CORS, or will be restricted to same-origin URLs. Sets request's mode. */\n  mode: 'cors' | 'no-cors' | 'same-origin'\n\n  /** A string indicating whether credentials will be sent with the request always, never, or only when sent to a same-origin URL. Sets request's credentials. */\n  credentials?: 'include' | 'omit' | 'same-origin'\n\n  /** Controls how the request is cached. */\n  cache: 'no-store'\n\n  /** A string indicating whether request follows redirects, results in an error upon encountering a redirect, or returns the redirect (in an opaque fashion). Sets request's redirect. */\n  redirect: 'error' | 'follow' | 'manual'\n}\n\n/**\n * @public\n * @deprecated Use `EventSourceFetchInit` instead.\n * This type is only here for backwards compatibility and will be removed in a future version.\n */\nexport type FetchLikeInit = EventSourceFetchInit\n\n/**\n * Stripped down version of `ReadableStreamDefaultReader`, only defining the parts we care about.\n *\n * @public\n */\nexport interface ReaderLike {\n  read(): Promise<{done: false; value: unknown} | {done: true; value?: undefined}>\n  cancel(): Promise<void>\n}\n\n/**\n * Minimal version of the `Response` type returned by `fetch()`.\n *\n * @public\n */\nexport interface FetchLikeResponse {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly body: {getReader(): ReaderLike} | Response['body'] | null\n  readonly url: string\n  readonly status: number\n  readonly redirected: boolean\n  readonly headers: {get(name: string): string | null}\n}\n\n/**\n * Mirrors the official DOM typings, with the exception of the extended ErrorEvent.\n *\n * @public\n */\nexport interface EventSourceEventMap {\n  error: ErrorEvent\n  message: MessageEvent\n  open: Event\n}\n\n/**\n * Mirrors the official DOM typings (for the most part)\n *\n * @public\n */\nexport interface EventSourceInit {\n  /**\n   * A boolean value, defaulting to `false`, indicating if CORS should be set to `include` credentials.\n   */\n  withCredentials?: boolean\n\n  /**\n   * Optional fetch implementation to use. Defaults to `globalThis.fetch`.\n   * Can also be used for advanced use cases like mocking, proxying, custom certs etc.\n   */\n  fetch?: FetchLike\n}\n\n/**\n * Mirrors the official DOM typings (sorta).\n *\n * @public\n */\nexport interface EventListenerOptions {\n  /** Not directly used by Node.js. Added for API completeness. Default: `false`. */\n  capture?: boolean\n}\n\n/**\n * Mirrors the official DOM typings (sorta).\n *\n * @public\n */\nexport interface AddEventListenerOptions extends EventListenerOptions {\n  /** When `true`, the listener is automatically removed when it is first invoked. Default: `false`. */\n  once?: boolean\n  /** When `true`, serves as a hint that the listener will not call the `Event` object's `preventDefault()` method. Default: false. */\n  passive?: boolean\n  /** The listener will be removed when the given AbortSignal object's `abort()` method is called. */\n  signal?: AbortSignal\n}\n\n/**\n * Mirrors the official DOM typings.\n *\n * @public\n */\nexport type EventListenerOrEventListenerObject = EventListener | EventListenerObject\n\n/**\n * Mirrors the official DOM typings.\n *\n * @public\n */\nexport interface EventListener {\n  (evt: Event | MessageEvent): void\n}\n\n/**\n * Mirrors the official DOM typings.\n *\n * @public\n */\nexport interface EventListenerObject {\n  handleEvent(object: Event): void\n}\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/eventsource-parser/src/errors.ts",
    "content": "/**\n * The type of error that occurred.\n * @public\n */\nexport type ErrorType = 'invalid-retry' | 'unknown-field'\n\n/**\n * Error thrown when encountering an issue during parsing.\n *\n * @public\n */\nexport class ParseError extends Error {\n  /**\n   * The type of error that occurred.\n   */\n  type: ErrorType\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the field name.\n   */\n  field?: string | undefined\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the value of the field.\n   */\n  value?: string | undefined\n\n  /**\n   * The line that caused the error, if available.\n   */\n  line?: string | undefined\n\n  constructor(\n    message: string,\n    options: {type: ErrorType; field?: string; value?: string; line?: string},\n  ) {\n    super(message)\n    this.name = 'ParseError'\n    this.type = options.type\n    this.field = options.field\n    this.value = options.value\n    this.line = options.line\n  }\n}\n",
    "symbols": [
      {
        "name": "ParseError",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/errors.ts",
        "startLine": 12,
        "endLine": 44
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/eventsource-parser/src/index.ts",
    "content": "export {type ErrorType, ParseError} from './errors.ts'\nexport {createParser} from './parse.ts'\nexport type {EventSourceMessage, EventSourceParser, ParserCallbacks} from './types.ts'\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
    "content": "/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */\nimport {ParseError} from './errors.ts'\nimport type {EventSourceParser, ParserCallbacks} from './types.ts'\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction noop(_arg: unknown) {\n  // intentional noop\n}\n\n/**\n * Creates a new EventSource parser.\n *\n * @param callbacks - Callbacks to invoke on different parsing events:\n *   - `onEvent` when a new event is parsed\n *   - `onError` when an error occurs\n *   - `onRetry` when a new reconnection interval has been sent from the server\n *   - `onComment` when a comment is encountered in the stream\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(callbacks: ParserCallbacks): EventSourceParser {\n  if (typeof callbacks === 'function') {\n    throw new TypeError(\n      '`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?',\n    )\n  }\n\n  const {onEvent = noop, onError = noop, onRetry = noop, onComment} = callbacks\n\n  let incompleteLine = ''\n\n  let isFirstChunk = true\n  let id: string | undefined\n  let data = ''\n  let eventType = ''\n\n  function feed(newChunk: string) {\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, '') : newChunk\n\n    // If there was a previous incomplete line, append it to the new chunk,\n    // so we may process it together as a new (hopefully complete) chunk.\n    const [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`)\n\n    for (const line of complete) {\n      parseLine(line)\n    }\n\n    incompleteLine = incomplete\n    isFirstChunk = false\n  }\n\n  function parseLine(line: string) {\n    // If the line is empty (a blank line), dispatch the event\n    if (line === '') {\n      dispatchEvent()\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:), ignore the line.\n    if (line.startsWith(':')) {\n      if (onComment) {\n        onComment(line.slice(line.startsWith(': ') ? 2 : 1))\n      }\n      return\n    }\n\n    // If the line contains a U+003A COLON character (:)\n    const fieldSeparatorIndex = line.indexOf(':')\n    if (fieldSeparatorIndex !== -1) {\n      // Collect the characters on the line before the first U+003A COLON character (:),\n      // and let `field` be that string.\n      const field = line.slice(0, fieldSeparatorIndex)\n\n      // Collect the characters on the line after the first U+003A COLON character (:),\n      // and let `value` be that string. If value starts with a U+0020 SPACE character,\n      // remove it from value.\n      const offset = line[fieldSeparatorIndex + 1] === ' ' ? 2 : 1\n      const value = line.slice(fieldSeparatorIndex + offset)\n\n      processField(field, value, line)\n      return\n    }\n\n    // Otherwise, the string is not empty but does not contain a U+003A COLON character (:)\n    // Process the field using the whole line as the field name, and an empty string as the field value.\n    // 👆 This is according to spec. That means that a line that has the value `data` will result in\n    // a newline being added to the current `data` buffer, for instance.\n    processField(line, '', line)\n  }\n\n  function processField(field: string, value: string, line: string) {\n    // Field names must be compared literally, with no case folding performed.\n    switch (field) {\n      case 'event':\n        // Set the `event type` buffer to field value\n        eventType = value\n        break\n      case 'data':\n        // Append the field value to the `data` buffer, then append a single U+000A LINE FEED(LF)\n        // character to the `data` buffer.\n        data = `${data}${value}\\n`\n        break\n      case 'id':\n        // If the field value does not contain U+0000 NULL, then set the `ID` buffer to\n        // the field value. Otherwise, ignore the field.\n        id = value.includes('\\0') ? undefined : value\n        break\n      case 'retry':\n        // If the field value consists of only ASCII digits, then interpret the field value as an\n        // integer in base ten, and set the event stream's reconnection time to that integer.\n        // Otherwise, ignore the field.\n        if (/^\\d+$/.test(value)) {\n          onRetry(parseInt(value, 10))\n        } else {\n          onError(\n            new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n              type: 'invalid-retry',\n              value,\n              line,\n            }),\n          )\n        }\n        break\n      default:\n        // Otherwise, the field is ignored.\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}…` : field}\"`,\n            {type: 'unknown-field', field, value, line},\n          ),\n        )\n        break\n    }\n  }\n\n  function dispatchEvent() {\n    const shouldDispatch = data.length > 0\n    if (shouldDispatch) {\n      onEvent({\n        id,\n        event: eventType || undefined,\n        // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n        // then remove the last character from the data buffer.\n        data: data.endsWith('\\n') ? data.slice(0, -1) : data,\n      })\n    }\n\n    // Reset for the next event\n    id = undefined\n    data = ''\n    eventType = ''\n  }\n\n  function reset(options: {consume?: boolean} = {}) {\n    if (incompleteLine && options.consume) {\n      parseLine(incompleteLine)\n    }\n\n    isFirstChunk = true\n    id = undefined\n    data = ''\n    eventType = ''\n    incompleteLine = ''\n  }\n\n  return {feed, reset}\n}\n\n/**\n * For the given `chunk`, split it into lines according to spec, and return any remaining incomplete line.\n *\n * @param chunk - The chunk to split into lines\n * @returns A tuple containing an array of complete lines, and any remaining incomplete line\n * @internal\n */\nfunction splitLines(chunk: string): [complete: Array<string>, incomplete: string] {\n  /**\n   * According to the spec, a line is terminated by either:\n   * - U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair\n   * - a single U+000A LINE FEED(LF) character not preceded by a U+000D CARRIAGE RETURN(CR) character\n   * - a single U+000D CARRIAGE RETURN(CR) character not followed by a U+000A LINE FEED(LF) character\n   */\n  const lines: Array<string> = []\n  let incompleteLine = ''\n  let searchIndex = 0\n\n  while (searchIndex < chunk.length) {\n    // Find next line terminator\n    const crIndex = chunk.indexOf('\\r', searchIndex)\n    const lfIndex = chunk.indexOf('\\n', searchIndex)\n\n    // Determine line end\n    let lineEnd = -1\n    if (crIndex !== -1 && lfIndex !== -1) {\n      // CRLF case\n      lineEnd = Math.min(crIndex, lfIndex)\n    } else if (crIndex !== -1) {\n      // CR at the end of a chunk might be part of a CRLF sequence that spans chunks,\n      // so we shouldn't treat it as a line terminator (yet)\n      if (crIndex === chunk.length - 1) {\n        lineEnd = -1\n      } else {\n        lineEnd = crIndex\n      }\n    } else if (lfIndex !== -1) {\n      lineEnd = lfIndex\n    }\n\n    // Extract line if terminator found\n    if (lineEnd === -1) {\n      // No terminator found, rest is incomplete\n      incompleteLine = chunk.slice(searchIndex)\n      break\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd)\n      lines.push(line)\n\n      // Move past line terminator\n      searchIndex = lineEnd + 1\n      if (chunk[searchIndex - 1] === '\\r' && chunk[searchIndex] === '\\n') {\n        searchIndex++\n      }\n    }\n  }\n\n  return [lines, incompleteLine]\n}\n",
    "symbols": [
      {
        "name": "noop",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
        "startLine": 9,
        "endLine": 11
      },
      {
        "name": "createParser",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
        "startLine": 25,
        "endLine": 172
      },
      {
        "name": "feed",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
        "startLine": 41,
        "endLine": 55
      },
      {
        "name": "parseLine",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
        "startLine": 57,
        "endLine": 94
      },
      {
        "name": "processField",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
        "startLine": 96,
        "endLine": 139
      },
      {
        "name": "dispatchEvent",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
        "startLine": 141,
        "endLine": 157
      },
      {
        "name": "reset",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
        "startLine": 159,
        "endLine": 169
      },
      {
        "name": "splitLines",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/parse.ts",
        "startLine": 181,
        "endLine": 232
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/eventsource-parser/src/stream.ts",
    "content": "import {createParser} from './parse.ts'\nimport type {EventSourceMessage, EventSourceParser} from './types.ts'\n\n/**\n * Options for the EventSourceParserStream.\n *\n * @public\n */\nexport interface StreamOptions {\n  /**\n   * Behavior when a parsing error occurs.\n   *\n   * - A custom function can be provided to handle the error.\n   * - `'terminate'` will error the stream and stop parsing.\n   * - Any other value will ignore the error and continue parsing.\n   *\n   * @defaultValue `undefined`\n   */\n  onError?: ('terminate' | ((error: Error) => void)) | undefined\n\n  /**\n   * Callback for when a reconnection interval is sent from the server.\n   *\n   * @param retry - The number of milliseconds to wait before reconnecting.\n   */\n  onRetry?: ((retry: number) => void) | undefined\n\n  /**\n   * Callback for when a comment is encountered in the stream.\n   *\n   * @param comment - The comment encountered in the stream.\n   */\n  onComment?: ((comment: string) => void) | undefined\n}\n\n/**\n * A TransformStream that ingests a stream of strings and produces a stream of `EventSourceMessage`.\n *\n * @example Basic usage\n * ```\n * const eventStream =\n *   response.body\n *     .pipeThrough(new TextDecoderStream())\n *     .pipeThrough(new EventSourceParserStream())\n * ```\n *\n * @example Terminate stream on parsing errors\n * ```\n * const eventStream =\n *  response.body\n *   .pipeThrough(new TextDecoderStream())\n *   .pipeThrough(new EventSourceParserStream({terminateOnError: true}))\n * ```\n *\n * @public\n */\nexport class EventSourceParserStream extends TransformStream<string, EventSourceMessage> {\n  constructor({onError, onRetry, onComment}: StreamOptions = {}) {\n    let parser!: EventSourceParser\n\n    super({\n      start(controller) {\n        parser = createParser({\n          onEvent: (event) => {\n            controller.enqueue(event)\n          },\n          onError(error) {\n            if (onError === 'terminate') {\n              controller.error(error)\n            } else if (typeof onError === 'function') {\n              onError(error)\n            }\n\n            // Ignore by default\n          },\n          onRetry,\n          onComment,\n        })\n      },\n      transform(chunk) {\n        parser.feed(chunk)\n      },\n    })\n  }\n}\n\nexport {type ErrorType, ParseError} from './errors.ts'\nexport type {EventSourceMessage} from './types.ts'\n",
    "symbols": [
      {
        "name": "EventSourceParserStream",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/eventsource-parser/src/stream.ts",
        "startLine": 57,
        "endLine": 85
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/eventsource-parser/src/types.ts",
    "content": "import type {ParseError} from './errors.ts'\n\n/**\n * EventSource parser instance.\n *\n * Needs to be reset between reconnections/when switching data source, using the `reset()` method.\n *\n * @public\n */\nexport interface EventSourceParser {\n  /**\n   * Feeds the parser another chunk. The method _does not_ return a parsed message.\n   * Instead, callbacks passed when creating the parser will be triggered once we see enough data\n   * for a valid/invalid parsing step (see {@link ParserCallbacks}).\n   *\n   * @param chunk - The chunk to parse. Can be a partial, eg in the case of streaming messages.\n   * @public\n   */\n  feed(chunk: string): void\n\n  /**\n   * Resets the parser state. This is required when you have a new stream of messages -\n   * for instance in the case of a client being disconnected and reconnecting.\n   *\n   * Previously received, incomplete data will NOT be parsed unless you pass `consume: true`,\n   * which tells the parser to attempt to consume any incomplete data as if it ended with a newline\n   * character. This is useful for cases when a server sends a non-EventSource message that you\n   * want to be able to react to in an `onError` callback.\n   *\n   * @public\n   */\n  reset(options?: {consume?: boolean}): void\n}\n\n/**\n * A parsed EventSource message event\n *\n * @public\n */\nexport interface EventSourceMessage {\n  /**\n   * The event type sent from the server. Note that this differs from the browser `EventSource`\n   * implementation in that browsers will default this to `message`, whereas this parser will\n   * leave this as `undefined` if not explicitly declared.\n   */\n  event?: string | undefined\n\n  /**\n   * ID of the message, if any was provided by the server. Can be used by clients to keep the\n   * last received message ID in sync when reconnecting.\n   */\n  id?: string | undefined\n\n  /**\n   * The data received for this message\n   */\n  data: string\n}\n\n/**\n * Callbacks that can be passed to the parser to handle different types of parsed messages\n * and errors.\n *\n * @public\n */\nexport interface ParserCallbacks {\n  /**\n   * Callback for when a new event/message is parsed from the stream.\n   * This is the main callback that clients will use to handle incoming messages.\n   *\n   * @param event - The parsed event/message\n   */\n  onEvent?: ((event: EventSourceMessage) => void) | undefined\n\n  /**\n   * Callback for when the server sends a new reconnection interval through the `retry` field.\n   *\n   * @param retry - The number of milliseconds to wait before reconnecting.\n   */\n  onRetry?: ((retry: number) => void) | undefined\n\n  /**\n   * Callback for when a comment is encountered in the stream.\n   *\n   * @param comment - The comment encountered in the stream.\n   */\n  onComment?: ((comment: string) => void) | undefined\n\n  /**\n   * Callback for when an error occurs during parsing. This is a catch-all for any errors\n   * that occur during parsing, and can be used to handle them in a custom way. Most clients\n   * tend to silently ignore any errors and instead retry, but it can be helpful to log/debug.\n   *\n   * @param error - The error that occurred during parsing\n   */\n  onError?: ((error: ParseError) => void) | undefined\n}\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/fastq/test/example.ts",
    "content": "import * as fastq from '../'\nimport { promise as queueAsPromised } from '../'\n\n// Basic example\n\nconst queue = fastq(worker, 1)\n\nqueue.push('world', (err, result) => {\n  if (err) throw err\n  console.log('the result is', result)\n})\n\nqueue.push('push without cb')\n\nqueue.concurrency\n\nqueue.drain()\n\nqueue.empty = () => undefined\n\nconsole.log('the queue tasks are', queue.getQueue())\n\nqueue.idle()\n\nqueue.kill()\n\nqueue.killAndDrain()\n\nqueue.length\n\nqueue.pause()\n\nqueue.resume()\n\nqueue.running()\n\nqueue.saturated = () => undefined\n\nqueue.unshift('world', (err, result) => {\n  if (err) throw err\n  console.log('the result is', result)\n})\n\nqueue.unshift('unshift without cb')\n\nfunction worker(task: any, cb: fastq.done) {\n  cb(null, 'hello ' + task)\n}\n\n// Generics example\n\ninterface GenericsContext {\n  base: number;\n}\n\nconst genericsQueue = fastq<GenericsContext, number, string>({ base: 6 }, genericsWorker, 1)\n\ngenericsQueue.push(7, (err, done) => {\n  if (err) throw err\n  console.log('the result is', done)\n})\n\ngenericsQueue.unshift(7, (err, done) => {\n  if (err) throw err\n  console.log('the result is', done)\n})\n\nfunction genericsWorker(this: GenericsContext, task: number, cb: fastq.done<string>) {\n  cb(null, 'the meaning of life is ' + (this.base * task))\n}\n\nconst queue2 = queueAsPromised(asyncWorker, 1)\n\nasync function asyncWorker(task: any) {\n  return 'hello ' + task\n}\n\nasync function run () {\n  await queue.push(42)\n  await queue.unshift(42)\n}\n\nrun()\n",
    "symbols": [
      {
        "name": "worker",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/fastq/test/example.ts",
        "startLine": 46,
        "endLine": 48
      },
      {
        "name": "genericsWorker",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/fastq/test/example.ts",
        "startLine": 68,
        "endLine": 70
      },
      {
        "name": "asyncWorker",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/fastq/test/example.ts",
        "startLine": 74,
        "endLine": 76
      },
      {
        "name": "run",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/fastq/test/example.ts",
        "startLine": 78,
        "endLine": 81
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/minisearch/src/index.ts",
    "content": "import MiniSearch from './MiniSearch'\n\nexport * from './MiniSearch'\nexport default MiniSearch\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
    "content": "import SearchableMap from './SearchableMap/SearchableMap'\n\nexport type LowercaseCombinationOperator = 'or' | 'and' | 'and_not'\nexport type CombinationOperator = LowercaseCombinationOperator | Uppercase<LowercaseCombinationOperator> | Capitalize<LowercaseCombinationOperator>\n\nconst OR: LowercaseCombinationOperator = 'or'\nconst AND: LowercaseCombinationOperator = 'and'\nconst AND_NOT: LowercaseCombinationOperator = 'and_not'\n\n/**\n * Search options to customize the search behavior.\n */\nexport type SearchOptions = {\n  /**\n   * Names of the fields to search in. If omitted, all fields are searched.\n   */\n  fields?: string[],\n\n  /**\n   * Function used to filter search results, for example on the basis of stored\n   * fields. It takes as argument each search result and should return a boolean\n   * to indicate if the result should be kept or not.\n   */\n  filter?: (result: SearchResult) => boolean,\n\n  /**\n   * Key-value object of field names to boosting values. By default, fields are\n   * assigned a boosting factor of 1. If one assigns to a field a boosting value\n   * of 2, a result that matches the query in that field is assigned a score\n   * twice as high as a result matching the query in another field, all else\n   * being equal.\n   */\n  boost?: { [fieldName: string]: number },\n\n  /**\n   * Function to calculate a boost factor for each term.\n   *\n   * This function, if provided, is called for each query term (as split by\n   * `tokenize` and processed by `processTerm`). The arguments passed to the\n   * function are the query term, the positional index of the term in the query,\n   * and the array of all query terms. It is expected to return a numeric boost\n   * factor for the term. A factor lower than 1 reduces the importance of the\n   * term, a factor greater than 1 increases it. A factor of exactly 1 is\n   * neutral, and does not affect the term's importance.\n   */\n  boostTerm?: (term: string, i: number, terms: string[]) => number,\n\n  /**\n   * Relative weights to assign to prefix search results and fuzzy search\n   * results. Exact matches are assigned a weight of 1.\n   */\n  weights?: { fuzzy: number, prefix: number },\n\n  /**\n   * Function to calculate a boost factor for documents. It takes as arguments\n   * the document ID, and a term that matches the search in that document, and\n   * the value of the stored fields for the document (if any).  It should return\n   * a boosting factor: a number higher than 1 increases the computed score, a\n   * number lower than 1 decreases the score, and a falsy value skips the search\n   * result completely.\n   */\n  boostDocument?: (documentId: any, term: string, storedFields?: Record<string, unknown>) => number,\n\n  /**\n   * Controls whether to perform prefix search. It can be a simple boolean, or a\n   * function.\n   *\n   * If a boolean is passed, prefix search is performed if true.\n   *\n   * If a function is passed, it is called upon search with a search term, the\n   * positional index of that search term in the tokenized search query, and the\n   * tokenized search query. The function should return a boolean to indicate\n   * whether to perform prefix search for that search term.\n   */\n  prefix?: boolean | ((term: string, index: number, terms: string[]) => boolean),\n\n  /**\n   * Controls whether to perform fuzzy search. It can be a simple boolean, or a\n   * number, or a function.\n   *\n   * If a boolean is given, fuzzy search with a default fuzziness parameter is\n   * performed if true.\n   *\n   * If a number higher or equal to 1 is given, fuzzy search is performed, with\n   * a maximum edit distance (Levenshtein) equal to the number.\n   *\n   * If a number between 0 and 1 is given, fuzzy search is performed within a\n   * maximum edit distance corresponding to that fraction of the term length,\n   * approximated to the nearest integer. For example, 0.2 would mean an edit\n   * distance of 20% of the term length, so 1 character in a 5-characters term.\n   * The calculated fuzziness value is limited by the `maxFuzzy` option, to\n   * prevent slowdown for very long queries.\n   *\n   * If a function is passed, the function is called upon search with a search\n   * term, a positional index of that term in the tokenized search query, and\n   * the tokenized search query. It should return a boolean or a number, with\n   * the meaning documented above.\n   */\n  fuzzy?: boolean | number | ((term: string, index: number, terms: string[]) => boolean | number),\n\n  /**\n   * Controls the maximum fuzziness when using a fractional fuzzy value. This is\n   * set to 6 by default. Very high edit distances usually don't produce\n   * meaningful results, but can excessively impact search performance.\n   */\n  maxFuzzy?: number,\n\n  /**\n   * The operand to combine partial results for each term. By default it is\n   * \"OR\", so results matching _any_ of the search terms are returned by a\n   * search. If \"AND\" is given, only results matching _all_ the search terms are\n   * returned by a search.\n   */\n  combineWith?: CombinationOperator,\n\n  /**\n   * Function to tokenize the search query. By default, the same tokenizer used\n   * for indexing is used also for search.\n   *\n   * @remarks This function is called after `extractField` extracts a truthy\n   * value from a field. This function is then expected to split the extracted\n   * `text` document into tokens (more commonly referred to as \"terms\" in this\n   * context). The resulting split might be simple, like for example on word\n   * boundaries, or it might be more complex, taking into account certain\n   * encoding, or parsing needs, or even just special cases. Think about how one\n   * might need to go about indexing the term \"short-term\". You would likely\n   * want to treat this case specially, and return two terms instead, `[\n   * \"short\", \"term\" ]`.\n   *\n   * Or, you could let such a case be handled by the `processTerm` function,\n   * which is designed to turn each token/term into whole terms or sub-terms. In\n   * any case, the purpose of this function is to split apart the provided\n   * `text` document into parts that can be processed by the `processTerm`\n   * function.\n   */\n  tokenize?: (text: string) => string[],\n\n  /**\n   * Function to process or normalize terms in the search query. By default, the\n   * same term processor used for indexing is used also for search.\n   *\n   * @remarks\n   * During the document indexing phase, the first step is to call the\n   * `extractField` function to fetch the requested value/field from the\n   * document. This is then passed off to the `tokenize` function, which will\n   * break apart each value into \"terms\". These terms are then individually\n   * passed through this function to compute each term individually. A term\n   * might for example be something like \"lbs\", in which case one would likely\n   * want to return `[ \"lbs\", \"lb\", \"pound\", \"pounds\" ]`. You may also return\n   * just a single string, or a falsy value if you would like to skip indexing\n   * entirely for a specific term.\n   *\n   * Truthy return value(s) are then fed to the indexer as positive matches for\n   * this document. In our example above, all four of the `[ \"lbs\", \"lb\",\n   * \"pound\", \"pounds\" ]` terms would be added to the indexing engine, matching\n   * against the current document being computed.\n   *\n   * *Note: Whatever values are returned from this function will receive no\n   * further processing before being indexed. This means for example, if you\n   * include whitespace at the beginning or end of a word, it will also be\n   * indexed that way, with the included whitespace.*\n   */\n  processTerm?: (term: string) => string | string[] | null | undefined | false\n\n  /**\n   * BM25+ algorithm parameters. Customizing these is almost never necessary,\n   * and finetuning them requires an understanding of the BM25 scoring model. In\n   * most cases, it is best to omit this option to use defaults, and instead use\n   * boosting to tweak scoring for specific use cases.\n   */\n  bm25?: BM25Params\n}\n\ntype SearchOptionsWithDefaults = SearchOptions & {\n  boost: { [fieldName: string]: number },\n\n  weights: { fuzzy: number, prefix: number },\n\n  prefix: boolean | ((term: string, index: number, terms: string[]) => boolean),\n\n  fuzzy: boolean | number | ((term: string, index: number, terms: string[]) => boolean | number),\n\n  maxFuzzy: number,\n\n  combineWith: CombinationOperator\n\n  bm25: BM25Params\n}\n\n/**\n * Configuration options passed to the {@link MiniSearch} constructor\n *\n * @typeParam T  The type of documents being indexed.\n */\nexport type Options<T = any> = {\n   /**\n    * Names of the document fields to be indexed.\n    */\n  fields: string[],\n\n   /**\n    * Name of the ID field, uniquely identifying a document.\n    */\n  idField?: string,\n\n   /**\n    * Names of fields to store, so that search results would include them. By\n    * default none, so results would only contain the id field.\n    */\n  storeFields?: string[],\n\n   /**\n    * Function used to extract the value of each field in documents. By default,\n    * the documents are assumed to be plain objects with field names as keys,\n    * but by specifying a custom `extractField` function one can completely\n    * customize how the fields are extracted.\n    *\n    * The function takes as arguments the document, and the name of the field to\n    * extract from it. It should return the field value as a string.\n    *\n    * @remarks\n    * The returned string is fed into the `tokenize` function to split it up\n    * into tokens.\n    */\n  extractField?: (document: T, fieldName: string) => any,\n\n  /**\n   * Function used to turn field values into strings for indexing\n   *\n   * The function takes as arguments the field value, and the name of the field\n   * to stringify, so that its logic can be customized on specific fields. By\n   * default, it simply calls `toString()` on the field value (which in many\n   * cases is already a string).\n   *\n   * ### Example:\n   *\n   * ```javascript\n   * // Custom stringifier that formats dates as \"Tuesday, September 16, 2025\"\n   * const miniSearch = new MiniSearch({\n   *   fields: ['title', 'date'],\n   *   stringifyField: ((fieldValue, _fieldName) => {\n   *     if (fieldValue instanceof Date) {\n   *       return fieldValue.toLocaleDateString('en-US', {\n   *         weekday: 'long',\n   *         year: 'numeric',\n   *         month: 'long',\n   *         day: 'numeric'\n   *       })\n   *     } else {\n   *      return fieldValue.toString()\n   *     }\n   *   }\n   * })\n   * ```\n   */\n  stringifyField?: (fieldValue: any, fieldName: string) => string,\n\n   /**\n    * Function used to split a field value into individual terms to be indexed.\n    * The default tokenizer separates terms by space or punctuation, but a\n    * custom tokenizer can be provided for custom logic.\n    *\n    * The function takes as arguments string to tokenize, and the name of the\n    * field it comes from. It should return the terms as an array of strings.\n    * When used for tokenizing a search query instead of a document field, the\n    * `fieldName` is undefined.\n    *\n    * @remarks\n    * This function is called after `extractField` extracts a truthy value from a\n    * field. This function is then expected to split the extracted `text` document\n    * into tokens (more commonly referred to as \"terms\" in this context). The resulting\n    * split might be simple, like for example on word boundaries, or it might be more\n    * complex, taking into account certain encoding, or parsing needs, or even just\n    * special cases. Think about how one might need to go about indexing the term\n    * \"short-term\". You would likely want to treat this case specially, and return two\n    * terms instead, `[ \"short\", \"term\" ]`.\n    *\n    * Or, you could let such a case be handled by the `processTerm` function,\n    * which is designed to turn each token/term into whole terms or sub-terms. In any\n    * case, the purpose of this function is to split apart the provided `text` document\n    * into parts that can be processed by the `processTerm` function.\n    */\n  tokenize?: (text: string, fieldName?: string) => string[],\n\n   /**\n    * Function used to process a term before indexing or search. This can be\n    * used for normalization (such as stemming). By default, terms are\n    * downcased, and otherwise no other normalization is performed.\n    *\n    * The function takes as arguments a term to process, and the name of the\n    * field it comes from. It should return the processed term as a string, or a\n    * falsy value to reject the term entirely.\n    *\n    * It can also return an array of strings, in which case each string in the\n    * returned array is indexed as a separate term.\n    *\n    * @remarks\n    * During the document indexing phase, the first step is to call the `extractField`\n    * function to fetch the requested value/field from the document. This is then\n    * passed off to the `tokenizer`, which will break apart each value into \"terms\".\n    * These terms are then individually passed through the `processTerm` function\n    * to compute each term individually. A term might for example be something\n    * like \"lbs\", in which case one would likely want to return\n    * `[ \"lbs\", \"lb\", \"pound\", \"pounds\" ]`. You may also return a single string value,\n    * or a falsy value if you would like to skip indexing entirely for a specific term.\n    *\n    * Truthy return value(s) are then fed to the indexer as positive matches for this\n    * document. In our example above, all four of the `[ \"lbs\", \"lb\", \"pound\", \"pounds\" ]`\n    * terms would be added to the indexing engine, matching against the current document\n    * being computed.\n    *\n    * *Note: Whatever values are returned from this function will receive no further\n    * processing before being indexed. This means for example, if you include whitespace\n    * at the beginning or end of a word, it will also be indexed that way, with the\n    * included whitespace.*\n    */\n  processTerm?: (term: string, fieldName?: string) => string | string[] | null | undefined | false,\n\n  /**\n   * Function called to log messages. Arguments are a log level ('debug',\n   * 'info', 'warn', or 'error'), a log message, and an optional string code\n   * that identifies the reason for the log.\n   *\n   * The default implementation uses `console`, if defined.\n   */\n  logger?: (level: LogLevel, message: string, code?: string) => void\n\n  /**\n   * If `true` (the default), vacuuming is performed automatically as soon as\n   * {@link MiniSearch#discard} is called a certain number of times, cleaning up\n   * obsolete references from the index. If `false`, no automatic vacuuming is\n   * performed. Custom settings controlling auto vacuuming thresholds, as well\n   * as batching behavior, can be passed as an object (see the {@link\n   * AutoVacuumOptions} type).\n   */\n  autoVacuum?: boolean | AutoVacuumOptions\n\n   /**\n    * Default search options (see the {@link SearchOptions} type and the {@link\n    * MiniSearch#search} method for details)\n    */\n  searchOptions?: SearchOptions,\n\n   /**\n    * Default auto suggest options (see the {@link SearchOptions} type and the\n    * {@link MiniSearch#autoSuggest} method for details)\n    */\n  autoSuggestOptions?: SearchOptions\n}\n\ntype OptionsWithDefaults<T = any> = Options<T> & {\n  storeFields: string[]\n\n  idField: string\n\n  extractField: (document: T, fieldName: string) => any\n\n  stringifyField: (fieldValue: any, fieldName: string) => string\n\n  tokenize: (text: string, fieldName: string) => string[]\n\n  processTerm: (term: string, fieldName: string) => string | string[] | null | undefined | false\n\n  logger: (level: LogLevel, message: string, code?: string) => void\n\n  autoVacuum: false | AutoVacuumOptions\n\n  searchOptions: SearchOptionsWithDefaults\n\n  autoSuggestOptions: SearchOptions\n}\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error'\n\n/**\n * The type of auto-suggestions\n */\nexport type Suggestion = {\n  /**\n   * The suggestion\n   */\n  suggestion: string,\n\n  /**\n   * Suggestion as an array of terms\n   */\n  terms: string[],\n\n  /**\n   * Score for the suggestion\n   */\n  score: number\n}\n\n/**\n * Match information for a search result. It is a key-value object where keys\n * are terms that matched, and values are the list of fields that the term was\n * found in.\n */\nexport type MatchInfo = {\n  [term: string]: string[]\n}\n\n/**\n * Type of the search results. Each search result indicates the document ID, the\n * terms that matched, the match information, the score, and all the stored\n * fields.\n */\nexport type SearchResult = {\n  /**\n   * The document ID\n   */\n  id: any,\n\n  /**\n   * List of document terms that matched. For example, if a prefix search for\n   * `\"moto\"` matches `\"motorcycle\"`, `terms` will contain `\"motorcycle\"`.\n   */\n  terms: string[],\n\n  /**\n   * List of query terms that matched. For example, if a prefix search for\n   * `\"moto\"` matches `\"motorcycle\"`, `queryTerms` will contain `\"moto\"`.\n   */\n  queryTerms: string[],\n\n  /**\n   * Score of the search results\n   */\n  score: number,\n\n  /**\n   * Match information, see {@link MatchInfo}\n   */\n  match: MatchInfo,\n\n  /**\n   * Stored fields\n   */\n  [key: string]: any\n}\n\n/**\n * @ignore\n */\nexport type AsPlainObject = {\n  documentCount: number,\n  nextId: number,\n  documentIds: { [shortId: string]: any }\n  fieldIds: { [fieldName: string]: number }\n  fieldLength: { [shortId: string]: number[] }\n  averageFieldLength: number[],\n  storedFields: { [shortId: string]: any }\n  dirtCount?: number,\n  index: [string, { [fieldId: string]: SerializedIndexEntry }][]\n  serializationVersion: number\n}\n\nexport type QueryCombination = SearchOptions & { queries: Query[] }\n\n/**\n * Wildcard query, used to match all terms\n */\nexport type Wildcard = typeof MiniSearch.wildcard\n\n/**\n * Search query expression, either a query string or an expression tree\n * combining several queries with a combination of AND or OR.\n */\nexport type Query = QueryCombination | string | Wildcard\n\n/**\n * Options to control vacuuming behavior.\n *\n * Vacuuming cleans up document references made obsolete by {@link\n * MiniSearch.discard} from the index. On large indexes, vacuuming is\n * potentially costly, because it has to traverse the whole inverted index.\n * Therefore, in order to dilute this cost so it does not negatively affects the\n * application, vacuuming is performed in batches, with a delay between each\n * batch. These options are used to configure the batch size and the delay\n * between batches.\n */\nexport type VacuumOptions = {\n  /**\n   * Size of each vacuuming batch (the number of terms in the index that will be\n   * traversed in each batch). Defaults to 1000.\n   */\n  batchSize?: number,\n\n  /**\n   * Wait time between each vacuuming batch in milliseconds. Defaults to 10.\n   */\n  batchWait?: number\n}\n\n/**\n * Sets minimum thresholds for `dirtCount` and `dirtFactor` that trigger an\n * automatic vacuuming.\n */\nexport type VacuumConditions = {\n  /**\n   * Minimum `dirtCount` (number of discarded documents since the last vacuuming)\n   * under which auto vacuum is not triggered. It defaults to 20.\n   */\n  minDirtCount?: number\n\n  /**\n   * Minimum `dirtFactor` (proportion of discarded documents over the total)\n   * under which auto vacuum is not triggered. It defaults to 0.1.\n   */\n  minDirtFactor?: number,\n}\n\n/**\n * Options to control auto vacuum behavior. When discarding a document with\n * {@link MiniSearch#discard}, a vacuuming operation is automatically started if\n * the `dirtCount` and `dirtFactor` are above the `minDirtCount` and\n * `minDirtFactor` thresholds defined by this configuration. See {@link\n * VacuumConditions} for details on these.\n *\n * Also, `batchSize` and `batchWait` can be specified, controlling batching\n * behavior (see {@link VacuumOptions}).\n */\nexport type AutoVacuumOptions = VacuumOptions & VacuumConditions\n\ntype QuerySpec = {\n  prefix: boolean,\n  fuzzy: number | boolean,\n  term: string,\n  termBoost: number\n}\n\ntype DocumentTermFreqs = Map<number, number>\ntype FieldTermData = Map<number, DocumentTermFreqs>\n\ninterface RawResultValue {\n  // Intermediate score, before applying the final score based on number of\n  // matched terms.\n  score: number,\n\n  // Set of all query terms that were matched. They may not be present in the\n  // text exactly in the case of prefix/fuzzy matches. We must check for\n  // uniqueness before adding a new term. This is much faster than using a set,\n  // because the number of elements is relatively small.\n  terms: string[],\n\n  // All terms that were found in the content, including the fields in which\n  // they were present. This object will be provided as part of the final search\n  // results.\n  match: MatchInfo,\n}\n\ntype RawResult = Map<number, RawResultValue>\n\n/**\n * {@link MiniSearch} is the main entrypoint class, implementing a full-text\n * search engine in memory.\n *\n * @typeParam T  The type of the documents being indexed.\n *\n * ### Basic example:\n *\n * ```javascript\n * const documents = [\n *   {\n *     id: 1,\n *     title: 'Moby Dick',\n *     text: 'Call me Ishmael. Some years ago...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 2,\n *     title: 'Zen and the Art of Motorcycle Maintenance',\n *     text: 'I can see by my watch...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 3,\n *     title: 'Neuromancer',\n *     text: 'The sky above the port was...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 4,\n *     title: 'Zen and the Art of Archery',\n *     text: 'At first sight it must seem...',\n *     category: 'non-fiction'\n *   },\n *   // ...and more\n * ]\n *\n * // Create a search engine that indexes the 'title' and 'text' fields for\n * // full-text search. Search results will include 'title' and 'category' (plus the\n * // id field, that is always stored and returned)\n * const miniSearch = new MiniSearch({\n *   fields: ['title', 'text'],\n *   storeFields: ['title', 'category']\n * })\n *\n * // Add documents to the index\n * miniSearch.addAll(documents)\n *\n * // Search for documents:\n * let results = miniSearch.search('zen art motorcycle')\n * // => [\n * //   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },\n * //   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }\n * // ]\n * ```\n */\nexport default class MiniSearch<T = any> {\n  protected _options: OptionsWithDefaults<T>\n  protected _index: SearchableMap<FieldTermData>\n  protected _documentCount: number\n  protected _documentIds: Map<number, any>\n  protected _idToShortId: Map<any, number>\n  protected _fieldIds: { [key: string]: number }\n  protected _fieldLength: Map<number, number[]>\n  protected _avgFieldLength: number[]\n  protected _nextId: number\n  protected _storedFields: Map<number, Record<string, unknown>>\n  protected _dirtCount: number\n  private _currentVacuum: Promise<void> | null\n  private _enqueuedVacuum: Promise<void> | null\n  private _enqueuedVacuumConditions: VacuumConditions | undefined\n\n  /**\n   * The special wildcard symbol that can be passed to {@link MiniSearch#search}\n   * to match all documents\n   */\n  static readonly wildcard: unique symbol = Symbol('*')\n\n  /**\n   * @param options  Configuration options\n   *\n   * ### Examples:\n   *\n   * ```javascript\n   * // Create a search engine that indexes the 'title' and 'text' fields of your\n   * // documents:\n   * const miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * ```\n   *\n   * ### ID Field:\n   *\n   * ```javascript\n   * // Your documents are assumed to include a unique 'id' field, but if you want\n   * // to use a different field for document identification, you can set the\n   * // 'idField' option:\n   * const miniSearch = new MiniSearch({ idField: 'key', fields: ['title', 'text'] })\n   * ```\n   *\n   * ### Options and defaults:\n   *\n   * ```javascript\n   * // The full set of options (here with their default value) is:\n   * const miniSearch = new MiniSearch({\n   *   // idField: field that uniquely identifies a document\n   *   idField: 'id',\n   *\n   *   // extractField: function used to get the value of a field in a document.\n   *   // By default, it assumes the document is a flat object with field names as\n   *   // property keys and field values as string property values, but custom logic\n   *   // can be implemented by setting this option to a custom extractor function.\n   *   extractField: (document, fieldName) => document[fieldName],\n   *\n   *   // tokenize: function used to split fields into individual terms. By\n   *   // default, it is also used to tokenize search queries, unless a specific\n   *   // `tokenize` search option is supplied. When tokenizing an indexed field,\n   *   // the field name is passed as the second argument.\n   *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n   *\n   *   // processTerm: function used to process each tokenized term before\n   *   // indexing. It can be used for stemming and normalization. Return a falsy\n   *   // value in order to discard a term. By default, it is also used to process\n   *   // search queries, unless a specific `processTerm` option is supplied as a\n   *   // search option. When processing a term from a indexed field, the field\n   *   // name is passed as the second argument.\n   *   processTerm: (term, _fieldName) => term.toLowerCase(),\n   *\n   *   // searchOptions: default search options, see the `search` method for\n   *   // details\n   *   searchOptions: undefined,\n   *\n   *   // fields: document fields to be indexed. Mandatory, but not set by default\n   *   fields: undefined\n   *\n   *   // storeFields: document fields to be stored and returned as part of the\n   *   // search results.\n   *   storeFields: []\n   * })\n   * ```\n   */\n  constructor (options: Options<T>) {\n    if (options?.fields == null) {\n      throw new Error('MiniSearch: option \"fields\" must be provided')\n    }\n\n    const autoVacuum = (options.autoVacuum == null || options.autoVacuum === true) ? defaultAutoVacuumOptions : options.autoVacuum\n\n    this._options = {\n      ...defaultOptions,\n      ...options,\n      autoVacuum,\n      searchOptions: { ...defaultSearchOptions, ...(options.searchOptions || {}) },\n      autoSuggestOptions: { ...defaultAutoSuggestOptions, ...(options.autoSuggestOptions || {}) }\n    }\n\n    this._index = new SearchableMap()\n\n    this._documentCount = 0\n\n    this._documentIds = new Map()\n\n    this._idToShortId = new Map()\n\n    // Fields are defined during initialization, don't change, are few in\n    // number, rarely need iterating over, and have string keys. Therefore in\n    // this case an object is a better candidate than a Map to store the mapping\n    // from field key to ID.\n    this._fieldIds = {}\n\n    this._fieldLength = new Map()\n\n    this._avgFieldLength = []\n\n    this._nextId = 0\n\n    this._storedFields = new Map()\n\n    this._dirtCount = 0\n\n    this._currentVacuum = null\n\n    this._enqueuedVacuum = null\n    this._enqueuedVacuumConditions = defaultVacuumConditions\n\n    this.addFields(this._options.fields)\n  }\n\n  /**\n   * Adds a document to the index\n   *\n   * @param document  The document to be indexed\n   */\n  add (document: T): void {\n    const { extractField, stringifyField, tokenize, processTerm, fields, idField } = this._options\n    const id = extractField(document, idField)\n    if (id == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n\n    if (this._idToShortId.has(id)) {\n      throw new Error(`MiniSearch: duplicate ID ${id}`)\n    }\n\n    const shortDocumentId = this.addDocumentId(id)\n    this.saveStoredFields(shortDocumentId, document)\n\n    for (const field of fields) {\n      const fieldValue = extractField(document, field)\n      if (fieldValue == null) continue\n\n      const tokens = tokenize(stringifyField(fieldValue, field), field)\n      const fieldId = this._fieldIds[field]\n\n      const uniqueTerms = new Set(tokens).size\n      this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms)\n\n      for (const term of tokens) {\n        const processedTerm = processTerm(term, field)\n        if (Array.isArray(processedTerm)) {\n          for (const t of processedTerm) {\n            this.addTerm(fieldId, shortDocumentId, t)\n          }\n        } else if (processedTerm) {\n          this.addTerm(fieldId, shortDocumentId, processedTerm)\n        }\n      }\n    }\n  }\n\n  /**\n   * Adds all the given documents to the index\n   *\n   * @param documents  An array of documents to be indexed\n   */\n  addAll (documents: readonly T[]): void {\n    for (const document of documents) this.add(document)\n  }\n\n  /**\n   * Adds all the given documents to the index asynchronously.\n   *\n   * Returns a promise that resolves (to `undefined`) when the indexing is done.\n   * This method is useful when index many documents, to avoid blocking the main\n   * thread. The indexing is performed asynchronously and in chunks.\n   *\n   * @param documents  An array of documents to be indexed\n   * @param options  Configuration options\n   * @return A promise resolving to `undefined` when the indexing is done\n   */\n  addAllAsync (documents: readonly T[], options: { chunkSize?: number } = {}): Promise<void> {\n    const { chunkSize = 10 } = options\n    const acc: { chunk: T[], promise: Promise<void> } = { chunk: [], promise: Promise.resolve() }\n\n    const { chunk, promise } = documents.reduce(({ chunk, promise }, document: T, i: number) => {\n      chunk.push(document)\n      if ((i + 1) % chunkSize === 0) {\n        return {\n          chunk: [],\n          promise: promise\n            .then(() => new Promise(resolve => setTimeout(resolve, 0)))\n            .then(() => this.addAll(chunk))\n        }\n      } else {\n        return { chunk, promise }\n      }\n    }, acc)\n\n    return promise.then(() => this.addAll(chunk))\n  }\n\n  /**\n   * Removes the given document from the index.\n   *\n   * The document to remove must NOT have changed between indexing and removal,\n   * otherwise the index will be corrupted.\n   *\n   * This method requires passing the full document to be removed (not just the\n   * ID), and immediately removes the document from the inverted index, allowing\n   * memory to be released. A convenient alternative is {@link\n   * MiniSearch#discard}, which needs only the document ID, and has the same\n   * visible effect, but delays cleaning up the index until the next vacuuming.\n   *\n   * @param document  The document to be removed\n   */\n  remove (document: T): void {\n    const { tokenize, processTerm, extractField, stringifyField, fields, idField } = this._options\n    const id = extractField(document, idField)\n\n    if (id == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) {\n      throw new Error(`MiniSearch: cannot remove document with ID ${id}: it is not in the index`)\n    }\n\n    for (const field of fields) {\n      const fieldValue = extractField(document, field)\n      if (fieldValue == null) continue\n\n      const tokens = tokenize(stringifyField(fieldValue, field), field)\n      const fieldId = this._fieldIds[field]\n\n      const uniqueTerms = new Set(tokens).size\n      this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms)\n\n      for (const term of tokens) {\n        const processedTerm = processTerm(term, field)\n        if (Array.isArray(processedTerm)) {\n          for (const t of processedTerm) {\n            this.removeTerm(fieldId, shortId, t)\n          }\n        } else if (processedTerm) {\n          this.removeTerm(fieldId, shortId, processedTerm)\n        }\n      }\n    }\n\n    this._storedFields.delete(shortId)\n    this._documentIds.delete(shortId)\n    this._idToShortId.delete(id)\n    this._fieldLength.delete(shortId)\n    this._documentCount -= 1\n  }\n\n  /**\n   * Removes all the given documents from the index. If called with no arguments,\n   * it removes _all_ documents from the index.\n   *\n   * @param documents  The documents to be removed. If this argument is omitted,\n   * all documents are removed. Note that, for removing all documents, it is\n   * more efficient to call this method with no arguments than to pass all\n   * documents.\n   */\n  removeAll (documents?: readonly T[]): void {\n    if (documents) {\n      for (const document of documents) this.remove(document)\n    } else if (arguments.length > 0) {\n      throw new Error('Expected documents to be present. Omit the argument to remove all documents.')\n    } else {\n      this._index = new SearchableMap()\n      this._documentCount = 0\n      this._documentIds = new Map()\n      this._idToShortId = new Map()\n      this._fieldLength = new Map()\n      this._avgFieldLength = []\n      this._storedFields = new Map()\n      this._nextId = 0\n    }\n  }\n\n  /**\n   * Discards the document with the given ID, so it won't appear in search results\n   *\n   * It has the same visible effect of {@link MiniSearch.remove} (both cause the\n   * document to stop appearing in searches), but a different effect on the\n   * internal data structures:\n   *\n   *   - {@link MiniSearch#remove} requires passing the full document to be\n   *   removed as argument, and removes it from the inverted index immediately.\n   *\n   *   - {@link MiniSearch#discard} instead only needs the document ID, and\n   *   works by marking the current version of the document as discarded, so it\n   *   is immediately ignored by searches. This is faster and more convenient\n   *   than {@link MiniSearch#remove}, but the index is not immediately\n   *   modified. To take care of that, vacuuming is performed after a certain\n   *   number of documents are discarded, cleaning up the index and allowing\n   *   memory to be released.\n   *\n   * After discarding a document, it is possible to re-add a new version, and\n   * only the new version will appear in searches. In other words, discarding\n   * and re-adding a document works exactly like removing and re-adding it. The\n   * {@link MiniSearch.replace} method can also be used to replace a document\n   * with a new version.\n   *\n   * #### Details about vacuuming\n   *\n   * Repetite calls to this method would leave obsolete document references in\n   * the index, invisible to searches. Two mechanisms take care of cleaning up:\n   * clean up during search, and vacuuming.\n   *\n   *   - Upon search, whenever a discarded ID is found (and ignored for the\n   *   results), references to the discarded document are removed from the\n   *   inverted index entries for the search terms. This ensures that subsequent\n   *   searches for the same terms do not need to skip these obsolete references\n   *   again.\n   *\n   *   - In addition, vacuuming is performed automatically by default (see the\n   *   `autoVacuum` field in {@link Options}) after a certain number of\n   *   documents are discarded. Vacuuming traverses all terms in the index,\n   *   cleaning up all references to discarded documents. Vacuuming can also be\n   *   triggered manually by calling {@link MiniSearch#vacuum}.\n   *\n   * @param id  The ID of the document to be discarded\n   */\n  discard (id: any): void {\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) {\n      throw new Error(`MiniSearch: cannot discard document with ID ${id}: it is not in the index`)\n    }\n\n    this._idToShortId.delete(id)\n    this._documentIds.delete(shortId)\n    this._storedFields.delete(shortId)\n\n    ;(this._fieldLength.get(shortId) || []).forEach((fieldLength, fieldId) => {\n      this.removeFieldLength(shortId, fieldId, this._documentCount, fieldLength)\n    })\n\n    this._fieldLength.delete(shortId)\n\n    this._documentCount -= 1\n    this._dirtCount += 1\n\n    this.maybeAutoVacuum()\n  }\n\n  private maybeAutoVacuum (): void {\n    if (this._options.autoVacuum === false) { return }\n\n    const { minDirtFactor, minDirtCount, batchSize, batchWait } = this._options.autoVacuum\n    this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor })\n  }\n\n  /**\n   * Discards the documents with the given IDs, so they won't appear in search\n   * results\n   *\n   * It is equivalent to calling {@link MiniSearch#discard} for all the given\n   * IDs, but with the optimization of triggering at most one automatic\n   * vacuuming at the end.\n   *\n   * Note: to remove all documents from the index, it is faster and more\n   * convenient to call {@link MiniSearch.removeAll} with no argument, instead\n   * of passing all IDs to this method.\n   */\n  discardAll (ids: readonly any[]): void {\n    const autoVacuum = this._options.autoVacuum\n\n    try {\n      this._options.autoVacuum = false\n\n      for (const id of ids) {\n        this.discard(id)\n      }\n    } finally {\n      this._options.autoVacuum = autoVacuum\n    }\n\n    this.maybeAutoVacuum()\n  }\n\n  /**\n   * It replaces an existing document with the given updated version\n   *\n   * It works by discarding the current version and adding the updated one, so\n   * it is functionally equivalent to calling {@link MiniSearch#discard}\n   * followed by {@link MiniSearch#add}. The ID of the updated document should\n   * be the same as the original one.\n   *\n   * Since it uses {@link MiniSearch#discard} internally, this method relies on\n   * vacuuming to clean up obsolete document references from the index, allowing\n   * memory to be released (see {@link MiniSearch#discard}).\n   *\n   * @param updatedDocument  The updated document to replace the old version\n   * with\n   */\n  replace (updatedDocument: T): void {\n    const { idField, extractField } = this._options\n    const id = extractField(updatedDocument, idField)\n\n    this.discard(id)\n    this.add(updatedDocument)\n  }\n\n  /**\n   * Triggers a manual vacuuming, cleaning up references to discarded documents\n   * from the inverted index\n   *\n   * Vacuuming is only useful for applications that use the {@link\n   * MiniSearch#discard} or {@link MiniSearch#replace} methods.\n   *\n   * By default, vacuuming is performed automatically when needed (controlled by\n   * the `autoVacuum` field in {@link Options}), so there is usually no need to\n   * call this method, unless one wants to make sure to perform vacuuming at a\n   * specific moment.\n   *\n   * Vacuuming traverses all terms in the inverted index in batches, and cleans\n   * up references to discarded documents from the posting list, allowing memory\n   * to be released.\n   *\n   * The method takes an optional object as argument with the following keys:\n   *\n   *   - `batchSize`: the size of each batch (1000 by default)\n   *\n   *   - `batchWait`: the number of milliseconds to wait between batches (10 by\n   *   default)\n   *\n   * On large indexes, vacuuming could have a non-negligible cost: batching\n   * avoids blocking the thread for long, diluting this cost so that it is not\n   * negatively affecting the application. Nonetheless, this method should only\n   * be called when necessary, and relying on automatic vacuuming is usually\n   * better.\n   *\n   * It returns a promise that resolves (to undefined) when the clean up is\n   * completed. If vacuuming is already ongoing at the time this method is\n   * called, a new one is enqueued immediately after the ongoing one, and a\n   * corresponding promise is returned. However, no more than one vacuuming is\n   * enqueued on top of the ongoing one, even if this method is called more\n   * times (enqueuing multiple ones would be useless).\n   *\n   * @param options  Configuration options for the batch size and delay. See\n   * {@link VacuumOptions}.\n   */\n  vacuum (options: VacuumOptions = {}): Promise<void> {\n    return this.conditionalVacuum(options)\n  }\n\n  private conditionalVacuum (options: VacuumOptions, conditions?: VacuumConditions): Promise<void> {\n    // If a vacuum is already ongoing, schedule another as soon as it finishes,\n    // unless there's already one enqueued. If one was already enqueued, do not\n    // enqueue another on top, but make sure that the conditions are the\n    // broadest.\n    if (this._currentVacuum) {\n      this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions\n      if (this._enqueuedVacuum != null) { return this._enqueuedVacuum }\n\n      this._enqueuedVacuum = this._currentVacuum.then(() => {\n        const conditions = this._enqueuedVacuumConditions\n        this._enqueuedVacuumConditions = defaultVacuumConditions\n        return this.performVacuuming(options, conditions)\n      })\n      return this._enqueuedVacuum\n    }\n\n    if (this.vacuumConditionsMet(conditions) === false) { return Promise.resolve() }\n\n    this._currentVacuum = this.performVacuuming(options)\n    return this._currentVacuum\n  }\n\n  private async performVacuuming (options: VacuumOptions, conditions?: VacuumConditions): Promise<void> {\n    const initialDirtCount = this._dirtCount\n\n    if (this.vacuumConditionsMet(conditions)) {\n      const batchSize = options.batchSize || defaultVacuumOptions.batchSize\n      const batchWait = options.batchWait || defaultVacuumOptions.batchWait\n      let i = 1\n\n      for (const [term, fieldsData] of this._index) {\n        for (const [fieldId, fieldIndex] of fieldsData) {\n          for (const [shortId] of fieldIndex) {\n            if (this._documentIds.has(shortId)) { continue }\n\n            if (fieldIndex.size <= 1) {\n              fieldsData.delete(fieldId)\n            } else {\n              fieldIndex.delete(shortId)\n            }\n          }\n        }\n\n        if (this._index.get(term)!.size === 0) {\n          this._index.delete(term)\n        }\n\n        if (i % batchSize === 0) {\n          await new Promise((resolve) => setTimeout(resolve, batchWait))\n        }\n\n        i += 1\n      }\n\n      this._dirtCount -= initialDirtCount\n    }\n\n    // Make the next lines always async, so they execute after this function returns\n    await null\n\n    this._currentVacuum = this._enqueuedVacuum\n    this._enqueuedVacuum = null\n  }\n\n  private vacuumConditionsMet (conditions?: VacuumConditions) {\n    if (conditions == null) { return true }\n\n    let { minDirtCount, minDirtFactor } = conditions\n    minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount\n    minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor\n\n    return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor\n  }\n\n  /**\n   * Is `true` if a vacuuming operation is ongoing, `false` otherwise\n   */\n  get isVacuuming (): boolean {\n    return this._currentVacuum != null\n  }\n\n  /**\n   * The number of documents discarded since the most recent vacuuming\n   */\n  get dirtCount (): number {\n    return this._dirtCount\n  }\n\n  /**\n   * A number between 0 and 1 giving an indication about the proportion of\n   * documents that are discarded, and can therefore be cleaned up by vacuuming.\n   * A value close to 0 means that the index is relatively clean, while a higher\n   * value means that the index is relatively dirty, and vacuuming could release\n   * memory.\n   */\n  get dirtFactor (): number {\n    return this._dirtCount / (1 + this._documentCount + this._dirtCount)\n  }\n\n  /**\n   * Returns `true` if a document with the given ID is present in the index and\n   * available for search, `false` otherwise\n   *\n   * @param id  The document ID\n   */\n  has (id: any): boolean {\n    return this._idToShortId.has(id)\n  }\n\n  /**\n   * Returns the stored fields (as configured in the `storeFields` constructor\n   * option) for the given document ID. Returns `undefined` if the document is\n   * not present in the index.\n   *\n   * @param id  The document ID\n   */\n  getStoredFields (id: any): Record<string, unknown> | undefined {\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) { return undefined }\n\n    return this._storedFields.get(shortId)\n  }\n\n  /**\n   * Search for documents matching the given search query.\n   *\n   * The result is a list of scored document IDs matching the query, sorted by\n   * descending score, and each including data about which terms were matched and\n   * in which fields.\n   *\n   * ### Basic usage:\n   *\n   * ```javascript\n   * // Search for \"zen art motorcycle\" with default options: terms have to match\n   * // exactly, and individual terms are joined with OR\n   * miniSearch.search('zen art motorcycle')\n   * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]\n   * ```\n   *\n   * ### Restrict search to specific fields:\n   *\n   * ```javascript\n   * // Search only in the 'title' field\n   * miniSearch.search('zen', { fields: ['title'] })\n   * ```\n   *\n   * ### Field boosting:\n   *\n   * ```javascript\n   * // Boost a field\n   * miniSearch.search('zen', { boost: { title: 2 } })\n   * ```\n   *\n   * ### Prefix search:\n   *\n   * ```javascript\n   * // Search for \"moto\" with prefix search (it will match documents\n   * // containing terms that start with \"moto\" or \"neuro\")\n   * miniSearch.search('moto neuro', { prefix: true })\n   * ```\n   *\n   * ### Fuzzy search:\n   *\n   * ```javascript\n   * // Search for \"ismael\" with fuzzy search (it will match documents containing\n   * // terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n   * // (rounded to nearest integer)\n   * miniSearch.search('ismael', { fuzzy: 0.2 })\n   * ```\n   *\n   * ### Combining strategies:\n   *\n   * ```javascript\n   * // Mix of exact match, prefix search, and fuzzy search\n   * miniSearch.search('ismael mob', {\n   *  prefix: true,\n   *  fuzzy: 0.2\n   * })\n   * ```\n   *\n   * ### Advanced prefix and fuzzy search:\n   *\n   * ```javascript\n   * // Perform fuzzy and prefix search depending on the search term. Here\n   * // performing prefix and fuzzy search only on terms longer than 3 characters\n   * miniSearch.search('ismael mob', {\n   *  prefix: term => term.length > 3\n   *  fuzzy: term => term.length > 3 ? 0.2 : null\n   * })\n   * ```\n   *\n   * ### Combine with AND:\n   *\n   * ```javascript\n   * // Combine search terms with AND (to match only documents that contain both\n   * // \"motorcycle\" and \"art\")\n   * miniSearch.search('motorcycle art', { combineWith: 'AND' })\n   * ```\n   *\n   * ### Combine with AND_NOT:\n   *\n   * There is also an AND_NOT combinator, that finds documents that match the\n   * first term, but do not match any of the other terms. This combinator is\n   * rarely useful with simple queries, and is meant to be used with advanced\n   * query combinations (see later for more details).\n   *\n   * ### Filtering results:\n   *\n   * ```javascript\n   * // Filter only results in the 'fiction' category (assuming that 'category'\n   * // is a stored field)\n   * miniSearch.search('motorcycle art', {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * ```\n   *\n   * ### Wildcard query\n   *\n   * Searching for an empty string (assuming the default tokenizer) returns no\n   * results. Sometimes though, one needs to match all documents, like in a\n   * \"wildcard\" search. This is possible by passing the special value\n   * {@link MiniSearch.wildcard} as the query:\n   *\n   * ```javascript\n   * // Return search results for all documents\n   * miniSearch.search(MiniSearch.wildcard)\n   * ```\n   *\n   * Note that search options such as `filter` and `boostDocument` are still\n   * applied, influencing which results are returned, and their order:\n   *\n   * ```javascript\n   * // Return search results for all documents in the 'fiction' category\n   * miniSearch.search(MiniSearch.wildcard, {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * ```\n   *\n   * ### Advanced combination of queries:\n   *\n   * It is possible to combine different subqueries with OR, AND, and AND_NOT,\n   * and even with different search options, by passing a query expression\n   * tree object as the first argument, instead of a string.\n   *\n   * ```javascript\n   * // Search for documents that contain \"zen\" and (\"motorcycle\" or \"archery\")\n   * miniSearch.search({\n   *   combineWith: 'AND',\n   *   queries: [\n   *     'zen',\n   *     {\n   *       combineWith: 'OR',\n   *       queries: ['motorcycle', 'archery']\n   *     }\n   *   ]\n   * })\n   *\n   * // Search for documents that contain (\"apple\" or \"pear\") but not \"juice\" and\n   * // not \"tree\"\n   * miniSearch.search({\n   *   combineWith: 'AND_NOT',\n   *   queries: [\n   *     {\n   *       combineWith: 'OR',\n   *       queries: ['apple', 'pear']\n   *     },\n   *     'juice',\n   *     'tree'\n   *   ]\n   * })\n   * ```\n   *\n   * Each node in the expression tree can be either a string, or an object that\n   * supports all {@link SearchOptions} fields, plus a `queries` array field for\n   * subqueries.\n   *\n   * Note that, while this can become complicated to do by hand for complex or\n   * deeply nested queries, it provides a formalized expression tree API for\n   * external libraries that implement a parser for custom query languages.\n   *\n   * @param query  Search query\n   * @param searchOptions  Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.\n   */\n  search (query: Query, searchOptions: SearchOptions = {}): SearchResult[] {\n    const { searchOptions: globalSearchOptions } = this._options\n    const searchOptionsWithDefaults: SearchOptionsWithDefaults = { ...globalSearchOptions, ...searchOptions }\n\n    const rawResults = this.executeQuery(query, searchOptions)\n    const results = []\n\n    for (const [docId, { score, terms, match }] of rawResults) {\n      // terms are the matched query terms, which will be returned to the user\n      // as queryTerms. The quality is calculated based on them, as opposed to\n      // the matched terms in the document (which can be different due to\n      // prefix and fuzzy match)\n      const quality = terms.length || 1\n\n      const result = {\n        id: this._documentIds.get(docId),\n        score: score * quality,\n        terms: Object.keys(match),\n        queryTerms: terms,\n        match\n      }\n\n      Object.assign(result, this._storedFields.get(docId))\n      if (searchOptionsWithDefaults.filter == null || searchOptionsWithDefaults.filter(result)) {\n        results.push(result)\n      }\n    }\n\n    // If it's a wildcard query, and no document boost is applied, skip sorting\n    // the results, as all results have the same score of 1\n    if (query === MiniSearch.wildcard && searchOptionsWithDefaults.boostDocument == null) {\n      return results\n    }\n\n    results.sort(byScore)\n    return results\n  }\n\n  /**\n   * Provide suggestions for the given search query\n   *\n   * The result is a list of suggested modified search queries, derived from the\n   * given search query, each with a relevance score, sorted by descending score.\n   *\n   * By default, it uses the same options used for search, except that by\n   * default it performs prefix search on the last term of the query, and\n   * combine terms with `'AND'` (requiring all query terms to match). Custom\n   * options can be passed as a second argument. Defaults can be changed upon\n   * calling the {@link MiniSearch} constructor, by passing a\n   * `autoSuggestOptions` option.\n   *\n   * ### Basic usage:\n   *\n   * ```javascript\n   * // Get suggestions for 'neuro':\n   * miniSearch.autoSuggest('neuro')\n   * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]\n   * ```\n   *\n   * ### Multiple words:\n   *\n   * ```javascript\n   * // Get suggestions for 'zen ar':\n   * miniSearch.autoSuggest('zen ar')\n   * // => [\n   * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n   * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n   * // ]\n   * ```\n   *\n   * ### Fuzzy suggestions:\n   *\n   * ```javascript\n   * // Correct spelling mistakes using fuzzy search:\n   * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n   * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n   * ```\n   *\n   * ### Filtering:\n   *\n   * ```javascript\n   * // Get suggestions for 'zen ar', but only within the 'fiction' category\n   * // (assuming that 'category' is a stored field):\n   * miniSearch.autoSuggest('zen ar', {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * // => [\n   * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n   * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n   * // ]\n   * ```\n   *\n   * @param queryString  Query string to be expanded into suggestions\n   * @param options  Search options. The supported options and default values\n   * are the same as for the {@link MiniSearch#search} method, except that by\n   * default prefix search is performed on the last term in the query, and terms\n   * are combined with `'AND'`.\n   * @return  A sorted array of suggestions sorted by relevance score.\n   */\n  autoSuggest (queryString: string, options: SearchOptions = {}): Suggestion[] {\n    options = { ...this._options.autoSuggestOptions, ...options }\n\n    const suggestions: Map<string, Omit<Suggestion, 'suggestion'> & { count: number }> = new Map()\n\n    for (const { score, terms } of this.search(queryString, options)) {\n      const phrase = terms.join(' ')\n      const suggestion = suggestions.get(phrase)\n      if (suggestion != null) {\n        suggestion.score += score\n        suggestion.count += 1\n      } else {\n        suggestions.set(phrase, { score, terms, count: 1 })\n      }\n    }\n\n    const results = []\n    for (const [suggestion, { score, terms, count }] of suggestions) {\n      results.push({ suggestion, terms, score: score / count })\n    }\n\n    results.sort(byScore)\n    return results\n  }\n\n  /**\n   * Total number of documents available to search\n   */\n  get documentCount (): number {\n    return this._documentCount\n  }\n\n  /**\n   * Number of terms in the index\n   */\n  get termCount (): number {\n    return this._index.size\n  }\n\n  /**\n   * Deserializes a JSON index (serialized with `JSON.stringify(miniSearch)`)\n   * and instantiates a MiniSearch instance. It should be given the same options\n   * originally used when serializing the index.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // If the index was serialized with:\n   * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * miniSearch.addAll(documents)\n   *\n   * const json = JSON.stringify(miniSearch)\n   * // It can later be deserialized like this:\n   * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n   * ```\n   *\n   * @param json  JSON-serialized index\n   * @param options  configuration options, same as the constructor\n   * @return An instance of MiniSearch deserialized from the given JSON.\n   */\n  static loadJSON<T = any> (json: string, options: Options<T>): MiniSearch<T> {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return this.loadJS(JSON.parse(json), options)\n  }\n\n  /**\n   * Async equivalent of {@link MiniSearch.loadJSON}\n   *\n   * This function is an alternative to {@link MiniSearch.loadJSON} that returns\n   * a promise, and loads the index in batches, leaving pauses between them to avoid\n   * blocking the main thread. It tends to be slower than the synchronous\n   * version, but does not block the main thread, so it can be a better choice\n   * when deserializing very large indexes.\n   *\n   * @param json  JSON-serialized index\n   * @param options  configuration options, same as the constructor\n   * @return A Promise that will resolve to an instance of MiniSearch deserialized from the given JSON.\n   */\n  static async loadJSONAsync<T = any> (json: string, options: Options<T>): Promise<MiniSearch<T>> {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return this.loadJSAsync(JSON.parse(json), options)\n  }\n\n  /**\n   * Returns the default value of an option. It will throw an error if no option\n   * with the given name exists.\n   *\n   * @param optionName  Name of the option\n   * @return The default value of the given option\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // Get default tokenizer\n   * MiniSearch.getDefault('tokenize')\n   *\n   * // Get default term processor\n   * MiniSearch.getDefault('processTerm')\n   *\n   * // Unknown options will throw an error\n   * MiniSearch.getDefault('notExisting')\n   * // => throws 'MiniSearch: unknown option \"notExisting\"'\n   * ```\n   */\n  static getDefault (optionName: string): any {\n    if (defaultOptions.hasOwnProperty(optionName)) {\n      return getOwnProperty(defaultOptions, optionName)\n    } else {\n      throw new Error(`MiniSearch: unknown option \"${optionName}\"`)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  static loadJS<T = any> (js: AsPlainObject, options: Options<T>): MiniSearch<T> {\n    const {\n      index,\n      documentIds,\n      fieldLength,\n      storedFields,\n      serializationVersion\n    } = js\n\n    const miniSearch = this.instantiateMiniSearch(js, options)\n\n    miniSearch._documentIds = objectToNumericMap(documentIds)\n    miniSearch._fieldLength = objectToNumericMap(fieldLength)\n    miniSearch._storedFields = objectToNumericMap(storedFields)\n\n    for (const [shortId, id] of miniSearch._documentIds) {\n      miniSearch._idToShortId.set(id, shortId)\n    }\n\n    for (const [term, data] of index) {\n      const dataMap = new Map() as FieldTermData\n\n      for (const fieldId of Object.keys(data)) {\n        let indexEntry = data[fieldId]\n\n        // Version 1 used to nest the index entry inside a field called ds\n        if (serializationVersion === 1) {\n          indexEntry = indexEntry.ds as unknown as SerializedIndexEntry\n        }\n\n        dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry) as DocumentTermFreqs)\n      }\n\n      miniSearch._index.set(term, dataMap)\n    }\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  static async loadJSAsync<T = any> (js: AsPlainObject, options: Options<T>): Promise<MiniSearch<T>> {\n    const {\n      index,\n      documentIds,\n      fieldLength,\n      storedFields,\n      serializationVersion\n    } = js\n\n    const miniSearch = this.instantiateMiniSearch(js, options)\n\n    miniSearch._documentIds = await objectToNumericMapAsync(documentIds)\n    miniSearch._fieldLength = await objectToNumericMapAsync(fieldLength)\n    miniSearch._storedFields = await objectToNumericMapAsync(storedFields)\n\n    for (const [shortId, id] of miniSearch._documentIds) {\n      miniSearch._idToShortId.set(id, shortId)\n    }\n\n    let count = 0\n    for (const [term, data] of index) {\n      const dataMap = new Map() as FieldTermData\n\n      for (const fieldId of Object.keys(data)) {\n        let indexEntry = data[fieldId]\n\n        // Version 1 used to nest the index entry inside a field called ds\n        if (serializationVersion === 1) {\n          indexEntry = indexEntry.ds as unknown as SerializedIndexEntry\n        }\n\n        dataMap.set(parseInt(fieldId, 10), await objectToNumericMapAsync(indexEntry) as DocumentTermFreqs)\n      }\n\n      if (++count % 1000 === 0) await wait(0)\n      miniSearch._index.set(term, dataMap)\n    }\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  private static instantiateMiniSearch<T = any> (js: AsPlainObject, options: Options<T>): MiniSearch<T> {\n    const {\n      documentCount,\n      nextId,\n      fieldIds,\n      averageFieldLength,\n      dirtCount,\n      serializationVersion\n    } = js\n\n    if (serializationVersion !== 1 && serializationVersion !== 2) {\n      throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version')\n    }\n\n    const miniSearch = new MiniSearch(options)\n\n    miniSearch._documentCount = documentCount\n    miniSearch._nextId = nextId\n    miniSearch._idToShortId = new Map<any, number>()\n    miniSearch._fieldIds = fieldIds\n    miniSearch._avgFieldLength = averageFieldLength\n    miniSearch._dirtCount = dirtCount || 0\n    miniSearch._index = new SearchableMap()\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  private executeQuery (query: Query, searchOptions: SearchOptions = {}): RawResult {\n    if (query === MiniSearch.wildcard) {\n      return this.executeWildcardQuery(searchOptions)\n    }\n\n    if (typeof query !== 'string') {\n      const options = { ...searchOptions, ...query, queries: undefined }\n      const results = query.queries.map((subquery) => this.executeQuery(subquery, options))\n      return this.combineResults(results, options.combineWith)\n    }\n\n    const { tokenize, processTerm, searchOptions: globalSearchOptions } = this._options\n    const options = { tokenize, processTerm, ...globalSearchOptions, ...searchOptions }\n    const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options\n    const terms = searchTokenize(query)\n      .flatMap((term: string) => searchProcessTerm(term))\n      .filter((term) => !!term) as string[]\n    const queries: QuerySpec[] = terms.map(termToQuerySpec(options))\n    const results = queries.map(query => this.executeQuerySpec(query, options))\n\n    return this.combineResults(results, options.combineWith)\n  }\n\n  /**\n   * @ignore\n   */\n  private executeQuerySpec (query: QuerySpec, searchOptions: SearchOptions): RawResult {\n    const options: SearchOptionsWithDefaults = { ...this._options.searchOptions, ...searchOptions }\n\n    const boosts = (options.fields || this._options.fields).reduce((boosts, field) =>\n      ({ ...boosts, [field]: getOwnProperty(options.boost, field) || 1 }), {})\n\n    const {\n      boostDocument,\n      weights,\n      maxFuzzy,\n      bm25: bm25params\n    } = options\n\n    const { fuzzy: fuzzyWeight, prefix: prefixWeight } = { ...defaultSearchOptions.weights, ...weights }\n\n    const data = this._index.get(query.term)\n    const results = this.termResults(query.term, query.term, 1, query.termBoost, data, boosts, boostDocument, bm25params)\n\n    let prefixMatches\n    let fuzzyMatches\n\n    if (query.prefix) {\n      prefixMatches = this._index.atPrefix(query.term)\n    }\n\n    if (query.fuzzy) {\n      const fuzzy = (query.fuzzy === true) ? 0.2 : query.fuzzy\n      const maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy\n      if (maxDistance) fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance)\n    }\n\n    if (prefixMatches) {\n      for (const [term, data] of prefixMatches) {\n        const distance = term.length - query.term.length\n        if (!distance) { continue } // Skip exact match.\n\n        // Delete the term from fuzzy results (if present) if it is also a\n        // prefix result. This entry will always be scored as a prefix result.\n        fuzzyMatches?.delete(term)\n\n        // Weight gradually approaches 0 as distance goes to infinity, with the\n        // weight for the hypothetical distance 0 being equal to prefixWeight.\n        // The rate of change is much lower than that of fuzzy matches to\n        // account for the fact that prefix matches stay more relevant than\n        // fuzzy matches for longer distances.\n        const weight = prefixWeight * term.length / (term.length + 0.3 * distance)\n        this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results)\n      }\n    }\n\n    if (fuzzyMatches) {\n      for (const term of fuzzyMatches.keys()) {\n        const [data, distance] = fuzzyMatches.get(term)!\n        if (!distance) { continue } // Skip exact match.\n\n        // Weight gradually approaches 0 as distance goes to infinity, with the\n        // weight for the hypothetical distance 0 being equal to fuzzyWeight.\n        const weight = fuzzyWeight * term.length / (term.length + distance)\n        this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results)\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private executeWildcardQuery (searchOptions: SearchOptions): RawResult {\n    const results = new Map() as RawResult\n    const options: SearchOptionsWithDefaults = { ...this._options.searchOptions, ...searchOptions }\n\n    for (const [shortId, id] of this._documentIds) {\n      const score = options.boostDocument ? options.boostDocument(id, '', this._storedFields.get(shortId)) : 1\n      results.set(shortId, {\n        score,\n        terms: [],\n        match: {}\n      })\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private combineResults (results: RawResult[], combineWith: CombinationOperator = OR): RawResult {\n    if (results.length === 0) { return new Map() }\n    const operator = combineWith.toLowerCase()\n    const combinator = (combinators as Record<string, CombinatorFunction>)[operator]\n\n    if (!combinator) {\n      throw new Error(`Invalid combination operator: ${combineWith}`)\n    }\n\n    return results.reduce(combinator) || new Map()\n  }\n\n  /**\n   * Allows serialization of the index to JSON, to possibly store it and later\n   * deserialize it with {@link MiniSearch.loadJSON}.\n   *\n   * Normally one does not directly call this method, but rather call the\n   * standard JavaScript `JSON.stringify()` passing the {@link MiniSearch}\n   * instance, and JavaScript will internally call this method. Upon\n   * deserialization, one must pass to {@link MiniSearch.loadJSON} the same\n   * options used to create the original instance that was serialized.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // Serialize the index:\n   * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * miniSearch.addAll(documents)\n   * const json = JSON.stringify(miniSearch)\n   *\n   * // Later, to deserialize it:\n   * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n   * ```\n   *\n   * @return A plain-object serializable representation of the search index.\n   */\n  toJSON (): AsPlainObject {\n    const index: [string, { [key: string]: SerializedIndexEntry }][] = []\n\n    for (const [term, fieldIndex] of this._index) {\n      const data: { [key: string]: SerializedIndexEntry } = {}\n\n      for (const [fieldId, freqs] of fieldIndex) {\n        data[fieldId] = Object.fromEntries(freqs)\n      }\n\n      index.push([term, data])\n    }\n\n    return {\n      documentCount: this._documentCount,\n      nextId: this._nextId,\n      documentIds: Object.fromEntries(this._documentIds),\n      fieldIds: this._fieldIds,\n      fieldLength: Object.fromEntries(this._fieldLength),\n      averageFieldLength: this._avgFieldLength,\n      storedFields: Object.fromEntries(this._storedFields),\n      dirtCount: this._dirtCount,\n      index,\n      serializationVersion: 2\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private termResults (\n    sourceTerm: string,\n    derivedTerm: string,\n    termWeight: number,\n    termBoost: number,\n    fieldTermData: FieldTermData | undefined,\n    fieldBoosts: { [field: string]: number },\n    boostDocumentFn: ((id: any, term: string, storedFields?: Record<string, unknown>) => number) | undefined,\n    bm25params: BM25Params,\n    results: RawResult = new Map()\n  ): RawResult {\n    if (fieldTermData == null) return results\n\n    for (const field of Object.keys(fieldBoosts)) {\n      const fieldBoost = fieldBoosts[field]\n      const fieldId = this._fieldIds[field]\n\n      const fieldTermFreqs = fieldTermData.get(fieldId)\n      if (fieldTermFreqs == null) continue\n\n      let matchingFields = fieldTermFreqs.size\n      const avgFieldLength = this._avgFieldLength[fieldId]\n\n      for (const docId of fieldTermFreqs.keys()) {\n        if (!this._documentIds.has(docId)) {\n          this.removeTerm(fieldId, docId, derivedTerm)\n          matchingFields -= 1\n          continue\n        }\n\n        const docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1\n        if (!docBoost) continue\n\n        const termFreq = fieldTermFreqs.get(docId)!\n        const fieldLength = this._fieldLength.get(docId)![fieldId]\n\n        // NOTE: The total number of fields is set to the number of documents\n        // `this._documentCount`. It could also make sense to use the number of\n        // documents where the current field is non-blank as a normalization\n        // factor. This will make a difference in scoring if the field is rarely\n        // present. This is currently not supported, and may require further\n        // analysis to see if it is a valid use case.\n        const rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params)\n        const weightedScore = termWeight * termBoost * fieldBoost * docBoost * rawScore\n\n        const result = results.get(docId)\n        if (result) {\n          result.score += weightedScore\n          assignUniqueTerm(result.terms, sourceTerm)\n          const match = getOwnProperty(result.match, derivedTerm)\n          if (match) {\n            match.push(field)\n          } else {\n            result.match[derivedTerm] = [field]\n          }\n        } else {\n          results.set(docId, {\n            score: weightedScore,\n            terms: [sourceTerm],\n            match: { [derivedTerm]: [field] }\n          })\n        }\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private addTerm (fieldId: number, documentId: number, term: string): void {\n    const indexData = this._index.fetch(term, createMap)\n\n    let fieldIndex = indexData.get(fieldId)\n    if (fieldIndex == null) {\n      fieldIndex = new Map()\n      fieldIndex.set(documentId, 1)\n      indexData.set(fieldId, fieldIndex)\n    } else {\n      const docs = fieldIndex.get(documentId)\n      fieldIndex.set(documentId, (docs || 0) + 1)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private removeTerm (fieldId: number, documentId: number, term: string): void {\n    if (!this._index.has(term)) {\n      this.warnDocumentChanged(documentId, fieldId, term)\n      return\n    }\n\n    const indexData = this._index.fetch(term, createMap)\n\n    const fieldIndex = indexData.get(fieldId)\n    if (fieldIndex == null || fieldIndex.get(documentId) == null) {\n      this.warnDocumentChanged(documentId, fieldId, term)\n    } else if (fieldIndex.get(documentId)! <= 1) {\n      if (fieldIndex.size <= 1) {\n        indexData.delete(fieldId)\n      } else {\n        fieldIndex.delete(documentId)\n      }\n    } else {\n      fieldIndex.set(documentId, fieldIndex.get(documentId)! - 1)\n    }\n\n    if (this._index.get(term)!.size === 0) {\n      this._index.delete(term)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private warnDocumentChanged (shortDocumentId: number, fieldId: number, term: string): void {\n    for (const fieldName of Object.keys(this._fieldIds)) {\n      if (this._fieldIds[fieldName] === fieldId) {\n        this._options.logger('warn', `MiniSearch: document with ID ${this._documentIds.get(shortDocumentId)} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`, 'version_conflict')\n        return\n      }\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private addDocumentId (documentId: any): number {\n    const shortDocumentId = this._nextId\n    this._idToShortId.set(documentId, shortDocumentId)\n    this._documentIds.set(shortDocumentId, documentId)\n    this._documentCount += 1\n    this._nextId += 1\n    return shortDocumentId\n  }\n\n  /**\n   * @ignore\n   */\n  private addFields (fields: string[]): void {\n    for (let i = 0; i < fields.length; i++) {\n      this._fieldIds[fields[i]] = i\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private addFieldLength (documentId: number, fieldId: number, count: number, length: number): void {\n    let fieldLengths = this._fieldLength.get(documentId)\n    if (fieldLengths == null) this._fieldLength.set(documentId, fieldLengths = [])\n    fieldLengths[fieldId] = length\n\n    const averageFieldLength = this._avgFieldLength[fieldId] || 0\n    const totalFieldLength = (averageFieldLength * count) + length\n    this._avgFieldLength[fieldId] = totalFieldLength / (count + 1)\n  }\n\n  /**\n   * @ignore\n   */\n  private removeFieldLength (documentId: number, fieldId: number, count: number, length: number): void {\n    if (count === 1) {\n      this._avgFieldLength[fieldId] = 0\n      return\n    }\n    const totalFieldLength = (this._avgFieldLength[fieldId] * count) - length\n    this._avgFieldLength[fieldId] = totalFieldLength / (count - 1)\n  }\n\n  /**\n   * @ignore\n   */\n  private saveStoredFields (documentId: number, doc: T): void {\n    const { storeFields, extractField } = this._options\n    if (storeFields == null || storeFields.length === 0) { return }\n\n    let documentFields = this._storedFields.get(documentId)\n    if (documentFields == null) this._storedFields.set(documentId, documentFields = {})\n\n    for (const fieldName of storeFields) {\n      const fieldValue = extractField(doc, fieldName)\n      if (fieldValue !== undefined) documentFields[fieldName] = fieldValue\n    }\n  }\n}\n\nconst getOwnProperty = (object: any, property: string) =>\n  Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined\n\ntype CombinatorFunction = (a: RawResult, b: RawResult) => RawResult\n\nconst combinators: Record<LowercaseCombinationOperator, CombinatorFunction> = {\n  [OR]: (a: RawResult, b: RawResult) => {\n    for (const docId of b.keys()) {\n      const existing = a.get(docId)\n      if (existing == null) {\n        a.set(docId, b.get(docId)!)\n      } else {\n        const { score, terms, match } = b.get(docId)!\n        existing.score = existing.score + score\n        existing.match = Object.assign(existing.match, match)\n        assignUniqueTerms(existing.terms, terms)\n      }\n    }\n\n    return a\n  },\n  [AND]: (a: RawResult, b: RawResult) => {\n    const combined = new Map()\n\n    for (const docId of b.keys()) {\n      const existing = a.get(docId)\n      if (existing == null) continue\n\n      const { score, terms, match } = b.get(docId)!\n      assignUniqueTerms(existing.terms, terms)\n      combined.set(docId, {\n        score: existing.score + score,\n        terms: existing.terms,\n        match: Object.assign(existing.match, match)\n      })\n    }\n\n    return combined\n  },\n  [AND_NOT]: (a: RawResult, b: RawResult) => {\n    for (const docId of b.keys()) a.delete(docId)\n    return a\n  }\n}\n\n/**\n * Parameters of the BM25+ scoring algorithm. Customizing these is almost never\n * necessary, and finetuning them requires an understanding of the BM25 scoring\n * model.\n *\n * Some information about BM25 (and BM25+) can be found at these links:\n *\n *   - https://en.wikipedia.org/wiki/Okapi_BM25\n *   - https://opensourceconnections.com/blog/2015/10/16/bm25-the-next-generation-of-lucene-relevation/\n */\nexport type BM25Params = {\n  /** Term frequency saturation point.\n   *\n   * Recommended values are between `1.2` and `2`. Higher values increase the\n   * difference in score between documents with higher and lower term\n   * frequencies. Setting this to `0` or a negative value is invalid. Defaults\n   * to `1.2`\n   */\n  k: number,\n\n  /**\n   * Length normalization impact.\n   *\n   * Recommended values are around `0.75`. Higher values increase the weight\n   * that field length has on scoring. Setting this to `0` (not recommended)\n   * means that the field length has no effect on scoring. Negative values are\n   * invalid. Defaults to `0.7`.\n   */\n  b: number,\n\n  /**\n   * BM25+ frequency normalization lower bound (usually called δ).\n   *\n   * Recommended values are between `0.5` and `1`. Increasing this parameter\n   * increases the minimum relevance of one occurrence of a search term\n   * regardless of its (possibly very long) field length. Negative values are\n   * invalid. Defaults to `0.5`.\n   */\n  d: number\n}\n\nconst defaultBM25params: BM25Params = { k: 1.2, b: 0.7, d: 0.5 }\n\nconst calcBM25Score = (\n  termFreq: number,\n  matchingCount: number,\n  totalCount: number,\n  fieldLength: number,\n  avgFieldLength: number,\n  bm25params: BM25Params\n): number => {\n  const { k, b, d } = bm25params\n  const invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5))\n  return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)))\n}\n\nconst termToQuerySpec = (options: SearchOptions) => (term: string, i: number, terms: string[]): QuerySpec => {\n  const fuzzy = (typeof options.fuzzy === 'function')\n    ? options.fuzzy(term, i, terms)\n    : (options.fuzzy || false)\n  const prefix = (typeof options.prefix === 'function')\n    ? options.prefix(term, i, terms)\n    : (options.prefix === true)\n  const termBoost = (typeof options.boostTerm === 'function')\n    ? options.boostTerm(term, i, terms)\n    : 1\n  return { term, fuzzy, prefix, termBoost }\n}\n\nconst defaultOptions = {\n  idField: 'id',\n  extractField: (document: any, fieldName: string) => document[fieldName],\n  stringifyField: (fieldValue: any, fieldName: string) => fieldValue.toString(),\n  tokenize: (text: string) => text.split(SPACE_OR_PUNCTUATION),\n  processTerm: (term: string) => term.toLowerCase(),\n  fields: undefined,\n  searchOptions: undefined,\n  storeFields: [],\n  logger: (level: LogLevel, message: string): void => {\n    if (typeof console?.[level] === 'function') console[level](message)\n  },\n  autoVacuum: true\n}\n\nconst defaultSearchOptions = {\n  combineWith: OR,\n  prefix: false,\n  fuzzy: false,\n  maxFuzzy: 6,\n  boost: {},\n  weights: { fuzzy: 0.45, prefix: 0.375 },\n  bm25: defaultBM25params\n}\n\nconst defaultAutoSuggestOptions = {\n  combineWith: AND,\n  prefix: (term: string, i: number, terms: string[]): boolean =>\n    i === terms.length - 1\n}\n\nconst defaultVacuumOptions = { batchSize: 1000, batchWait: 10 }\nconst defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 }\n\nconst defaultAutoVacuumOptions = { ...defaultVacuumOptions, ...defaultVacuumConditions }\n\nconst assignUniqueTerm = (target: string[], term: string): void => {\n  // Avoid adding duplicate terms.\n  if (!target.includes(term)) target.push(term)\n}\n\nconst assignUniqueTerms = (target: string[], source: readonly string[]): void => {\n  for (const term of source) {\n    // Avoid adding duplicate terms.\n    if (!target.includes(term)) target.push(term)\n  }\n}\n\ntype Scored = { score: number }\nconst byScore = ({ score: a }: Scored, { score: b }: Scored) => b - a\n\nconst createMap = () => new Map()\n\ninterface SerializedIndexEntry {\n  [key: string]: number\n}\n\nconst objectToNumericMap = <T>(object: { [key: string]: T }): Map<number, T> => {\n  const map = new Map()\n\n  for (const key of Object.keys(object)) {\n    map.set(parseInt(key, 10), object[key])\n  }\n\n  return map\n}\n\nconst objectToNumericMapAsync = async <T>(object: { [key: string]: T }): Promise<Map<number, T>> => {\n  const map = new Map()\n\n  let count = 0\n  for (const key of Object.keys(object)) {\n    map.set(parseInt(key, 10), object[key])\n    if (++count % 1000 === 0) {\n      await wait(0)\n    }\n  }\n\n  return map\n}\n\nconst wait = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))\n\n// This regular expression matches any Unicode space, newline, or punctuation\n// character\nconst SPACE_OR_PUNCTUATION = /[\\n\\r\\p{Z}\\p{P}]+/u\n",
    "symbols": [
      {
        "name": "MiniSearch",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 611,
        "endLine": 2060
      },
      {
        "name": "MiniSearch.add",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 746,
        "endLine": 781
      },
      {
        "name": "MiniSearch.addAll",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 788,
        "endLine": 790
      },
      {
        "name": "MiniSearch.addAllAsync",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 803,
        "endLine": 822
      },
      {
        "name": "MiniSearch.remove",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 838,
        "endLine": 879
      },
      {
        "name": "MiniSearch.removeAll",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 890,
        "endLine": 905
      },
      {
        "name": "MiniSearch.discard",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 951,
        "endLine": 972
      },
      {
        "name": "MiniSearch.maybeAutoVacuum",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 974,
        "endLine": 979
      },
      {
        "name": "MiniSearch.discardAll",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 993,
        "endLine": 1007
      },
      {
        "name": "MiniSearch.replace",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1024,
        "endLine": 1030
      },
      {
        "name": "MiniSearch.vacuum",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1071,
        "endLine": 1073
      },
      {
        "name": "MiniSearch.conditionalVacuum",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1075,
        "endLine": 1096
      },
      {
        "name": "MiniSearch.performVacuuming",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1098,
        "endLine": 1138
      },
      {
        "name": "MiniSearch.vacuumConditionsMet",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1140,
        "endLine": 1148
      },
      {
        "name": "MiniSearch.has",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1181,
        "endLine": 1183
      },
      {
        "name": "MiniSearch.getStoredFields",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1192,
        "endLine": 1198
      },
      {
        "name": "MiniSearch.search",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1360,
        "endLine": 1396
      },
      {
        "name": "MiniSearch.autoSuggest",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1459,
        "endLine": 1482
      },
      {
        "name": "MiniSearch.loadJSON",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1519,
        "endLine": 1524
      },
      {
        "name": "MiniSearch.loadJSONAsync",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1539,
        "endLine": 1544
      },
      {
        "name": "MiniSearch.getDefault",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1567,
        "endLine": 1573
      },
      {
        "name": "MiniSearch.loadJS",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1578,
        "endLine": 1615
      },
      {
        "name": "MiniSearch.loadJSAsync",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1620,
        "endLine": 1659
      },
      {
        "name": "MiniSearch.instantiateMiniSearch",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1664,
        "endLine": 1689
      },
      {
        "name": "MiniSearch.executeQuery",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1694,
        "endLine": 1715
      },
      {
        "name": "MiniSearch.executeQuerySpec",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1720,
        "endLine": 1783
      },
      {
        "name": "MiniSearch.executeWildcardQuery",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1788,
        "endLine": 1802
      },
      {
        "name": "MiniSearch.combineResults",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1807,
        "endLine": 1817
      },
      {
        "name": "MiniSearch.toJSON",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1843,
        "endLine": 1868
      },
      {
        "name": "MiniSearch.termResults",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1873,
        "endLine": 1939
      },
      {
        "name": "MiniSearch.addTerm",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1944,
        "endLine": 1956
      },
      {
        "name": "MiniSearch.removeTerm",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1961,
        "endLine": 1985
      },
      {
        "name": "MiniSearch.warnDocumentChanged",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 1990,
        "endLine": 1997
      },
      {
        "name": "MiniSearch.addDocumentId",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 2002,
        "endLine": 2009
      },
      {
        "name": "MiniSearch.addFields",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 2014,
        "endLine": 2018
      },
      {
        "name": "MiniSearch.addFieldLength",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 2023,
        "endLine": 2031
      },
      {
        "name": "MiniSearch.removeFieldLength",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 2036,
        "endLine": 2043
      },
      {
        "name": "MiniSearch.saveStoredFields",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/MiniSearch.ts",
        "startLine": 2048,
        "endLine": 2059
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/index.ts",
    "content": "import * as z from \"./v3/external.js\";\nexport * from \"./v3/external.js\";\nexport { z };\nexport default z;\n",
    "symbols": []
  },
  {
    "path": "node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "content": "import { StringReader, StringWriter } from './strings';\nimport { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\n\nconst EMPTY: any[] = [];\n\ntype Line = number;\ntype Column = number;\ntype Kind = number;\ntype Name = number;\ntype Var = number;\ntype SourcesIndex = number;\ntype ScopesIndex = number;\n\ntype Mix<A, B, O> = (A & O) | (B & O);\n\nexport type OriginalScope = Mix<\n  [Line, Column, Line, Column, Kind],\n  [Line, Column, Line, Column, Kind, Name],\n  { vars: Var[] }\n>;\n\nexport type GeneratedRange = Mix<\n  [Line, Column, Line, Column],\n  [Line, Column, Line, Column, SourcesIndex, ScopesIndex],\n  {\n    callsite: CallSite | null;\n    bindings: Binding[];\n    isScope: boolean;\n  }\n>;\nexport type CallSite = [SourcesIndex, Line, Column];\ntype Binding = BindingExpressionRange[];\nexport type BindingExpressionRange = [Name] | [Name, Line, Column];\n\nexport function decodeOriginalScopes(input: string): OriginalScope[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes: OriginalScope[] = [];\n  const stack: OriginalScope[] = [];\n  let line = 0;\n\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop()!;\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 0b0001;\n\n    const scope: OriginalScope = (\n      hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]\n    ) as OriginalScope;\n\n    let vars: Var[] = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n\n    scopes.push(scope);\n    stack.push(scope);\n  }\n\n  return scopes;\n}\n\nexport function encodeOriginalScopes(scopes: OriginalScope[]): string {\n  const writer = new StringWriter();\n\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeOriginalScopes(\n  scopes: OriginalScope[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenColumn\n  ],\n): number {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n\n  if (index > 0) writer.write(comma);\n\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n\n  const fields = scope.length === 6 ? 0b0001 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n\n  return index;\n}\n\nexport function decodeGeneratedRanges(input: string): GeneratedRange[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges: GeneratedRange[] = [];\n  const stack: GeneratedRange[] = [];\n\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    let genColumn = 0;\n\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop()!;\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 0b0001;\n      const hasCallsite = fields & 0b0010;\n      const hasScope = fields & 0b0100;\n\n      let callsite: CallSite | null = null;\n      let bindings: Binding[] = EMPTY;\n      let range: GeneratedRange;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0,\n        );\n\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex] as GeneratedRange;\n      } else {\n        range = [genLine, genColumn, 0, 0] as GeneratedRange;\n      }\n\n      range.isScope = !!hasScope;\n\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0,\n        );\n\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges: BindingExpressionRange[];\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n\n      ranges.push(range);\n      stack.push(range);\n    }\n\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n\n  return ranges;\n}\n\nexport function encodeGeneratedRanges(ranges: GeneratedRange[]): string {\n  if (ranges.length === 0) return '';\n\n  const writer = new StringWriter();\n\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeGeneratedRanges(\n  ranges: GeneratedRange[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenLine\n    number, // GenColumn\n    number, // DefSourcesIndex\n    number, // DefScopesIndex\n    number, // CallSourcesIndex\n    number, // CallLine\n    number, // CallColumn\n  ],\n): number {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings,\n  } = range;\n\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n\n  state[1] = encodeInteger(writer, range[1], state[1]);\n\n  const fields =\n    (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\n  encodeInteger(writer, fields, 0);\n\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite!;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1]!, bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2]!, bindingStartColumn);\n        encodeInteger(writer, expRange[0]!, 0);\n      }\n    }\n  }\n\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n\n  return index;\n}\n\nfunction catchupLine(writer: StringWriter, lastLine: number, line: number) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}\n",
    "symbols": [
      {
        "name": "decodeOriginalScopes",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
        "startLine": 35,
        "endLine": 76
      },
      {
        "name": "encodeOriginalScopes",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
        "startLine": 78,
        "endLine": 86
      },
      {
        "name": "_encodeOriginalScopes",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
        "startLine": 88,
        "endLine": 127
      },
      {
        "name": "decodeGeneratedRanges",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
        "startLine": 129,
        "endLine": 229
      },
      {
        "name": "encodeGeneratedRanges",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
        "startLine": 231,
        "endLine": 241
      },
      {
        "name": "_encodeGeneratedRanges",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
        "startLine": 243,
        "endLine": 339
      },
      {
        "name": "catchupLine",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
        "startLine": 341,
        "endLine": 345
      }
    ]
  },
  {
    "path": "node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
    "content": "import { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\nimport { StringWriter, StringReader } from './strings';\n\nexport {\n  decodeOriginalScopes,\n  encodeOriginalScopes,\n  decodeGeneratedRanges,\n  encodeGeneratedRanges,\n} from './scopes';\nexport type { OriginalScope, GeneratedRange, CallSite, BindingExpressionRange } from './scopes';\n\nexport type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nexport function decode(mappings: string): SourceMapMappings {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded: SourceMapMappings = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n\n    while (reader.pos < semi) {\n      let seg: SourceMapSegment;\n\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n\n      line.push(seg);\n      reader.pos++;\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n\n  return decoded;\n}\n\nfunction sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}\n\nexport function encode(decoded: SourceMapMappings): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n\n    let genColumn = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n\n  return writer.flush();\n}\n",
    "symbols": [
      {
        "name": "decode",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
        "startLine": 19,
        "endLine": 68
      },
      {
        "name": "sort",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
        "startLine": 70,
        "endLine": 72
      },
      {
        "name": "sortComparator",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
        "startLine": 74,
        "endLine": 76
      },
      {
        "name": "encode",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
        "startLine": 78,
        "endLine": 78
      },
      {
        "name": "encode",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
        "startLine": 79,
        "endLine": 79
      },
      {
        "name": "encode",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
        "startLine": 80,
        "endLine": 111
      }
    ]
  },
  {
    "path": "node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "content": "const bufLength = 1024 * 16;\n\n// Provide a fallback for older environments.\nconst td =\n  typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n      ? {\n          decode(buf: Uint8Array): string {\n            const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n            return out.toString();\n          },\n        }\n      : {\n          decode(buf: Uint8Array): string {\n            let out = '';\n            for (let i = 0; i < buf.length; i++) {\n              out += String.fromCharCode(buf[i]);\n            }\n            return out;\n          },\n        };\n\nexport class StringWriter {\n  pos = 0;\n  private out = '';\n  private buffer = new Uint8Array(bufLength);\n\n  write(v: number): void {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n\n  flush(): string {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n}\n\nexport class StringReader {\n  pos = 0;\n  declare private buffer: string;\n\n  constructor(buffer: string) {\n    this.buffer = buffer;\n  }\n\n  next(): number {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n\n  peek(): number {\n    return this.buffer.charCodeAt(this.pos);\n  }\n\n  indexOf(char: string): number {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n}\n",
    "symbols": [
      {
        "name": "StringWriter",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
        "startLine": 24,
        "endLine": 42
      },
      {
        "name": "StringWriter.write",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
        "startLine": 29,
        "endLine": 36
      },
      {
        "name": "StringWriter.flush",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
        "startLine": 38,
        "endLine": 41
      },
      {
        "name": "StringReader",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
        "startLine": 44,
        "endLine": 65
      },
      {
        "name": "StringReader.next",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
        "startLine": 52,
        "endLine": 54
      },
      {
        "name": "StringReader.peek",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
        "startLine": 56,
        "endLine": 58
      },
      {
        "name": "StringReader.indexOf",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
        "startLine": 60,
        "endLine": 64
      }
    ]
  },
  {
    "path": "node_modules/@jridgewell/sourcemap-codec/src/vlq.ts",
    "content": "import type { StringReader, StringWriter } from './strings';\n\nexport const comma = ','.charCodeAt(0);\nexport const semicolon = ';'.charCodeAt(0);\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\n\nexport function decodeInteger(reader: StringReader, relative: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  return relative + value;\n}\n\nexport function encodeInteger(builder: StringWriter, num: number, relative: number): number {\n  let delta = num - relative;\n\n  delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\n  do {\n    let clamped = delta & 0b011111;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 0b100000;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n\n  return num;\n}\n\nexport function hasMoreVlq(reader: StringReader, max: number) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n",
    "symbols": [
      {
        "name": "decodeInteger",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts",
        "startLine": 16,
        "endLine": 36
      },
      {
        "name": "encodeInteger",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts",
        "startLine": 38,
        "endLine": 50
      },
      {
        "name": "hasMoreVlq",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts",
        "startLine": 52,
        "endLine": 55
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/cache.ts",
    "content": "import Redis from 'ioredis';\n\nexport class QueryCache {\n  private redis?: Redis;\n  private mem = new Map<string, { v: any; exp: number }>();\n  constructor(url?: string) {\n    if (url) {\n      try { this.redis = new Redis(url); } catch { this.redis = undefined; }\n    }\n  }\n  async get(key: string): Promise<any | undefined> {\n    if (this.redis) {\n      const v = await this.redis.get(key);\n      return v ? JSON.parse(v) : undefined;\n    }\n    const e = this.mem.get(key);\n    if (!e) return undefined;\n    if (Date.now() > e.exp) { this.mem.delete(key); return undefined; }\n    return e.v;\n  }\n  async set(key: string, value: any, ttlSec: number) {\n    if (this.redis) {\n      await this.redis.set(key, JSON.stringify(value), 'EX', ttlSec);\n      return;\n    }\n    this.mem.set(key, { v: value, exp: Date.now() + ttlSec * 1000 });\n  }\n}\n",
    "symbols": [
      {
        "name": "QueryCache",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/cache.ts",
        "startLine": 3,
        "endLine": 28
      },
      {
        "name": "QueryCache.get",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/cache.ts",
        "startLine": 11,
        "endLine": 20
      },
      {
        "name": "QueryCache.set",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/cache.ts",
        "startLine": 21,
        "endLine": 27
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/context_profiler.ts",
    "content": "export type ContextIntent = 'refactor' | 'test' | 'performance' | 'docs' | 'dataflow' | 'general';\n\nexport interface ContextProfile {\n  intent: ContextIntent;\n  tokenBudget: number;\n  requestedTopK: number;\n  effectiveTopK: number;\n  notes: string[];\n}\n\nconst KEYWORDS: Array<{ intent: ContextIntent; words: RegExp[]; budget: number; topK: number; note: string }> = [\n  {\n    intent: 'refactor',\n    words: [/refactor/i, /rename/i, /cleanup/i, /architecture/i],\n    budget: 1400,\n    topK: 8,\n    note: 'Refactor intent detected; widen snippet allocation.',\n  },\n  {\n    intent: 'dataflow',\n    words: [/data[\\s-]?flow/i, /dependency/i, /graph/i, /call tree/i, /topolog/i],\n    budget: 1300,\n    topK: 7,\n    note: 'Dataflow intent; prioritize dependency graph context.',\n  },\n  {\n    intent: 'test',\n    words: [/test/i, /assert/i, /coverage/i, /unit/i],\n    budget: 900,\n    topK: 6,\n    note: 'Testing intent; focus on functions and call sites.',\n  },\n  {\n    intent: 'performance',\n    words: [/perf/i, /performance/i, /slow/i, /latenc/i, /optimi[sz]e/i],\n    budget: 1100,\n    topK: 7,\n    note: 'Performance audit; include dependency graph context.',\n  },\n  {\n    intent: 'docs',\n    words: [/doc/i, /explain/i, /usage/i, /readme/i],\n    budget: 700,\n    topK: 5,\n    note: 'Docs intent; concise summaries are sufficient.',\n  },\n];\n\nexport function profileContext(query: string, requestedTopK: number): ContextProfile {\n  const trimmed = query.trim();\n  for (const candidate of KEYWORDS) {\n    if (candidate.words.some(re => re.test(trimmed))) {\n      return {\n        intent: candidate.intent,\n        tokenBudget: candidate.budget,\n        requestedTopK,\n        effectiveTopK: Math.max(1, Math.min(candidate.topK, requestedTopK || candidate.topK)),\n        notes: [candidate.note],\n      };\n    }\n  }\n  return {\n    intent: 'general',\n    tokenBudget: 600,\n    requestedTopK,\n    effectiveTopK: Math.max(1, Math.min(requestedTopK || 5, 5)),\n    notes: ['General search; apply balanced context selection.'],\n  };\n}\n",
    "symbols": [
      {
        "name": "profileContext",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/context_profiler.ts",
        "startLine": 49,
        "endLine": 69
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/generate_telemetry.ts",
    "content": "import path from 'path';\nimport process from 'process';\nimport { generate_telemetry_panel } from './tools';\n\nfunction parseArgs(argv: string[]): { root?: string; output?: string } {\n  const result: { root?: string; output?: string } = {};\n  for (let i = 0; i < argv.length; i++) {\n    const arg = argv[i];\n    if (arg.startsWith('--root=')) {\n      result.root = arg.slice('--root='.length);\n    } else if (arg === '--root' && argv[i + 1]) {\n      result.root = argv[++i];\n    } else if (arg.startsWith('--output=')) {\n      result.output = arg.slice('--output='.length);\n    } else if (arg === '--output' && argv[i + 1]) {\n      result.output = argv[++i];\n    }\n  }\n  return result;\n}\n\nfunction main() {\n  const args = parseArgs(process.argv.slice(2));\n  const repoRoot = args.root ? path.resolve(args.root) : process.cwd();\n  const result = generate_telemetry_panel(repoRoot, args.output);\n  // eslint-disable-next-line no-console\n  console.log(JSON.stringify(result, null, 2));\n}\n\nmain();\n\n",
    "symbols": [
      {
        "name": "parseArgs",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/generate_telemetry.ts",
        "startLine": 5,
        "endLine": 20
      },
      {
        "name": "main",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/generate_telemetry.ts",
        "startLine": 22,
        "endLine": 28
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/graph_store.ts",
    "content": "import Database from 'better-sqlite3';\nimport path from 'path';\n\nexport class GraphStore {\n  private db: Database.Database;\n  constructor(dbPath: string) {\n    const resolved = path.resolve(dbPath);\n    this.db = new Database(resolved);\n    this.bootstrap();\n  }\n  private bootstrap() {\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS files (\n        id INTEGER PRIMARY KEY,\n        path TEXT UNIQUE\n      );\n      CREATE TABLE IF NOT EXISTS symbols (\n        id INTEGER PRIMARY KEY,\n        file_id INTEGER,\n        name TEXT,\n        kind TEXT,\n        start_line INTEGER,\n        end_line INTEGER,\n        FOREIGN KEY(file_id) REFERENCES files(id)\n      );\n      CREATE TABLE IF NOT EXISTS edges (\n        from_file INTEGER,\n        to_file INTEGER,\n        kind TEXT,\n        UNIQUE(from_file, to_file, kind)\n      );\n    `);\n  }\n  listSymbols(file?: string) {\n    if (file) {\n      const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(file) as any;\n      if (!row) return [] as any[];\n      return this.db.prepare('SELECT name, kind, start_line AS startLine, end_line AS endLine FROM symbols WHERE file_id=?').all(row.id) as any[];\n    }\n    return this.db.prepare('SELECT f.path AS file, s.name, s.kind, s.start_line AS startLine, s.end_line AS endLine FROM symbols s JOIN files f ON s.file_id=f.id').all() as any[];\n  }\n  listImports(filePath: string): string[] {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return [];\n    const rows = this.db\n      .prepare('SELECT f.path AS path FROM edges e JOIN files f ON e.to_file=f.id WHERE e.from_file=?')\n      .all(row.id) as Array<{ path: string }>;\n    return rows.map(r => r.path);\n  }\n  listDependents(filePath: string): string[] {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return [];\n    const rows = this.db\n      .prepare('SELECT f.path AS path FROM edges e JOIN files f ON e.from_file=f.id WHERE e.to_file=?')\n      .all(row.id) as Array<{ path: string }>;\n    return rows.map(r => r.path);\n  }\n  findRefs(symbol: string) {\n    // Simple heuristic: return files that import the file containing the symbol\n    const fileRows = this.db.prepare('SELECT f.id, f.path, s.name FROM symbols s JOIN files f ON s.file_id=f.id WHERE s.name LIKE ?').all(`%${symbol}%`);\n    if (fileRows.length === 0) return [];\n    const fileIds = fileRows.map((r: any) => r.id);\n    const placeholders = fileIds.map(() => '?').join(',');\n    const refRows = this.db.prepare(`SELECT DISTINCT f2.path AS file FROM edges e JOIN files f1 ON e.to_file=f1.id JOIN files f2 ON e.from_file=f2.id WHERE e.kind='import' AND e.to_file IN (${placeholders})`).all(...fileIds) as any[];\n    return refRows as any[];\n  }\n  degree(filePath: string) {\n    const row = this.db.prepare('SELECT id FROM files WHERE path=?').get(filePath) as any;\n    if (!row) return 0;\n    const out = this.db.prepare('SELECT COUNT(*) AS c FROM edges WHERE from_file=?').get(row.id) as any;\n    const inn = this.db.prepare('SELECT COUNT(*) AS c FROM edges WHERE to_file=?').get(row.id) as any;\n    return (out?.c || 0) + (inn?.c || 0);\n  }\n}\n",
    "symbols": [
      {
        "name": "GraphStore",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/graph_store.ts",
        "startLine": 4,
        "endLine": 74
      },
      {
        "name": "GraphStore.bootstrap",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/graph_store.ts",
        "startLine": 11,
        "endLine": 33
      },
      {
        "name": "GraphStore.listSymbols",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/graph_store.ts",
        "startLine": 34,
        "endLine": 41
      },
      {
        "name": "GraphStore.listImports",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/graph_store.ts",
        "startLine": 42,
        "endLine": 49
      },
      {
        "name": "GraphStore.listDependents",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/graph_store.ts",
        "startLine": 50,
        "endLine": 57
      },
      {
        "name": "GraphStore.findRefs",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/graph_store.ts",
        "startLine": 58,
        "endLine": 66
      },
      {
        "name": "GraphStore.degree",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/graph_store.ts",
        "startLine": 67,
        "endLine": 73
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/indexer.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport { Project, SyntaxKind } from 'ts-morph';\nimport madge from 'madge';\nimport { FileMeta, SymbolMeta, SemanticEntry } from '@mcp/shared';\nimport Database from 'better-sqlite3';\n\nfunction writeSQLite(dbPath: string, files: FileMeta[], imports: Array<{ from: string; to: string }>) {\n  // Ensure directory and file exist\n  try {\n    const dir = path.dirname(dbPath);\n    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n    if (!fs.existsSync(dbPath)) {\n      const fd = fs.openSync(dbPath, 'a');\n      fs.closeSync(fd);\n    }\n  } catch {}\n  const db = new Database(dbPath);\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS files (\n      id INTEGER PRIMARY KEY,\n      path TEXT UNIQUE\n    );\n    CREATE TABLE IF NOT EXISTS symbols (\n      id INTEGER PRIMARY KEY,\n      file_id INTEGER,\n      name TEXT,\n      kind TEXT,\n      start_line INTEGER,\n      end_line INTEGER,\n      FOREIGN KEY(file_id) REFERENCES files(id)\n    );\n    CREATE TABLE IF NOT EXISTS edges (\n      from_file INTEGER,\n      to_file INTEGER,\n      kind TEXT,\n      UNIQUE(from_file, to_file, kind)\n    );\n  `);\n  db.exec('BEGIN');\n  db.exec('DELETE FROM edges; DELETE FROM symbols; DELETE FROM files;');\n  const insertFile = db.prepare('INSERT OR IGNORE INTO files(path) VALUES (?)');\n  const getFileId = db.prepare('SELECT id FROM files WHERE path=?');\n  const insertSym = db.prepare('INSERT INTO symbols(file_id,name,kind,start_line,end_line) VALUES (?,?,?,?,?)');\n  for (const f of files) {\n    insertFile.run(f.path);\n    const row = getFileId.get(f.path) as any;\n    for (const s of f.symbols) insertSym.run(row.id, s.name, s.kind, s.startLine, s.endLine);\n  }\n  const insertEdge = db.prepare('INSERT OR IGNORE INTO edges(from_file,to_file,kind) VALUES (?,?,?)');\n  for (const e of imports) {\n    const fromRow = getFileId.get(e.from) as any;\n    const toRow = getFileId.get(e.to) as any;\n    if (fromRow && toRow) insertEdge.run(fromRow.id, toRow.id, 'import');\n  }\n  db.exec('COMMIT');\n  db.close();\n}\n\nfunction buildEdgesWithTsMorph(project: Project, rootDir: string): Array<{ from: string; to: string }> {\n  const edges: Array<{ from: string; to: string }> = [];\n  const files = project.getSourceFiles();\n  // Debug root info if needed\n  try {\n    const info = `rootDir=${rootDir}\\nfirstFile=${files[0]?.getFilePath()}`;\n    const out = path.join(process.cwd(), 'data', 'edges_info.txt');\n    fs.mkdirSync(path.dirname(out), { recursive: true });\n    fs.writeFileSync(out, info, 'utf8');\n  } catch {}\n  for (const sf of files) {\n    const fromAbs = sf.getFilePath();\n    const fromRel = path.relative(rootDir, fromAbs).replace(/\\\\/g, '/');\n    // import declarations\n    for (const imp of sf.getImportDeclarations()) {\n      const target = imp.getModuleSpecifierSourceFile();\n      if (!target) continue;\n      const toAbs = target.getFilePath();\n      if (!toAbs.startsWith(rootDir)) continue;\n      const toRel = path.relative(rootDir, toAbs).replace(/\\\\/g, '/');\n      if (fromRel !== toRel) edges.push({ from: fromRel, to: toRel });\n    }\n    // export declarations (re-exports)\n    for (const exp of sf.getExportDeclarations()) {\n      const target = exp.getModuleSpecifierSourceFile();\n      if (!target) continue;\n      const toAbs = target.getFilePath();\n      if (!toAbs.startsWith(rootDir)) continue;\n      const toRel = path.relative(rootDir, toAbs).replace(/\\\\/g, '/');\n      if (fromRel !== toRel) edges.push({ from: fromRel, to: toRel });\n    }\n  }\n  // de-duplicate\n  const key = (e: { from: string; to: string }) => `${e.from}=>${e.to}`;\n  const map = new Map<string, { from: string; to: string }>();\n  for (const e of edges) map.set(key(e), e);\n  return Array.from(map.values());\n}\n\nfunction resolveTsConfig(): string | undefined {\n  const envPath = process.env.TS_CONFIG_PATH;\n  if (envPath && fs.existsSync(envPath)) return envPath;\n  // Prefer the package-local tsconfig to avoid relying on process.cwd()\n  const pkgTs = path.resolve(__dirname, '..', 'tsconfig.json');\n  if (fs.existsSync(pkgTs)) return pkgTs;\n  // Next, try repository root tsconfig relative to this file\n  const repoRootTs = path.resolve(__dirname, '..', '..', '..', 'tsconfig.json');\n  if (fs.existsSync(repoRootTs)) return repoRootTs;\n  // Finally, try current working directory only if it actually exists\n  const cwdTs = path.resolve(process.cwd(), 'tsconfig.json');\n  if (fs.existsSync(cwdTs)) return cwdTs;\n  return undefined;\n}\n\nexport async function runIndexer(rootDir: string, outDir: string, sqlitePath?: string) {\n  const tsConfigPath = resolveTsConfig();\n  let project: Project;\n  try {\n    project = tsConfigPath\n      ? new Project({ tsConfigFilePath: tsConfigPath })\n      : new Project({ skipAddingFilesFromTsConfig: true });\n  } catch {\n    // Fall back to a minimal config that avoids reading any tsconfig\n    project = new Project({ skipAddingFilesFromTsConfig: true });\n  }\n  const tsFiles = project.addSourceFilesAtPaths([path.join(rootDir, '**/*.ts'), '!' + path.join(rootDir, '**/*.d.ts')]);\n  const fileMetas: FileMeta[] = [];\n  const semanticEntries: SemanticEntry[] = [];\n  for (const sf of tsFiles) {\n    const fullPath = sf.getFilePath();\n    const content = sf.getFullText();\n    const symbols: SymbolMeta[] = [];\n    sf.forEachDescendant(node => {\n      if (node.getKind() === SyntaxKind.FunctionDeclaration) {\n        const fn = node.asKind(SyntaxKind.FunctionDeclaration)!;\n        const name = fn.getName();\n        if (name) {\n          const start = fn.getStartLineNumber();\n          const end = fn.getEndLineNumber();\n          symbols.push({ name, kind: 'function', file: fullPath, startLine: start, endLine: end });\n        }\n      } else if (node.getKind() === SyntaxKind.ClassDeclaration) {\n        const cls = node.asKind(SyntaxKind.ClassDeclaration)!;\n        const name = cls.getName();\n        if (name) {\n          const start = cls.getStartLineNumber();\n          const end = cls.getEndLineNumber();\n          symbols.push({ name, kind: 'class', file: fullPath, startLine: start, endLine: end });\n          for (const m of cls.getMethods()) {\n            symbols.push({ name: `${name}.${m.getName()}`, kind: 'method', file: fullPath, startLine: m.getStartLineNumber(), endLine: m.getEndLineNumber() });\n          }\n        }\n      }\n    });\n    const relativePath = path.relative(rootDir, fullPath).replace(/\\\\/g, '/');\n    const fm: FileMeta = { path: relativePath, content, symbols };\n    fileMetas.push(fm);\n    const lines = content.split(/\\r?\\n/);\n    for (const s of symbols) {\n      const snippet = lines.slice(s.startLine - 1, s.endLine).join('\\n');\n      semanticEntries.push({ id: `${s.file}:${s.name}`, file: relativePath, symbol: s.name, startLine: s.startLine, endLine: s.endLine, text: snippet });\n    }\n  }\n  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });\n  fs.writeFileSync(path.join(outDir, 'index.json'), JSON.stringify(fileMetas, null, 2), 'utf8');\n  fs.writeFileSync(path.join(outDir, 'semantic_entries.json'), JSON.stringify(semanticEntries, null, 2), 'utf8');\n\n  // Build edges via madge (best-effort)\n  let edges: Array<{ from: string; to: string }> = [];\n  try {\n    const result = await madge(rootDir, {\n      fileExtensions: ['ts', 'tsx', 'js', 'jsx'],\n      // Provide a stable tsconfig path that actually exists\n      tsConfig: (tsConfigPath && fs.existsSync(tsConfigPath))\n        ? tsConfigPath\n        : path.resolve(__dirname, '..', 'tsconfig.json'),\n      detectiveOptions: { ts: { skipTypeImports: true } } as any,\n      includeNpm: false,\n      baseDir: rootDir,\n    } as any);\n    const graph = await result.obj();\n    for (const [from, tos] of Object.entries(graph)) {\n      const fromAbs = path.isAbsolute(from) ? from : path.resolve(rootDir, from);\n      const fromRel = path.relative(rootDir, fromAbs).replace(/\\\\/g, '/');\n      for (const to of tos as string[]) {\n        const toAbs = path.isAbsolute(to) ? to : path.resolve(rootDir, to);\n        const toRel = path.relative(rootDir, toAbs).replace(/\\\\/g, '/');\n        if (fromRel && toRel && fromRel !== toRel) edges.push({ from: fromRel, to: toRel });\n      }\n    }\n  } catch {\n    // ignore madge errors; fallback to ts-morph\n  }\n\n  // Fallback/union with ts-morph derived edges\n  const morphEdges = buildEdgesWithTsMorph(project, rootDir);\n  const existing = new Set(edges.map(e => `${e.from}=>${e.to}`));\n  for (const e of morphEdges) if (!existing.has(`${e.from}=>${e.to}`)) edges.push(e);\n  // Debug: dump edges\n  try { fs.writeFileSync(path.join(outDir, 'edges.json'), JSON.stringify(edges, null, 2), 'utf8'); } catch {}\n  if (sqlitePath) writeSQLite(sqlitePath, fileMetas, edges);\n}\n\nif (require.main === module) {\n  const rootDir = path.join(process.cwd(), 'src');\n  const outDir = path.join(process.cwd(), 'data');\n  const sqlite = path.join(outDir, 'graph.db');\n  runIndexer(rootDir, outDir, sqlite).then(() => console.log('Indexing (monorepo) complete.'));\n}\n",
    "symbols": [
      {
        "name": "writeSQLite",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/indexer.ts",
        "startLine": 8,
        "endLine": 58
      },
      {
        "name": "buildEdgesWithTsMorph",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/indexer.ts",
        "startLine": 60,
        "endLine": 97
      },
      {
        "name": "resolveTsConfig",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/indexer.ts",
        "startLine": 99,
        "endLine": 112
      },
      {
        "name": "runIndexer",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/indexer.ts",
        "startLine": 114,
        "endLine": 201
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/index_cli.ts",
    "content": "import path from 'path';\nimport fs from 'fs';\nimport { runIndexer } from './indexer';\n\nasync function main() {\n  const envRoot = process.env.INDEX_ROOT || process.env.MCP_INDEX_ROOT || process.env.WORKSPACE_ROOT;\n  const envData = process.env.DATA_DIR || process.env.MCP_DATA_DIR;\n  const rootDir = envRoot ? path.resolve(envRoot) : process.cwd();\n  const outDir = envData ? path.resolve(envData) : path.join(process.cwd(), 'data');\n  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });\n  const sqlite = path.join(outDir, 'graph.db');\n  await runIndexer(rootDir, outDir, sqlite);\n  // Also set env so any subsequent child tools could reuse\n  process.env.DATA_DIR = outDir;\n  process.env.SQLITE_DB = sqlite;\n}\n\nmain().then(() => console.log('Indexing complete.'), err => { console.error(err?.message || String(err)); process.exit(1); });\n\n",
    "symbols": [
      {
        "name": "main",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/index_cli.ts",
        "startLine": 5,
        "endLine": 16
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/job_queue.ts",
    "content": "import { Queue, Worker, JobsOptions } from 'bullmq';\nimport IORedis from 'ioredis';\nimport { runIndexer } from './indexer';\n\nexport function createQueue(name = 'mcp-jobs', connection?: string) {\n  const conn = connection ? new IORedis(connection) : undefined;\n  const queue = new Queue(name, { connection: conn as any });\n  return queue;\n}\n\nexport function startWorker(name = 'mcp-jobs', connection?: string) {\n  const conn = connection ? new IORedis(connection) : undefined;\n  const worker = new Worker(name, async job => {\n    if (job.name === 'reindex') {\n      const { rootDir, outDir, sqlite } = job.data as { rootDir: string; outDir: string; sqlite: string };\n      await runIndexer(rootDir, outDir, sqlite);\n    }\n  }, { connection: conn as any });\n  return worker;\n}\n\nexport async function enqueueReindex(queue: Queue, payload: { rootDir: string; outDir: string; sqlite: string }, opts?: JobsOptions) {\n  await queue.add('reindex', payload, opts);\n}\n\n",
    "symbols": [
      {
        "name": "createQueue",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/job_queue.ts",
        "startLine": 5,
        "endLine": 9
      },
      {
        "name": "startWorker",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/job_queue.ts",
        "startLine": 11,
        "endLine": 20
      },
      {
        "name": "enqueueReindex",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/job_queue.ts",
        "startLine": 22,
        "endLine": 24
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/langchain_bridge.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\ninterface SemanticEntry {\n  id: string;\n  file: string;\n  symbol: string;\n  text: string;\n}\n\ninterface BridgeResult {\n  id: string;\n  file: string;\n  symbol: string;\n  score: number;\n  snippet: string;\n}\n\nexport class LangChainBridge {\n  private entries: SemanticEntry[] = [];\n  private available = false;\n  private reason = 'langchain package not detected';\n\n  constructor(private dataDir: string) {\n    this.loadEntries();\n    this.detectLangChain();\n  }\n\n  private loadEntries() {\n    const semanticPath = path.join(this.dataDir, 'semantic_entries.json');\n    if (!fs.existsSync(semanticPath)) return;\n    try {\n      const parsed = JSON.parse(fs.readFileSync(semanticPath, 'utf8')) as Array<any>;\n      this.entries = parsed.map(e => ({\n        id: String(e.id ?? `${e.file}:${e.symbol}`),\n        file: String(e.file),\n        symbol: String(e.symbol),\n        text: String(e.text ?? ''),\n      }));\n    } catch {\n      this.entries = [];\n    }\n  }\n\n  private detectLangChain() {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      require.resolve('langchain');\n      this.available = true;\n      this.reason = '';\n    } catch {\n      this.available = false;\n    }\n  }\n\n  private lexicalQuery(query: string, topK: number): BridgeResult[] {\n    const tokens = query\n      .toLowerCase()\n      .split(/\\W+/)\n      .filter(Boolean);\n    const scored = this.entries.map(entry => {\n      const text = entry.text.toLowerCase();\n      let hits = 0;\n      for (const token of tokens) {\n        if (text.includes(token)) hits += 1;\n      }\n      const score = tokens.length ? hits / tokens.length : 0;\n      return {\n        id: entry.id,\n        file: entry.file,\n        symbol: entry.symbol,\n        score,\n        snippet: entry.text.slice(0, 200),\n      };\n    });\n    return scored\n      .sort((a, b) => b.score - a.score)\n      .slice(0, Math.max(1, Math.min(topK, scored.length)));\n  }\n\n  async query(query: string, topK: number): Promise<{ available: boolean; provider: 'langchain' | 'fallback'; reason?: string; results: BridgeResult[] }> {\n    if (!this.entries.length) {\n      return {\n        available: this.available,\n        provider: this.available ? 'langchain' : 'fallback',\n        reason: this.entries.length ? undefined : 'semantic_entries.json not found or empty',\n        results: [],\n      };\n    }\n\n    if (!this.available) {\n      return {\n        available: false,\n        provider: 'fallback',\n        reason: this.reason,\n        results: this.lexicalQuery(query, topK),\n      };\n    }\n\n    // Placeholder for real LangChain integration. Until dependencies are present,\n    // fall back to lexical scoring while reporting availability.\n    return {\n      available: true,\n      provider: 'langchain',\n      reason: 'LangChain detected but no vector store configured; using lexical fallback.',\n      results: this.lexicalQuery(query, topK),\n    };\n  }\n}\n\n",
    "symbols": [
      {
        "name": "LangChainBridge",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/langchain_bridge.ts",
        "startLine": 19,
        "endLine": 109
      },
      {
        "name": "LangChainBridge.loadEntries",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/langchain_bridge.ts",
        "startLine": 29,
        "endLine": 43
      },
      {
        "name": "LangChainBridge.detectLangChain",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/langchain_bridge.ts",
        "startLine": 45,
        "endLine": 54
      },
      {
        "name": "LangChainBridge.lexicalQuery",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/langchain_bridge.ts",
        "startLine": 56,
        "endLine": 79
      },
      {
        "name": "LangChainBridge.query",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/langchain_bridge.ts",
        "startLine": 81,
        "endLine": 108
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/launch_mcp.ts",
    "content": "import path from 'path';\nimport fs from 'fs';\nimport http from 'http';\nimport net from 'net';\nimport type { FSWatcher } from 'chokidar';\nimport { spawn, execSync } from 'child_process';\nimport { runIndexer } from './indexer';\nimport { startWatcher } from './watcher';\n\nasync function ensureIndex(rootDir: string, outDir: string, sqlite: string) {\n  await runIndexer(rootDir, outDir, sqlite);\n}\n\nfunction tryStartMemurai() {\n  try {\n    // Start Memurai service if installed; ignore failures.\n    if (process.platform === 'win32') {\n      execSync('powershell -NoProfile -Command \"$s=Get-Service -Name Memurai* -ErrorAction SilentlyContinue | Select-Object -First 1; if ($s -and $s.Status -ne \\\"Running\\\") { Start-Service -InputObject $s }\"', { stdio: 'ignore' });\n    }\n  } catch {}\n}\n\nfunction checkPortFree(port: number): Promise<boolean> {\n  return new Promise(resolve => {\n    const srv = net.createServer();\n    srv.once('error', () => resolve(false));\n    srv.once('listening', () => { srv.close(() => resolve(true)); });\n    srv.listen(port, '127.0.0.1');\n  });\n}\n\nasync function findFreePort(start: number, max: number): Promise<number> {\n  for (let p = start; p <= max; p++) {\n    // eslint-disable-next-line no-await-in-loop\n    if (await checkPortFree(p)) return p;\n  }\n  return start;\n}\n\nfunction waitForHealth(url: string, attempts = 30, delayMs = 500): Promise<void> {\n  return new Promise((resolve, reject) => {\n    let tries = 0;\n    const tick = () => {\n      tries++;\n      const req = http.get(url, res => {\n        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\n          res.resume();\n          resolve();\n        } else {\n          res.resume();\n          if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health timeout'));\n        }\n      });\n      req.on('error', () => { if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health error')); });\n    };\n    tick();\n  });\n}\n\nasync function startFastApi(dataDir: string, port: number) {\n  const script = path.join(process.cwd(), 'packages', 'semantic-engine', 'semantic_engine_fastapi.py');\n  const env = { ...process.env, DATA_DIR: dataDir, ENGINE_PORT: String(port) };\n  // Quick preflight to ensure python + fastapi are usable; if not, throw and fallback\n  try {\n    execSync('python -V', { stdio: 'ignore' });\n    execSync('python -c \"import fastapi,uvicorn\"', { stdio: 'ignore' });\n  } catch {\n    throw new Error('python or fastapi/uvicorn not available');\n  }\n  const proc = spawn('python', [script], { env, stdio: 'ignore', windowsHide: true });\n  await waitForHealth(`http://127.0.0.1:${port}/health`, 40, 500);\n  return proc;\n}\n\nfunction startLocalNodeEngine(dataDir: string, port: number) {\n  // Minimal in-process engine with /health and /search using naive scoring\n  const entriesPath = path.join(dataDir, 'semantic_entries.json');\n  let entries: Array<{ id: string; file: string; symbol: string; startLine: number; endLine: number; text: string }> = [];\n  try {\n    const raw = fs.readFileSync(entriesPath, 'utf8');\n    entries = JSON.parse(raw);\n  } catch {\n    entries = [];\n  }\n  const server = http.createServer((req, res) => {\n    try {\n      const url = new URL(req.url || '/', `http://127.0.0.1:${port}`);\n      if (url.pathname === '/health') {\n        res.writeHead(200, { 'content-type': 'application/json' });\n        res.end(JSON.stringify({ ok: true }));\n        return;\n      }\n      if (url.pathname === '/search') {\n        const q = (url.searchParams.get('q') || '').toLowerCase();\n        const topK = Math.max(1, Math.min(50, Number(url.searchParams.get('top_k') || '5')));\n        const scored = entries.map(e => {\n          const text = (e.text || '').toLowerCase();\n          let score = 0;\n          if (q) {\n            // naive: frequency of query tokens present\n            const tokens = q.split(/\\s+/).filter(Boolean);\n            for (const t of tokens) {\n              if (!t) continue;\n              const matches = text.split(t).length - 1;\n              score += matches;\n            }\n          }\n          return { file: e.file, symbol: e.symbol, startLine: e.startLine, endLine: e.endLine, score, snippet: e.text?.slice(0, 200) || '' };\n        }).sort((a, b) => b.score - a.score).slice(0, topK);\n        res.writeHead(200, { 'content-type': 'application/json' });\n        res.end(JSON.stringify({ query: q, results: scored }));\n        return;\n      }\n      res.writeHead(404);\n      res.end();\n    } catch (e) {\n      res.writeHead(500);\n      res.end();\n    }\n  });\n  server.listen(port, '127.0.0.1');\n  return server;\n}\n\n(async () => {\n  if (process.env.MCP_STDOUT_LOGS !== '1') {\n    const passThrough = (stream: 'log' | 'info' | 'warn') => (...args: unknown[]) =>\n      console.error(`[${stream}]`, ...args);\n    console.log = passThrough('log');\n    console.info = passThrough('info');\n    console.warn = passThrough('warn');\n  }\n\n  const fastStart = (process.env.MCP_FAST_START === '1' || process.env.FAST_START === '1');\n  tryStartMemurai();\n\n  const envRoot = process.env.INDEX_ROOT || process.env.MCP_INDEX_ROOT;\n  const envData = process.env.DATA_DIR || process.env.MCP_DATA_DIR;\n  const rootDir = envRoot ? path.resolve(envRoot) : path.join(__dirname, '..', 'src');\n  const dataDir = envData ? path.resolve(envData) : path.join(__dirname, '..', 'data');\n  const sqlitePath = path.join(dataDir, 'graph.db');\n  process.env.DATA_DIR = dataDir;\n  process.env.SQLITE_DB = sqlitePath;\n\n  const port = await findFreePort(8010, 8020);\n  let engineCleanup: (() => void) | null = null;\n  const engineUrl = `http://127.0.0.1:${port}`;\n  let watcher: FSWatcher | null = null;\n\n  const startIndexWatcher = () => {\n    if (!watcher) {\n      try {\n        watcher = startWatcher(rootDir, dataDir, sqlitePath);\n      } catch (err) {\n        if (process.env.DEBUG_WATCHER) {\n          // eslint-disable-next-line no-console\n          console.warn('[mcp] watcher failed to start', err);\n        }\n      }\n    }\n  };\n  const ensureFreshIndex = async () => {\n    await ensureIndex(rootDir, dataDir, sqlitePath);\n  };\n\n  if (fastStart) {\n    // Start local engine immediately and bind adapter without waiting for index\n    const srv = startLocalNodeEngine(dataDir, port);\n    engineCleanup = () => { try { srv.close(); } catch {} };\n    process.env.ENGINE_URL = engineUrl;\n\n    // Bind stdio adapter ASAP\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    require('./mcp_adapter');\n\n    startIndexWatcher();\n\n    // Index in background\n    setImmediate(async () => { try { await ensureFreshIndex(); } catch {} });\n  } else {\n    await ensureFreshIndex();\n    startIndexWatcher();\n    try {\n      const engineProc = await startFastApi(dataDir, port);\n      engineCleanup = () => { try { engineProc.kill(); } catch {} };\n    } catch {\n      const srv = startLocalNodeEngine(dataDir, port);\n      engineCleanup = () => { try { srv.close(); } catch {} };\n    }\n    process.env.ENGINE_URL = engineUrl;\n\n    // Bind stdio adapter\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    require('./mcp_adapter');\n  }\n\n  const shutdown = () => {\n    try { engineCleanup && engineCleanup(); } catch {}\n    try {\n      if (watcher) {\n        watcher.close().catch(() => undefined);\n      }\n    } catch {}\n    process.exit(0);\n  };\n  process.on('SIGINT', shutdown);\n  process.on('SIGTERM', shutdown);\n})();\n",
    "symbols": [
      {
        "name": "ensureIndex",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp.ts",
        "startLine": 10,
        "endLine": 12
      },
      {
        "name": "tryStartMemurai",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp.ts",
        "startLine": 14,
        "endLine": 21
      },
      {
        "name": "checkPortFree",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp.ts",
        "startLine": 23,
        "endLine": 30
      },
      {
        "name": "findFreePort",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp.ts",
        "startLine": 32,
        "endLine": 38
      },
      {
        "name": "waitForHealth",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp.ts",
        "startLine": 40,
        "endLine": 58
      },
      {
        "name": "startFastApi",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp.ts",
        "startLine": 60,
        "endLine": 73
      },
      {
        "name": "startLocalNodeEngine",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp.ts",
        "startLine": 75,
        "endLine": 123
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/launch_mcp_http.ts",
    "content": "import path from 'path';\nimport { spawn, execSync } from 'child_process';\nimport http from 'http';\nimport { runIndexer } from './indexer';\nimport { startMcpHttpBridge } from './mcp_http_bridge';\n\nasync function ensureIndex() {\n  const envRoot = process.env.INDEX_ROOT || process.env.MCP_INDEX_ROOT;\n  const envData = process.env.DATA_DIR;\n  const rootDir = envRoot ? path.resolve(envRoot) : path.join(__dirname, '..', 'src');\n  const outDir = envData ? path.resolve(envData) : path.join(__dirname, '..', 'data');\n  const sqlite = path.join(outDir, 'graph.db');\n  await runIndexer(rootDir, outDir, sqlite);\n}\n\nfunction waitForHealth(url: string, attempts = 30, delayMs = 500): Promise<void> {\n  return new Promise((resolve, reject) => {\n    let tries = 0;\n    const tick = () => {\n      tries++;\n      const req = http.get(url, res => {\n        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\n          res.resume(); resolve();\n        } else { res.resume(); if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health timeout')); }\n      });\n      req.on('error', () => { if (tries < attempts) setTimeout(tick, delayMs); else reject(new Error('health error')); });\n    };\n    tick();\n  });\n}\n\nasync function startFastApi(dataDir: string, port: number) {\n  const script = path.join(process.cwd(), 'packages', 'semantic-engine', 'semantic_engine_fastapi.py');\n  const env = { ...process.env, DATA_DIR: dataDir, ENGINE_PORT: String(port) };\n  try { execSync('python -V', { stdio: 'ignore' }); execSync('python -c \"import fastapi,uvicorn\"', { stdio: 'ignore' }); }\n  catch { throw new Error('python or fastapi/uvicorn not available'); }\n  const proc = spawn('python', [script], { env, stdio: 'ignore', windowsHide: true });\n  await waitForHealth(`http://127.0.0.1:${port}/health`, 40, 500);\n  return proc;\n}\n\n(async () => {\n  await ensureIndex();\n  const dataDir = process.env.DATA_DIR ? path.resolve(process.env.DATA_DIR) : path.join(__dirname, '..', 'data');\n  // Start engine or proceed (fallback handled by orchestrator if not reachable)\n  let engineCleanup: (() => void) | null = null;\n  try {\n    const engineProc = await startFastApi(dataDir, 8010);\n    engineCleanup = () => { try { engineProc.kill(); } catch {} };\n    process.env.ENGINE_URL = `http://127.0.0.1:8010`;\n  } catch {\n    process.env.ENGINE_URL = process.env.ENGINE_URL || 'http://127.0.0.1:8000';\n  }\n  process.env.DATA_DIR = dataDir;\n  process.env.SQLITE_DB = path.join(dataDir, 'graph.db');\n\n  const port = parseInt(process.env.MCP_HTTP_PORT || '7450', 10);\n  const { server, child } = startMcpHttpBridge(port);\n  // eslint-disable-next-line no-console\n  console.log(`MCP HTTP bridge listening at http://127.0.0.1:${port}/mcp`);\n\n  const shutdown = () => {\n    try { server.close(); } catch {}\n    try { child.kill(); } catch {}\n    try { engineCleanup && engineCleanup(); } catch {}\n    process.exit(0);\n  };\n  process.on('SIGINT', shutdown);\n  process.on('SIGTERM', shutdown);\n})();\n",
    "symbols": [
      {
        "name": "ensureIndex",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp_http.ts",
        "startLine": 7,
        "endLine": 14
      },
      {
        "name": "waitForHealth",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp_http.ts",
        "startLine": 16,
        "endLine": 30
      },
      {
        "name": "startFastApi",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/launch_mcp_http.ts",
        "startLine": 32,
        "endLine": 40
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/mcp.ts",
    "content": "/**\n * Minimal MCP JSON-RPC (stdio) server exposing core tools.\n * Methods:\n *  - search_code(q: string, top_k?: number)\n *  - get_file(path: string)\n *  - list_symbols(file?: string)\n */\nimport readline from 'readline';\nimport path from 'path';\nimport { Orchestrator } from './orchestrator';\nimport { GraphStore } from './graph_store';\nimport { startTimer } from './telemetry';\nimport {\n  summarize_architecture,\n  detect_smells,\n  suggest_tests,\n  plan_refactor,\n  generate_patch,\n  apply_patch as applyPatchOperations,\n  analyze_performance,\n  compare_versions,\n  auto_docs,\n  run_tests,\n  run_task,\n  generate_telemetry_panel,\n  langchain_query,\n  open_telemetry_webview,\n} from './tools';\nimport { set_weights } from './ranker';\nimport { WeightManager } from './weights';\n\nconst DATA_DIR = process.env.DATA_DIR || process.cwd() + '/data';\nconst ENGINE_URL = process.env.ENGINE_URL || 'http://localhost:8000';\nconst orchestrator = new Orchestrator(DATA_DIR, ENGINE_URL);\nconst graph = new GraphStore(process.env.SQLITE_DB || (process.cwd() + '/data/graph.db'));\nconst wm = new WeightManager();\nset_weights(wm.get());\n\ntype Json = any;\n\ninterface RpcRequest {\n  jsonrpc: '2.0';\n  id: string | number | null;\n  method: string;\n  params?: Json;\n}\n\nfunction respond(id: RpcRequest['id'], result?: Json, error?: { code: number; message: string }) {\n  const payload: any = { jsonrpc: '2.0', id };\n  if (error) payload.error = error; else payload.result = result ?? null;\n  process.stdout.write(JSON.stringify(payload) + '\\n');\n}\n\nasync function handle(req: RpcRequest) {\n  try {\n    switch (req.method) {\n      case 'search_code': {\n        const stop = startTimer('search_code', { source: 'mcp:tools' });\n        const q = String(req.params?.q ?? '');\n        const topK = Number(req.params?.top_k ?? 5);\n        const results = await orchestrator.searchCode(q, topK);\n        const profile = orchestrator.getLastProfile();\n        respond(req.id, { query: q, profile, results });\n        stop({ query_length: q.length, result_count: results.length, top_k: topK, intent: profile?.intent });\n        return;\n      }\n      case 'get_file': {\n        const stop = startTimer('get_file', { source: 'mcp:tools' });\n        const filePath = String(req.params?.path ?? '');\n        const content = orchestrator.getFile(filePath);\n        respond(req.id, { path: filePath, content });\n        stop({ path: filePath, content_length: content.length });\n        return;\n      }\n      case 'list_symbols': {\n        const file = req.params?.file ? String(req.params.file) : undefined;\n        const symbols = graph.listSymbols(file);\n        respond(req.id, symbols);\n        return;\n      }\n      case 'find_refs': {\n        const symbol = String(req.params?.symbol ?? '');\n        const refs = graph.findRefs(symbol);\n        respond(req.id, refs);\n        return;\n      }\n      case 'plan_refactor': {\n        const file = req.params?.file ? String(req.params.file) : undefined;\n        const symbol = req.params?.symbol ? String(req.params.symbol) : undefined;\n        const goal = req.params?.goal ? String(req.params.goal) : undefined;\n        const plan = plan_refactor(orchestrator, graph, process.cwd(), { file, symbol, goal });\n        respond(req.id, plan);\n        return;\n      }\n      case 'gen_patch': {\n        const file = String(req.params?.path ?? '');\n        const operations = Array.isArray(req.params?.operations) ? (req.params.operations as any[]) : [];\n        const patch = generate_patch(process.cwd(), file, operations);\n        respond(req.id, patch);\n        return;\n      }\n      case 'apply_patch': {\n        const file = String(req.params?.path ?? '');\n        const operations = Array.isArray(req.params?.operations) ? (req.params.operations as any[]) : [];\n        const result = applyPatchOperations(process.cwd(), file, operations);\n        respond(req.id, result);\n        return;\n      }\n      case 'analyze_performance': {\n        const file = String(req.params?.path ?? '');\n        const insight = analyze_performance(process.cwd(), file);\n        respond(req.id, insight);\n        return;\n      }\n      case 'compare_versions': {\n        const pathA = String(req.params?.pathA ?? '');\n        const pathB = String(req.params?.pathB ?? '');\n        const diff = compare_versions(process.cwd(), pathA, pathB);\n        respond(req.id, diff);\n        return;\n      }\n      case 'auto_docs': {\n        const file = String(req.params?.path ?? '');\n        const docs = auto_docs(orchestrator, graph, process.cwd(), file);\n        respond(req.id, docs);\n        return;\n      }\n      case 'run_tests': {\n        const command = req.params?.command ? String(req.params.command) : 'npm test';\n        const outcome = run_tests(process.cwd(), command);\n        respond(req.id, outcome);\n        return;\n      }\n      case 'run_task': {\n        const script = String(req.params?.script ?? '');\n        const outcome = run_task(process.cwd(), script);\n        respond(req.id, outcome);\n        return;\n      }\n      case 'generate_telemetry_panel': {\n        const output = req.params?.output ? String(req.params.output) : undefined;\n        const panel = generate_telemetry_panel(process.cwd(), output);\n        respond(req.id, panel);\n        return;\n      }\n      case 'open_telemetry_webview': {\n        const regenerate = req.params?.regenerate === true;\n        const output = req.params?.output ? String(req.params.output) : undefined;\n        const webview = open_telemetry_webview(process.cwd(), { regenerate, output });\n        respond(req.id, webview);\n        return;\n      }\n      case 'langchain_query': {\n        const query = String(req.params?.q ?? '');\n        const topK = Number(req.params?.top_k ?? 5);\n        const dataDir = process.env.DATA_DIR || path.join(process.cwd(), 'data');\n        langchain_query(dataDir, query, topK)\n          .then(result => respond(req.id, result))\n          .catch(err => respond(req.id, undefined, { code: -32000, message: err?.message || 'LangChain query failed' }));\n        return;\n      }\n      case 'summarize_architecture': {\n        const summary = summarize_architecture(graph);\n        respond(req.id, summary);\n        return;\n      }\n      case 'detect_smells': {\n        const repo = String(req.params?.root ?? process.cwd());\n        const res = detect_smells(repo);\n        respond(req.id, res);\n        return;\n      }\n      case 'suggest_tests': {\n        const symbols = (req.params?.symbols ?? []) as Array<{ file: string; name: string }>;\n        const suggestions = suggest_tests(symbols);\n        respond(req.id, suggestions);\n        return;\n      }\n      case 'submit_feedback': {\n        const kind = String(req.params?.kind ?? 'up');\n        wm.feedback(kind === 'down' ? 'down' : 'up');\n        set_weights(wm.get());\n        respond(req.id, { ok: true, weights: wm.get() });\n        return;\n      }\n      case 'get_weights': {\n        respond(req.id, wm.get());\n        return;\n      }\n      default:\n        respond(req.id, undefined, { code: -32601, message: 'Method not found' });\n    }\n  } catch (e: any) {\n    respond(req.id, undefined, { code: -32000, message: e?.message || 'Internal error' });\n  }\n}\n\nconst rl = readline.createInterface({ input: process.stdin, output: process.stdout, terminal: false });\nrl.on('line', line => {\n  if (!line.trim()) return;\n  try {\n    const req = JSON.parse(line) as RpcRequest;\n    if (req && req.jsonrpc === '2.0' && req.method) {\n      handle(req);\n    }\n  } catch {\n    // ignore\n  }\n});\n\nprocess.on('SIGINT', () => process.exit(0));\n",
    "symbols": [
      {
        "name": "respond",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp.ts",
        "startLine": 48,
        "endLine": 52
      },
      {
        "name": "handle",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp.ts",
        "startLine": 54,
        "endLine": 196
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/mcp_adapter.ts",
    "content": "/**\n * Minimal MCP adapter implementing a subset of the Model Context Protocol\n * over stdio using JSON-RPC 2.0. Exposes tools via tools/list and tools/call.\n */\nimport readline from 'readline';\nimport fs from 'fs';\nimport path from 'path';\nimport { Orchestrator } from './orchestrator';\nimport { GraphStore } from './graph_store';\nimport {\n  summarize_architecture,\n  detect_smells,\n  suggest_tests,\n  plan_refactor,\n  generate_patch,\n  apply_patch as applyPatchOperations,\n  analyze_performance,\n  compare_versions,\n  auto_docs,\n  run_tests,\n  run_task,\n  generate_telemetry_panel,\n  langchain_query,\n  open_telemetry_webview,\n} from './tools';\nimport { allowPath } from './policy';\nimport { set_weights } from './ranker';\nimport { WeightManager } from './weights';\n\nconst DATA_DIR = process.env.DATA_DIR || process.cwd() + '/data';\nconst ENGINE_URL = process.env.ENGINE_URL || 'http://localhost:8000';\nconst SQLITE_DB = process.env.SQLITE_DB || (process.cwd() + '/data/graph.db');\n\nlet orchestrator: Orchestrator | null = null;\nlet graph: GraphStore | null = null;\nconst wm = new WeightManager();\nset_weights(wm.get());\n\nfunction getOrchestrator(): Orchestrator {\n  if (!orchestrator) {\n    const dir = process.env.DATA_DIR || DATA_DIR;\n    const url = process.env.ENGINE_URL || ENGINE_URL;\n    orchestrator = new Orchestrator(dir, url);\n  }\n  return orchestrator;\n}\n\nfunction getGraph(): GraphStore {\n  if (!graph) {\n    const db = process.env.SQLITE_DB || SQLITE_DB;\n    graph = new GraphStore(db);\n  }\n  return graph;\n}\n\ntype Json = any;\ninterface RpcRequest { \n  jsonrpc: '2.0'; \n  id: string | number | null; \n  method: string; \n  params?: Json;\n  msg?: {\n    type: string;\n    kind: string;\n    message: string;\n  };\n}\n\nfunction write(obj: any) { process.stdout.write(JSON.stringify(obj) + '\\n'); }\nfunction ok(id: RpcRequest['id'], result: any) { write({ jsonrpc: '2.0', id, result }); }\nfunction err(id: RpcRequest['id'], code: number, message: string, data?: any) {\n  const e: any = { code, message };\n  if (data) e.data = data;\n  write({ jsonrpc: '2.0', id, error: e });\n}\n\nconst INDEX_ROOT = process.env.INDEX_ROOT || process.env.MCP_INDEX_ROOT;\nconst ROOTS: string[] = Array.from(new Set([\n  process.cwd(),\n  path.resolve(DATA_DIR),\n  ...(INDEX_ROOT ? [path.resolve(INDEX_ROOT)] as string[] : [])\n]));\n\nfunction toFileUri(p: string): string {\n  const abs = path.resolve(p);\n  const withSlashes = abs.replace(/\\\\/g, '/');\n  // Ensure file:/// prefix with Windows drive support\n  if (/^[A-Za-z]:\\//.test(withSlashes)) {\n    return `file:///${withSlashes}`;\n  }\n  return `file://${withSlashes.startsWith('/') ? '' : '/'}${withSlashes}`;\n}\n\nfunction fromFileUri(u: string): string {\n  try {\n    if (!u.startsWith('file://')) return u;\n    const url = new URL(u);\n    let p = decodeURIComponent(url.pathname);\n    // Windows path like /C:/...\n    if (process.platform === 'win32' && /^\\/[A-Za-z]:\\//.test(p)) {\n      p = p.slice(1);\n    }\n    return path.normalize(p);\n  } catch {\n    return u;\n  }\n}\n\nfunction safeJoin(root: string, rel: string): string | null {\n  const p = path.resolve(root, rel);\n  if (!p.startsWith(path.resolve(root))) return null;\n  return p;\n}\n\nfunction listFiles(root: string, max = 200): string[] {\n  const out: string[] = [];\n  const stack: string[] = [root];\n  while (stack.length && out.length < max) {\n    const cur = stack.pop()!;\n    try {\n      const st = fs.statSync(cur);\n      if (st.isDirectory()) {\n        for (const name of fs.readdirSync(cur)) {\n          const full = path.join(cur, name);\n          try {\n            const s2 = fs.statSync(full);\n            if (s2.isDirectory()) stack.push(full);\n            else if (s2.isFile() && allowPath(full)) out.push(full);\n          } catch { }\n          if (out.length >= max) break;\n        }\n      } else if (st.isFile() && allowPath(cur)) out.push(cur);\n    } catch { }\n  }\n  return out;\n}\n\nconst MAX_PROMPT_SNIPPET_LINES = 40;\n\nfunction normalizeRepoPath(p: string): string {\n  return p.replace(/\\\\/g, '/');\n}\n\nfunction uniqueList(values: string[]): string[] {\n  const seen = new Set<string>();\n  const result: string[] = [];\n  for (const value of values) {\n    const normalized = normalizeRepoPath(value);\n    if (!seen.has(normalized)) {\n      seen.add(normalized);\n      result.push(normalized);\n    }\n  }\n  return result;\n}\n\nfunction filePreview(file: string, maxLines = MAX_PROMPT_SNIPPET_LINES): string {\n  try {\n    const content = getOrchestrator().getFile(file);\n    const lines = content.split(/\\r?\\n/).slice(0, maxLines);\n    return lines.join('\\n').trimEnd();\n  } catch {\n    return '';\n  }\n}\n\nfunction formatList(label: string, items: string[]): string {\n  const list = uniqueList(items).slice(0, 8);\n  if (!list.length) return '';\n  return `${label}:\\n${list.map(item => `- ${item}`).join('\\n')}`;\n}\n\nfunction buildPromptContext(args: { file?: string; symbol?: string; extraNote?: string }): string {\n  const segments: string[] = [];\n  const graph = getGraph();\n  const file = args.file ? normalizeRepoPath(String(args.file)) : undefined;\n  const symbol = args.symbol ? String(args.symbol) : undefined;\n\n  if (file) {\n    segments.push(`File Scope: ${file}`);\n    const symbols = graph.listSymbols(file).slice(0, 8).map((s: any) => `${s.kind}:${s.name} (L${s.startLine}-${s.endLine})`);\n    const imports = graph.listImports(file);\n    const dependents = graph.listDependents(file);\n    const preview = filePreview(file);\n    if (symbols.length) segments.push(formatList('Local symbols', symbols));\n    const importBlock = formatList('Imports', imports);\n    if (importBlock) segments.push(importBlock);\n    const dependentsBlock = formatList('Referenced by', dependents);\n    if (dependentsBlock) segments.push(dependentsBlock);\n    if (preview) {\n      const previewLines = preview.split(/\\r?\\n/).length;\n      segments.push(`File preview (first ${Math.min(previewLines, MAX_PROMPT_SNIPPET_LINES)} lines):\\n${preview}`);\n    }\n  }\n\n  if (symbol) {\n    segments.push(`Focus symbol: ${symbol}`);\n    const refs = (graph.findRefs(symbol) as Array<{ file?: string }> | undefined) ?? [];\n    const refList = uniqueList(refs.map(r => r.file || '').filter(Boolean));\n    if (refList.length) segments.push(formatList('Referenced in', refList));\n  }\n\n  if (args.extraNote) {\n    segments.push(`Additional notes: ${args.extraNote}`);\n  }\n\n  return segments.filter(Boolean).join('\\n\\n');\n}\n\nfunction buildPromptText(name: string, args: Record<string, unknown>): string | null {\n  const fileArg = typeof args.file === 'string' ? args.file : undefined;\n  const symbolArg = typeof args.symbol === 'string' ? args.symbol : undefined;\n  const userContext = typeof args.context === 'string' ? args.context : undefined;\n  const extra = typeof args.notes === 'string' ? args.notes : undefined;\n  const baseContext = buildPromptContext({ file: fileArg, symbol: symbolArg, extraNote: extra });\n\n  const sections: string[] = [];\n  switch (name) {\n    case 'refactor': {\n      sections.push('Goal: Refactor the target code to improve readability and maintainability without altering behaviour.');\n      if (baseContext) sections.push(`Context:\\n${baseContext}`);\n      if (userContext) sections.push(`Caller notes:\\n${userContext}`);\n      sections.push('Guidelines:\\n- Preserve public contracts and side-effects.\\n- Identify technical debt hotspots and propose concise fixes.\\n- Provide updated code excerpts with rationale for each change.');\n      break;\n    }\n    case 'test': {\n      const subject = symbolArg || fileArg || 'the specified module';\n      sections.push(`Goal: Design a focused test strategy for ${subject}.`);\n      if (baseContext) sections.push(`Context:\\n${baseContext}`);\n      if (userContext) sections.push(`Caller notes:\\n${userContext}`);\n      sections.push('Checklist:\\n- Enumerate critical behaviours and edge cases.\\n- Recommend unit/integration test boundaries.\\n- Suggest fixtures or mocks and expected assertions.');\n      break;\n    }\n    case 'perf': {\n      const scope = fileArg || symbolArg || 'the target codebase';\n      sections.push(`Goal: Investigate potential performance issues in ${scope}.`);\n      if (baseContext) sections.push(`Context:\\n${baseContext}`);\n      if (userContext) sections.push(`Caller notes:\\n${userContext}`);\n      sections.push('Focus:\\n- Highlight expensive code paths or dependency hot spots.\\n- Suggest measurement approaches (profilers, metrics).\\n- Recommend optimisation tactics while keeping clarity.');\n      break;\n    }\n    default:\n      return null;\n  }\n  return sections.filter(Boolean).join('\\n\\n');\n}\n\nconst tools = [\n  {\n    name: 'search_code',\n    description: 'Semantic code search with hybrid ranking',\n    inputSchema: {\n      type: 'object',\n      properties: { q: { type: 'string' }, top_k: { type: 'number' } },\n      required: ['q']\n    }\n  },\n  {\n    name: 'get_file',\n    description: 'Get file content from index',\n    inputSchema: {\n      type: 'object',\n      properties: { path: { type: 'string' } },\n      required: ['path']\n    }\n  },\n  {\n    name: 'list_symbols',\n    description: 'List symbols, optionally filtered by file',\n    inputSchema: {\n      type: 'object',\n      properties: { file: { type: 'string' } },\n      required: []\n    }\n  },\n  {\n    name: 'find_refs',\n    description: 'Find references via import graph',\n    inputSchema: {\n      type: 'object',\n      properties: { symbol: { type: 'string' } },\n      required: ['symbol']\n    }\n  },\n  {\n    name: 'plan_refactor',\n    description: 'Drafts a refactor plan for a target file or symbol',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        file: { type: 'string' },\n        symbol: { type: 'string' },\n        goal: { type: 'string' }\n      },\n      required: []\n    }\n  },\n  {\n    name: 'gen_patch',\n    description: 'Generates a dry-run find/replace patch preview',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        path: { type: 'string' },\n        operations: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              find: { type: 'string' },\n              replace: { type: 'string' },\n              occurrences: { type: 'number' }\n            },\n            required: ['find', 'replace']\n          }\n        }\n      },\n      required: ['path', 'operations']\n    }\n  },\n  {\n    name: 'apply_patch',\n    description: 'Applies an approved find/replace patch to disk',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        path: { type: 'string' },\n        operations: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              find: { type: 'string' },\n              replace: { type: 'string' },\n              occurrences: { type: 'number' }\n            },\n            required: ['find', 'replace']\n          }\n        }\n      },\n      required: ['path', 'operations']\n    }\n  },\n  {\n    name: 'analyze_performance',\n    description: 'Runs lightweight static heuristics for performance risks',\n    inputSchema: {\n      type: 'object',\n      properties: { path: { type: 'string' } },\n      required: ['path']\n    }\n  },\n  {\n    name: 'compare_versions',\n    description: 'Compares two files line-by-line for quick diffing',\n    inputSchema: {\n      type: 'object',\n      properties: { pathA: { type: 'string' }, pathB: { type: 'string' } },\n      required: ['pathA', 'pathB']\n    }\n  },\n  {\n    name: 'auto_docs',\n    description: 'Produces an automated documentation summary for a file',\n    inputSchema: {\n      type: 'object',\n      properties: { path: { type: 'string' } },\n      required: ['path']\n    }\n  },\n  {\n    name: 'run_tests',\n    description: 'Executes a repository-defined test command',\n    inputSchema: {\n      type: 'object',\n      properties: { command: { type: 'string' } },\n      required: []\n    }\n  },\n  {\n    name: 'run_task',\n    description: 'Runs an npm script defined in package.json',\n    inputSchema: {\n      type: 'object',\n      properties: { script: { type: 'string' } },\n      required: ['script']\n    }\n  },\n  {\n    name: 'generate_telemetry_panel',\n    description: 'Generates an HTML telemetry dashboard from logs',\n    inputSchema: {\n      type: 'object',\n      properties: { output: { type: 'string' } },\n      required: []\n    }\n  },\n  {\n    name: 'open_telemetry_webview',\n    description: 'Returns the telemetry dashboard HTML for rendering in a webview',\n    inputSchema: {\n      type: 'object',\n      properties: { file: { type: 'string' } },\n      required: ['file']\n    }\n  },\n  {\n    name: 'langchain_query',\n    description: 'Queries the LangChain bridge (falls back to lexical search)',\n    inputSchema: {\n      type: 'object',\n      properties: { q: { type: 'string' }, top_k: { type: 'number' } },\n      required: ['q']\n    }\n  },\n  {\n    name: 'summarize_architecture',\n    description: 'Summarize codebase topology from graph store',\n    inputSchema: { type: 'object', properties: {}, required: [] }\n  },\n  {\n    name: 'detect_smells',\n    description: 'Detect simple code smells (TODO/long lines)',\n    inputSchema: {\n      type: 'object',\n      properties: { root: { type: 'string' } },\n      required: []\n    }\n  },\n  {\n    name: 'suggest_tests',\n    description: 'Suggest unit tests for symbols',\n    inputSchema: {\n      type: 'object',\n      properties: { symbols: { type: 'array' } },\n      required: ['symbols']\n    }\n  },\n  {\n    name: 'submit_feedback',\n    description: 'Submit feedback to adapt ranker weights (kind: up|down)',\n    inputSchema: {\n      type: 'object',\n      properties: { kind: { type: 'string', enum: ['up', 'down'] } },\n      required: ['kind']\n    }\n  },\n  {\n    name: 'get_weights',\n    description: 'Get current hybrid ranker weights',\n    inputSchema: { type: 'object', properties: {}, required: [] }\n  },\n  {\n    name: 'resources-list',\n    description: 'List files under allowed roots (policy filtered)',\n    inputSchema: { type: 'object', properties: { root: { type: 'string' }, max: { type: 'number' } }, required: [] }\n  },\n  {\n    name: 'resources-read',\n    description: 'Read a single file (policy filtered)',\n    inputSchema: { type: 'object', properties: { path: { type: 'string' }, maxChars: { type: 'number' } }, required: ['path'] }\n  },\n  {\n    name: 'roots-list',\n    description: 'List allowed roots for resources',\n    inputSchema: { type: 'object', properties: {}, required: [] }\n  },\n  {\n    name: 'prompts-list',\n    description: 'List available prompts',\n    inputSchema: { type: 'object', properties: {}, required: [] }\n  },\n  {\n    name: 'prompts-call',\n    description: 'Call a prompt template',\n    inputSchema: { type: 'object', properties: { name: { type: 'string' }, args: { type: 'object' } }, required: ['name'] }\n  }\n];\n\nconst PROMPT_DESCRIPTORS = [\n  {\n    name: 'refactor',\n    description: 'Refactor guidance with repository context',\n    arguments: [\n      { name: 'file', description: 'Relative file path to focus on', required: false },\n      { name: 'symbol', description: 'Specific symbol or class to prioritise', required: false },\n      { name: 'context', description: 'Additional human-provided notes', required: false },\n      { name: 'notes', description: 'Inline hints or concerns to surface', required: false },\n    ],\n  },\n  {\n    name: 'test',\n    description: 'Unit/integration test planning for a module or symbol',\n    arguments: [\n      { name: 'file', description: 'Relative file path for test scope', required: false },\n      { name: 'symbol', description: 'Specific function/class to cover', required: false },\n      { name: 'context', description: 'Known behaviours or regressions to consider', required: false },\n    ],\n  },\n  {\n    name: 'perf',\n    description: 'Performance review with dependency awareness',\n    arguments: [\n      { name: 'file', description: 'File/module suspected to be a bottleneck', required: false },\n      { name: 'symbol', description: 'Critical symbol or method to profile', required: false },\n      { name: 'target', description: 'Custom target description (default derived from file/symbol)', required: false },\n      { name: 'context', description: 'Observed latency or memory symptoms', required: false },\n    ],\n  },\n];\n\nasync function handle(req: RpcRequest) {\n  try {\n    // Ignore notifications (JSON-RPC without id). MCP may send sessionConfigured, etc.\n    if (req.id === null || typeof req.id === 'undefined') {\n      // Known MCP notifications we can safely ignore\n      if (req.method === 'sessionConfigured' || req.method === 'ping' || req.method === 'initialized') {\n        return; // no response for notifications\n      }\n      return; // silently ignore unknown notifications per JSON-RPC\n    }\n    if (req.method === 'initialize') {\n      return ok(req.id, {\n        protocolVersion: '2024-11-05',\n        capabilities: { tools: {}, resources: {}, prompts: {} },\n        serverInfo: { name: 'mcp-local', version: '1.0.0' }\n      });\n    }\n    if (req.method === 'ping') {\n      return ok(req.id, { ok: true });\n    }\n    if (req.method === 'shutdown') {\n      ok(req.id, { ok: true });\n      process.exit(0);\n      return;\n    }\n    if (req.method === 'tools/list') {\n      return ok(req.id, { tools });\n    }\n    if (req.method === 'tools/call') {\n      const name = String(req.params?.name || '');\n      const args = (req.params?.arguments as any) || {};\n      switch (name) {\n        case 'search_code': {\n          const orchestrator = getOrchestrator();\n          const q = String(args.q || '');\n          const topK = Number.isFinite(args.top_k) ? Number(args.top_k) : 5;\n          const results = await orchestrator.searchCode(q, topK);\n          const profile = orchestrator.getLastProfile();\n          return ok(req.id, {\n            content: [{\n              type: 'text',\n              text: JSON.stringify({ query: q, profile, results }),\n            }],\n          });\n        }\n        case 'get_file': {\n          const p = String(args.path || '');\n          const content = getOrchestrator().getFile(p);\n          return ok(req.id, { content: [{ type: 'text', text: content }] });\n        }\n        case 'list_symbols': {\n          const file = args.file ? String(args.file) : undefined;\n          const syms = getGraph().listSymbols(file);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(syms) }] });\n        }\n        case 'find_refs': {\n          const sym = String(args.symbol || '');\n          const refs = getGraph().findRefs(sym);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(refs) }] });\n        }\n        case 'plan_refactor': {\n          const file = args.file ? String(args.file) : undefined;\n          const symbol = args.symbol ? String(args.symbol) : undefined;\n          const goal = args.goal ? String(args.goal) : undefined;\n          const plan = plan_refactor(getOrchestrator(), getGraph(), process.cwd(), { file, symbol, goal });\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(plan) }] });\n        }\n        case 'gen_patch': {\n          const file = String(args.path || '');\n          const operations = Array.isArray(args.operations) ? args.operations as any[] : [];\n          const patch = generate_patch(process.cwd(), file, operations);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(patch) }] });\n        }\n        case 'apply_patch': {\n          const file = String(args.path || '');\n          const operations = Array.isArray(args.operations) ? args.operations as any[] : [];\n          const res = applyPatchOperations(process.cwd(), file, operations);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(res) }] });\n        }\n        case 'analyze_performance': {\n          const file = String(args.path || '');\n          const insight = analyze_performance(process.cwd(), file);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(insight) }] });\n        }\n        case 'compare_versions': {\n          const pathA = String(args.pathA || '');\n          const pathB = String(args.pathB || '');\n          const cmp = compare_versions(process.cwd(), pathA, pathB);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(cmp) }] });\n        }\n        case 'auto_docs': {\n          const file = String(args.path || '');\n          const docs = auto_docs(getOrchestrator(), getGraph(), process.cwd(), file);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(docs) }] });\n        }\n        case 'run_tests': {\n          const command = args.command ? String(args.command) : 'npm test';\n          const outcome = run_tests(process.cwd(), command);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(outcome) }] });\n        }\n        case 'run_task': {\n          const script = String(args.script || '');\n          const outcome = run_task(process.cwd(), script);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(outcome) }] });\n        }\n        case 'generate_telemetry_panel': {\n          const output = args.output ? String(args.output) : undefined;\n          const panel = generate_telemetry_panel(process.cwd(), output);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(panel) }] });\n        }\n        case 'open_telemetry_webview': {\n          const regenerate = args.regenerate === true;\n          const output = args.output ? String(args.output) : undefined;\n          const webview = open_telemetry_webview(process.cwd(), { regenerate, output });\n          return ok(req.id, {\n            content: [{\n              type: 'text',\n              text: webview.html,\n              mimeType: 'text/html',\n              metadata: { path: webview.path },\n            }],\n          });\n        }\n        case 'langchain_query': {\n          const q = String(args.q || '');\n          const topK = Number.isFinite(args.top_k) ? Number(args.top_k) : 5;\n          const dataDir = process.env.DATA_DIR || DATA_DIR;\n          const result = await langchain_query(dataDir, q, topK);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(result) }] });\n        }\n        case 'summarize_architecture': {\n          const s = summarize_architecture(getGraph());\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(s) }] });\n        }\n        case 'detect_smells': {\n          const root = String(args.root || process.cwd());\n          const res = detect_smells(root);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(res) }] });\n        }\n        case 'suggest_tests': {\n          const symbols = (args.symbols as Array<{ file: string; name: string }>) || [];\n          const sugg = suggest_tests(symbols);\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(sugg) }] });\n        }\n        case 'submit_feedback': {\n          const kind = String(args.kind || 'up');\n          wm.feedback(kind === 'down' ? 'down' : 'up');\n          set_weights(wm.get());\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify({ ok: true, weights: wm.get() }) }] });\n        }\n        case 'get_weights': {\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(wm.get()) }] });\n        }\n        case 'resources-list': {\n          const root = args.root ? String(args.root) : ROOTS[0];\n          const max = Number.isFinite(args.max) ? Number(args.max) : 200;\n          if (!ROOTS.some(r => path.resolve(root).startsWith(path.resolve(r)))) {\n            return err(req.id, -32001, 'Root not allowed', { root, allowed: ROOTS });\n          }\n          const files = listFiles(root, max).map(f => path.normalize(f));\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(files) }] });\n        }\n        case 'resources-read': {\n          const p = String(args.path || '');\n          const maxChars = Number.isFinite(args.maxChars) ? Number(args.maxChars) : 200_000;\n          if (!ROOTS.some(r => path.resolve(p).startsWith(path.resolve(r)))) {\n            return err(req.id, -32001, 'Path not under allowed roots', { path: p, allowed: ROOTS });\n          }\n          if (!allowPath(p)) return err(req.id, -32002, 'Path not allowed by policy', { path: p });\n          try {\n            const buf = fs.readFileSync(p, 'utf8');\n            const text = buf.slice(0, maxChars);\n            return ok(req.id, { content: [{ type: 'text', text }] });\n          } catch (e: any) {\n            return err(req.id, -32003, 'Failed to read file', { path: p, error: e?.message });\n          }\n        }\n        case 'roots-list': {\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(ROOTS) }] });\n        }\n        case 'prompts-list': {\n          return ok(req.id, { content: [{ type: 'text', text: JSON.stringify(PROMPT_DESCRIPTORS) }] });\n        }\n        case 'prompts-call': {\n          const pname = String(args.name || '');\n          const a = (args.args || {}) as Record<string, unknown>;\n          const text = buildPromptText(pname, a);\n          if (!text) return err(req.id, -32601, 'Prompt not found', { name: pname });\n          return ok(req.id, { content: [{ type: 'text', text }] });\n        }\n        default:\n          return err(req.id, -32601, 'Tool not found');\n      }\n    }\n    // Expose top-level MCP resource/prompt methods for IDE panels\n    if (req.method === 'resources/list') {\n      const args = (req.params as any) || {};\n      const rootArg = String(args.root || args.uri || ROOTS[0]);\n      const root = rootArg.startsWith('file://') ? fromFileUri(rootArg) : rootArg;\n      const max = Number.isFinite(args.max) ? Number(args.max) : 200;\n      if (!ROOTS.some(r => path.resolve(root).startsWith(path.resolve(r)))) {\n        return err(req.id, -32001, 'Root not allowed', { root, allowed: ROOTS });\n      }\n      const files = listFiles(root, max).map(f => path.normalize(f));\n      return ok(req.id, { resources: files.map(f => ({ uri: toFileUri(f), name: path.basename(f) })) });\n    }\n    if (req.method === 'resources/read') {\n      const args = (req.params as any) || {};\n      const raw = String(args.path || args.uri || '');\n      const p = raw.startsWith('file://') ? fromFileUri(raw) : raw;\n      const maxChars = Number.isFinite(args.maxChars) ? Number(args.maxChars) : 200_000;\n      if (!ROOTS.some(r => path.resolve(p).startsWith(path.resolve(r)))) {\n        return err(req.id, -32001, 'Path not under allowed roots', { path: p, allowed: ROOTS });\n      }\n      if (!allowPath(p)) return err(req.id, -32002, 'Path not allowed by policy', { path: p });\n      try {\n        const buf = fs.readFileSync(p, 'utf8');\n        const text = buf.slice(0, maxChars);\n        const mimeType = p.endsWith('.html') ? 'text/html' : 'text/plain';\n        return ok(req.id, { contents: [{ uri: toFileUri(p), mimeType, text }] });\n      } catch (e: any) {\n        return err(req.id, -32003, 'Failed to read file', { path: p, error: e?.message });\n      }\n    }\n    if (req.method === 'roots/list') {\n      return ok(req.id, { roots: ROOTS.map(r => ({ uri: toFileUri(r), name: r })) });\n    }\n    if (req.method === 'prompts/list') {\n      return ok(req.id, { prompts: PROMPT_DESCRIPTORS });\n    }\n    if (req.method === 'prompts/call') {\n      const args = (req.params as any) || {};\n      const pname = String(args.name || '');\n      const a = (args.args || {}) as Record<string, unknown>;\n      const text = buildPromptText(pname, a);\n      if (!text) return err(req.id, -32601, 'Prompt not found', { name: pname });\n      return ok(req.id, { content: [{ type: 'text', text }] });\n    }\n    return err(req.id, -32601, 'Method not found');\n  } catch (e: any) {\n    return err(req.id, -32000, e?.message || 'Internal error');\n  }\n}\n\nconst rl = readline.createInterface({ input: process.stdin, output: process.stdout, terminal: false });\nrl.on('line', line => {\n  const s = line.trim(); if (!s) return;\n  try { \n    const req = JSON.parse(s) as RpcRequest; \n    if (req.msg?.type === 'user_message') {\n      if (req.msg.kind === 'environment_context') {\n        const contextObj = parseEnvironmentContext(req.msg.message);\n        process.env.MCP_CWD = contextObj.cwd;\n        process.env.MCP_APPROVAL_POLICY = contextObj.approval_policy;\n        process.env.MCP_SANDBOX_MODE = contextObj.sandbox_mode;\n        write({\n          jsonrpc: '2.0',\n          id: req.id,\n          result: { status: 'ok' }\n        });\n        return;\n      }\n    }\n    handle(req); \n  } catch (e) { \n    console.error('Error handling message:', e);\n  }\n});\n\nfunction parseEnvironmentContext(xmlStr: string): any {\n  const matches = {\n    cwd: xmlStr.match(/<cwd>(.*?)<\\/cwd>/)?.[1] || '',\n    approval_policy: xmlStr.match(/<approval_policy>(.*?)<\\/approval_policy>/)?.[1] || 'on-request',\n    sandbox_mode: xmlStr.match(/<sandbox_mode>(.*?)<\\/sandbox_mode>/)?.[1] || 'workspace-write'\n  };\n  return matches;\n}\n\nprocess.on('SIGINT', () => process.exit(0));\n",
    "symbols": [
      {
        "name": "getOrchestrator",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 39,
        "endLine": 46
      },
      {
        "name": "getGraph",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 48,
        "endLine": 54
      },
      {
        "name": "write",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 69,
        "endLine": 69
      },
      {
        "name": "ok",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 70,
        "endLine": 70
      },
      {
        "name": "err",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 71,
        "endLine": 75
      },
      {
        "name": "toFileUri",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 84,
        "endLine": 92
      },
      {
        "name": "fromFileUri",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 94,
        "endLine": 107
      },
      {
        "name": "safeJoin",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 109,
        "endLine": 113
      },
      {
        "name": "listFiles",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 115,
        "endLine": 136
      },
      {
        "name": "normalizeRepoPath",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 140,
        "endLine": 142
      },
      {
        "name": "uniqueList",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 144,
        "endLine": 155
      },
      {
        "name": "filePreview",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 157,
        "endLine": 165
      },
      {
        "name": "formatList",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 167,
        "endLine": 171
      },
      {
        "name": "buildPromptContext",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 173,
        "endLine": 208
      },
      {
        "name": "buildPromptText",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 210,
        "endLine": 246
      },
      {
        "name": "handle",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 512,
        "endLine": 754
      },
      {
        "name": "parseEnvironmentContext",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_adapter.ts",
        "startLine": 781,
        "endLine": 788
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/mcp_http_bridge.ts",
    "content": "import http from 'http';\nimport { spawn, ChildProcessByStdio } from 'child_process';\nimport { Readable, Writable } from 'stream';\nimport path from 'path';\nimport readline from 'readline';\n\ntype Json = any;\ninterface RpcRequest { jsonrpc: '2.0'; id: string | number | null; method: string; params?: Json }\n\nexport function startMcpHttpBridge(port: number) {\n  const adapterPath = path.join(__dirname, 'mcp_adapter.js');\n  const child: ChildProcessByStdio<Writable, Readable, Readable> = spawn(process.execPath, [adapterPath], {\n    stdio: ['pipe', 'pipe', 'pipe'],\n    env: process.env,\n  });\n\n  const rl = readline.createInterface({ input: child.stdout });\n  const pending = new Map<string, (resp: any) => void>();\n\n  rl.on('line', line => {\n    try {\n      const obj = JSON.parse(line);\n      const id = String(obj.id);\n      const resolve = pending.get(id);\n      if (resolve) {\n        pending.delete(id);\n        resolve(obj);\n      }\n    } catch { /* ignore non-JSON lines */ }\n  });\n\n  const server = http.createServer(async (req, res) => {\n    try {\n      if (req.method !== 'POST' || !req.url) { res.writeHead(405); return res.end(); }\n      const url = new URL(req.url, `http://${req.headers.host}`);\n      if (url.pathname !== '/mcp') { res.writeHead(404); return res.end(); }\n      const chunks: Buffer[] = [];\n      req.on('data', c => chunks.push(c));\n      req.on('end', async () => {\n        try {\n          const body = Buffer.concat(chunks).toString('utf8');\n          const payload = JSON.parse(body);\n          const handleOne = (p: RpcRequest) => new Promise<any>((resolveOne, rejectOne) => {\n            if (p.id === null || typeof p.id === 'undefined') {\n              // notification: just forward and return 204 later\n              child.stdin.write(JSON.stringify(p) + '\\n');\n              resolveOne(undefined);\n              return;\n            }\n            const key = String(p.id);\n            pending.set(key, resp => resolveOne(resp));\n            child.stdin.write(JSON.stringify(p) + '\\n');\n            // Optionally add a timeout\n            setTimeout(() => {\n              if (pending.has(key)) { pending.delete(key); rejectOne(new Error('timeout')); }\n            }, 30000);\n          });\n\n          if (Array.isArray(payload)) {\n            const responses = await Promise.all(payload.map(p => handleOne(p)));\n            const filtered = responses.filter(r => r !== undefined);\n            res.writeHead(200, { 'content-type': 'application/json' });\n            res.end(JSON.stringify(filtered));\n          } else {\n            const response = await handleOne(payload);\n            if (response === undefined) { res.writeHead(204); res.end(); }\n            else { res.writeHead(200, { 'content-type': 'application/json' }); res.end(JSON.stringify(response)); }\n          }\n        } catch (e: any) {\n          res.writeHead(400, { 'content-type': 'application/json' });\n          res.end(JSON.stringify({ error: e?.message || 'bad request' }));\n        }\n      });\n    } catch {\n      res.writeHead(500); res.end();\n    }\n  });\n\n  server.listen(port, '127.0.0.1');\n  return { server, child };\n}\n",
    "symbols": [
      {
        "name": "startMcpHttpBridge",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/mcp_http_bridge.ts",
        "startLine": 10,
        "endLine": 81
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/orchestrator.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport http from 'http';\nimport { FileMeta, SearchResult } from '@mcp/shared';\nimport { rank_hybrid, pack_tokens } from './ranker';\nimport { GraphStore } from './graph_store';\nimport { profileContext, ContextProfile } from './context_profiler';\n\ninterface EngineSearchResult {\n  file: string;\n  symbol: string;\n  startLine: number;\n  endLine: number;\n  score: number;\n  snippet: string;\n}\n\nexport class Orchestrator {\n  private fileIndex: Map<string, FileMeta> = new Map();\n  private engineUrl: string;\n  private graph?: GraphStore;\n  private lastProfile: ContextProfile | null = null;\n\n  constructor(dataDir: string, engineUrl: string = 'http://localhost:8000', graph?: GraphStore) {\n    this.engineUrl = engineUrl;\n    this.loadIndex(dataDir);\n    this.graph = graph;\n  }\n\n  private loadIndex(dataDir: string) {\n    const idxPath = path.join(dataDir, 'index.json');\n    const json = fs.readFileSync(idxPath, 'utf8');\n    const files: FileMeta[] = JSON.parse(json);\n    for (const file of files) {\n      this.fileIndex.set(file.path, file);\n    }\n  }\n\n  public getFile(filePath: string): string {\n    const fileMeta = this.fileIndex.get(filePath);\n    if (!fileMeta) throw new Error(`File not found in index: ${filePath}`);\n    return fileMeta.content;\n  }\n\n  public getLastProfile(): ContextProfile | null {\n    return this.lastProfile ? { ...this.lastProfile } : null;\n  }\n\n  public async searchCode(query: string, topK = 5): Promise<SearchResult[]> {\n    const url = new URL('/search', this.engineUrl);\n    url.searchParams.set('q', query);\n    url.searchParams.set('top_k', topK.toString());\n    const engineResults: EngineSearchResult[] = await new Promise((resolve, reject) => {\n      const req = http.get(url.toString(), res => {\n        const chunks: Buffer[] = [];\n        res.on('data', c => chunks.push(c));\n        res.on('end', () => {\n          try {\n            const parsed = JSON.parse(Buffer.concat(chunks).toString('utf8'));\n            resolve(parsed.results as EngineSearchResult[]);\n          } catch (err) {\n            reject(err);\n          }\n        });\n      });\n      req.on('error', err => reject(err));\n    });\n    const initial: SearchResult[] = engineResults.map(er => ({ ...er } as SearchResult));\n    const profile = profileContext(query, topK);\n    const ranked = rank_hybrid(initial, query, this.graph ? (f => this.graph!.degree(f)) : undefined);\n    let curated = pack_tokens(ranked, profile.tokenBudget);\n    if (!curated.length) {\n      curated = ranked.slice(0, Math.max(1, profile.effectiveTopK));\n    }\n    if (curated.length > profile.effectiveTopK) {\n      curated = curated.slice(0, profile.effectiveTopK);\n    }\n    this.lastProfile = profile;\n    return curated;\n  }\n}\n",
    "symbols": [
      {
        "name": "Orchestrator",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/orchestrator.ts",
        "startLine": 18,
        "endLine": 81
      },
      {
        "name": "Orchestrator.loadIndex",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/orchestrator.ts",
        "startLine": 30,
        "endLine": 37
      },
      {
        "name": "Orchestrator.getFile",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/orchestrator.ts",
        "startLine": 39,
        "endLine": 43
      },
      {
        "name": "Orchestrator.getLastProfile",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/orchestrator.ts",
        "startLine": 45,
        "endLine": 47
      },
      {
        "name": "Orchestrator.searchCode",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/orchestrator.ts",
        "startLine": 49,
        "endLine": 80
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/policy.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\nexport function allowPath(p: string): boolean {\n  const basename = path.basename(p).toLowerCase();\n  if (basename.endsWith('.env') || basename.endsWith('.key') || basename.endsWith('.pem')) return false;\n  try {\n    const stat = fs.statSync(p);\n    if (stat.size > 50 * 1024 * 1024) return false;\n  } catch {\n    // ignore\n  }\n  return true;\n}\n\nexport function filterPaths(paths: string[]): string[] {\n  return paths.filter(allowPath);\n}\n\n",
    "symbols": [
      {
        "name": "allowPath",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/policy.ts",
        "startLine": 4,
        "endLine": 14
      },
      {
        "name": "filterPaths",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/policy.ts",
        "startLine": 16,
        "endLine": 18
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/ranker.ts",
    "content": "import { SearchResult } from '@mcp/shared';\n\nexport interface HybridSignals {\n  semantic: number; // engine score [0..1]\n  lexical: number;  // token hit ratio [0..1]\n  graph: number;    // normalized degree [0..1]\n}\n\nlet weights = { semantic: 0.6, lexical: 0.25, graph: 0.15 };\nexport function set_weights(w: { semantic: number; lexical: number; graph: number }) {\n  const s = w.semantic + w.lexical + w.graph;\n  weights = { semantic: w.semantic / s, lexical: w.lexical / s, graph: w.graph / s };\n}\n\nexport function rank_hybrid(results: SearchResult[], query: string, fileDegree?: (file: string) => number): SearchResult[] {\n  const tokens = query.toLowerCase().split(/\\W+/).filter(Boolean);\n  const degrees = new Map<string, number>();\n  let maxDeg = 1;\n  if (fileDegree) {\n    for (const r of results) {\n      const d = fileDegree(r.file) || 0;\n      degrees.set(r.file, d);\n      if (d > maxDeg) maxDeg = d;\n    }\n  }\n  return results.map(r => {\n    const snippetLower = r.snippet.toLowerCase();\n    let hits = 0;\n    for (const t of tokens) if (snippetLower.includes(t)) hits++;\n    const lexical = tokens.length ? hits / tokens.length : 0;\n    const graph = degrees.has(r.file) ? (degrees.get(r.file)! / maxDeg) : 0;\n    const semantic = r.score; // assume engine score in [0..1]\n    const score = semantic * weights.semantic + lexical * weights.lexical + graph * weights.graph;\n    return { ...r, score };\n  }).sort((a, b) => b.score - a.score);\n}\n\nexport function pack_tokens(results: SearchResult[], budgetTokens: number): SearchResult[] {\n  // naive token estimate: ~1 token per 4 chars\n  const estimate = (s: string) => Math.ceil(s.length / 4);\n  const selected: SearchResult[] = [];\n  let used = 0;\n  // MMR-like greedy selection with diversity by file\n  const usedFiles = new Set<string>();\n  for (const r of results) {\n    const cost = estimate(r.snippet);\n    if (used + cost > budgetTokens) continue;\n    if (usedFiles.has(r.file)) continue; // diversity: one per file first\n    selected.push(r);\n    used += cost;\n    usedFiles.add(r.file);\n  }\n  // fill remaining budget regardless of file if space left\n  if (used < budgetTokens) {\n    for (const r of results) {\n      if (selected.includes(r)) continue;\n      const cost = estimate(r.snippet);\n      if (used + cost > budgetTokens) continue;\n      selected.push(r);\n      used += cost;\n    }\n  }\n  return selected;\n}\n",
    "symbols": [
      {
        "name": "set_weights",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/ranker.ts",
        "startLine": 10,
        "endLine": 13
      },
      {
        "name": "rank_hybrid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/ranker.ts",
        "startLine": 15,
        "endLine": 36
      },
      {
        "name": "pack_tokens",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/ranker.ts",
        "startLine": 38,
        "endLine": 64
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/server.ts",
    "content": "import http from 'http';\nimport { Orchestrator } from './orchestrator';\n\nconst PORT = parseInt(process.env.PORT || '3000', 10);\nconst DATA_DIR = process.env.DATA_DIR || './data';\nconst ENGINE_URL = process.env.ENGINE_URL || 'http://localhost:8000';\n\nconst orchestrator = new Orchestrator(DATA_DIR, ENGINE_URL);\nconst server = http.createServer((req, res) => {\n  if (!req.url) { res.statusCode = 400; return res.end('Bad request'); }\n  const url = new URL(req.url, `http://${req.headers.host}`);\n  if (req.method === 'GET' && url.pathname === '/get_file') {\n    const filePath = url.searchParams.get('path');\n    if (!filePath) { res.statusCode = 400; return res.end(JSON.stringify({ error: 'Missing path' })); }\n    try {\n      const content = orchestrator.getFile(filePath);\n      res.setHeader('Content-Type', 'application/json');\n      res.end(JSON.stringify({ path: filePath, content }));\n    } catch (e: any) {\n      res.statusCode = 404; res.end(JSON.stringify({ error: e.message }));\n    }\n  } else if (req.method === 'GET' && url.pathname === '/search_code') {\n    const q = url.searchParams.get('q') || '';\n    const topK = parseInt(url.searchParams.get('top_k') || '5', 10);\n    orchestrator.searchCode(q, topK).then(results => {\n      res.setHeader('Content-Type', 'application/json');\n      res.end(JSON.stringify({ query: q, results }));\n    }).catch(err => { res.statusCode = 500; res.end(JSON.stringify({ error: err.message })); });\n  } else { res.statusCode = 404; res.end(JSON.stringify({ error: 'Not found' })); }\n});\n\nserver.listen(PORT, () => console.log(`MCP HTTP debug server on ${PORT}`));\n\n",
    "symbols": []
  },
  {
    "path": "node_modules/@mcp/server/src/telemetry.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\ntype MetricPayload = Record<string, unknown> & {\n  name: string;\n  duration_ms: number;\n  ts: string;\n};\n\ntype AggregateKey = string;\n\nconst LOG_DIR = path.join(process.cwd(), 'logs');\nconst JSON_LOG_FILE = path.join(LOG_DIR, 'telemetry.log');\nlet promFile = process.env.TELEMETRY_PROM_FILE\n  ? path.resolve(process.cwd(), process.env.TELEMETRY_PROM_FILE)\n  : path.join(LOG_DIR, 'telemetry.prom');\nlet jsonSnapshotFile = process.env.TELEMETRY_JSON_SNAPSHOT\n  ? path.resolve(process.cwd(), process.env.TELEMETRY_JSON_SNAPSHOT)\n  : path.join(LOG_DIR, 'telemetry_latest.json');\n\nconst aggregates = new Map<AggregateKey, { count: number; total: number; max: number; min: number }>();\nlet promEnabled = true;\nlet jsonSnapshotEnabled = true;\n\nexport function configureTelemetry(options: { promFile?: string; jsonSnapshotFile?: string; disableProm?: boolean; disableSnapshot?: boolean } = {}) {\n  if (options.promFile) {\n    promFile = path.resolve(process.cwd(), options.promFile);\n  }\n  if (options.jsonSnapshotFile) {\n    jsonSnapshotFile = path.resolve(process.cwd(), options.jsonSnapshotFile);\n  }\n  if (typeof options.disableProm === 'boolean') promEnabled = !options.disableProm;\n  if (typeof options.disableSnapshot === 'boolean') jsonSnapshotEnabled = !options.disableSnapshot;\n}\n\nexport function startTimer(name: string, attributes: Record<string, unknown> = {}) {\n  const start = Date.now();\n  return (extra: Record<string, unknown> = {}) => {\n    const dur = Date.now() - start;\n    const payload: MetricPayload = {\n      name,\n      duration_ms: dur,\n      ts: new Date().toISOString(),\n      ...attributes,\n      ...extra,\n    };\n    writeMetric(payload);\n  };\n}\n\nfunction ensureDir(filePath: string) {\n  fs.mkdirSync(path.dirname(filePath), { recursive: true });\n}\n\nfunction writeMetric(m: MetricPayload) {\n  try {\n    ensureDir(JSON_LOG_FILE);\n    fs.appendFileSync(JSON_LOG_FILE, JSON.stringify(m) + '\\n', 'utf8');\n  } catch (err) {\n    if (process.env.DEBUG_TELEMETRY) {\n      // eslint-disable-next-line no-console\n      console.warn('[telemetry] failed to write JSON log', err);\n    }\n  }\n  updateAggregates(m);\n  if (promEnabled) emitPrometheus();\n  if (jsonSnapshotEnabled) emitJsonSnapshot();\n}\n\nfunction aggregateKey(m: MetricPayload): AggregateKey {\n  return `${m.name}:${m.source ?? 'unknown'}`;\n}\n\nfunction updateAggregates(m: MetricPayload) {\n  const key = aggregateKey(m);\n  const entry = aggregates.get(key) ?? { count: 0, total: 0, max: Number.MIN_SAFE_INTEGER, min: Number.MAX_SAFE_INTEGER };\n  entry.count += 1;\n  entry.total += m.duration_ms;\n  entry.max = Math.max(entry.max, m.duration_ms);\n  entry.min = Math.min(entry.min, m.duration_ms);\n  aggregates.set(key, entry);\n}\n\nfunction emitPrometheus() {\n  try {\n    ensureDir(promFile);\n    const lines: string[] = [\n      '# HELP mcp_request_duration_ms MCP request durations in milliseconds.',\n      '# TYPE mcp_request_duration_ms summary',\n    ];\n    for (const [key, stats] of aggregates.entries()) {\n      const [name, source] = key.split(':');\n      const avg = stats.count ? stats.total / stats.count : 0;\n      lines.push(`mcp_request_duration_ms_count{name=\"${name}\",source=\"${source}\"} ${stats.count}`);\n      lines.push(`mcp_request_duration_ms_sum{name=\"${name}\",source=\"${source}\"} ${stats.total}`);\n      lines.push(`mcp_request_duration_ms_avg{name=\"${name}\",source=\"${source}\"} ${avg.toFixed(2)}`);\n      lines.push(`mcp_request_duration_ms_max{name=\"${name}\",source=\"${source}\"} ${stats.max}`);\n      lines.push(`mcp_request_duration_ms_min{name=\"${name}\",source=\"${source}\"} ${stats.min}`);\n    }\n    fs.writeFileSync(promFile, lines.join('\\n') + '\\n', 'utf8');\n  } catch (err) {\n    if (process.env.DEBUG_TELEMETRY) {\n      // eslint-disable-next-line no-console\n      console.warn('[telemetry] failed to write Prometheus output', err);\n    }\n  }\n}\n\nfunction emitJsonSnapshot() {\n  try {\n    ensureDir(jsonSnapshotFile);\n    const snapshot = Array.from(aggregates.entries()).map(([key, stats]) => {\n      const [name, source] = key.split(':');\n      const avg = stats.count ? stats.total / stats.count : 0;\n      return { name, source, count: stats.count, total: stats.total, avg, max: stats.max, min: stats.min };\n    });\n    fs.writeFileSync(jsonSnapshotFile, JSON.stringify(snapshot, null, 2), 'utf8');\n  } catch (err) {\n    if (process.env.DEBUG_TELEMETRY) {\n      // eslint-disable-next-line no-console\n      console.warn('[telemetry] failed to write JSON snapshot', err);\n    }\n  }\n}\n",
    "symbols": [
      {
        "name": "configureTelemetry",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts",
        "startLine": 25,
        "endLine": 34
      },
      {
        "name": "startTimer",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts",
        "startLine": 36,
        "endLine": 49
      },
      {
        "name": "ensureDir",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts",
        "startLine": 51,
        "endLine": 53
      },
      {
        "name": "writeMetric",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts",
        "startLine": 55,
        "endLine": 68
      },
      {
        "name": "aggregateKey",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts",
        "startLine": 70,
        "endLine": 72
      },
      {
        "name": "updateAggregates",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts",
        "startLine": 74,
        "endLine": 82
      },
      {
        "name": "emitPrometheus",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts",
        "startLine": 84,
        "endLine": 107
      },
      {
        "name": "emitJsonSnapshot",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/telemetry.ts",
        "startLine": 109,
        "endLine": 124
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/tools.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\nimport { spawnSync } from 'child_process';\nimport { GraphStore } from './graph_store';\nimport { Orchestrator } from './orchestrator';\nimport { SearchResult } from '@mcp/shared';\nimport { LangChainBridge } from './langchain_bridge';\n\nexport interface RefactorPlanInput {\n  file?: string;\n  symbol?: string;\n  goal?: string;\n}\n\nexport interface RefactorPlan {\n  intent: string;\n  summary: string;\n  steps: string[];\n  risks: string[];\n  impact: {\n    imports: string[];\n    dependents: string[];\n  };\n}\n\nexport interface PatchOperation {\n  find: string;\n  replace: string;\n  occurrences?: number;\n}\n\nexport interface GeneratedPatch {\n  path: string;\n  operations: PatchOperation[];\n  preview: {\n    before: string[];\n    after: string[];\n  };\n}\n\nexport interface PatchResult {\n  path: string;\n  applied: number;\n  total: number;\n}\n\nexport interface PerformanceInsight {\n  file: string;\n  issues: string[];\n  suggestions: string[];\n}\n\nexport interface VersionComparison {\n  fileA: string;\n  fileB: string;\n  added: string[];\n  removed: string[];\n  changed: string[];\n}\n\nexport interface AutoDoc {\n  file: string;\n  summary: string;\n  exports: Array<{ name: string; kind: string; range: string }>;\n  deps: {\n    imports: string[];\n    dependents: string[];\n  };\n}\n\nexport interface TestRunResult {\n  command: string;\n  status: number | null;\n  stdout: string;\n  stderr: string;\n}\n\nexport interface LangChainHit {\n  id: string;\n  file: string;\n  symbol: string;\n  score: number;\n  snippet: string;\n}\n\nexport interface LangChainQueryResult {\n  available: boolean;\n  provider: 'langchain' | 'fallback';\n  reason?: string;\n  results: LangChainHit[];\n}\n\nexport interface TelemetryPanelResult {\n  output: string;\n  entries: number;\n}\n\nexport interface TelemetryWebview {\n  path: string;\n  html: string;\n}\nconst MAX_PREVIEW_LINES = 12;\n\nfunction safeRelative(root: string, target: string) {\n  return path.relative(root, target).replace(/\\\\/g, '/');\n}\n\nfunction slicePreview(lines: string[], startLine: number, endLine: number): string[] {\n  const start = Math.max(0, startLine - 1);\n  const end = Math.min(lines.length, endLine);\n  return lines.slice(start, Math.min(end, start + MAX_PREVIEW_LINES));\n}\n\nfunction applyOperations(content: string, operations: PatchOperation[]): { updated: string; applied: number } {\n  let current = content;\n  let applied = 0;\n  for (const op of operations) {\n    const occurrences = typeof op.occurrences === 'number' && op.occurrences > 0 ? op.occurrences : 1;\n    let count = 0;\n    let idx = current.indexOf(op.find);\n    while (idx !== -1 && count < occurrences) {\n      current = current.slice(0, idx) + op.replace + current.slice(idx + op.find.length);\n      applied += 1;\n      count += 1;\n      idx = current.indexOf(op.find, idx + op.replace.length);\n    }\n  }\n  return { updated: current, applied };\n}\n\nexport function plan_refactor(orchestrator: Orchestrator, graph: GraphStore, repoRoot: string, input: RefactorPlanInput): RefactorPlan {\n  const targetFile = input.file ?? '';\n  let summary = 'High level refactor plan for the repository';\n  const steps: string[] = [];\n  const risks: string[] = [];\n  let imports: string[] = [];\n  let dependents: string[] = [];\n\n  if (targetFile) {\n    try {\n      const content = orchestrator.getFile(targetFile);\n      const lines = content.split(/\\r?\\n/);\n      const symbols = graph.listSymbols(targetFile) as Array<{ name: string; kind: string; startLine: number; endLine: number }> | [];\n\n      if (input.symbol) {\n        const sym = symbols.find(s => s.name === input.symbol);\n        if (sym) {\n          summary = `Targeted refactor plan for ${input.symbol}`;\n          const preview = slicePreview(lines, sym.startLine, sym.endLine);\n          steps.push(`Review ${input.symbol} (${sym.kind}) lines ${sym.startLine}-${sym.endLine}`);\n          steps.push(`Update dependent tests and call sites for ${input.symbol}`);\n          if (input.goal) steps.push(`Apply requested goal: ${input.goal}`);\n          risks.push('Run existing tests to catch regressions');\n          risks.push('Update documentation if the public API changes');\n          if (preview.length) {\n            steps.push(`Current snippet:\\n${preview.join('\\n')}`);\n          }\n        } else {\n          summary = `${input.symbol} symbol not found in GraphStore`;\n          steps.push(`Inspect ${targetFile} and verify symbol naming`);\n        }\n      } else {\n        summary = `High level refactor plan for ${targetFile}`;\n        const topSymbols = symbols.slice(0, 5).map(s => `${s.name} (${s.kind})`);\n        if (topSymbols.length) steps.push(`Review structure: ${topSymbols.join(', ')}`);\n        if (input.goal) steps.push(`Focus goal: ${input.goal}`);\n        steps.push('Simplify dependencies and deduplicate logic');\n      }\n\n      imports = graph.listImports(targetFile);\n      dependents = graph.listDependents(targetFile);\n\n      if (!imports.length && !dependents.length) {\n        risks.push('File is isolated in the dependency graph; check downstream impact manually');\n      } else {\n        if (imports.length) risks.push(`${imports.length} imports must remain coherent`);\n        if (dependents.length) risks.push(`${dependents.length} files depend on this module; plan regression tests`);\n      }\n    } catch (err: any) {\n      summary = `Failed to produce refactor plan for ${targetFile} (${err?.message ?? 'unknown error'})`;\n      steps.push('Verify that the file is indexed (run build and index tasks)');\n    }\n  } else {\n    steps.push('No target file or symbol supplied; outline global refactor goals');\n    steps.push('Use GraphStore metadata to pick high-impact modules');\n  }\n\n  if (!steps.length) steps.push('Additional context required to craft actionable steps');\n  if (!risks.length) risks.push('Follow standard code review and regression testing workflow');\n\n  return {\n    intent: input.goal ?? (input.symbol ? 'targeted-refactor' : 'structural-refactor'),\n    summary,\n    steps,\n    risks,\n    impact: {\n      imports,\n      dependents,\n    },\n  };\n}\n\nexport function generate_patch(repoRoot: string, filePath: string, operations: PatchOperation[]): GeneratedPatch {\n  const abs = path.resolve(repoRoot, filePath);\n  const content = fs.readFileSync(abs, 'utf8');\n  const { updated } = applyOperations(content, operations);\n  const originalPreview = slicePreview(content.split(/\\r?\\n/), 1, MAX_PREVIEW_LINES);\n  const updatedPreview = slicePreview(updated.split(/\\r?\\n/), 1, MAX_PREVIEW_LINES);\n  return {\n    path: safeRelative(repoRoot, abs),\n    operations,\n    preview: {\n      before: originalPreview,\n      after: updatedPreview,\n    },\n  };\n}\n\nexport function apply_patch(repoRoot: string, filePath: string, operations: PatchOperation[]): PatchResult {\n  const abs = path.resolve(repoRoot, filePath);\n  const content = fs.readFileSync(abs, 'utf8');\n  const { updated, applied } = applyOperations(content, operations);\n  fs.writeFileSync(abs, updated, 'utf8');\n  return {\n    path: safeRelative(repoRoot, abs),\n    applied,\n    total: operations.length,\n  };\n}\n\nexport function analyze_performance(repoRoot: string, filePath: string): PerformanceInsight {\n  const abs = path.resolve(repoRoot, filePath);\n  const content = fs.readFileSync(abs, 'utf8');\n  const issues: string[] = [];\n  const suggestions: string[] = [];\n\n  if (/for\\s*\\([^)]*\\)[\\s\\S]*for\\s*\\(/.test(content) || /for\\s*\\([^)]*\\)[\\s\\S]*while\\s*\\(/.test(content)) {\n    issues.push('Nested loops detected');\n    suggestions.push('Flatten or refactor nested loops to reduce complexity');\n  }\n  if (/JSON\\.stringify\\(.{400,}\\)/.test(content)) {\n    issues.push('Large JSON.stringify usage may impact performance');\n    suggestions.push('Stream or chunk large JSON payloads');\n  }\n  if (/fs\\.(readFileSync|writeFileSync|readdirSync)/.test(content)) {\n    issues.push('Synchronous fs calls detected');\n    suggestions.push('Prefer async fs APIs to avoid blocking the event loop');\n  }\n  if (/await\\s+.*\\.map\\(/.test(content) && !/await\\s+Promise\\.all\\([^)]*map\\(/.test(content)) {\n    issues.push('Await inside Array.map without Promise.all');\n    suggestions.push('Wrap async map calls with Promise.all for parallel execution');\n  }\n  if (!issues.length) {\n    suggestions.push('No obvious performance smells detected; capture runtime metrics to confirm');\n  }\n  return { file: safeRelative(repoRoot, abs), issues, suggestions };\n}\n\nfunction diffLines(a: string[], b: string[]) {\n  const removed: string[] = [];\n  const added: string[] = [];\n  const changed: string[] = [];\n  const len = Math.max(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    const left = a[i];\n    const right = b[i];\n    if (left === undefined) {\n      added.push(`${i + 1}: ${right}`);\n    } else if (right === undefined) {\n      removed.push(`${i + 1}: ${left}`);\n    } else if (left !== right) {\n      changed.push(`${i + 1}: ${left} -> ${right}`);\n    }\n  }\n  return { added, removed, changed };\n}\n\nexport function compare_versions(repoRoot: string, fileA: string, fileB: string): VersionComparison {\n  const absA = path.resolve(repoRoot, fileA);\n  const absB = path.resolve(repoRoot, fileB);\n  const contentA = fs.readFileSync(absA, 'utf8').split(/\\r?\\n/);\n  const contentB = fs.readFileSync(absB, 'utf8').split(/\\r?\\n/);\n  const diff = diffLines(contentA, contentB);\n  return {\n    fileA: safeRelative(repoRoot, absA),\n    fileB: safeRelative(repoRoot, absB),\n    added: diff.added,\n    removed: diff.removed,\n    changed: diff.changed,\n  };\n}\n\nexport function auto_docs(orchestrator: Orchestrator, graph: GraphStore, repoRoot: string, filePath: string): AutoDoc {\n  const abs = path.resolve(repoRoot, filePath);\n  const rel = safeRelative(repoRoot, abs);\n  const content = orchestrator.getFile(rel);\n  const lines = content.split(/\\r?\\n/);\n  const symbols = graph.listSymbols(rel) as Array<{ name: string; kind: string; startLine: number; endLine: number }>;\n  const exports = symbols.map(s => ({\n    name: s.name,\n    kind: s.kind,\n    range: `${s.startLine}-${s.endLine}`,\n  }));\n  const summary = `${rel} contains ${symbols.length} symbols across ${lines.length} lines.`;\n  return {\n    file: rel,\n    summary,\n    exports,\n    deps: {\n      imports: graph.listImports(rel),\n      dependents: graph.listDependents(rel),\n    },\n  };\n}\n\nexport function run_tests(repoRoot: string, testCommand = 'npm test'): TestRunResult {\n  const [cmd, ...args] = testCommand.split(/\\s+/).filter(Boolean);\n  const binary = process.platform === 'win32' && cmd === 'npm' ? 'npm.cmd' : cmd;\n  const result = spawnSync(binary, args, {\n    cwd: repoRoot,\n    encoding: 'utf8',\n  });\n  return {\n    command: testCommand,\n    status: result.status,\n    stdout: result.stdout ?? '',\n    stderr: result.stderr ?? '',\n  };\n}\n\nexport function run_task(repoRoot: string, scriptName: string): TestRunResult {\n  const pkgPath = path.join(repoRoot, 'package.json');\n  if (!fs.existsSync(pkgPath)) {\n    throw new Error(`package.json not found under ${repoRoot}`);\n  }\n  const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));\n  const scripts = pkg.scripts || {};\n  if (!scripts[scriptName]) {\n    throw new Error(`Script \"${scriptName}\" is not defined in package.json`);\n  }\n  const scriptCommand = String(scripts[scriptName]);\n  const bin = process.platform === 'win32' ? 'npm.cmd' : 'npm';\n  const result = spawnSync(bin, ['run', scriptName], {\n    cwd: repoRoot,\n    encoding: 'utf8',\n  });\n  const status =\n    typeof result.status === 'number'\n      ? result.status\n      : result.error\n      ? -1\n      : 0;\n  let finalStatus = status;\n  let stdout = result.stdout ?? '';\n  let stderr = result.stderr ?? '';\n  if (finalStatus !== 0) {\n    const fallback = spawnSync(scriptCommand, {\n      cwd: repoRoot,\n      encoding: 'utf8',\n      shell: true,\n    });\n    finalStatus =\n      typeof fallback.status === 'number'\n        ? fallback.status\n        : fallback.error\n        ? -1\n        : 0;\n    stdout += fallback.stdout ?? '';\n    stderr += fallback.stderr ?? '';\n  }\n  return {\n    command: `npm run ${scriptName}`,\n    status: finalStatus,\n    stdout,\n    stderr,\n  };\n}\n\nexport function summarize_architecture(graph: GraphStore) {\n  const files = graph['db'].prepare('SELECT COUNT(*) AS c FROM files').get() as any;\n  const symbols = graph['db'].prepare('SELECT COUNT(*) AS c FROM symbols').get() as any;\n  const edges = graph['db'].prepare('SELECT COUNT(*) AS c FROM edges').get() as any;\n  return { files: files?.c || 0, symbols: symbols?.c || 0, edges: edges?.c || 0 };\n}\n\nexport function detect_smells(repoRoot: string) {\n  const smells: Array<{ file: string; issue: string }> = [];\n  const walk = (dir: string) => {\n    for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {\n      const full = path.join(dir, entry.name);\n      if (entry.isDirectory()) {\n        if (entry.name === 'node_modules' || entry.name === 'dist' || entry.name.startsWith('.')) continue;\n        walk(full);\n      } else if (entry.isFile() && (entry.name.endsWith('.ts') || entry.name.endsWith('.tsx'))) {\n        const content = fs.readFileSync(full, 'utf8');\n        if (/TODO|FIXME/.test(content)) smells.push({ file: safeRelative(repoRoot, full), issue: 'TODO/FIXME marker present' });\n        if (content.split(/\\r?\\n/).some(line => line.length > 200)) {\n          smells.push({ file: safeRelative(repoRoot, full), issue: 'Line longer than 200 chars' });\n        }\n      }\n    }\n  };\n  walk(repoRoot);\n  return smells;\n}\n\nexport function suggest_tests(symbols: Array<{ file: string; name: string }>) {\n  return symbols.map(s => ({ symbol: s.name, suggestion: `Add unit test for ${s.name} in ${s.file}` }));\n}\n\nexport async function langchain_query(dataDir: string, query: string, topK = 5): Promise<LangChainQueryResult> {\n  const bridge = new LangChainBridge(dataDir);\n  return bridge.query(query, topK);\n}\n\nexport function generate_telemetry_panel(repoRoot: string, outputPath?: string): TelemetryPanelResult {\n  const logsDir = path.join(repoRoot, 'logs');\n  const snapshotPath = path.join(logsDir, 'telemetry_latest.json');\n  let entries: Array<{ name: string; source: string; count: number; total: number; avg: number; max: number; min: number }> = [];\n  if (fs.existsSync(snapshotPath)) {\n    try {\n      entries = JSON.parse(fs.readFileSync(snapshotPath, 'utf8'));\n    } catch {\n      entries = [];\n    }\n  }\n  const outFile = outputPath ? path.resolve(repoRoot, outputPath) : path.join(logsDir, 'telemetry_panel.html');\n  fs.mkdirSync(path.dirname(outFile), { recursive: true });\n  const rows = entries\n    .map(\n      entry =>\n        `<tr><td>${entry.name}</td><td>${entry.source}</td><td>${entry.count}</td><td>${entry.total}</td><td>${entry.avg.toFixed(\n          2\n        )}</td><td>${entry.max}</td><td>${entry.min}</td></tr>`\n    )\n    .join('');\n  const html = `<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\" />\n  <title>MCP Telemetry Panel</title>\n  <style>\n    body { font-family: Arial, sans-serif; margin: 2rem; background: #111; color: #eee; }\n    table { border-collapse: collapse; width: 100%; }\n    th, td { border: 1px solid #444; padding: 0.5rem; text-align: left; }\n    th { background: #222; }\n    tbody tr:nth-child(even) { background: #1a1a1a; }\n  </style>\n</head>\n<body>\n  <h1>Telemetry Metrics</h1>\n  <p>Generated at ${new Date().toISOString()}</p>\n  <table>\n    <thead>\n      <tr>\n        <th>Name</th>\n        <th>Source</th>\n        <th>Count</th>\n        <th>Total (ms)</th>\n        <th>Avg (ms)</th>\n        <th>Max (ms)</th>\n        <th>Min (ms)</th>\n      </tr>\n    </thead>\n    <tbody>\n      ${rows || '<tr><td colspan=\"7\">No telemetry entries recorded.</td></tr>'}\n    </tbody>\n  </table>\n</body>\n</html>`;\n  fs.writeFileSync(outFile, html, 'utf8');\n  return { output: safeRelative(repoRoot, outFile), entries: entries.length };\n}\n\nexport function open_telemetry_webview(repoRoot: string, options: { regenerate?: boolean; output?: string } = {}): TelemetryWebview {\n  const shouldRegenerate = options.regenerate ?? false;\n  const preferredPath = options.output\n    ? path.resolve(repoRoot, options.output)\n    : path.join(repoRoot, 'logs', 'telemetry_panel.html');\n\n  let htmlPath = preferredPath;\n  if (shouldRegenerate || !fs.existsSync(preferredPath)) {\n    const generated = generate_telemetry_panel(repoRoot, options.output);\n    htmlPath = path.resolve(repoRoot, generated.output);\n  }\n\n  const html = fs.readFileSync(htmlPath, 'utf8');\n  return { path: safeRelative(repoRoot, htmlPath), html };\n}\n\nexport function select_context(results: SearchResult[], budgetTokens: number) {\n  if (!results.length) return results;\n  if (budgetTokens <= 0) return results;\n  const approxTokens = (snippet: string) => Math.ceil(snippet.length / 4);\n  const selected: SearchResult[] = [];\n  let used = 0;\n  for (const res of results) {\n    const cost = approxTokens(res.snippet);\n    if (used + cost > budgetTokens) continue;\n    selected.push(res);\n    used += cost;\n  }\n  return selected.length ? selected : results.slice(0, Math.max(1, Math.min(results.length, 3)));\n}\n",
    "symbols": [
      {
        "name": "safeRelative",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 104,
        "endLine": 106
      },
      {
        "name": "slicePreview",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 108,
        "endLine": 112
      },
      {
        "name": "applyOperations",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 114,
        "endLine": 129
      },
      {
        "name": "plan_refactor",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 131,
        "endLine": 201
      },
      {
        "name": "generate_patch",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 203,
        "endLine": 217
      },
      {
        "name": "apply_patch",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 219,
        "endLine": 229
      },
      {
        "name": "analyze_performance",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 231,
        "endLine": 257
      },
      {
        "name": "diffLines",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 259,
        "endLine": 276
      },
      {
        "name": "compare_versions",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 278,
        "endLine": 291
      },
      {
        "name": "auto_docs",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 293,
        "endLine": 314
      },
      {
        "name": "run_tests",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 316,
        "endLine": 329
      },
      {
        "name": "run_task",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 331,
        "endLine": 377
      },
      {
        "name": "summarize_architecture",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 379,
        "endLine": 384
      },
      {
        "name": "detect_smells",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 386,
        "endLine": 405
      },
      {
        "name": "suggest_tests",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 407,
        "endLine": 409
      },
      {
        "name": "langchain_query",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 411,
        "endLine": 414
      },
      {
        "name": "generate_telemetry_panel",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 416,
        "endLine": 473
      },
      {
        "name": "open_telemetry_webview",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 475,
        "endLine": 489
      },
      {
        "name": "select_context",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/tools.ts",
        "startLine": 491,
        "endLine": 504
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/watcher.ts",
    "content": "import chokidar from 'chokidar';\nimport path from 'path';\nimport { runIndexer } from './indexer';\nimport { createQueue, enqueueReindex } from './job_queue';\n\nexport function startWatcher(rootDir: string, outDir: string, sqlitePath: string) {\n  const watcher = chokidar.watch([path.join(rootDir, '**/*.ts'), path.join(rootDir, '**/*.tsx')], {\n    ignored: [/node_modules/, /dist/, /(^|[/\\\\])\\../],\n    ignoreInitial: true,\n  });\n  const redisUrl = process.env.REDIS_URL;\n  const queue = redisUrl ? createQueue('mcp-jobs', redisUrl) : undefined;\n  const schedule = debounce(async () => {\n    if (queue) {\n      await enqueueReindex(queue, { rootDir, outDir, sqlite: sqlitePath });\n    } else {\n      await runIndexer(rootDir, outDir, sqlitePath);\n    }\n    console.log('Incremental index scheduled');\n  }, 500);\n  watcher.on('add', schedule).on('change', schedule).on('unlink', schedule);\n  return watcher;\n}\n\nfunction debounce(fn: () => void | Promise<void>, ms: number) {\n  let t: any;\n  return () => {\n    clearTimeout(t);\n    t = setTimeout(fn, ms);\n  };\n}\n\nif (require.main === module) {\n  const envRoot = process.env.INDEX_ROOT || process.env.MCP_INDEX_ROOT || process.env.WORKSPACE_ROOT;\n  const envData = process.env.DATA_DIR || process.env.MCP_DATA_DIR;\n  const rootDir = envRoot ? path.resolve(envRoot) : path.join(process.cwd(), 'src');\n  const outDir = envData ? path.resolve(envData) : path.join(process.cwd(), 'data');\n  const sqlite = path.join(outDir, 'graph.db');\n  console.log(`[mcp-watch] rootDir=${rootDir}`);\n  console.log(`[mcp-watch] outDir=${outDir}`);\n  startWatcher(rootDir, outDir, sqlite);\n}\n",
    "symbols": [
      {
        "name": "startWatcher",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/watcher.ts",
        "startLine": 6,
        "endLine": 23
      },
      {
        "name": "debounce",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/watcher.ts",
        "startLine": 25,
        "endLine": 31
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/src/weights.ts",
    "content": "import fs from 'fs';\nimport path from 'path';\n\nexport interface Weights { semantic: number; lexical: number; graph: number; }\nconst defaultWeights: Weights = { semantic: 0.6, lexical: 0.25, graph: 0.15 };\n\nfunction clamp01(x: number) { return Math.max(0, Math.min(1, x)); }\n\nexport class WeightManager {\n  private file: string;\n  private w: Weights;\n  constructor(file = path.join(process.cwd(), 'weights.json')) {\n    this.file = file;\n    this.w = this.load();\n  }\n  private load(): Weights {\n    try {\n      const data = JSON.parse(fs.readFileSync(this.file, 'utf8'));\n      return { semantic: data.semantic, lexical: data.lexical, graph: data.graph } as Weights;\n    } catch { return { ...defaultWeights }; }\n  }\n  private save() { fs.writeFileSync(this.file, JSON.stringify(this.w, null, 2), 'utf8'); }\n  get(): Weights { return { ...this.w }; }\n  feedback(kind: 'up' | 'down') {\n    const delta = kind === 'up' ? 0.01 : -0.01;\n    // simple strategy: increase semantic on up, lexical on down toggles towards balance\n    this.w.semantic = clamp01(this.w.semantic + delta);\n    this.w.lexical = clamp01(this.w.lexical + (kind === 'up' ? -delta/2 : +delta/2));\n    // normalize\n    const s = this.w.semantic + this.w.lexical + this.w.graph;\n    this.w.semantic /= s; this.w.lexical /= s; this.w.graph /= s;\n    this.save();\n  }\n}\n\n",
    "symbols": [
      {
        "name": "clamp01",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/weights.ts",
        "startLine": 7,
        "endLine": 7
      },
      {
        "name": "WeightManager",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/weights.ts",
        "startLine": 9,
        "endLine": 34
      },
      {
        "name": "WeightManager.load",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/weights.ts",
        "startLine": 16,
        "endLine": 21
      },
      {
        "name": "WeightManager.save",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/weights.ts",
        "startLine": 22,
        "endLine": 22
      },
      {
        "name": "WeightManager.get",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/weights.ts",
        "startLine": 23,
        "endLine": 23
      },
      {
        "name": "WeightManager.feedback",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/@mcp/server/src/weights.ts",
        "startLine": 24,
        "endLine": 33
      }
    ]
  },
  {
    "path": "node_modules/@mcp/server/tests/ranker.test.ts",
    "content": "import { describe, it, expect } from 'vitest';\nimport { rank_hybrid, set_weights } from '../src/ranker';\nimport type { SearchResult } from '@mcp/shared';\n\ndescribe('rank_hybrid', () => {\n  it('combines signals and sorts', () => {\n    set_weights({ semantic: 0.6, lexical: 0.3, graph: 0.1 });\n    const res: SearchResult[] = [\n      { file: 'a.ts', symbol: 'A.fn', startLine: 1, endLine: 5, score: 0.6, snippet: 'alpha beta' },\n      { file: 'b.ts', symbol: 'B.fn', startLine: 1, endLine: 5, score: 0.5, snippet: 'beta gamma' }\n    ];\n    const ranked = rank_hybrid(res, 'beta', f => (f === 'b.ts' ? 2 : 1));\n    expect(ranked[0].file).toBe('a.ts');\n  });\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/@mcp/server/tests/tools.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport fs from 'fs';\nimport os from 'os';\nimport path from 'path';\nimport {\n  plan_refactor,\n  generate_patch,\n  apply_patch,\n  analyze_performance,\n  compare_versions,\n  auto_docs,\n  run_tests,\n  run_task,\n  generate_telemetry_panel,\n  open_telemetry_webview,\n  langchain_query,\n} from '../src/tools';\nimport type { Orchestrator } from '../src/orchestrator';\nimport type { GraphStore } from '../src/graph_store';\n\nconst sampleCode = `export class Sample {\n  items: number[] = [];\n\n  addItem(value: number) {\n    for (let i = 0; i < this.items.length; i++) {\n      for (let j = 0; j < this.items.length; j++) {\n        this.items[j] += value;\n      }\n    }\n    return this.items.length;\n  }\n}\n`;\n\nconst fakeOrchestrator = {\n  getFile: () => sampleCode,\n} as unknown as Orchestrator;\n\nconst fakeGraph = {\n  listSymbols: () => [\n    { name: 'Sample', kind: 'class', startLine: 1, endLine: 11 },\n    { name: 'Sample.addItem', kind: 'method', startLine: 4, endLine: 10 },\n  ],\n  listImports: () => ['utils/logger.ts'],\n  listDependents: () => ['services/consumer.ts'],\n} as unknown as GraphStore;\n\ndescribe('tools helpers', () => {\n  let tempDir: string;\n\n  beforeEach(() => {\n    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'mcp-tools-'));\n  });\n\n  afterEach(() => {\n    fs.rmSync(tempDir, { recursive: true, force: true });\n  });\n\n  it('plans refactor with symbol focus', () => {\n    const plan = plan_refactor(fakeOrchestrator, fakeGraph, tempDir, { file: 'sample.ts', symbol: 'Sample.addItem', goal: 'reduce loop count' });\n    expect(plan.summary).toContain('Sample.addItem');\n    expect(plan.steps.some(step => step.includes('Sample.addItem'))).toBe(true);\n    expect(plan.impact.imports).toEqual(['utils/logger.ts']);\n  });\n\n  it('generates and applies patches', () => {\n    const filePath = path.join(tempDir, 'demo.ts');\n    fs.writeFileSync(filePath, 'const value = 1;\\n', 'utf8');\n    const patch = generate_patch(tempDir, 'demo.ts', [{ find: '1', replace: '2' }]);\n    expect(patch.preview.after.join('\\n')).toContain('2');\n    const result = apply_patch(tempDir, 'demo.ts', [{ find: '1', replace: '2' }]);\n    expect(result.applied).toBe(1);\n    const updated = fs.readFileSync(filePath, 'utf8');\n    expect(updated).toContain('2');\n  });\n\n  it('detects basic performance smells', () => {\n    const filePath = path.join(tempDir, 'perf.ts');\n    fs.writeFileSync(filePath, sampleCode, 'utf8');\n    const insight = analyze_performance(tempDir, 'perf.ts');\n    expect(insight.issues.some(issue => issue.includes('Nested'))).toBe(true);\n  });\n\n  it('compares versions line by line', () => {\n    const a = path.join(tempDir, 'a.ts');\n    const b = path.join(tempDir, 'b.ts');\n    fs.writeFileSync(a, 'const a = 1;\\n', 'utf8');\n    fs.writeFileSync(b, 'const a = 2;\\n', 'utf8');\n    const diff = compare_versions(tempDir, 'a.ts', 'b.ts');\n    expect(diff.changed.length).toBeGreaterThan(0);\n  });\n\n  it('produces auto docs summary', () => {\n    const docs = auto_docs(fakeOrchestrator, fakeGraph, tempDir, 'sample.ts');\n    expect(docs.summary).toContain('sample.ts');\n    expect(docs.exports.length).toBe(2);\n  });\n\n  it('runs provided test command', () => {\n    const result = run_tests(tempDir, 'node -e process.exit(0)');\n    expect(result.status).toBe(0);\n  });\n\n  it('runs an npm script via run_task', () => {\n    const pkg = {\n      name: 'fixture',\n      version: '1.0.0',\n      scripts: {\n        exit0: 'node -e \"process.exit(0)\"',\n      },\n    };\n    fs.writeFileSync(path.join(tempDir, 'package.json'), JSON.stringify(pkg, null, 2), 'utf8');\n    const result = run_task(tempDir, 'exit0');\n    expect(result.status).toBe(0);\n    expect(result.command).toBe('npm run exit0');\n  });\n\n  it('generates telemetry panel html', () => {\n    const logsDir = path.join(tempDir, 'logs');\n    fs.mkdirSync(logsDir, { recursive: true });\n    const snapshot = [\n      { name: 'search_code', source: 'mcp:tools', count: 2, total: 40, avg: 20, max: 30, min: 10 },\n    ];\n    fs.writeFileSync(path.join(logsDir, 'telemetry_latest.json'), JSON.stringify(snapshot), 'utf8');\n    const result = generate_telemetry_panel(tempDir);\n    const htmlPath = path.join(tempDir, result.output);\n    const html = fs.readFileSync(htmlPath, 'utf8');\n    expect(html).toContain('Telemetry Metrics');\n    expect(html).toContain('search_code');\n  });\n\n  it('opens telemetry webview html', () => {\n    const logsDir = path.join(tempDir, 'logs');\n    fs.mkdirSync(logsDir, { recursive: true });\n    const snapshot = [\n      { name: 'search_code', source: 'mcp:tools', count: 1, total: 10, avg: 10, max: 10, min: 10 },\n    ];\n    fs.writeFileSync(path.join(logsDir, 'telemetry_latest.json'), JSON.stringify(snapshot), 'utf8');\n    generate_telemetry_panel(tempDir);\n    const webview = open_telemetry_webview(tempDir);\n    expect(webview.html).toContain('<html');\n    expect(webview.path.endsWith('.html')).toBe(true);\n  });\n\n  it('provides langchain bridge fallback results', async () => {\n    const dataDir = path.join(tempDir, 'data');\n    fs.mkdirSync(dataDir, { recursive: true });\n    const entries = [\n      {\n        id: 'demo:add',\n        file: 'demo.ts',\n        symbol: 'add',\n        text: 'export function add(a: number, b: number) { return a + b; }',\n      },\n      {\n        id: 'demo:sub',\n        file: 'demo.ts',\n        symbol: 'sub',\n        text: 'export function sub(a: number, b: number) { return a - b; }',\n      },\n    ];\n    fs.writeFileSync(path.join(dataDir, 'semantic_entries.json'), JSON.stringify(entries), 'utf8');\n    const result = await langchain_query(dataDir, 'add numbers', 2);\n    expect(result.results.length).toBeGreaterThan(0);\n    expect(result.results[0].symbol.toLowerCase()).toContain('add');\n  });\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/@mcp/shared/src/index.ts",
    "content": "export interface SymbolMeta {\n  name: string;\n  kind: 'function' | 'class' | 'method' | 'unknown';\n  file: string;\n  startLine: number;\n  endLine: number;\n}\n\nexport interface FileMeta {\n  path: string;\n  content: string;\n  symbols: SymbolMeta[];\n}\n\nexport interface SemanticEntry {\n  id: string;\n  file: string;\n  symbol: string;\n  startLine: number;\n  endLine: number;\n  text: string;\n}\n\nexport interface SearchResult {\n  file: string;\n  symbol: string;\n  startLine: number;\n  endLine: number;\n  score: number;\n  snippet: string;\n}\n\n",
    "symbols": []
  },
  {
    "path": "node_modules/madge/test/typescript/export.ts",
    "content": "class ExportClass {\n\tstringLength(s: string) {\n\t\treturn s.length;\n\t}\n}\n\nexport = ExportClass;\n",
    "symbols": [
      {
        "name": "ExportClass",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/export.ts",
        "startLine": 1,
        "endLine": 5
      },
      {
        "name": "ExportClass.stringLength",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/export.ts",
        "startLine": 2,
        "endLine": 4
      }
    ]
  },
  {
    "path": "node_modules/madge/test/typescript/import.ts",
    "content": "import B from './require';\nimport heading from './require-x';\n\nclass ImportClass {\n\tconstructor(public greeting: string) { }\n\tgreet() {\n\t\treturn \"<h1>\" + this.greeting + \"</h1>\";\n\t}\n};\n",
    "symbols": [
      {
        "name": "ImportClass",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/import.ts",
        "startLine": 4,
        "endLine": 9
      },
      {
        "name": "ImportClass.greet",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/import.ts",
        "startLine": 6,
        "endLine": 8
      }
    ]
  },
  {
    "path": "node_modules/madge/test/typescript/mixed.ts",
    "content": "require('./export');\nimport './export-x';\n",
    "symbols": []
  },
  {
    "path": "node_modules/madge/test/typescript/require.ts",
    "content": "import x = require('./export');\n\nexport default class RequireClass  {\n\tstringLength(s: string) {\n\t\treturn s.length;\n\t}\n}\n",
    "symbols": [
      {
        "name": "RequireClass",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/require.ts",
        "startLine": 3,
        "endLine": 7
      },
      {
        "name": "RequireClass.stringLength",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/require.ts",
        "startLine": 4,
        "endLine": 6
      }
    ]
  },
  {
    "path": "node_modules/piscina/src/task_queue/array_queue.ts",
    "content": "import assert from 'node:assert';\n\nimport type { TaskQueue, Task } from '.';\n\nexport class ArrayTaskQueue implements TaskQueue {\n  tasks: Task[] = []\n\n  get size () {\n    return this.tasks.length;\n  }\n\n  shift (): Task | null {\n    return this.tasks.shift() ?? null;\n  }\n\n  push (task: Task): void {\n    this.tasks.push(task);\n  }\n\n  remove (task: Task): void {\n    const index = this.tasks.indexOf(task);\n    assert.notStrictEqual(index, -1);\n    this.tasks.splice(index, 1);\n  }\n}\n",
    "symbols": [
      {
        "name": "ArrayTaskQueue",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/array_queue.ts",
        "startLine": 5,
        "endLine": 25
      },
      {
        "name": "ArrayTaskQueue.shift",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/array_queue.ts",
        "startLine": 12,
        "endLine": 14
      },
      {
        "name": "ArrayTaskQueue.push",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/array_queue.ts",
        "startLine": 16,
        "endLine": 18
      },
      {
        "name": "ArrayTaskQueue.remove",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/array_queue.ts",
        "startLine": 20,
        "endLine": 24
      }
    ]
  },
  {
    "path": "node_modules/piscina/src/task_queue/common.ts",
    "content": "import type { kQueueOptions } from '../symbols';\n\nexport interface TaskQueue {\n    readonly size: number;\n    shift(): Task | null;\n    remove(task: Task): void;\n    push(task: Task): void;\n}\n\n// Public Interface\nexport interface PiscinaTask extends Task {\n    taskId: number;\n    filename: string;\n    name: string;\n    created: number;\n    isAbortable: boolean;\n}\n\nexport interface Task {\n    readonly [kQueueOptions]: object | null\n};\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/src/task_queue/fixed_queue.ts",
    "content": "/*\n * Modified Fixed Queue Implementation based on the one from Node.js Project\n * License: MIT License\n * Source: https://github.com/nodejs/node/blob/de7b37880f5a541d5f874c1c2362a65a4be76cd0/lib/internal/fixed_queue.js\n */\nimport assert from 'node:assert';\nimport type { Task } from './common';\nimport { TaskQueue } from '.';\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  bottom: number\n  top: number\n  list: Array<Task | undefined>\n  next: FixedCircularBuffer | null\n\n  constructor () {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty () {\n    return this.top === this.bottom;\n  }\n\n  isFull () {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push (data:Task) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift () {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined) { return null; }\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n\n  remove (task: Task) {\n    const indexToRemove = this.list.indexOf(task);\n\n    assert.notStrictEqual(indexToRemove, -1);\n    let curr = indexToRemove;\n    while (true) {\n      const next = (curr + 1) & kMask;\n      this.list[curr] = this.list[next];\n      if (this.list[curr] === undefined) {\n        break;\n      }\n      if (next === indexToRemove) {\n        this.list[curr] = undefined;\n        break;\n      }\n      curr = next;\n    }\n    this.top = (this.top - 1) & kMask;\n  }\n}\n\nexport class FixedQueue implements TaskQueue {\n  head: FixedCircularBuffer\n  tail: FixedCircularBuffer\n  _size: number = 0\n\n  constructor () {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty () {\n    return this.head.isEmpty();\n  }\n\n  push (data:Task) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n    this._size++;\n  }\n\n  shift (): Task | null {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (next !== null) this._size--;\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n      tail.next = null;\n    }\n    return next;\n  }\n\n  remove (task: Task) {\n    let prev: FixedCircularBuffer | null = null;\n    let buffer = this.tail;\n    while (true) {\n      if (buffer.list.includes(task)) {\n        buffer.remove(task);\n        this._size--;\n        break;\n      }\n      if (buffer.next === null) break;\n      prev = buffer;\n      buffer = buffer.next;\n    }\n    if (buffer.isEmpty()) {\n      // removing tail\n      if (prev === null) {\n        // if tail is not the last buffer\n        if (buffer.next !== null) this.tail = buffer.next;\n      } else {\n        // removing head\n        if (buffer.next === null) {\n          this.head = prev;\n        } else {\n          // removing buffer from middle\n          prev.next = buffer.next;\n        }\n      }\n    }\n  }\n\n  get size () {\n    return this._size;\n  }\n};\n",
    "symbols": [
      {
        "name": "FixedCircularBuffer",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts",
        "startLine": 61,
        "endLine": 114
      },
      {
        "name": "FixedCircularBuffer.isEmpty",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts",
        "startLine": 74,
        "endLine": 76
      },
      {
        "name": "FixedCircularBuffer.isFull",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts",
        "startLine": 78,
        "endLine": 80
      },
      {
        "name": "FixedCircularBuffer.push",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts",
        "startLine": 82,
        "endLine": 85
      },
      {
        "name": "FixedCircularBuffer.shift",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts",
        "startLine": 87,
        "endLine": 93
      },
      {
        "name": "FixedCircularBuffer.remove",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts",
        "startLine": 95,
        "endLine": 113
      },
      {
        "name": "FixedQueue",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts",
        "startLine": 116,
        "endLine": 184
      },
      {
        "name": "FixedQueue.isEmpty",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts",
        "startLine": 125,
        "endLine": 127
      },
      {
        "name": "FixedQueue.push",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts",
        "startLine": 129,
        "endLine": 137
      },
      {
        "name": "FixedQueue.shift",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts",
        "startLine": 139,
        "endLine": 149
      },
      {
        "name": "FixedQueue.remove",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/fixed_queue.ts",
        "startLine": 151,
        "endLine": 179
      }
    ]
  },
  {
    "path": "node_modules/piscina/src/task_queue/index.ts",
    "content": "import type { MessagePort } from 'node:worker_threads';\nimport { performance } from 'node:perf_hooks';\nimport { AsyncResource } from 'node:async_hooks';\n\nimport type { WorkerInfo } from '../worker_pool';\nimport type { AbortSignalAny, AbortSignalEventEmitter } from '../abort';\nimport { isMovable } from '../common';\nimport { kTransferable, kValue, kQueueOptions } from '../symbols';\n\nimport type { Task, TaskQueue, PiscinaTask } from './common';\n\nexport { ArrayTaskQueue } from './array_queue';\nexport { FixedQueue } from './fixed_queue';\n\nexport type TaskCallback = (err: Error, result: any) => void\n// Grab the type of `transferList` off `MessagePort`. At the time of writing,\n// only ArrayBuffer and MessagePort are valid, but let's avoid having to update\n// our types here every time Node.js adds support for more objects.\nexport type TransferList = MessagePort extends {\n  postMessage: (value: any, transferList: infer T) => any\n}\n  ? T\n  : never\nexport type TransferListItem = TransferList extends Array<infer T> ? T : never\n\n/**\n * Verifies if a given TaskQueue is valid\n *\n * @export\n * @param {*} value\n * @return {*}  {boolean}\n */\nexport function isTaskQueue (value: TaskQueue): boolean {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'size' in value &&\n    typeof value.shift === 'function' &&\n    typeof value.remove === 'function' &&\n    typeof value.push === 'function'\n  );\n}\n\nlet taskIdCounter = 0;\n// Extend AsyncResource so that async relations between posting a task and\n// receiving its result are visible to diagnostic tools.\nexport class TaskInfo extends AsyncResource implements Task {\n    callback : TaskCallback;\n    task : any;\n    transferList : TransferList;\n    filename : string;\n    name : string;\n    taskId : number;\n    abortSignal : AbortSignalAny | null;\n    abortListener : (() => void) | null = null;\n    workerInfo : WorkerInfo | null = null;\n    created : number;\n    started : number;\n\n    constructor (\n      task : any,\n      transferList : TransferList,\n      filename : string,\n      name : string,\n      callback : TaskCallback,\n      abortSignal : AbortSignalAny | null,\n      triggerAsyncId : number) {\n      super('Piscina.Task', { requireManualDestroy: true, triggerAsyncId });\n      this.callback = callback;\n      this.task = task;\n      this.transferList = transferList;\n\n      // If the task is a Transferable returned by\n      // Piscina.move(), then add it to the transferList\n      // automatically\n      if (isMovable(task)) {\n        // This condition should never be hit but typescript\n        // complains if we dont do the check.\n        /* istanbul ignore if */\n        if (this.transferList == null) {\n          this.transferList = [];\n        }\n        this.transferList =\n          this.transferList.concat(task[kTransferable]);\n        this.task = task[kValue];\n      }\n\n      this.filename = filename;\n      this.name = name;\n      this.taskId = taskIdCounter++;\n      this.abortSignal = abortSignal;\n      this.created = performance.now();\n      this.started = 0;\n    }\n\n    releaseTask () : any {\n      const ret = this.task;\n      this.task = null;\n      return ret;\n    }\n\n    done (err : Error | null, result? : any) : void {\n      this.runInAsyncScope(this.callback, null, err, result);\n      this.emitDestroy(); // `TaskInfo`s are used only once.\n      // If an abort signal was used, remove the listener from it when\n      // done to make sure we do not accidentally leak.\n      if (this.abortSignal && this.abortListener) {\n        if ('removeEventListener' in this.abortSignal && this.abortListener) {\n          this.abortSignal.removeEventListener('abort', this.abortListener);\n        } else {\n          (this.abortSignal as AbortSignalEventEmitter).off(\n            'abort', this.abortListener);\n        }\n      }\n    }\n\n    get [kQueueOptions] () : object | null {\n      return kQueueOptions in this.task ? this.task[kQueueOptions] : null;\n    }\n\n    get interface (): PiscinaTask {\n      return {\n        taskId: this.taskId,\n        filename: this.filename,\n        name: this.name,\n        created: this.created,\n        isAbortable: this.abortSignal !== null,\n        [kQueueOptions]: this[kQueueOptions]\n      };\n    }\n}\n\nexport { Task, TaskQueue, PiscinaTask };\n",
    "symbols": [
      {
        "name": "isTaskQueue",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/index.ts",
        "startLine": 33,
        "endLine": 42
      },
      {
        "name": "TaskInfo",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/index.ts",
        "startLine": 47,
        "endLine": 131
      },
      {
        "name": "TaskInfo.releaseTask",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/index.ts",
        "startLine": 96,
        "endLine": 100
      },
      {
        "name": "TaskInfo.done",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/task_queue/index.ts",
        "startLine": 102,
        "endLine": 115
      }
    ]
  },
  {
    "path": "node_modules/piscina/src/worker_pool/index.ts",
    "content": "import { Worker, MessagePort, receiveMessageOnPort } from 'node:worker_threads';\nimport assert from 'node:assert';\n\nimport { RequestMessage, ResponseMessage } from '../types';\nimport { Errors } from '../errors';\n\nimport { TaskInfo } from '../task_queue';\nimport { kFieldCount, kRequestCountField, kResponseCountField } from '../symbols';\n\ntype ResponseCallback = (response : ResponseMessage) => void;\n\nabstract class AsynchronouslyCreatedResource {\n    onreadyListeners : (() => void)[] | null = [];\n\n    markAsReady () : void {\n      const listeners = this.onreadyListeners;\n      assert(listeners !== null);\n      this.onreadyListeners = null;\n      for (const listener of listeners) {\n        listener();\n      }\n    }\n\n    isReady () : boolean {\n      return this.onreadyListeners === null;\n    }\n\n    onReady (fn : () => void) {\n      if (this.onreadyListeners === null) {\n        fn(); // Zalgo is okay here.\n        return;\n      }\n      this.onreadyListeners.push(fn);\n    }\n\n    abstract currentUsage() : number;\n}\n\nexport class AsynchronouslyCreatedResourcePool<\n  T extends AsynchronouslyCreatedResource> {\n  pendingItems = new Set<T>();\n  readyItems = new Set<T>();\n  maximumUsage : number;\n  onAvailableListeners : ((item : T) => void)[];\n\n  constructor (maximumUsage : number) {\n    this.maximumUsage = maximumUsage;\n    this.onAvailableListeners = [];\n  }\n\n  add (item : T) {\n    this.pendingItems.add(item);\n    item.onReady(() => {\n      /* istanbul ignore else */\n      if (this.pendingItems.has(item)) {\n        this.pendingItems.delete(item);\n        this.readyItems.add(item);\n        this.maybeAvailable(item);\n      }\n    });\n  }\n\n  delete (item : T) {\n    this.pendingItems.delete(item);\n    this.readyItems.delete(item);\n  }\n\n  findAvailable () : T | null {\n    let minUsage = this.maximumUsage;\n    let candidate = null;\n    for (const item of this.readyItems) {\n      const usage = item.currentUsage();\n      if (usage === 0) return item;\n      if (usage < minUsage) {\n        candidate = item;\n        minUsage = usage;\n      }\n    }\n    return candidate;\n  }\n\n  * [Symbol.iterator] () {\n    yield * this.pendingItems;\n    yield * this.readyItems;\n  }\n\n  get size () {\n    return this.pendingItems.size + this.readyItems.size;\n  }\n\n  maybeAvailable (item : T) {\n    /* istanbul ignore else */\n    if (item.currentUsage() < this.maximumUsage) {\n      for (const listener of this.onAvailableListeners) {\n        listener(item);\n      }\n    }\n  }\n\n  onAvailable (fn : (item : T) => void) {\n    this.onAvailableListeners.push(fn);\n  }\n}\n\nexport class WorkerInfo extends AsynchronouslyCreatedResource {\n    worker : Worker;\n    taskInfos : Map<number, TaskInfo>;\n    idleTimeout : NodeJS.Timeout | null = null; // eslint-disable-line no-undef\n    port : MessagePort;\n    sharedBuffer : Int32Array;\n    lastSeenResponseCount : number = 0;\n    onMessage : ResponseCallback;\n\n    constructor (\n      worker : Worker,\n      port : MessagePort,\n      onMessage : ResponseCallback) {\n      super();\n      this.worker = worker;\n      this.port = port;\n      this.port.on('message',\n        (message : ResponseMessage) => this._handleResponse(message));\n      this.onMessage = onMessage;\n      this.taskInfos = new Map();\n      this.sharedBuffer = new Int32Array(\n        new SharedArrayBuffer(kFieldCount * Int32Array.BYTES_PER_ELEMENT));\n    }\n\n    destroy () : void {\n      this.worker.terminate();\n      this.port.close();\n      this.clearIdleTimeout();\n      for (const taskInfo of this.taskInfos.values()) {\n        taskInfo.done(Errors.ThreadTermination());\n      }\n      this.taskInfos.clear();\n    }\n\n    clearIdleTimeout () : void {\n      if (this.idleTimeout !== null) {\n        clearTimeout(this.idleTimeout);\n        this.idleTimeout = null;\n      }\n    }\n\n    ref () : WorkerInfo {\n      this.port.ref();\n      return this;\n    }\n\n    unref () : WorkerInfo {\n      // Note: Do not call ref()/unref() on the Worker itself since that may cause\n      // a hard crash, see https://github.com/nodejs/node/pull/33394.\n      this.port.unref();\n      return this;\n    }\n\n    _handleResponse (message : ResponseMessage) : void {\n      this.onMessage(message);\n\n      if (this.taskInfos.size === 0) {\n        // No more tasks running on this Worker means it should not keep the\n        // process running.\n        this.unref();\n      }\n    }\n\n    postTask (taskInfo : TaskInfo) {\n      assert(!this.taskInfos.has(taskInfo.taskId));\n      const message : RequestMessage = {\n        task: taskInfo.releaseTask(),\n        taskId: taskInfo.taskId,\n        filename: taskInfo.filename,\n        name: taskInfo.name\n      };\n\n      try {\n        this.port.postMessage(message, taskInfo.transferList);\n      } catch (err) {\n        // This would mostly happen if e.g. message contains unserializable data\n        // or transferList is invalid.\n        taskInfo.done(<Error>err);\n        return;\n      }\n\n      taskInfo.workerInfo = this;\n      this.taskInfos.set(taskInfo.taskId, taskInfo);\n      this.ref();\n      this.clearIdleTimeout();\n\n      // Inform the worker that there are new messages posted, and wake it up\n      // if it is waiting for one.\n      Atomics.add(this.sharedBuffer, kRequestCountField, 1);\n      Atomics.notify(this.sharedBuffer, kRequestCountField, 1);\n    }\n\n    processPendingMessages () {\n      // If we *know* that there are more messages than we have received using\n      // 'message' events yet, then try to load and handle them synchronously,\n      // without the need to wait for more expensive events on the event loop.\n      // This would usually break async tracking, but in our case, we already have\n      // the extra TaskInfo/AsyncResource layer that rectifies that situation.\n      const actualResponseCount =\n        Atomics.load(this.sharedBuffer, kResponseCountField);\n      if (actualResponseCount !== this.lastSeenResponseCount) {\n        this.lastSeenResponseCount = actualResponseCount;\n\n        let entry;\n        while ((entry = receiveMessageOnPort(this.port)) !== undefined) {\n          this._handleResponse(entry.message);\n        }\n      }\n    }\n\n    isRunningAbortableTask () : boolean {\n      // If there are abortable tasks, we are running one at most per Worker.\n      if (this.taskInfos.size !== 1) return false;\n      const [[, task]] = this.taskInfos;\n      return task.abortSignal !== null;\n    }\n\n    currentUsage () : number {\n      if (this.isRunningAbortableTask()) return Infinity;\n      return this.taskInfos.size;\n    }\n}\n",
    "symbols": [
      {
        "name": "AsynchronouslyCreatedResource",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 12,
        "endLine": 37
      },
      {
        "name": "AsynchronouslyCreatedResource.markAsReady",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 15,
        "endLine": 22
      },
      {
        "name": "AsynchronouslyCreatedResource.isReady",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 24,
        "endLine": 26
      },
      {
        "name": "AsynchronouslyCreatedResource.onReady",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 28,
        "endLine": 34
      },
      {
        "name": "AsynchronouslyCreatedResource.currentUsage",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 36,
        "endLine": 36
      },
      {
        "name": "AsynchronouslyCreatedResourcePool",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 39,
        "endLine": 103
      },
      {
        "name": "AsynchronouslyCreatedResourcePool.add",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 51,
        "endLine": 61
      },
      {
        "name": "AsynchronouslyCreatedResourcePool.delete",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 63,
        "endLine": 66
      },
      {
        "name": "AsynchronouslyCreatedResourcePool.findAvailable",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 68,
        "endLine": 80
      },
      {
        "name": "AsynchronouslyCreatedResourcePool.[Symbol.iterator]",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 82,
        "endLine": 85
      },
      {
        "name": "AsynchronouslyCreatedResourcePool.maybeAvailable",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 91,
        "endLine": 98
      },
      {
        "name": "AsynchronouslyCreatedResourcePool.onAvailable",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 100,
        "endLine": 102
      },
      {
        "name": "WorkerInfo",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 105,
        "endLine": 226
      },
      {
        "name": "WorkerInfo.destroy",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 129,
        "endLine": 137
      },
      {
        "name": "WorkerInfo.clearIdleTimeout",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 139,
        "endLine": 144
      },
      {
        "name": "WorkerInfo.ref",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 146,
        "endLine": 149
      },
      {
        "name": "WorkerInfo.unref",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 151,
        "endLine": 156
      },
      {
        "name": "WorkerInfo._handleResponse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 158,
        "endLine": 166
      },
      {
        "name": "WorkerInfo.postTask",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 168,
        "endLine": 195
      },
      {
        "name": "WorkerInfo.processPendingMessages",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 197,
        "endLine": 213
      },
      {
        "name": "WorkerInfo.isRunningAbortableTask",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 215,
        "endLine": 220
      },
      {
        "name": "WorkerInfo.currentUsage",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/piscina/src/worker_pool/index.ts",
        "startLine": 222,
        "endLine": 225
      }
    ]
  },
  {
    "path": "node_modules/piscina/test/fixtures/console-log.ts",
    "content": "import Piscina from '../..';\nimport { resolve } from 'path';\n\nconst pool = new Piscina({\n  filename: resolve(__dirname, 'eval.js'),\n  maxThreads: 1\n});\n\npool.runTask('console.log(\"A\"); console.log(\"B\");');\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/fixtures/move.ts",
    "content": "import Piscina from '../..';\nimport assert from 'assert';\nimport { types } from 'util';\n\nexport default function (moved) {\n  if (moved !== undefined) {\n    assert(types.isAnyArrayBuffer(moved));\n  }\n  return Piscina.move(new ArrayBuffer(10));\n}\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/fixtures/notify-then-sleep-or.ts",
    "content": "// Set the index-th bith in i32array[0], then wait for it to be un-set again.\nmodule.exports = function ({ i32array, index }) {\n  Atomics.or(i32array, 0, 1 << index);\n  Atomics.notify(i32array, 0, Infinity);\n  do {\n    const v = Atomics.load(i32array, 0);\n    if (!(v & (1 << index))) break;\n    Atomics.wait(i32array, 0, v);\n  } while (true);\n};\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/fixtures/notify-then-sleep.ts",
    "content": "module.exports = function (i32array) {\n  Atomics.store(i32array, 0, 1);\n  Atomics.notify(i32array, 0, Infinity);\n  Atomics.wait(i32array, 0, 1);\n};\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/fixtures/simple-isworkerthread-named-import.ts",
    "content": "import { isWorkerThread } from '../..';\nimport assert from 'assert';\n\nassert.strictEqual(isWorkerThread, true);\n\nexport default function () { return 'done'; }\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/fixtures/simple-isworkerthread.ts",
    "content": "import Piscina from '../..';\nimport assert from 'assert';\n\nassert.strictEqual(Piscina.isWorkerThread, true);\n\nexport default function () { return 'done'; }\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/fixtures/simple-workerdata-named-import.ts",
    "content": "import { workerData } from '../..';\nimport assert from 'assert';\n\nassert.strictEqual(workerData, 'ABC');\n\nexport default function () { return 'done'; }\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/fixtures/simple-workerdata.ts",
    "content": "import Piscina from '../..';\nimport assert from 'assert';\n\nassert.strictEqual(Piscina.workerData, 'ABC');\n\nexport default function () { return 'done'; }\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/fixtures/wait-for-notify.ts",
    "content": "module.exports = function (i32array) {\n  Atomics.wait(i32array, 0, 0);\n  Atomics.store(i32array, 0, -1);\n  Atomics.notify(i32array, 0, Infinity);\n};\n",
    "symbols": []
  },
  {
    "path": "node_modules/piscina/test/fixtures/wait-for-others.ts",
    "content": "import { threadId } from 'worker_threads';\n\nmodule.exports = async function ([i32array, n]) {\n  Atomics.add(i32array, 0, 1);\n  Atomics.notify(i32array, 0, Infinity);\n  let lastSeenValue;\n  while ((lastSeenValue = Atomics.load(i32array, 0)) < n) {\n    Atomics.wait(i32array, 0, lastSeenValue);\n  }\n  return threadId;\n};\n",
    "symbols": []
  },
  {
    "path": "node_modules/tsconfig-paths/src/__tests__/config-loader.test.ts",
    "content": "import {\n  configLoader,\n  loadConfig,\n  ConfigLoaderFailResult,\n  ConfigLoaderSuccessResult,\n} from \"../config-loader\";\nimport { join } from \"path\";\n\ndescribe(\"config-loader\", (): void => {\n  it(\"should use explicitParams when set\", () => {\n    const result = configLoader({\n      explicitParams: {\n        baseUrl: \"/foo/bar\",\n        paths: {\n          asd: [\"asd\"],\n        },\n      },\n      cwd: \"/baz\",\n    });\n\n    const successResult = result as ConfigLoaderSuccessResult;\n    // assert.equal(successResult.resultType, \"success\");\n    // assert.equal(successResult.absoluteBaseUrl, \"/foo/bar\");\n    // assert.equal(successResult.paths[\"asd\"][0], \"asd\");\n    expect(successResult.resultType).toBe(\"success\");\n    expect(successResult.absoluteBaseUrl).toBe(\"/foo/bar\");\n    expect(successResult.paths[\"asd\"][0]).toBe(\"asd\");\n  });\n\n  it(\"should use explicitParams when set and add cwd when path is relative\", () => {\n    const result = configLoader({\n      explicitParams: {\n        baseUrl: \"bar/\",\n        paths: {\n          asd: [\"asd\"],\n        },\n      },\n      cwd: \"/baz\",\n    });\n\n    const successResult = result as ConfigLoaderSuccessResult;\n    // assert.equal(successResult.resultType, \"success\");\n    // assert.equal(successResult.absoluteBaseUrl, join(\"/baz\", \"bar/\"));\n    expect(successResult.resultType).toBe(\"success\");\n    expect(successResult.absoluteBaseUrl).toBe(join(\"/baz\", \"bar/\"));\n  });\n\n  it(\"should fallback to tsConfigLoader when explicitParams is not set\", () => {\n    const result = configLoader({\n      explicitParams: undefined,\n      cwd: \"/baz\",\n      // tslint:disable-next-line:no-any\n      tsConfigLoader: (_: any) => ({\n        tsConfigPath: \"/baz/tsconfig.json\",\n        baseUrl: \"./src\",\n        paths: {},\n      }),\n    });\n\n    const successResult = result as ConfigLoaderSuccessResult;\n    // assert.equal(successResult.resultType, \"success\");\n    // assert.equal(successResult.absoluteBaseUrl, join(\"/baz\", \"src\"));\n    expect(successResult.resultType).toBe(\"success\");\n    expect(successResult.absoluteBaseUrl).toBe(join(\"/baz\", \"src\"));\n  });\n\n  it(\"should show an error message when baseUrl is missing\", () => {\n    const result = configLoader({\n      explicitParams: undefined,\n      cwd: \"/baz\",\n      // tslint:disable-next-line:no-any\n      tsConfigLoader: (_: any) => ({\n        tsConfigPath: \"/baz/tsconfig.json\",\n        baseUrl: undefined,\n        paths: {},\n      }),\n    });\n\n    const failResult = result as ConfigLoaderFailResult;\n    // assert.equal(failResult.resultType, \"failed\");\n    // assert.isTrue(failResult.message.indexOf(\"baseUrl\") > -1);\n    expect(failResult.resultType).toBe(\"failed\");\n    expect(failResult.message.indexOf(\"baseUrl\") > -1).toBeTruthy();\n  });\n\n  it(\"should presume cwd to be a tsconfig file when loadConfig is called with absolute path to tsconfig.json\", () => {\n    // using tsconfig-named.json to ensure that future changes to fix\n    // https://github.com/dividab/tsconfig-paths/issues/31\n    // do not pass this test case just because of a directory walk looking\n    // for tsconfig.json\n    const configFile = join(__dirname, \"tsconfig-named.json\");\n    const result = loadConfig(configFile);\n\n    const successResult = result as ConfigLoaderSuccessResult;\n    // assert.equal(successResult.resultType, \"success\");\n    // assert.equal(successResult.configFileAbsolutePath, configFile);\n    expect(successResult.resultType).toBe(\"success\");\n    expect(successResult.configFileAbsolutePath).toBe(configFile);\n  });\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/tsconfig-paths/src/__tests__/filesystem.test.ts",
    "content": "import * as Filesystem from \"../filesystem\";\nimport * as path from \"path\";\n\ndescribe(\"filesystem\", () => {\n  const fileThatExists = path.join(__dirname, \"../../package.json\");\n  const fileThatNotExists = path.join(__dirname, \"../../package2.json\");\n\n  it(\"should find file that exists, sync\", () => {\n    const result = Filesystem.fileExistsSync(fileThatExists);\n    // assert.equal(result, true);\n    expect(result).toBe(true);\n  });\n\n  it(\"should not find file that not exists, sync\", () => {\n    const result = Filesystem.fileExistsSync(fileThatNotExists);\n    // assert.equal(result, false);\n    expect(result).toBe(false);\n  });\n\n  it(\"should find file that exists, async\", (done) => {\n    Filesystem.fileExistsAsync(fileThatExists, (_err, result) => {\n      try {\n        // assert.equal(result, true);\n        expect(result).toBe(true);\n        done();\n      } catch (error) {\n        done(error);\n      }\n    });\n  });\n\n  it(\"should not find file that not exists, async\", (done) => {\n    Filesystem.fileExistsAsync(fileThatNotExists, (_err, result) => {\n      try {\n        // assert.equal(result, false);\n        expect(result).toBe(false);\n        done();\n      } catch (error) {\n        done(error);\n      }\n    });\n  });\n\n  it(\"should load json, sync\", () => {\n    const result = Filesystem.readJsonFromDiskSync(fileThatExists);\n    // assert.isOk(result);\n    expect(result);\n    // assert.equal(result.main, \"lib/index.js\");\n    expect(result.main).toBe(\"lib/index.js\");\n  });\n\n  it(\"should load json, async\", (done) => {\n    Filesystem.readJsonFromDiskAsync(fileThatExists, (_err, result) => {\n      try {\n        // assert.isOk(result); // Asserts that object is truthy.\n        expect(result).toBeTruthy();\n        // assert.equal(result.main, \"lib/index.js\");\n        expect(result.main).toBe(\"lib/index.js\");\n        done();\n      } catch (error) {\n        done(error);\n      }\n    });\n  });\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/tsconfig-paths/src/__tests__/mapping-entry.test.ts",
    "content": "import { getAbsoluteMappingEntries } from \"../mapping-entry\";\nimport { join } from \"path\";\n\ndescribe(\"mapping-entry\", () => {\n  it(\"should change to absolute paths and sort in longest prefix order\", () => {\n    const result = getAbsoluteMappingEntries(\n      \"/absolute/base/url\",\n      {\n        \"*\": [\"/foo1\", \"/foo2\"],\n        \"longest/pre/fix/*\": [\"/foo2/bar\"],\n        \"pre/fix/*\": [\"/foo3\"],\n      },\n      true\n    );\n    // assert.deepEqual(result, [\n    //   {\n    //     pattern: \"longest/pre/fix/*\",\n    //     paths: [join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\")],\n    //   },\n    //   {\n    //     pattern: \"pre/fix/*\",\n    //     paths: [join(\"/absolute\", \"base\", \"url\", \"foo3\")],\n    //   },\n    //   {\n    //     pattern: \"*\",\n    //     paths: [\n    //       join(\"/absolute\", \"base\", \"url\", \"foo1\"),\n    //       join(\"/absolute\", \"base\", \"url\", \"foo2\"),\n    //     ],\n    //   },\n    // ]);\n    expect(result).toEqual([\n      {\n        pattern: \"longest/pre/fix/*\",\n        paths: [join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\")],\n      },\n      {\n        pattern: \"pre/fix/*\",\n        paths: [join(\"/absolute\", \"base\", \"url\", \"foo3\")],\n      },\n      {\n        pattern: \"*\",\n        paths: [\n          join(\"/absolute\", \"base\", \"url\", \"foo1\"),\n          join(\"/absolute\", \"base\", \"url\", \"foo2\"),\n        ],\n      },\n    ]);\n  });\n\n  it(\"should should add a match-all pattern when requested\", () => {\n    let result = getAbsoluteMappingEntries(\"/absolute/base/url\", {}, true);\n    // assert.deepEqual(result, [\n    //   {\n    //     pattern: \"*\",\n    //     paths: [join(\"/absolute\", \"base\", \"url\", \"*\")],\n    //   },\n    // ]);\n    expect(result).toEqual([\n      {\n        pattern: \"*\",\n        paths: [join(\"/absolute\", \"base\", \"url\", \"*\")],\n      },\n    ]);\n\n    result = getAbsoluteMappingEntries(\"/absolute/base/url\", {}, false);\n    // assert.deepEqual(result, []);\n    expect(result).toEqual([]);\n  });\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/tsconfig-paths/src/__tests__/match-path-async.test.ts",
    "content": "import { createMatchPathAsync } from \"../match-path-async\";\nimport * as Tests from \"./data/match-path-data\";\n\ndescribe(\"match-path-async\", () => {\n  Tests.tests.forEach((t) =>\n    it(t.name, (done) => {\n      const matchPath = createMatchPathAsync(\n        t.absoluteBaseUrl,\n        t.paths,\n        t.mainFields,\n        t.addMatchAll\n      );\n      matchPath(\n        t.requestedModule,\n        (_path, callback) => callback(undefined, t.packageJson),\n        (path, callback) =>\n          callback(undefined, t.existingFiles.indexOf(path) !== -1),\n        t.extensions,\n        (_err, result) => {\n          // assert.equal(result, t.expectedPath);\n          expect(result).toBe(t.expectedPath);\n          done();\n        }\n      );\n    })\n  );\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/tsconfig-paths/src/__tests__/match-path-sync.test.ts",
    "content": "import { createMatchPath } from \"../match-path-sync\";\nimport * as Tests from \"./data/match-path-data\";\n\ndescribe(\"match-path-sync\", () => {\n  Tests.tests.forEach((t) =>\n    it(t.name, () => {\n      const matchPath = createMatchPath(\n        t.absoluteBaseUrl,\n        t.paths,\n        t.mainFields,\n        t.addMatchAll\n      );\n      const result = matchPath(\n        t.requestedModule,\n        (_: string) => t.packageJson,\n        (name: string) => t.existingFiles.indexOf(name) !== -1,\n        t.extensions\n      );\n      // assert.equal(result, t.expectedPath);\n      expect(result).toBe(t.expectedPath);\n    })\n  );\n});\n",
    "symbols": []
  },
  {
    "path": "node_modules/tsconfig-paths/src/__tests__/try-path.test.ts",
    "content": "import { getPathsToTry } from \"../try-path\";\nimport { join } from \"path\";\n\ndescribe(\"mapping-entry\", () => {\n  const abosolutePathMappings = [\n    {\n      pattern: \"longest/pre/fix/*\",\n      paths: [join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\")],\n    },\n    { pattern: \"pre/fix/*\", paths: [join(\"/absolute\", \"base\", \"url\", \"foo3\")] },\n    { pattern: \"*\", paths: [join(\"/absolute\", \"base\", \"url\", \"foo1\")] },\n  ];\n  const abosolutePathMappingsStarstWithSlash = [\n    {\n      pattern: \"/opt/*\",\n      paths: [join(\"/absolute\", \"src\", \"aws-layer\")],\n    },\n    {\n      pattern: \"*\",\n      paths: [join(\"/absolute\", \"src\")],\n    },\n  ];\n  it(\"should return no paths for relative requested module\", () => {\n    const result = getPathsToTry(\n      [\".ts\", \"tsx\"],\n      abosolutePathMappings,\n      \"./requested-module\"\n    );\n    // assert.deepEqual(result, undefined);\n    expect(result).toBeUndefined();\n  });\n\n  it(\"should return no paths if no pattern match the requested module\", () => {\n    const result = getPathsToTry(\n      [\".ts\", \"tsx\"],\n      [\n        {\n          pattern: \"longest/pre/fix/*\",\n          paths: [join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\")],\n        },\n        {\n          pattern: \"pre/fix/*\",\n          paths: [join(\"/absolute\", \"base\", \"url\", \"foo3\")],\n        },\n      ],\n      \"requested-module\"\n    );\n    expect(result).toBeUndefined();\n  });\n\n  it(\"should get all paths that matches requested module\", () => {\n    const result = getPathsToTry(\n      [\".ts\", \".tsx\"],\n      abosolutePathMappings,\n      \"longest/pre/fix/requested-module\"\n    );\n    // assert.deepEqual(result, [\n    //   // \"longest/pre/fix/*\"\n    //   { type: \"file\", path: join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\") },\n    //   {\n    //     type: \"extension\",\n    //     path: join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar.ts\"),\n    //   },\n    //   {\n    //     type: \"extension\",\n    //     path: join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar.tsx\"),\n    //   },\n    //   {\n    //     type: \"package\",\n    //     path: join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\", \"package.json\"),\n    //   },\n    //   {\n    //     type: \"index\",\n    //     path: join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\", \"index.ts\"),\n    //   },\n    //   {\n    //     type: \"index\",\n    //     path: join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\", \"index.tsx\"),\n    //   },\n    //   // \"*\"\n    //   { type: \"file\", path: join(\"/absolute\", \"base\", \"url\", \"foo1\") },\n    //   { type: \"extension\", path: join(\"/absolute\", \"base\", \"url\", \"foo1.ts\") },\n    //   { type: \"extension\", path: join(\"/absolute\", \"base\", \"url\", \"foo1.tsx\") },\n    //   {\n    //     type: \"package\",\n    //     path: join(\"/absolute\", \"base\", \"url\", \"foo1\", \"package.json\"),\n    //   },\n    //   {\n    //     type: \"index\",\n    //     path: join(\"/absolute\", \"base\", \"url\", \"foo1\", \"index.ts\"),\n    //   },\n    //   {\n    //     type: \"index\",\n    //     path: join(\"/absolute\", \"base\", \"url\", \"foo1\", \"index.tsx\"),\n    //   },\n    // ]);\n    expect(result).toEqual([\n      // \"longest/pre/fix/*\"\n      { type: \"file\", path: join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\") },\n      {\n        type: \"extension\",\n        path: join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar.ts\"),\n      },\n      {\n        type: \"extension\",\n        path: join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar.tsx\"),\n      },\n      {\n        type: \"package\",\n        path: join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\", \"package.json\"),\n      },\n      {\n        type: \"index\",\n        path: join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\", \"index.ts\"),\n      },\n      {\n        type: \"index\",\n        path: join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\", \"index.tsx\"),\n      },\n      // \"*\"\n      { type: \"file\", path: join(\"/absolute\", \"base\", \"url\", \"foo1\") },\n      { type: \"extension\", path: join(\"/absolute\", \"base\", \"url\", \"foo1.ts\") },\n      { type: \"extension\", path: join(\"/absolute\", \"base\", \"url\", \"foo1.tsx\") },\n      {\n        type: \"package\",\n        path: join(\"/absolute\", \"base\", \"url\", \"foo1\", \"package.json\"),\n      },\n      {\n        type: \"index\",\n        path: join(\"/absolute\", \"base\", \"url\", \"foo1\", \"index.ts\"),\n      },\n      {\n        type: \"index\",\n        path: join(\"/absolute\", \"base\", \"url\", \"foo1\", \"index.tsx\"),\n      },\n    ]);\n  });\n\n  it(\"should resolve paths starting with a slash\", () => {\n    const result = getPathsToTry(\n      [\".ts\"],\n      abosolutePathMappingsStarstWithSlash,\n      \"/opt/utils\"\n    );\n    expect(result).toEqual([\n      // \"opt/*\"\n      {\n        path: join(\"/absolute\", \"src\", \"aws-layer\"),\n        type: \"file\",\n      },\n      {\n        path: join(\"/absolute\", \"src\", \"aws-layer.ts\"),\n        type: \"extension\",\n      },\n      {\n        path: join(\"/absolute\", \"src\", \"aws-layer\", \"package.json\"),\n        type: \"package\",\n      },\n      {\n        path: join(\"/absolute\", \"src\", \"aws-layer\", \"index.ts\"),\n        type: \"index\",\n      },\n      // \"*\"\n      {\n        path: join(\"/absolute\", \"src\"),\n        type: \"file\",\n      },\n      {\n        path: join(\"/absolute\", \"src.ts\"),\n        type: \"extension\",\n      },\n      {\n        path: join(\"/absolute\", \"src\", \"package.json\"),\n        type: \"package\",\n      },\n      {\n        path: join(\"/absolute\", \"src\", \"index.ts\"),\n        type: \"index\",\n      },\n    ]);\n  });\n});\n\n// describe(\"match-star\", () => {\n//   it(\"should match star in last position\", () => {\n//     const result = matchStar(\"lib/*\", \"lib/mylib\");\n//     assert.equal(result, \"mylib\");\n//   });\n//   it(\"should match star in first position\", () => {\n//     const result = matchStar(\"*/lib\", \"mylib/lib\");\n//     assert.equal(result, \"mylib\");\n//   });\n// });\n",
    "symbols": []
  },
  {
    "path": "node_modules/tsconfig-paths/src/__tests__/tsconfig-loader.test.ts",
    "content": "import {\n  loadTsconfig,\n  tsConfigLoader,\n  walkForTsConfig,\n} from \"../tsconfig-loader\";\nimport { join } from \"path\";\n\ndescribe(\"tsconfig-loader\", () => {\n  it(\"should find tsconfig in cwd\", () => {\n    const result = tsConfigLoader({\n      cwd: \"/foo/bar\",\n      getEnv: (_: string) => undefined,\n      loadSync: (cwd: string) => {\n        return {\n          tsConfigPath: `${cwd}/tsconfig.json`,\n          baseUrl: \"./\",\n          paths: {},\n        };\n      },\n    });\n\n    // assert.equal(result.tsConfigPath, \"/foo/bar/tsconfig.json\");\n    expect(result.tsConfigPath).toBe(\"/foo/bar/tsconfig.json\");\n  });\n\n  it(\"should return loaderResult.tsConfigPath as undefined when not found\", () => {\n    const result = tsConfigLoader({\n      cwd: \"/foo/bar\",\n      getEnv: (_: string) => undefined,\n      loadSync: (_: string) => {\n        return {\n          tsConfigPath: undefined,\n          baseUrl: \"./\",\n          paths: {},\n        };\n      },\n    });\n\n    // assert.isUndefined(result.tsConfigPath);\n    expect(result.tsConfigPath).toBeUndefined();\n  });\n\n  it(\"should use TS_NODE_PROJECT env if exists\", () => {\n    const result = tsConfigLoader({\n      cwd: \"/foo/bar\",\n      getEnv: (key: string) =>\n        key === \"TS_NODE_PROJECT\" ? \"/foo/baz\" : undefined,\n      loadSync: (cwd: string, fileName: string) => {\n        if (cwd === \"/foo/bar\" && fileName === \"/foo/baz\") {\n          return {\n            tsConfigPath: \"/foo/baz/tsconfig.json\",\n            baseUrl: \"./\",\n            paths: {},\n          };\n        }\n\n        return {\n          tsConfigPath: undefined,\n          baseUrl: \"./\",\n          paths: {},\n        };\n      },\n    });\n\n    // assert.equal(result.tsConfigPath, \"/foo/baz/tsconfig.json\");\n    expect(result.tsConfigPath).toBe(\"/foo/baz/tsconfig.json\");\n  });\n\n  it(\"should use TS_NODE_BASEURL env if exists\", () => {\n    const result = tsConfigLoader({\n      cwd: \"/foo/bar\",\n      getEnv: (key: string) =>\n        key === \"TS_NODE_BASEURL\" ? \"SOME_BASEURL\" : undefined,\n      loadSync: (_0: string, _1: string, baseUrl: string) => {\n        return {\n          tsConfigPath: undefined,\n          baseUrl,\n          paths: {},\n        };\n      },\n    });\n\n    // assert.equal(result.baseUrl, \"SOME_BASEURL\");\n    expect(result.baseUrl).toBe(\"SOME_BASEURL\");\n  });\n\n  it(\"should not use TS_NODE_BASEURL env if it does not exist\", () => {\n    const result = tsConfigLoader({\n      cwd: \"/foo/bar\",\n      getEnv: (_: string) => {\n        return undefined;\n      },\n      loadSync: (_0: string, _1: string, baseUrl: string) => {\n        return {\n          tsConfigPath: undefined,\n          baseUrl,\n          paths: {},\n        };\n      },\n    });\n\n    // assert.equal(result.baseUrl, undefined);\n    expect(result.baseUrl).toBeUndefined();\n  });\n});\n\ndescribe(\"walkForTsConfig\", () => {\n  it(\"should find tsconfig in starting directory\", () => {\n    const pathToTsconfig = join(\"/root\", \"dir1\", \"tsconfig.json\");\n    const res = walkForTsConfig(\n      join(\"/root\", \"dir1\"),\n      (path) => path === pathToTsconfig\n    );\n    // assert.equal(res, pathToTsconfig);\n    expect(res).toBe(pathToTsconfig);\n  });\n\n  it(\"should find tsconfig in parent directory\", () => {\n    const pathToTsconfig = join(\"/root\", \"tsconfig.json\");\n    const res = walkForTsConfig(\n      join(\"/root\", \"dir1\"),\n      (path) => path === pathToTsconfig\n    );\n    // assert.equal(res, pathToTsconfig);\n    expect(res).toBe(pathToTsconfig);\n  });\n\n  it(\"should return undefined when reaching the top\", () => {\n    const res = walkForTsConfig(join(\"/root\", \"dir1\", \"kalle\"), () => false);\n    // assert.equal(res, undefined);\n    expect(res).toBeUndefined();\n  });\n});\n\ndescribe(\"loadConfig\", () => {\n  it(\"should load a config\", () => {\n    const config = { compilerOptions: { baseUrl: \"hej\" } };\n    const res = loadTsconfig(\n      \"/root/dir1/tsconfig.json\",\n      (path) => path === \"/root/dir1/tsconfig.json\",\n      (_) => JSON.stringify(config)\n    );\n    // assert.deepEqual(res, config);\n    expect(res).toStrictEqual(config);\n  });\n\n  it(\"should load a config with comments\", () => {\n    const config = { compilerOptions: { baseUrl: \"hej\" } };\n    const res = loadTsconfig(\n      \"/root/dir1/tsconfig.json\",\n      (path) => path === \"/root/dir1/tsconfig.json\",\n      (_) => `{\n          // my comment\n          \"compilerOptions\": { \n            \"baseUrl\": \"hej\"\n          }\n        }`\n    );\n    // assert.deepEqual(res, config);\n    expect(res).toStrictEqual(config);\n  });\n\n  it(\"should load a config with trailing commas\", () => {\n    const config = { compilerOptions: { baseUrl: \"hej\" } };\n    const res = loadTsconfig(\n      \"/root/dir1/tsconfig.json\",\n      (path) => path === \"/root/dir1/tsconfig.json\",\n      (_) => `{\n          \"compilerOptions\": { \n            \"baseUrl\": \"hej\",\n          },\n        }`\n    );\n    // assert.deepEqual(res, config);\n    expect(res).toStrictEqual(config);\n  });\n\n  it(\"should throw an error including the file path when encountering invalid JSON5\", () => {\n    expect(() =>\n      loadTsconfig(\n        \"/root/dir1/tsconfig.json\",\n        (path) => path === \"/root/dir1/tsconfig.json\",\n        (_) => `{\n            \"compilerOptions\": {\n          }`\n      )\n    ).toThrowError(\n      \"/root/dir1/tsconfig.json is malformed JSON5: invalid end of input at 3:12\"\n    );\n  });\n\n  it(\"should load a config with string extends and overwrite all options\", () => {\n    const firstConfig = {\n      extends: \"../base-config.json\",\n      compilerOptions: { baseUrl: \"kalle\", paths: { foo: [\"bar2\"] } },\n    };\n    const firstConfigPath = join(\"/root\", \"dir1\", \"tsconfig.json\");\n    const baseConfig = {\n      compilerOptions: {\n        baseUrl: \"olle\",\n        paths: { foo: [\"bar1\"] },\n        strict: true,\n      },\n    };\n    const baseConfigPath = join(\"/root\", \"base-config.json\");\n    const res = loadTsconfig(\n      join(\"/root\", \"dir1\", \"tsconfig.json\"),\n      (path) => path === firstConfigPath || path === baseConfigPath,\n      (path) => {\n        if (path === firstConfigPath) {\n          return JSON.stringify(firstConfig);\n        }\n        if (path === baseConfigPath) {\n          return JSON.stringify(baseConfig);\n        }\n        return \"\";\n      }\n    );\n\n    // assert.deepEqual(res, {\n    //   extends: \"../base-config.json\",\n    //   compilerOptions: {\n    //     baseUrl: \"kalle\",\n    //     paths: { foo: [\"bar2\"] },\n    //     strict: true,\n    //   },\n    // });\n    expect(res).toEqual({\n      extends: \"../base-config.json\",\n      compilerOptions: {\n        baseUrl: \"kalle\",\n        paths: { foo: [\"bar2\"] },\n        strict: true,\n      },\n    });\n  });\n\n  it(\"should load a config with string extends from node_modules and overwrite all options\", () => {\n    const firstConfig = {\n      extends: \"my-package/base-config.json\",\n      compilerOptions: { baseUrl: \"kalle\", paths: { foo: [\"bar2\"] } },\n    };\n    const firstConfigPath = join(\"/root\", \"dir1\", \"tsconfig.json\");\n    const baseConfig = {\n      compilerOptions: {\n        baseUrl: \"olle\",\n        paths: { foo: [\"bar1\"] },\n        strict: true,\n      },\n    };\n    const baseConfigPath = join(\n      \"/root\",\n      \"dir1\",\n      \"node_modules\",\n      \"my-package\",\n      \"base-config.json\"\n    );\n    const res = loadTsconfig(\n      join(\"/root\", \"dir1\", \"tsconfig.json\"),\n      (path) => path === firstConfigPath || path === baseConfigPath,\n      (path) => {\n        if (path === firstConfigPath) {\n          return JSON.stringify(firstConfig);\n        }\n        if (path === baseConfigPath) {\n          return JSON.stringify(baseConfig);\n        }\n        return \"\";\n      }\n    );\n\n    // assert.deepEqual(res, {\n    //   extends: \"my-package/base-config.json\",\n    //   compilerOptions: {\n    //     baseUrl: \"kalle\",\n    //     paths: { foo: [\"bar2\"] },\n    //     strict: true,\n    //   },\n    // });\n    expect(res).toEqual({\n      extends: \"my-package/base-config.json\",\n      compilerOptions: {\n        baseUrl: \"kalle\",\n        paths: { foo: [\"bar2\"] },\n        strict: true,\n      },\n    });\n  });\n\n  it(\"should use baseUrl relative to location of extended tsconfig\", () => {\n    const firstConfig = { compilerOptions: { baseUrl: \".\" } };\n    const firstConfigPath = join(\"/root\", \"first-config.json\");\n    const secondConfig = { extends: \"../first-config.json\" };\n    const secondConfigPath = join(\"/root\", \"dir1\", \"second-config.json\");\n    const thirdConfig = { extends: \"../second-config.json\" };\n    const thirdConfigPath = join(\"/root\", \"dir1\", \"dir2\", \"third-config.json\");\n    const res = loadTsconfig(\n      join(\"/root\", \"dir1\", \"dir2\", \"third-config.json\"),\n      (path) =>\n        path === firstConfigPath ||\n        path === secondConfigPath ||\n        path === thirdConfigPath,\n      (path) => {\n        if (path === firstConfigPath) {\n          return JSON.stringify(firstConfig);\n        }\n        if (path === secondConfigPath) {\n          return JSON.stringify(secondConfig);\n        }\n        if (path === thirdConfigPath) {\n          return JSON.stringify(thirdConfig);\n        }\n        return \"\";\n      }\n    );\n\n    // assert.deepEqual(res, {\n    //   extends: \"../second-config.json\",\n    //   compilerOptions: { baseUrl: join(\"..\", \"..\") },\n    // });\n    expect(res).toEqual({\n      extends: \"../second-config.json\",\n      compilerOptions: { baseUrl: join(\"..\", \"..\") },\n    });\n  });\n\n  it(\"should load a config with array extends and overwrite all options\", () => {\n    const baseConfig1 = {\n      compilerOptions: { baseUrl: \".\", paths: { foo: [\"bar\"] } },\n    };\n    const baseConfig1Path = join(\"/root\", \"base-config-1.json\");\n    const baseConfig2 = { compilerOptions: { baseUrl: \".\" } };\n    const baseConfig2Path = join(\"/root\", \"dir1\", \"base-config-2.json\");\n    const baseConfig3 = {\n      compilerOptions: { baseUrl: \".\", paths: { foo: [\"bar2\"] } },\n    };\n    const baseConfig3Path = join(\"/root\", \"dir1\", \"dir2\", \"base-config-3.json\");\n    const actualConfig = {\n      extends: [\n        \"./base-config-1.json\",\n        \"./dir1/base-config-2.json\",\n        \"./dir1/dir2/base-config-3.json\",\n      ],\n    };\n    const actualConfigPath = join(\"/root\", \"tsconfig.json\");\n\n    const res = loadTsconfig(\n      join(\"/root\", \"tsconfig.json\"),\n      (path) =>\n        [\n          baseConfig1Path,\n          baseConfig2Path,\n          baseConfig3Path,\n          actualConfigPath,\n        ].indexOf(path) >= 0,\n      (path) => {\n        if (path === baseConfig1Path) {\n          return JSON.stringify(baseConfig1);\n        }\n        if (path === baseConfig2Path) {\n          return JSON.stringify(baseConfig2);\n        }\n        if (path === baseConfig3Path) {\n          return JSON.stringify(baseConfig3);\n        }\n        if (path === actualConfigPath) {\n          return JSON.stringify(actualConfig);\n        }\n        return \"\";\n      }\n    );\n\n    expect(res).toEqual({\n      extends: [\n        \"./base-config-1.json\",\n        \"./dir1/base-config-2.json\",\n        \"./dir1/dir2/base-config-3.json\",\n      ],\n      compilerOptions: {\n        baseUrl: join(\"dir1\", \"dir2\"),\n        paths: { foo: [\"bar2\"] },\n      },\n    });\n  });\n\n  it(\"should load a config with array extends without .json extension\", () => {\n    const baseConfig = {\n      compilerOptions: { baseUrl: \".\", paths: { foo: [\"bar\"] } },\n    };\n    const baseConfigPath = join(\"/root\", \"base-config-1.json\");\n    const actualConfig = { extends: [\"./base-config-1\"] };\n    const actualConfigPath = join(\"/root\", \"tsconfig.json\");\n\n    const res = loadTsconfig(\n      join(\"/root\", \"tsconfig.json\"),\n      (path) => [baseConfigPath, actualConfigPath].indexOf(path) >= 0,\n      (path) => {\n        if (path === baseConfigPath) {\n          return JSON.stringify(baseConfig);\n        }\n        if (path === actualConfigPath) {\n          return JSON.stringify(actualConfig);\n        }\n        return \"\";\n      }\n    );\n\n    expect(res).toEqual({\n      extends: [\"./base-config-1\"],\n      compilerOptions: {\n        baseUrl: \".\",\n        paths: { foo: [\"bar\"] },\n      },\n    });\n  });\n});\n",
    "symbols": []
  },
  {
    "path": "tests/sample_src/src/orders/order.service.ts",
    "content": "export class OrderService {\n  /**\n   * Create a new order with the given items.\n   */\n  createOrder(items: string[]): number {\n    // compute total\n    let total = 0;\n    for (const item of items) {\n      total += item.length;\n    }\n    return total;\n  }\n}\n",
    "symbols": [
      {
        "name": "OrderService",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/tests/sample_src/src/orders/order.service.ts",
        "startLine": 1,
        "endLine": 13
      },
      {
        "name": "OrderService.createOrder",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/tests/sample_src/src/orders/order.service.ts",
        "startLine": 5,
        "endLine": 12
      }
    ]
  },
  {
    "path": "tests/sample_src/src/utils/math.ts",
    "content": "export function add(a: number, b: number): number {\n  return a + b;\n}\n",
    "symbols": [
      {
        "name": "add",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/tests/sample_src/src/utils/math.ts",
        "startLine": 1,
        "endLine": 3
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
    "content": "import { StringReader, StringWriter } from './strings';\nimport { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\n\nconst EMPTY: any[] = [];\n\ntype Line = number;\ntype Column = number;\ntype Kind = number;\ntype Name = number;\ntype Var = number;\ntype SourcesIndex = number;\ntype ScopesIndex = number;\n\ntype Mix<A, B, O> = (A & O) | (B & O);\n\nexport type OriginalScope = Mix<\n  [Line, Column, Line, Column, Kind],\n  [Line, Column, Line, Column, Kind, Name],\n  { vars: Var[] }\n>;\n\nexport type GeneratedRange = Mix<\n  [Line, Column, Line, Column],\n  [Line, Column, Line, Column, SourcesIndex, ScopesIndex],\n  {\n    callsite: CallSite | null;\n    bindings: Binding[];\n    isScope: boolean;\n  }\n>;\nexport type CallSite = [SourcesIndex, Line, Column];\ntype Binding = BindingExpressionRange[];\nexport type BindingExpressionRange = [Name] | [Name, Line, Column];\n\nexport function decodeOriginalScopes(input: string): OriginalScope[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes: OriginalScope[] = [];\n  const stack: OriginalScope[] = [];\n  let line = 0;\n\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop()!;\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 0b0001;\n\n    const scope: OriginalScope = (\n      hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]\n    ) as OriginalScope;\n\n    let vars: Var[] = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n\n    scopes.push(scope);\n    stack.push(scope);\n  }\n\n  return scopes;\n}\n\nexport function encodeOriginalScopes(scopes: OriginalScope[]): string {\n  const writer = new StringWriter();\n\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeOriginalScopes(\n  scopes: OriginalScope[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenColumn\n  ],\n): number {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n\n  if (index > 0) writer.write(comma);\n\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n\n  const fields = scope.length === 6 ? 0b0001 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n\n  return index;\n}\n\nexport function decodeGeneratedRanges(input: string): GeneratedRange[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges: GeneratedRange[] = [];\n  const stack: GeneratedRange[] = [];\n\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    let genColumn = 0;\n\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop()!;\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 0b0001;\n      const hasCallsite = fields & 0b0010;\n      const hasScope = fields & 0b0100;\n\n      let callsite: CallSite | null = null;\n      let bindings: Binding[] = EMPTY;\n      let range: GeneratedRange;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0,\n        );\n\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex] as GeneratedRange;\n      } else {\n        range = [genLine, genColumn, 0, 0] as GeneratedRange;\n      }\n\n      range.isScope = !!hasScope;\n\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0,\n        );\n\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges: BindingExpressionRange[];\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n\n      ranges.push(range);\n      stack.push(range);\n    }\n\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n\n  return ranges;\n}\n\nexport function encodeGeneratedRanges(ranges: GeneratedRange[]): string {\n  if (ranges.length === 0) return '';\n\n  const writer = new StringWriter();\n\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeGeneratedRanges(\n  ranges: GeneratedRange[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenLine\n    number, // GenColumn\n    number, // DefSourcesIndex\n    number, // DefScopesIndex\n    number, // CallSourcesIndex\n    number, // CallLine\n    number, // CallColumn\n  ],\n): number {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings,\n  } = range;\n\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n\n  state[1] = encodeInteger(writer, range[1], state[1]);\n\n  const fields =\n    (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\n  encodeInteger(writer, fields, 0);\n\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite!;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1]!, bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2]!, bindingStartColumn);\n        encodeInteger(writer, expRange[0]!, 0);\n      }\n    }\n  }\n\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n\n  return index;\n}\n\nfunction catchupLine(writer: StringWriter, lastLine: number, line: number) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}\n",
    "symbols": [
      {
        "name": "decodeOriginalScopes",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
        "startLine": 35,
        "endLine": 76
      },
      {
        "name": "encodeOriginalScopes",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
        "startLine": 78,
        "endLine": 86
      },
      {
        "name": "_encodeOriginalScopes",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
        "startLine": 88,
        "endLine": 127
      },
      {
        "name": "decodeGeneratedRanges",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
        "startLine": 129,
        "endLine": 229
      },
      {
        "name": "encodeGeneratedRanges",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
        "startLine": 231,
        "endLine": 241
      },
      {
        "name": "_encodeGeneratedRanges",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
        "startLine": 243,
        "endLine": 339
      },
      {
        "name": "catchupLine",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/scopes.ts",
        "startLine": 341,
        "endLine": 345
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
    "content": "import { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\nimport { StringWriter, StringReader } from './strings';\n\nexport {\n  decodeOriginalScopes,\n  encodeOriginalScopes,\n  decodeGeneratedRanges,\n  encodeGeneratedRanges,\n} from './scopes';\nexport type { OriginalScope, GeneratedRange, CallSite, BindingExpressionRange } from './scopes';\n\nexport type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nexport function decode(mappings: string): SourceMapMappings {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded: SourceMapMappings = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n\n    while (reader.pos < semi) {\n      let seg: SourceMapSegment;\n\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n\n      line.push(seg);\n      reader.pos++;\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n\n  return decoded;\n}\n\nfunction sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}\n\nexport function encode(decoded: SourceMapMappings): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n\n    let genColumn = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n\n  return writer.flush();\n}\n",
    "symbols": [
      {
        "name": "decode",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
        "startLine": 19,
        "endLine": 68
      },
      {
        "name": "sort",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
        "startLine": 70,
        "endLine": 72
      },
      {
        "name": "sortComparator",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
        "startLine": 74,
        "endLine": 76
      },
      {
        "name": "encode",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
        "startLine": 78,
        "endLine": 78
      },
      {
        "name": "encode",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
        "startLine": 79,
        "endLine": 79
      },
      {
        "name": "encode",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts",
        "startLine": 80,
        "endLine": 111
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
    "content": "const bufLength = 1024 * 16;\n\n// Provide a fallback for older environments.\nconst td =\n  typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n      ? {\n          decode(buf: Uint8Array): string {\n            const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n            return out.toString();\n          },\n        }\n      : {\n          decode(buf: Uint8Array): string {\n            let out = '';\n            for (let i = 0; i < buf.length; i++) {\n              out += String.fromCharCode(buf[i]);\n            }\n            return out;\n          },\n        };\n\nexport class StringWriter {\n  pos = 0;\n  private out = '';\n  private buffer = new Uint8Array(bufLength);\n\n  write(v: number): void {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n\n  flush(): string {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n}\n\nexport class StringReader {\n  pos = 0;\n  declare private buffer: string;\n\n  constructor(buffer: string) {\n    this.buffer = buffer;\n  }\n\n  next(): number {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n\n  peek(): number {\n    return this.buffer.charCodeAt(this.pos);\n  }\n\n  indexOf(char: string): number {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n}\n",
    "symbols": [
      {
        "name": "StringWriter",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
        "startLine": 24,
        "endLine": 42
      },
      {
        "name": "StringWriter.write",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
        "startLine": 29,
        "endLine": 36
      },
      {
        "name": "StringWriter.flush",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
        "startLine": 38,
        "endLine": 41
      },
      {
        "name": "StringReader",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
        "startLine": 44,
        "endLine": 65
      },
      {
        "name": "StringReader.next",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
        "startLine": 52,
        "endLine": 54
      },
      {
        "name": "StringReader.peek",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
        "startLine": 56,
        "endLine": 58
      },
      {
        "name": "StringReader.indexOf",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/strings.ts",
        "startLine": 60,
        "endLine": 64
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts",
    "content": "import type { StringReader, StringWriter } from './strings';\n\nexport const comma = ','.charCodeAt(0);\nexport const semicolon = ';'.charCodeAt(0);\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\n\nexport function decodeInteger(reader: StringReader, relative: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  return relative + value;\n}\n\nexport function encodeInteger(builder: StringWriter, num: number, relative: number): number {\n  let delta = num - relative;\n\n  delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\n  do {\n    let clamped = delta & 0b011111;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 0b100000;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n\n  return num;\n}\n\nexport function hasMoreVlq(reader: StringReader, max: number) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n",
    "symbols": [
      {
        "name": "decodeInteger",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts",
        "startLine": 16,
        "endLine": 36
      },
      {
        "name": "encodeInteger",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts",
        "startLine": 38,
        "endLine": 50
      },
      {
        "name": "hasMoreVlq",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts",
        "startLine": 52,
        "endLine": 55
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/fuzzySearch.ts",
    "content": "/* eslint-disable no-labels */\nimport { LEAF } from './TreeIterator'\nimport type { RadixTree } from './types'\n\nexport type FuzzyResult<T> = [T, number]\n\nexport type FuzzyResults<T> = Map<string, FuzzyResult<T>>\n\n/**\n * @ignore\n */\nexport const fuzzySearch = <T = any>(node: RadixTree<T>, query: string, maxDistance: number): FuzzyResults<T> => {\n  const results: FuzzyResults<T> = new Map()\n  if (query === undefined) return results\n\n  // Number of columns in the Levenshtein matrix.\n  const n = query.length + 1\n\n  // Matching terms can never be longer than N + maxDistance.\n  const m = n + maxDistance\n\n  // Fill first matrix row and column with numbers: 0 1 2 3 ...\n  const matrix = new Uint8Array(m * n).fill(maxDistance + 1)\n  for (let j = 0; j < n; ++j) matrix[j] = j\n  for (let i = 1; i < m; ++i) matrix[i * n] = i\n\n  recurse(\n    node,\n    query,\n    maxDistance,\n    results,\n    matrix,\n    1,\n    n,\n    ''\n  )\n\n  return results\n}\n\n// Modified version of http://stevehanov.ca/blog/?id=114\n\n// This builds a Levenshtein matrix for a given query and continuously updates\n// it for nodes in the radix tree that fall within the given maximum edit\n// distance. Keeping the same matrix around is beneficial especially for larger\n// edit distances.\n//\n//           k   a   t   e   <-- query\n//       0   1   2   3   4\n//   c   1   1   2   3   4\n//   a   2   2   1   2   3\n//   t   3   3   2   1  [2]  <-- edit distance\n//   ^\n//   ^ term in radix tree, rows are added and removed as needed\n\nconst recurse = <T = any>(\n  node: RadixTree<T>,\n  query: string,\n  maxDistance: number,\n  results: FuzzyResults<T>,\n  matrix: Uint8Array,\n  m: number,\n  n: number,\n  prefix: string\n): void => {\n  const offset = m * n\n\n  key: for (const key of node.keys()) {\n    if (key === LEAF) {\n      // We've reached a leaf node. Check if the edit distance acceptable and\n      // store the result if it is.\n      const distance = matrix[offset - 1]\n      if (distance <= maxDistance) {\n        results.set(prefix, [node.get(key)!, distance])\n      }\n    } else {\n      // Iterate over all characters in the key. Update the Levenshtein matrix\n      // and check if the minimum distance in the last row is still within the\n      // maximum edit distance. If it is, we can recurse over all child nodes.\n      let i = m\n      for (let pos = 0; pos < key.length; ++pos, ++i) {\n        const char = key[pos]\n        const thisRowOffset = n * i\n        const prevRowOffset = thisRowOffset - n\n\n        // Set the first column based on the previous row, and initialize the\n        // minimum distance in the current row.\n        let minDistance = matrix[thisRowOffset]\n\n        const jmin = Math.max(0, i - maxDistance - 1)\n        const jmax = Math.min(n - 1, i + maxDistance)\n\n        // Iterate over remaining columns (characters in the query).\n        for (let j = jmin; j < jmax; ++j) {\n          const different = char !== query[j]\n\n          // It might make sense to only read the matrix positions used for\n          // deletion/insertion if the characters are different. But we want to\n          // avoid conditional reads for performance reasons.\n          const rpl = matrix[prevRowOffset + j] + +different\n          const del = matrix[prevRowOffset + j + 1] + 1\n          const ins = matrix[thisRowOffset + j] + 1\n\n          const dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins)\n\n          if (dist < minDistance) minDistance = dist\n        }\n\n        // Because distance will never decrease, we can stop. There will be no\n        // matching child nodes.\n        if (minDistance > maxDistance) {\n          continue key\n        }\n      }\n\n      recurse(\n        node.get(key)!,\n        query,\n        maxDistance,\n        results,\n        matrix,\n        i,\n        n,\n        prefix + key\n      )\n    }\n  }\n}\n\nexport default fuzzySearch\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
    "content": "/* eslint-disable no-labels */\nimport { TreeIterator, ENTRIES, KEYS, VALUES, LEAF } from './TreeIterator'\nimport fuzzySearch, { type FuzzyResults } from './fuzzySearch'\nimport type { RadixTree, Entry, Path } from './types'\n\n/**\n * A class implementing the same interface as a standard JavaScript\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * with string keys, but adding support for efficiently searching entries with\n * prefix or fuzzy search. This class is used internally by {@link MiniSearch}\n * as the inverted index data structure. The implementation is a radix tree\n * (compressed prefix tree).\n *\n * Since this class can be of general utility beyond _MiniSearch_, it is\n * exported by the `minisearch` package and can be imported (or required) as\n * `minisearch/SearchableMap`.\n *\n * @typeParam T  The type of the values stored in the map.\n */\nexport default class SearchableMap<T = any> {\n  /**\n   * @internal\n   */\n  _tree: RadixTree<T>\n\n  /**\n   * @internal\n   */\n  _prefix: string\n\n  private _size: number | undefined = undefined\n\n  /**\n   * The constructor is normally called without arguments, creating an empty\n   * map. In order to create a {@link SearchableMap} from an iterable or from an\n   * object, check {@link SearchableMap.from} and {@link\n   * SearchableMap.fromObject}.\n   *\n   * The constructor arguments are for internal use, when creating derived\n   * mutable views of a map at a prefix.\n   */\n  constructor (tree: RadixTree<T> = new Map(), prefix = '') {\n    this._tree = tree\n    this._prefix = prefix\n  }\n\n  /**\n   * Creates and returns a mutable view of this {@link SearchableMap},\n   * containing only entries that share the given prefix.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * let map = new SearchableMap()\n   * map.set(\"unicorn\", 1)\n   * map.set(\"universe\", 2)\n   * map.set(\"university\", 3)\n   * map.set(\"unique\", 4)\n   * map.set(\"hello\", 5)\n   *\n   * let uni = map.atPrefix(\"uni\")\n   * uni.get(\"unique\") // => 4\n   * uni.get(\"unicorn\") // => 1\n   * uni.get(\"hello\") // => undefined\n   *\n   * let univer = map.atPrefix(\"univer\")\n   * univer.get(\"unique\") // => undefined\n   * univer.get(\"universe\") // => 2\n   * univer.get(\"university\") // => 3\n   * ```\n   *\n   * @param prefix  The prefix\n   * @return A {@link SearchableMap} representing a mutable view of the original\n   * Map at the given prefix\n   */\n  atPrefix (prefix: string): SearchableMap<T> {\n    if (!prefix.startsWith(this._prefix)) { throw new Error('Mismatched prefix') }\n\n    const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length))\n\n    if (node === undefined) {\n      const [parentNode, key] = last(path)\n\n      for (const k of parentNode!.keys()) {\n        if (k !== LEAF && k.startsWith(key)) {\n          const node = new Map()\n          node.set(k.slice(key.length), parentNode!.get(k)!)\n          return new SearchableMap(node, prefix)\n        }\n      }\n    }\n\n    return new SearchableMap<T>(node, prefix)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\n   */\n  clear (): void {\n    this._size = undefined\n    this._tree.clear()\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\n   * @param key  Key to delete\n   */\n  delete (key: string): void {\n    this._size = undefined\n    return remove(this._tree, key)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\n   * @return An iterator iterating through `[key, value]` entries.\n   */\n  entries () {\n    return new TreeIterator(this, ENTRIES)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\n   * @param fn  Iteration function\n   */\n  forEach (fn: (key: string, value: T, map: SearchableMap) => void): void {\n    for (const [key, value] of this) {\n      fn(key, value, this)\n    }\n  }\n\n  /**\n   * Returns a Map of all the entries that have a key within the given edit\n   * distance from the search key. The keys of the returned Map are the matching\n   * keys, while the values are two-element arrays where the first element is\n   * the value associated to the key, and the second is the edit distance of the\n   * key to the search key.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * let map = new SearchableMap()\n   * map.set('hello', 'world')\n   * map.set('hell', 'yeah')\n   * map.set('ciao', 'mondo')\n   *\n   * // Get all entries that match the key 'hallo' with a maximum edit distance of 2\n   * map.fuzzyGet('hallo', 2)\n   * // => Map(2) { 'hello' => ['world', 1], 'hell' => ['yeah', 2] }\n   *\n   * // In the example, the \"hello\" key has value \"world\" and edit distance of 1\n   * // (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n   * // (change \"e\" to \"a\", delete \"o\")\n   * ```\n   *\n   * @param key  The search key\n   * @param maxEditDistance  The maximum edit distance (Levenshtein)\n   * @return A Map of the matching keys to their value and edit distance\n   */\n  fuzzyGet (key: string, maxEditDistance: number): FuzzyResults<T> {\n    return fuzzySearch<T>(this._tree, key, maxEditDistance)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\n   * @param key  Key to get\n   * @return Value associated to the key, or `undefined` if the key is not\n   * found.\n   */\n  get (key: string): T | undefined {\n    const node = lookup<T>(this._tree, key)\n    return node !== undefined ? node.get(LEAF) : undefined\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\n   * @param key  Key\n   * @return True if the key is in the map, false otherwise\n   */\n  has (key: string): boolean {\n    const node = lookup(this._tree, key)\n    return node !== undefined && node.has(LEAF)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\n   * @return An `Iterable` iterating through keys\n   */\n  keys () {\n    return new TreeIterator(this, KEYS)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\n   * @param key  Key to set\n   * @param value  Value to associate to the key\n   * @return The {@link SearchableMap} itself, to allow chaining\n   */\n  set (key: string, value: T): SearchableMap<T> {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n    node.set(LEAF, value)\n    return this\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\n   */\n  get size (): number {\n    if (this._size) { return this._size }\n    /** @ignore */\n    this._size = 0\n\n    const iter = this.entries()\n    while (!iter.next().done) this._size! += 1\n\n    return this._size\n  }\n\n  /**\n   * Updates the value at the given key using the provided function. The function\n   * is called with the current value at the key, and its return value is used as\n   * the new value to be set.\n   *\n   * ### Example:\n   *\n   * ```javascript\n   * // Increment the current value by one\n   * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)\n   * ```\n   *\n   * If the value at the given key is or will be an object, it might not require\n   * re-assignment. In that case it is better to use `fetch()`, because it is\n   * faster.\n   *\n   * @param key  The key to update\n   * @param fn  The function used to compute the new value from the current one\n   * @return The {@link SearchableMap} itself, to allow chaining\n   */\n  update (key: string, fn: (value: T | undefined) => T): SearchableMap<T> {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n    node.set(LEAF, fn(node.get(LEAF)))\n    return this\n  }\n\n  /**\n   * Fetches the value of the given key. If the value does not exist, calls the\n   * given function to create a new value, which is inserted at the given key\n   * and subsequently returned.\n   *\n   * ### Example:\n   *\n   * ```javascript\n   * const map = searchableMap.fetch('somekey', () => new Map())\n   * map.set('foo', 'bar')\n   * ```\n   *\n   * @param key  The key to update\n   * @param initial  A function that creates a new value if the key does not exist\n   * @return The existing or new value at the given key\n   */\n  fetch (key: string, initial: () => T): T {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n\n    let value = node.get(LEAF)\n    if (value === undefined) {\n      node.set(LEAF, value = initial())\n    }\n\n    return value\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\n   * @return An `Iterable` iterating through values.\n   */\n  values () {\n    return new TreeIterator(this, VALUES)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Creates a {@link SearchableMap} from an `Iterable` of entries\n   *\n   * @param entries  Entries to be inserted in the {@link SearchableMap}\n   * @return A new {@link SearchableMap} with the given entries\n   */\n  static from<T = any> (entries: Iterable<Entry<T>> | Entry<T>[]) {\n    const tree = new SearchableMap()\n    for (const [key, value] of entries) {\n      tree.set(key, value)\n    }\n    return tree\n  }\n\n  /**\n   * Creates a {@link SearchableMap} from the iterable properties of a JavaScript object\n   *\n   * @param object  Object of entries for the {@link SearchableMap}\n   * @return A new {@link SearchableMap} with the given entries\n   */\n  static fromObject<T = any> (object: { [key: string]: T }) {\n    return SearchableMap.from<T>(Object.entries(object))\n  }\n}\n\nconst trackDown = <T = any>(tree: RadixTree<T> | undefined, key: string, path: Path<T> = []): [RadixTree<T> | undefined, Path<T>] => {\n  if (key.length === 0 || tree == null) { return [tree, path] }\n\n  for (const k of tree.keys()) {\n    if (k !== LEAF && key.startsWith(k)) {\n      path.push([tree, k]) // performance: update in place\n      return trackDown(tree.get(k)!, key.slice(k.length), path)\n    }\n  }\n\n  path.push([tree, key]) // performance: update in place\n  return trackDown(undefined, '', path)\n}\n\nconst lookup = <T = any>(tree: RadixTree<T>, key: string): RadixTree<T> | undefined => {\n  if (key.length === 0 || tree == null) { return tree }\n\n  for (const k of tree.keys()) {\n    if (k !== LEAF && key.startsWith(k)) {\n      return lookup(tree.get(k)!, key.slice(k.length))\n    }\n  }\n}\n\n// Create a path in the radix tree for the given key, and returns the deepest\n// node. This function is in the hot path for indexing. It avoids unnecessary\n// string operations and recursion for performance.\nconst createPath = <T = any>(node: RadixTree<T>, key: string): RadixTree<T> => {\n  const keyLength = key.length\n\n  outer: for (let pos = 0; node && pos < keyLength;) {\n    for (const k of node.keys()) {\n      // Check whether this key is a candidate: the first characters must match.\n      if (k !== LEAF && key[pos] === k[0]) {\n        const len = Math.min(keyLength - pos, k.length)\n\n        // Advance offset to the point where key and k no longer match.\n        let offset = 1\n        while (offset < len && key[pos + offset] === k[offset]) ++offset\n\n        const child = node.get(k)!\n        if (offset === k.length) {\n          // The existing key is shorter than the key we need to create.\n          node = child\n        } else {\n          // Partial match: we need to insert an intermediate node to contain\n          // both the existing subtree and the new node.\n          const intermediate = new Map()\n          intermediate.set(k.slice(offset), child)\n          node.set(key.slice(pos, pos + offset), intermediate)\n          node.delete(k)\n          node = intermediate\n        }\n\n        pos += offset\n        continue outer\n      }\n    }\n\n    // Create a final child node to contain the final suffix of the key.\n    const child = new Map()\n    node.set(key.slice(pos), child)\n    return child\n  }\n\n  return node\n}\n\nconst remove = <T = any>(tree: RadixTree<T>, key: string): void => {\n  const [node, path] = trackDown(tree, key)\n  if (node === undefined) { return }\n  node.delete(LEAF)\n\n  if (node.size === 0) {\n    cleanup(path)\n  } else if (node.size === 1) {\n    const [key, value] = node.entries().next().value!\n    merge(path, key as string, value as RadixTree<T>)\n  }\n}\n\nconst cleanup = <T = any>(path: Path<T>): void => {\n  if (path.length === 0) { return }\n\n  const [node, key] = last(path)\n  node!.delete(key)\n\n  if (node!.size === 0) {\n    cleanup(path.slice(0, -1))\n  } else if (node!.size === 1) {\n    const [key, value] = node!.entries().next().value!\n    if (key !== LEAF) {\n      merge(path.slice(0, -1), key as string, value as RadixTree<T>)\n    }\n  }\n}\n\nconst merge = <T = any>(path: Path<T>, key: string, value: RadixTree<T>): void => {\n  if (path.length === 0) { return }\n\n  const [node, nodeKey] = last(path)\n  node!.set(nodeKey + key, value)\n  node!.delete(nodeKey)\n}\n\nconst last = <T = any>(array: T[]): T => {\n  return array[array.length - 1]\n}\n",
    "symbols": [
      {
        "name": "SearchableMap",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 20,
        "endLine": 315
      },
      {
        "name": "SearchableMap.atPrefix",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 76,
        "endLine": 94
      },
      {
        "name": "SearchableMap.clear",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 99,
        "endLine": 102
      },
      {
        "name": "SearchableMap.delete",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 108,
        "endLine": 111
      },
      {
        "name": "SearchableMap.entries",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 117,
        "endLine": 119
      },
      {
        "name": "SearchableMap.forEach",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 125,
        "endLine": 129
      },
      {
        "name": "SearchableMap.fuzzyGet",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 159,
        "endLine": 161
      },
      {
        "name": "SearchableMap.get",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 169,
        "endLine": 172
      },
      {
        "name": "SearchableMap.has",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 179,
        "endLine": 182
      },
      {
        "name": "SearchableMap.keys",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 188,
        "endLine": 190
      },
      {
        "name": "SearchableMap.set",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 198,
        "endLine": 204
      },
      {
        "name": "SearchableMap.update",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 240,
        "endLine": 246
      },
      {
        "name": "SearchableMap.fetch",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 264,
        "endLine": 275
      },
      {
        "name": "SearchableMap.values",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 281,
        "endLine": 283
      },
      {
        "name": "SearchableMap.[Symbol.iterator]",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 288,
        "endLine": 290
      },
      {
        "name": "SearchableMap.from",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 298,
        "endLine": 304
      },
      {
        "name": "SearchableMap.fromObject",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/SearchableMap.ts",
        "startLine": 312,
        "endLine": 314
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
    "content": "import type { RadixTree, Entry, LeafType } from './types'\n\n/** @ignore */\nconst ENTRIES = 'ENTRIES'\n\n/** @ignore */\nconst KEYS = 'KEYS'\n\n/** @ignore */\nconst VALUES = 'VALUES'\n\n/** @ignore */\nconst LEAF = '' as LeafType\n\ninterface Iterators<T> {\n  ENTRIES: Entry<T>\n  KEYS: string\n  VALUES: T\n}\n\ntype Kind<T> = keyof Iterators<T>\ntype Result<T, K extends keyof Iterators<T>> = Iterators<T>[K]\n\ntype IteratorPath<T> = {\n  node: RadixTree<T>,\n  keys: string[]\n}[]\n\nexport type IterableSet<T> = {\n  _tree: RadixTree<T>,\n  _prefix: string\n}\n\n/**\n * @private\n */\nclass TreeIterator<T, K extends Kind<T>> implements Iterator<Result<T, K>> {\n  set: IterableSet<T>\n  _type: K\n  _path: IteratorPath<T>\n\n  constructor (set: IterableSet<T>, type: K) {\n    const node = set._tree\n    const keys = Array.from(node.keys())\n    this.set = set\n    this._type = type\n    this._path = keys.length > 0 ? [{ node, keys }] : []\n  }\n\n  next (): IteratorResult<Result<T, K>> {\n    const value = this.dive()\n    this.backtrack()\n    return value\n  }\n\n  dive (): IteratorResult<Result<T, K>> {\n    if (this._path.length === 0) { return { done: true, value: undefined } }\n    const { node, keys } = last(this._path)!\n    if (last(keys) === LEAF) { return { done: false, value: this.result() } }\n\n    const child = node.get(last(keys)!)!\n    this._path.push({ node: child, keys: Array.from(child.keys()) })\n    return this.dive()\n  }\n\n  backtrack (): void {\n    if (this._path.length === 0) { return }\n    const keys = last(this._path)!.keys\n    keys.pop()\n    if (keys.length > 0) { return }\n    this._path.pop()\n    this.backtrack()\n  }\n\n  key (): string {\n    return this.set._prefix + this._path\n      .map(({ keys }) => last(keys))\n      .filter(key => key !== LEAF)\n      .join('')\n  }\n\n  value (): T {\n    return last(this._path)!.node.get(LEAF)!\n  }\n\n  result (): Result<T, K> {\n    switch (this._type) {\n      case VALUES: return this.value() as Result<T, K>\n      case KEYS: return this.key() as Result<T, K>\n      default: return [this.key(), this.value()] as Result<T, K>\n    }\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n}\n\nconst last = <T>(array: T[]): T | undefined => {\n  return array[array.length - 1]\n}\n\nexport { TreeIterator, ENTRIES, KEYS, VALUES, LEAF }\n",
    "symbols": [
      {
        "name": "TreeIterator",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
        "startLine": 37,
        "endLine": 97
      },
      {
        "name": "TreeIterator.next",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
        "startLine": 50,
        "endLine": 54
      },
      {
        "name": "TreeIterator.dive",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
        "startLine": 56,
        "endLine": 64
      },
      {
        "name": "TreeIterator.backtrack",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
        "startLine": 66,
        "endLine": 73
      },
      {
        "name": "TreeIterator.key",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
        "startLine": 75,
        "endLine": 80
      },
      {
        "name": "TreeIterator.value",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
        "startLine": 82,
        "endLine": 84
      },
      {
        "name": "TreeIterator.result",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
        "startLine": 86,
        "endLine": 92
      },
      {
        "name": "TreeIterator.[Symbol.iterator]",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/minisearch/src/SearchableMap/TreeIterator.ts",
        "startLine": 94,
        "endLine": 96
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/minisearch/src/SearchableMap/types.ts",
    "content": "export type LeafType = '' & { readonly __tag: unique symbol }\n\nexport interface RadixTree<T> extends Map<string, T | RadixTree<T>> {\n  // Distinguish between an empty string indicating a leaf node and a non-empty\n  // string indicating a subtree. Overriding these types avoids a lot of type\n  // assertions elsewhere in the code. It is not 100% foolproof because you can\n  // still pass in a blank string '' disguised as `string` and potentially get a\n  // leaf value.\n  get(key: LeafType): T | undefined\n  get(key: string): RadixTree<T> | undefined\n\n  set(key: LeafType, value: T): this\n  set(key: string, value: RadixTree<T>): this\n}\n\nexport type Entry<T> = [string, T]\n\nexport type Path<T> = [RadixTree<T> | undefined, string][]\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/errors.ts",
    "content": "import type { ZodErrorMap } from \"./ZodError.js\";\nimport defaultErrorMap from \"./locales/en.js\";\n\nlet overrideErrorMap = defaultErrorMap;\nexport { defaultErrorMap };\n\nexport function setErrorMap(map: ZodErrorMap) {\n  overrideErrorMap = map;\n}\n\nexport function getErrorMap() {\n  return overrideErrorMap;\n}\n",
    "symbols": [
      {
        "name": "setErrorMap",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/errors.ts",
        "startLine": 7,
        "endLine": 9
      },
      {
        "name": "getErrorMap",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/errors.ts",
        "startLine": 11,
        "endLine": 13
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/external.ts",
    "content": "export * from \"./errors.js\";\nexport * from \"./helpers/parseUtil.js\";\nexport * from \"./helpers/typeAliases.js\";\nexport * from \"./helpers/util.js\";\nexport * from \"./types.js\";\nexport * from \"./ZodError.js\";\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/index.ts",
    "content": "import * as z from \"./external.js\";\nexport * from \"./external.js\";\nexport { z };\nexport default z;\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/standard-schema.ts",
    "content": "/**\n * The Standard Schema interface.\n */\nexport type StandardSchemaV1<Input = unknown, Output = Input> = {\n  /**\n   * The Standard Schema properties.\n   */\n  readonly \"~standard\": StandardSchemaV1.Props<Input, Output>;\n};\n\nexport declare namespace StandardSchemaV1 {\n  /**\n   * The Standard Schema properties interface.\n   */\n  export interface Props<Input = unknown, Output = Input> {\n    /**\n     * The version number of the standard.\n     */\n    readonly version: 1;\n    /**\n     * The vendor name of the schema library.\n     */\n    readonly vendor: string;\n    /**\n     * Validates unknown input values.\n     */\n    readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n    /**\n     * Inferred types associated with the schema.\n     */\n    readonly types?: Types<Input, Output> | undefined;\n  }\n\n  /**\n   * The result interface of the validate function.\n   */\n  export type Result<Output> = SuccessResult<Output> | FailureResult;\n\n  /**\n   * The result interface if validation succeeds.\n   */\n  export interface SuccessResult<Output> {\n    /**\n     * The typed output value.\n     */\n    readonly value: Output;\n    /**\n     * The non-existent issues.\n     */\n    readonly issues?: undefined;\n  }\n\n  /**\n   * The result interface if validation fails.\n   */\n  export interface FailureResult {\n    /**\n     * The issues of failed validation.\n     */\n    readonly issues: ReadonlyArray<Issue>;\n  }\n\n  /**\n   * The issue interface of the failure output.\n   */\n  export interface Issue {\n    /**\n     * The error message of the issue.\n     */\n    readonly message: string;\n    /**\n     * The path of the issue, if any.\n     */\n    readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;\n  }\n\n  /**\n   * The path segment interface of the issue.\n   */\n  export interface PathSegment {\n    /**\n     * The key representing a path segment.\n     */\n    readonly key: PropertyKey;\n  }\n\n  /**\n   * The Standard Schema types interface.\n   */\n  export interface Types<Input = unknown, Output = Input> {\n    /**\n     * The input type of the schema.\n     */\n    readonly input: Input;\n    /**\n     * The output type of the schema.\n     */\n    readonly output: Output;\n  }\n\n  /**\n   * Infers the input type of a Standard Schema.\n   */\n  export type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"input\"];\n\n  /**\n   * Infers the output type of a Standard Schema.\n   */\n  export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"output\"];\n\n  // biome-ignore lint/complexity/noUselessEmptyExport: needed for granular visibility control of TS namespace\n  export {};\n}\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/types.ts",
    "content": "import {\n  type IssueData,\n  type StringValidation,\n  type ZodCustomIssue,\n  ZodError,\n  type ZodErrorMap,\n  type ZodIssue,\n  ZodIssueCode,\n} from \"./ZodError.js\";\nimport { defaultErrorMap, getErrorMap } from \"./errors.js\";\nimport type { enumUtil } from \"./helpers/enumUtil.js\";\nimport { errorUtil } from \"./helpers/errorUtil.js\";\nimport {\n  type AsyncParseReturnType,\n  DIRTY,\n  INVALID,\n  OK,\n  type ParseContext,\n  type ParseInput,\n  type ParseParams,\n  type ParsePath,\n  type ParseReturnType,\n  ParseStatus,\n  type SyncParseReturnType,\n  addIssueToContext,\n  isAborted,\n  isAsync,\n  isDirty,\n  isValid,\n  makeIssue,\n} from \"./helpers/parseUtil.js\";\nimport type { partialUtil } from \"./helpers/partialUtil.js\";\nimport type { Primitive } from \"./helpers/typeAliases.js\";\nimport { util, ZodParsedType, getParsedType, type objectUtil } from \"./helpers/util.js\";\nimport type { StandardSchemaV1 } from \"./standard-schema.js\";\n\n///////////////////////////////////////\n///////////////////////////////////////\n//////////                   //////////\n//////////      ZodType      //////////\n//////////                   //////////\n///////////////////////////////////////\n///////////////////////////////////////\n\nexport interface RefinementCtx {\n  addIssue: (arg: IssueData) => void;\n  path: (string | number)[];\n}\nexport type ZodRawShape = { [k: string]: ZodTypeAny };\nexport type ZodTypeAny = ZodType<any, any, any>;\nexport type TypeOf<T extends ZodType<any, any, any>> = T[\"_output\"];\nexport type input<T extends ZodType<any, any, any>> = T[\"_input\"];\nexport type output<T extends ZodType<any, any, any>> = T[\"_output\"];\nexport type { TypeOf as infer };\n\nexport type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, \"code\">>;\nexport interface ZodTypeDef {\n  errorMap?: ZodErrorMap | undefined;\n  description?: string | undefined;\n}\n\nclass ParseInputLazyPath implements ParseInput {\n  parent: ParseContext;\n  data: any;\n  _path: ParsePath;\n  _key: string | number | (string | number)[];\n  _cachedPath: ParsePath = [];\n  constructor(parent: ParseContext, value: any, path: ParsePath, key: string | number | (string | number)[]) {\n    this.parent = parent;\n    this.data = value;\n    this._path = path;\n    this._key = key;\n  }\n  get path() {\n    if (!this._cachedPath.length) {\n      if (Array.isArray(this._key)) {\n        this._cachedPath.push(...this._path, ...this._key);\n      } else {\n        this._cachedPath.push(...this._path, this._key);\n      }\n    }\n\n    return this._cachedPath;\n  }\n}\n\nconst handleResult = <Input, Output>(\n  ctx: ParseContext,\n  result: SyncParseReturnType<Output>\n): { success: true; data: Output } | { success: false; error: ZodError<Input> } => {\n  if (isValid(result)) {\n    return { success: true, data: result.value };\n  } else {\n    if (!ctx.common.issues.length) {\n      throw new Error(\"Validation failed but no issues detected.\");\n    }\n\n    return {\n      success: false,\n      get error() {\n        if ((this as any)._error) return (this as any)._error as Error;\n        const error = new ZodError(ctx.common.issues);\n        (this as any)._error = error;\n        return (this as any)._error;\n      },\n    };\n  }\n};\n\nexport type RawCreateParams =\n  | {\n      errorMap?: ZodErrorMap | undefined;\n      invalid_type_error?: string | undefined;\n      required_error?: string | undefined;\n      message?: string | undefined;\n      description?: string | undefined;\n    }\n  | undefined;\nexport type ProcessedCreateParams = {\n  errorMap?: ZodErrorMap | undefined;\n  description?: string | undefined;\n};\nfunction processCreateParams(params: RawCreateParams): ProcessedCreateParams {\n  if (!params) return {};\n  const { errorMap, invalid_type_error, required_error, description } = params;\n  if (errorMap && (invalid_type_error || required_error)) {\n    throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  }\n  if (errorMap) return { errorMap: errorMap, description };\n  const customMap: ZodErrorMap = (iss, ctx) => {\n    const { message } = params;\n\n    if (iss.code === \"invalid_enum_value\") {\n      return { message: message ?? ctx.defaultError };\n    }\n    if (typeof ctx.data === \"undefined\") {\n      return { message: message ?? required_error ?? ctx.defaultError };\n    }\n    if (iss.code !== \"invalid_type\") return { message: ctx.defaultError };\n    return { message: message ?? invalid_type_error ?? ctx.defaultError };\n  };\n  return { errorMap: customMap, description };\n}\n\nexport type SafeParseSuccess<Output> = {\n  success: true;\n  data: Output;\n  error?: never;\n};\nexport type SafeParseError<Input> = {\n  success: false;\n  error: ZodError<Input>;\n  data?: never;\n};\n\nexport type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output> | SafeParseError<Input>;\n\nexport abstract class ZodType<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> {\n  readonly _type!: Output;\n  readonly _output!: Output;\n  readonly _input!: Input;\n  readonly _def!: Def;\n\n  get description(): string | undefined {\n    return this._def.description;\n  }\n\n  \"~standard\": StandardSchemaV1.Props<Input, Output>;\n\n  abstract _parse(input: ParseInput): ParseReturnType<Output>;\n\n  _getType(input: ParseInput): string {\n    return getParsedType(input.data);\n  }\n\n  _getOrReturnCtx(input: ParseInput, ctx?: ParseContext | undefined): ParseContext {\n    return (\n      ctx || {\n        common: input.parent.common,\n        data: input.data,\n\n        parsedType: getParsedType(input.data),\n\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent,\n      }\n    );\n  }\n\n  _processInputParams(input: ParseInput): {\n    status: ParseStatus;\n    ctx: ParseContext;\n  } {\n    return {\n      status: new ParseStatus(),\n      ctx: {\n        common: input.parent.common,\n        data: input.data,\n\n        parsedType: getParsedType(input.data),\n\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent,\n      },\n    };\n  }\n\n  _parseSync(input: ParseInput): SyncParseReturnType<Output> {\n    const result = this._parse(input);\n    if (isAsync(result)) {\n      throw new Error(\"Synchronous parse encountered promise.\");\n    }\n    return result;\n  }\n\n  _parseAsync(input: ParseInput): AsyncParseReturnType<Output> {\n    const result = this._parse(input);\n    return Promise.resolve(result);\n  }\n\n  parse(data: unknown, params?: util.InexactPartial<ParseParams>): Output {\n    const result = this.safeParse(data, params);\n    if (result.success) return result.data;\n    throw result.error;\n  }\n\n  safeParse(data: unknown, params?: util.InexactPartial<ParseParams>): SafeParseReturnType<Input, Output> {\n    const ctx: ParseContext = {\n      common: {\n        issues: [],\n        async: params?.async ?? false,\n        contextualErrorMap: params?.errorMap,\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data),\n    };\n    const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n\n    return handleResult(ctx, result);\n  }\n\n  \"~validate\"(data: unknown): StandardSchemaV1.Result<Output> | Promise<StandardSchemaV1.Result<Output>> {\n    const ctx: ParseContext = {\n      common: {\n        issues: [],\n        async: !!(this[\"~standard\"] as any).async,\n      },\n      path: [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data),\n    };\n\n    if (!(this[\"~standard\"] as any).async) {\n      try {\n        const result = this._parseSync({ data, path: [], parent: ctx });\n        return isValid(result)\n          ? {\n              value: result.value,\n            }\n          : {\n              issues: ctx.common.issues,\n            };\n      } catch (err: any) {\n        if ((err as Error)?.message?.toLowerCase()?.includes(\"encountered\")) {\n          (this[\"~standard\"] as any).async = true;\n        }\n        (ctx as any).common = {\n          issues: [],\n          async: true,\n        };\n      }\n    }\n\n    return this._parseAsync({ data, path: [], parent: ctx }).then((result) =>\n      isValid(result)\n        ? {\n            value: result.value,\n          }\n        : {\n            issues: ctx.common.issues,\n          }\n    );\n  }\n\n  async parseAsync(data: unknown, params?: util.InexactPartial<ParseParams>): Promise<Output> {\n    const result = await this.safeParseAsync(data, params);\n    if (result.success) return result.data;\n    throw result.error;\n  }\n\n  async safeParseAsync(\n    data: unknown,\n    params?: util.InexactPartial<ParseParams>\n  ): Promise<SafeParseReturnType<Input, Output>> {\n    const ctx: ParseContext = {\n      common: {\n        issues: [],\n        contextualErrorMap: params?.errorMap,\n        async: true,\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data),\n    };\n\n    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n    return handleResult(ctx, result);\n  }\n\n  /** Alias of safeParseAsync */\n  spa = this.safeParseAsync;\n\n  refine<RefinedOutput extends Output>(\n    check: (arg: Output) => arg is RefinedOutput,\n    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)\n  ): ZodEffects<this, RefinedOutput, Input>;\n  refine(\n    check: (arg: Output) => unknown | Promise<unknown>,\n    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)\n  ): ZodEffects<this, Output, Input>;\n  refine(\n    check: (arg: Output) => unknown,\n    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)\n  ): ZodEffects<this, Output, Input> {\n    const getIssueProperties = (val: Output) => {\n      if (typeof message === \"string\" || typeof message === \"undefined\") {\n        return { message };\n      } else if (typeof message === \"function\") {\n        return message(val);\n      } else {\n        return message;\n      }\n    };\n    return this._refinement((val, ctx) => {\n      const result = check(val);\n      const setError = () =>\n        ctx.addIssue({\n          code: ZodIssueCode.custom,\n          ...getIssueProperties(val),\n        });\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then((data) => {\n          if (!data) {\n            setError();\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      if (!result) {\n        setError();\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n\n  refinement<RefinedOutput extends Output>(\n    check: (arg: Output) => arg is RefinedOutput,\n    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)\n  ): ZodEffects<this, RefinedOutput, Input>;\n  refinement(\n    check: (arg: Output) => boolean,\n    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)\n  ): ZodEffects<this, Output, Input>;\n  refinement(\n    check: (arg: Output) => unknown,\n    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)\n  ): ZodEffects<this, Output, Input> {\n    return this._refinement((val, ctx) => {\n      if (!check(val)) {\n        ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n\n  _refinement(refinement: RefinementEffect<Output>[\"refinement\"]): ZodEffects<this, Output, Input> {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"refinement\", refinement },\n    });\n  }\n\n  superRefine<RefinedOutput extends Output>(\n    refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput\n  ): ZodEffects<this, RefinedOutput, Input>;\n  superRefine(refinement: (arg: Output, ctx: RefinementCtx) => void): ZodEffects<this, Output, Input>;\n  superRefine(refinement: (arg: Output, ctx: RefinementCtx) => Promise<void>): ZodEffects<this, Output, Input>;\n  superRefine(\n    refinement: (arg: Output, ctx: RefinementCtx) => unknown | Promise<unknown>\n  ): ZodEffects<this, Output, Input> {\n    return this._refinement(refinement);\n  }\n\n  constructor(def: Def) {\n    this._def = def;\n    this.parse = this.parse.bind(this);\n    this.safeParse = this.safeParse.bind(this);\n    this.parseAsync = this.parseAsync.bind(this);\n    this.safeParseAsync = this.safeParseAsync.bind(this);\n    this.spa = this.spa.bind(this);\n    this.refine = this.refine.bind(this);\n    this.refinement = this.refinement.bind(this);\n    this.superRefine = this.superRefine.bind(this);\n    this.optional = this.optional.bind(this);\n    this.nullable = this.nullable.bind(this);\n    this.nullish = this.nullish.bind(this);\n    this.array = this.array.bind(this);\n    this.promise = this.promise.bind(this);\n    this.or = this.or.bind(this);\n    this.and = this.and.bind(this);\n    this.transform = this.transform.bind(this);\n    this.brand = this.brand.bind(this);\n    this.default = this.default.bind(this);\n    this.catch = this.catch.bind(this);\n    this.describe = this.describe.bind(this);\n    this.pipe = this.pipe.bind(this);\n    this.readonly = this.readonly.bind(this);\n    this.isNullable = this.isNullable.bind(this);\n    this.isOptional = this.isOptional.bind(this);\n    this[\"~standard\"] = {\n      version: 1,\n      vendor: \"zod\",\n      validate: (data) => this[\"~validate\"](data),\n    };\n  }\n\n  optional(): ZodOptional<this> {\n    return ZodOptional.create(this, this._def) as any;\n  }\n  nullable(): ZodNullable<this> {\n    return ZodNullable.create(this, this._def) as any;\n  }\n  nullish(): ZodOptional<ZodNullable<this>> {\n    return this.nullable().optional();\n  }\n  array(): ZodArray<this> {\n    return ZodArray.create(this);\n  }\n  promise(): ZodPromise<this> {\n    return ZodPromise.create(this, this._def);\n  }\n\n  or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {\n    return ZodUnion.create([this, option], this._def) as any;\n  }\n\n  and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T> {\n    return ZodIntersection.create(this, incoming, this._def);\n  }\n\n  transform<NewOut>(\n    transform: (arg: Output, ctx: RefinementCtx) => NewOut | Promise<NewOut>\n  ): ZodEffects<this, NewOut> {\n    return new ZodEffects({\n      ...processCreateParams(this._def),\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"transform\", transform },\n    }) as any;\n  }\n\n  default(def: util.noUndefined<Input>): ZodDefault<this>;\n  default(def: () => util.noUndefined<Input>): ZodDefault<this>;\n  default(def: any) {\n    const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n\n    return new ZodDefault({\n      ...processCreateParams(this._def),\n      innerType: this,\n      defaultValue: defaultValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodDefault,\n    }) as any;\n  }\n\n  brand<B extends string | number | symbol>(brand?: B): ZodBranded<this, B>;\n  brand<B extends string | number | symbol>(): ZodBranded<this, B> {\n    return new ZodBranded({\n      typeName: ZodFirstPartyTypeKind.ZodBranded,\n      type: this,\n      ...processCreateParams(this._def),\n    });\n  }\n\n  catch(def: Output): ZodCatch<this>;\n  catch(def: (ctx: { error: ZodError; input: Input }) => Output): ZodCatch<this>;\n  catch(def: any) {\n    const catchValueFunc = typeof def === \"function\" ? def : () => def;\n\n    return new ZodCatch({\n      ...processCreateParams(this._def),\n      innerType: this,\n      catchValue: catchValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodCatch,\n    }) as any;\n  }\n\n  describe(description: string): this {\n    const This = (this as any).constructor;\n    return new This({\n      ...this._def,\n      description,\n    });\n  }\n\n  pipe<T extends ZodTypeAny>(target: T): ZodPipeline<this, T> {\n    return ZodPipeline.create(this, target);\n  }\n  readonly(): ZodReadonly<this> {\n    return ZodReadonly.create(this);\n  }\n\n  isOptional(): boolean {\n    return this.safeParse(undefined).success;\n  }\n  isNullable(): boolean {\n    return this.safeParse(null).success;\n  }\n}\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n//////////                     //////////\n//////////      ZodString      //////////\n//////////                     //////////\n/////////////////////////////////////////\n/////////////////////////////////////////\nexport type IpVersion = \"v4\" | \"v6\";\nexport type ZodStringCheck =\n  | { kind: \"min\"; value: number; message?: string | undefined }\n  | { kind: \"max\"; value: number; message?: string | undefined }\n  | { kind: \"length\"; value: number; message?: string | undefined }\n  | { kind: \"email\"; message?: string | undefined }\n  | { kind: \"url\"; message?: string | undefined }\n  | { kind: \"emoji\"; message?: string | undefined }\n  | { kind: \"uuid\"; message?: string | undefined }\n  | { kind: \"nanoid\"; message?: string | undefined }\n  | { kind: \"cuid\"; message?: string | undefined }\n  | { kind: \"includes\"; value: string; position?: number | undefined; message?: string | undefined }\n  | { kind: \"cuid2\"; message?: string | undefined }\n  | { kind: \"ulid\"; message?: string | undefined }\n  | { kind: \"startsWith\"; value: string; message?: string | undefined }\n  | { kind: \"endsWith\"; value: string; message?: string | undefined }\n  | { kind: \"regex\"; regex: RegExp; message?: string | undefined }\n  | { kind: \"trim\"; message?: string | undefined }\n  | { kind: \"toLowerCase\"; message?: string | undefined }\n  | { kind: \"toUpperCase\"; message?: string | undefined }\n  | { kind: \"jwt\"; alg?: string; message?: string | undefined }\n  | {\n      kind: \"datetime\";\n      offset: boolean;\n      local: boolean;\n      precision: number | null;\n      message?: string | undefined;\n    }\n  | {\n      kind: \"date\";\n      // withDate: true;\n      message?: string | undefined;\n    }\n  | {\n      kind: \"time\";\n      precision: number | null;\n      message?: string | undefined;\n    }\n  | { kind: \"duration\"; message?: string | undefined }\n  | { kind: \"ip\"; version?: IpVersion | undefined; message?: string | undefined }\n  | { kind: \"cidr\"; version?: IpVersion | undefined; message?: string | undefined }\n  | { kind: \"base64\"; message?: string | undefined }\n  | { kind: \"base64url\"; message?: string | undefined };\n\nexport interface ZodStringDef extends ZodTypeDef {\n  checks: ZodStringCheck[];\n  typeName: ZodFirstPartyTypeKind.ZodString;\n  coerce: boolean;\n}\n\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex =\n  /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex: RegExp;\n\n// faster, simpler, safer\nconst ipv4Regex =\n  /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex =\n  /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex =\n  /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex =\n  /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\n\nfunction timeRegexSource(args: { precision?: number | null }) {\n  let secondsRegexSource = `[0-5]\\\\d`;\n  if (args.precision) {\n    secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n  } else if (args.precision == null) {\n    secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n  }\n\n  const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n  return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\n\nfunction timeRegex(args: {\n  offset?: boolean;\n  local?: boolean;\n  precision?: number | null;\n}) {\n  return new RegExp(`^${timeRegexSource(args)}$`);\n}\n\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetimeRegex(args: {\n  precision?: number | null;\n  offset?: boolean;\n  local?: boolean;\n}) {\n  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n\n  const opts: string[] = [];\n  opts.push(args.local ? `Z?` : `Z`);\n  if (args.offset) opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n  regex = `${regex}(${opts.join(\"|\")})`;\n  return new RegExp(`^${regex}$`);\n}\n\nfunction isValidIP(ip: string, version?: IpVersion) {\n  if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n    return true;\n  }\n  if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isValidJWT(jwt: string, alg?: string): boolean {\n  if (!jwtRegex.test(jwt)) return false;\n  try {\n    const [header] = jwt.split(\".\");\n    if (!header) return false;\n    // Convert base64url to base64\n    const base64 = header\n      .replace(/-/g, \"+\")\n      .replace(/_/g, \"/\")\n      .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n    const decoded = JSON.parse(atob(base64));\n    if (typeof decoded !== \"object\" || decoded === null) return false;\n    if (\"typ\" in decoded && decoded?.typ !== \"JWT\") return false;\n    if (!decoded.alg) return false;\n    if (alg && decoded.alg !== alg) return false;\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction isValidCidr(ip: string, version?: IpVersion) {\n  if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n    return true;\n  }\n  if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport class ZodString extends ZodType<string, ZodStringDef, string> {\n  _parse(input: ParseInput): ParseReturnType<string> {\n    if (this._def.coerce) {\n      input.data = String(input.data);\n    }\n    const parsedType = this._getType(input);\n\n    if (parsedType !== ZodParsedType.string) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.string,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const status = new ParseStatus();\n    let ctx: undefined | ParseContext = undefined;\n\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.length < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.length > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"length\") {\n        const tooBig = input.data.length > check.value;\n        const tooSmall = input.data.length < check.value;\n        if (tooBig || tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          if (tooBig) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_big,\n              maximum: check.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check.message,\n            });\n          } else if (tooSmall) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_small,\n              minimum: check.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check.message,\n            });\n          }\n          status.dirty();\n        }\n      } else if (check.kind === \"email\") {\n        if (!emailRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"email\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"emoji\") {\n        if (!emojiRegex) {\n          emojiRegex = new RegExp(_emojiRegex, \"u\");\n        }\n        if (!emojiRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"emoji\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"uuid\") {\n        if (!uuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"uuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"nanoid\") {\n        if (!nanoidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"nanoid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid\") {\n        if (!cuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid2\") {\n        if (!cuid2Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid2\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"ulid\") {\n        if (!ulidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ulid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"url\") {\n        try {\n          new URL(input.data);\n        } catch {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"url\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"regex\") {\n        check.regex.lastIndex = 0;\n        const testResult = check.regex.test(input.data);\n        if (!testResult) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"regex\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"trim\") {\n        input.data = input.data.trim();\n      } else if (check.kind === \"includes\") {\n        if (!(input.data as string).includes(check.value, check.position)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { includes: check.value, position: check.position },\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"toLowerCase\") {\n        input.data = input.data.toLowerCase();\n      } else if (check.kind === \"toUpperCase\") {\n        input.data = input.data.toUpperCase();\n      } else if (check.kind === \"startsWith\") {\n        if (!(input.data as string).startsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { startsWith: check.value },\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"endsWith\") {\n        if (!(input.data as string).endsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { endsWith: check.value },\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"datetime\") {\n        const regex = datetimeRegex(check);\n\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"datetime\",\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"date\") {\n        const regex = dateRegex;\n\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"date\",\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"time\") {\n        const regex = timeRegex(check);\n\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"time\",\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"duration\") {\n        if (!durationRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"duration\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"ip\") {\n        if (!isValidIP(input.data, check.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ip\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"jwt\") {\n        if (!isValidJWT(input.data, check.alg)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"jwt\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cidr\") {\n        if (!isValidCidr(input.data, check.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cidr\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"base64\") {\n        if (!base64Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"base64\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"base64url\") {\n        if (!base64urlRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"base64url\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n\n    return { status: status.value, value: input.data };\n  }\n\n  protected _regex(regex: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage) {\n    return this.refinement((data) => regex.test(data), {\n      validation,\n      code: ZodIssueCode.invalid_string,\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  _addCheck(check: ZodStringCheck) {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, check],\n    });\n  }\n\n  email(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n  }\n\n  url(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n  }\n\n  emoji(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n  }\n\n  uuid(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n  }\n  nanoid(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n  }\n  cuid(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n  }\n\n  cuid2(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n  }\n  ulid(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n  }\n  base64(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n  }\n  base64url(message?: errorUtil.ErrMessage) {\n    // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n    return this._addCheck({\n      kind: \"base64url\",\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  jwt(options?: { alg?: string; message?: string | undefined }) {\n    return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n  }\n\n  ip(options?: string | { version?: IpVersion; message?: string | undefined }) {\n    return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n  }\n\n  cidr(options?: string | { version?: IpVersion; message?: string | undefined }) {\n    return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n  }\n\n  datetime(\n    options?:\n      | string\n      | {\n          message?: string | undefined;\n          precision?: number | null;\n          offset?: boolean;\n          local?: boolean;\n        }\n  ) {\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"datetime\",\n        precision: null,\n        offset: false,\n        local: false,\n        message: options,\n      });\n    }\n    return this._addCheck({\n      kind: \"datetime\",\n\n      precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n      offset: options?.offset ?? false,\n      local: options?.local ?? false,\n      ...errorUtil.errToObj(options?.message),\n    });\n  }\n\n  date(message?: string) {\n    return this._addCheck({ kind: \"date\", message });\n  }\n\n  time(\n    options?:\n      | string\n      | {\n          message?: string | undefined;\n          precision?: number | null;\n        }\n  ) {\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"time\",\n        precision: null,\n        message: options,\n      });\n    }\n    return this._addCheck({\n      kind: \"time\",\n      precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n      ...errorUtil.errToObj(options?.message),\n    });\n  }\n\n  duration(message?: errorUtil.ErrMessage) {\n    return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n  }\n\n  regex(regex: RegExp, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"regex\",\n      regex: regex,\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  includes(value: string, options?: { message?: string; position?: number }) {\n    return this._addCheck({\n      kind: \"includes\",\n      value: value,\n      position: options?.position,\n      ...errorUtil.errToObj(options?.message),\n    });\n  }\n\n  startsWith(value: string, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"startsWith\",\n      value: value,\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  endsWith(value: string, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"endsWith\",\n      value: value,\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  min(minLength: number, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minLength,\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  max(maxLength: number, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxLength,\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  length(len: number, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"length\",\n      value: len,\n      ...errorUtil.errToObj(message),\n    });\n  }\n\n  /**\n   * Equivalent to `.min(1)`\n   */\n  nonempty(message?: errorUtil.ErrMessage) {\n    return this.min(1, errorUtil.errToObj(message));\n  }\n\n  trim() {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"trim\" }],\n    });\n  }\n\n  toLowerCase() {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n    });\n  }\n\n  toUpperCase() {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n    });\n  }\n\n  get isDatetime() {\n    return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n  }\n\n  get isDate() {\n    return !!this._def.checks.find((ch) => ch.kind === \"date\");\n  }\n\n  get isTime() {\n    return !!this._def.checks.find((ch) => ch.kind === \"time\");\n  }\n  get isDuration() {\n    return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n  }\n\n  get isEmail() {\n    return !!this._def.checks.find((ch) => ch.kind === \"email\");\n  }\n\n  get isURL() {\n    return !!this._def.checks.find((ch) => ch.kind === \"url\");\n  }\n\n  get isEmoji() {\n    return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n  }\n\n  get isUUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n  }\n  get isNANOID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n  }\n\n  get isCUID2() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n  }\n  get isULID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n  }\n  get isIP() {\n    return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n  }\n  get isCIDR() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n  }\n  get isBase64() {\n    return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n  }\n  get isBase64url() {\n    // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n    return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n  }\n\n  get minLength() {\n    let min: number | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      }\n    }\n    return min;\n  }\n\n  get maxLength() {\n    let max: number | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n    return max;\n  }\n\n  static create = (params?: RawCreateParams & { coerce?: true }): ZodString => {\n    return new ZodString({\n      checks: [],\n      typeName: ZodFirstPartyTypeKind.ZodString,\n      coerce: params?.coerce ?? false,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n//////////                     //////////\n//////////      ZodNumber      //////////\n//////////                     //////////\n/////////////////////////////////////////\n/////////////////////////////////////////\nexport type ZodNumberCheck =\n  | { kind: \"min\"; value: number; inclusive: boolean; message?: string | undefined }\n  | { kind: \"max\"; value: number; inclusive: boolean; message?: string | undefined }\n  | { kind: \"int\"; message?: string | undefined }\n  | { kind: \"multipleOf\"; value: number; message?: string | undefined }\n  | { kind: \"finite\"; message?: string | undefined };\n\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val: number, step: number) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return (valInt % stepInt) / 10 ** decCount;\n}\n\nexport interface ZodNumberDef extends ZodTypeDef {\n  checks: ZodNumberCheck[];\n  typeName: ZodFirstPartyTypeKind.ZodNumber;\n  coerce: boolean;\n}\n\nexport class ZodNumber extends ZodType<number, ZodNumberDef, number> {\n  _parse(input: ParseInput): ParseReturnType<number> {\n    if (this._def.coerce) {\n      input.data = Number(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.number) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.number,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    let ctx: undefined | ParseContext = undefined;\n    const status = new ParseStatus();\n\n    for (const check of this._def.checks) {\n      if (check.kind === \"int\") {\n        if (!util.isInteger(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: \"integer\",\n            received: \"float\",\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (floatSafeRemainder(input.data, check.value) !== 0) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"finite\") {\n        if (!Number.isFinite(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_finite,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n\n    return { status: status.value, value: input.data };\n  }\n\n  static create = (params?: RawCreateParams & { coerce?: boolean }): ZodNumber => {\n    return new ZodNumber({\n      checks: [],\n      typeName: ZodFirstPartyTypeKind.ZodNumber,\n      coerce: params?.coerce || false,\n      ...processCreateParams(params),\n    });\n  };\n\n  gte(value: number, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n  }\n  min = this.gte;\n\n  gt(value: number, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n  }\n\n  lte(value: number, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n  }\n  max = this.lte;\n\n  lt(value: number, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n  }\n\n  protected setLimit(kind: \"min\" | \"max\", value: number, inclusive: boolean, message?: string) {\n    return new ZodNumber({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message),\n        },\n      ],\n    });\n  }\n\n  _addCheck(check: ZodNumberCheck) {\n    return new ZodNumber({\n      ...this._def,\n      checks: [...this._def.checks, check],\n    });\n  }\n\n  int(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"int\",\n      message: errorUtil.toString(message),\n    });\n  }\n\n  positive(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  negative(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  nonpositive(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  nonnegative(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  multipleOf(value: number, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value: value,\n      message: errorUtil.toString(message),\n    });\n  }\n  step = this.multipleOf;\n\n  finite(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"finite\",\n      message: errorUtil.toString(message),\n    });\n  }\n\n  safe(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      inclusive: true,\n      value: Number.MIN_SAFE_INTEGER,\n      message: errorUtil.toString(message),\n    })._addCheck({\n      kind: \"max\",\n      inclusive: true,\n      value: Number.MAX_SAFE_INTEGER,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  get minValue() {\n    let min: number | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      }\n    }\n    return min;\n  }\n\n  get maxValue() {\n    let max: number | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n    return max;\n  }\n\n  get isInt() {\n    return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n  }\n\n  get isFinite() {\n    let max: number | null = null;\n    let min: number | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n        return true;\n      } else if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      } else if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n    return Number.isFinite(min) && Number.isFinite(max);\n  }\n}\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n//////////                     //////////\n//////////      ZodBigInt      //////////\n//////////                     //////////\n/////////////////////////////////////////\n/////////////////////////////////////////\nexport type ZodBigIntCheck =\n  | { kind: \"min\"; value: bigint; inclusive: boolean; message?: string | undefined }\n  | { kind: \"max\"; value: bigint; inclusive: boolean; message?: string | undefined }\n  | { kind: \"multipleOf\"; value: bigint; message?: string | undefined };\n\nexport interface ZodBigIntDef extends ZodTypeDef {\n  checks: ZodBigIntCheck[];\n  typeName: ZodFirstPartyTypeKind.ZodBigInt;\n  coerce: boolean;\n}\n\nexport class ZodBigInt extends ZodType<bigint, ZodBigIntDef, bigint> {\n  _parse(input: ParseInput): ParseReturnType<bigint> {\n    if (this._def.coerce) {\n      try {\n        input.data = BigInt(input.data);\n      } catch {\n        return this._getInvalidInput(input);\n      }\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.bigint) {\n      return this._getInvalidInput(input);\n    }\n\n    let ctx: undefined | ParseContext = undefined;\n    const status = new ParseStatus();\n\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            type: \"bigint\",\n            minimum: check.value,\n            inclusive: check.inclusive,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            type: \"bigint\",\n            maximum: check.value,\n            inclusive: check.inclusive,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (input.data % check.value !== BigInt(0)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message,\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n\n    return { status: status.value, value: input.data };\n  }\n\n  _getInvalidInput(input: ParseInput) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.bigint,\n      received: ctx.parsedType,\n    });\n    return INVALID;\n  }\n\n  static create = (params?: RawCreateParams & { coerce?: boolean }): ZodBigInt => {\n    return new ZodBigInt({\n      checks: [],\n      typeName: ZodFirstPartyTypeKind.ZodBigInt,\n      coerce: params?.coerce ?? false,\n      ...processCreateParams(params),\n    });\n  };\n\n  gte(value: bigint, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n  }\n  min = this.gte;\n\n  gt(value: bigint, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n  }\n\n  lte(value: bigint, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n  }\n  max = this.lte;\n\n  lt(value: bigint, message?: errorUtil.ErrMessage) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n  }\n\n  protected setLimit(kind: \"min\" | \"max\", value: bigint, inclusive: boolean, message?: string) {\n    return new ZodBigInt({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message),\n        },\n      ],\n    });\n  }\n\n  _addCheck(check: ZodBigIntCheck) {\n    return new ZodBigInt({\n      ...this._def,\n      checks: [...this._def.checks, check],\n    });\n  }\n\n  positive(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  negative(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  nonpositive(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  nonnegative(message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  multipleOf(value: bigint, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message),\n    });\n  }\n\n  get minValue() {\n    let min: bigint | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      }\n    }\n    return min;\n  }\n\n  get maxValue() {\n    let max: bigint | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n    return max;\n  }\n}\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                     ///////////\n//////////      ZodBoolean      //////////\n//////////                     ///////////\n//////////////////////////////////////////\n//////////////////////////////////////////\nexport interface ZodBooleanDef extends ZodTypeDef {\n  typeName: ZodFirstPartyTypeKind.ZodBoolean;\n  coerce: boolean;\n}\n\nexport class ZodBoolean extends ZodType<boolean, ZodBooleanDef, boolean> {\n  _parse(input: ParseInput): ParseReturnType<boolean> {\n    if (this._def.coerce) {\n      input.data = Boolean(input.data);\n    }\n    const parsedType = this._getType(input);\n\n    if (parsedType !== ZodParsedType.boolean) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.boolean,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n\n  static create = (params?: RawCreateParams & { coerce?: boolean }): ZodBoolean => {\n    return new ZodBoolean({\n      typeName: ZodFirstPartyTypeKind.ZodBoolean,\n      coerce: params?.coerce || false,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n///////////////////////////////////////\n///////////////////////////////////////\n//////////                     ////////\n//////////      ZodDate        ////////\n//////////                     ////////\n///////////////////////////////////////\n///////////////////////////////////////\nexport type ZodDateCheck =\n  | { kind: \"min\"; value: number; message?: string | undefined }\n  | { kind: \"max\"; value: number; message?: string | undefined };\nexport interface ZodDateDef extends ZodTypeDef {\n  checks: ZodDateCheck[];\n  coerce: boolean;\n  typeName: ZodFirstPartyTypeKind.ZodDate;\n}\n\nexport class ZodDate extends ZodType<Date, ZodDateDef, Date> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    if (this._def.coerce) {\n      input.data = new Date(input.data);\n    }\n    const parsedType = this._getType(input);\n\n    if (parsedType !== ZodParsedType.date) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.date,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    if (Number.isNaN(input.data.getTime())) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_date,\n      });\n      return INVALID;\n    }\n\n    const status = new ParseStatus();\n    let ctx: undefined | ParseContext = undefined;\n\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.getTime() < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            minimum: check.value,\n            type: \"date\",\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.getTime() > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            maximum: check.value,\n            type: \"date\",\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n\n    return {\n      status: status.value,\n      value: new Date((input.data as Date).getTime()),\n    };\n  }\n\n  _addCheck(check: ZodDateCheck) {\n    return new ZodDate({\n      ...this._def,\n      checks: [...this._def.checks, check],\n    });\n  }\n\n  min(minDate: Date, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minDate.getTime(),\n      message: errorUtil.toString(message),\n    });\n  }\n\n  max(maxDate: Date, message?: errorUtil.ErrMessage) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxDate.getTime(),\n      message: errorUtil.toString(message),\n    });\n  }\n\n  get minDate() {\n    let min: number | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min) min = ch.value;\n      }\n    }\n\n    return min != null ? new Date(min) : null;\n  }\n\n  get maxDate() {\n    let max: number | null = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max) max = ch.value;\n      }\n    }\n\n    return max != null ? new Date(max) : null;\n  }\n\n  static create = (params?: RawCreateParams & { coerce?: boolean }): ZodDate => {\n    return new ZodDate({\n      checks: [],\n      coerce: params?.coerce || false,\n      typeName: ZodFirstPartyTypeKind.ZodDate,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////       ZodSymbol        //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\nexport interface ZodSymbolDef extends ZodTypeDef {\n  typeName: ZodFirstPartyTypeKind.ZodSymbol;\n}\n\nexport class ZodSymbol extends ZodType<symbol, ZodSymbolDef, symbol> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.symbol) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.symbol,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    return OK(input.data);\n  }\n\n  static create = (params?: RawCreateParams): ZodSymbol => {\n    return new ZodSymbol({\n      typeName: ZodFirstPartyTypeKind.ZodSymbol,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////      ZodUndefined      //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\nexport interface ZodUndefinedDef extends ZodTypeDef {\n  typeName: ZodFirstPartyTypeKind.ZodUndefined;\n}\n\nexport class ZodUndefined extends ZodType<undefined, ZodUndefinedDef, undefined> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.undefined,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  params?: RawCreateParams;\n\n  static create = (params?: RawCreateParams): ZodUndefined => {\n    return new ZodUndefined({\n      typeName: ZodFirstPartyTypeKind.ZodUndefined,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n///////////////////////////////////////\n///////////////////////////////////////\n//////////                   //////////\n//////////      ZodNull      //////////\n//////////                   //////////\n///////////////////////////////////////\n///////////////////////////////////////\nexport interface ZodNullDef extends ZodTypeDef {\n  typeName: ZodFirstPartyTypeKind.ZodNull;\n}\n\nexport class ZodNull extends ZodType<null, ZodNullDef, null> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.null) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.null,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  static create = (params?: RawCreateParams): ZodNull => {\n    return new ZodNull({\n      typeName: ZodFirstPartyTypeKind.ZodNull,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n//////////////////////////////////////\n//////////////////////////////////////\n//////////                  //////////\n//////////      ZodAny      //////////\n//////////                  //////////\n//////////////////////////////////////\n//////////////////////////////////////\nexport interface ZodAnyDef extends ZodTypeDef {\n  typeName: ZodFirstPartyTypeKind.ZodAny;\n}\n\nexport class ZodAny extends ZodType<any, ZodAnyDef, any> {\n  // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n  _any = true as const;\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    return OK(input.data);\n  }\n  static create = (params?: RawCreateParams): ZodAny => {\n    return new ZodAny({\n      typeName: ZodFirstPartyTypeKind.ZodAny,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      ZodUnknown      //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\nexport interface ZodUnknownDef extends ZodTypeDef {\n  typeName: ZodFirstPartyTypeKind.ZodUnknown;\n}\n\nexport class ZodUnknown extends ZodType<unknown, ZodUnknownDef, unknown> {\n  // required\n  _unknown = true as const;\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    return OK(input.data);\n  }\n\n  static create = (params?: RawCreateParams): ZodUnknown => {\n    return new ZodUnknown({\n      typeName: ZodFirstPartyTypeKind.ZodUnknown,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      ZodNever      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nexport interface ZodNeverDef extends ZodTypeDef {\n  typeName: ZodFirstPartyTypeKind.ZodNever;\n}\n\nexport class ZodNever extends ZodType<never, ZodNeverDef, never> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.never,\n      received: ctx.parsedType,\n    });\n    return INVALID;\n  }\n  static create = (params?: RawCreateParams): ZodNever => {\n    return new ZodNever({\n      typeName: ZodFirstPartyTypeKind.ZodNever,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n///////////////////////////////////////\n///////////////////////////////////////\n//////////                   //////////\n//////////      ZodVoid      //////////\n//////////                   //////////\n///////////////////////////////////////\n///////////////////////////////////////\nexport interface ZodVoidDef extends ZodTypeDef {\n  typeName: ZodFirstPartyTypeKind.ZodVoid;\n}\n\nexport class ZodVoid extends ZodType<void, ZodVoidDef, void> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.void,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n\n  static create = (params?: RawCreateParams): ZodVoid => {\n    return new ZodVoid({\n      typeName: ZodFirstPartyTypeKind.ZodVoid,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      ZodArray      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nexport interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n  type: T;\n  typeName: ZodFirstPartyTypeKind.ZodArray;\n  exactLength: { value: number; message?: string | undefined } | null;\n  minLength: { value: number; message?: string | undefined } | null;\n  maxLength: { value: number; message?: string | undefined } | null;\n}\n\nexport type ArrayCardinality = \"many\" | \"atleastone\";\nexport type arrayOutputType<\n  T extends ZodTypeAny,\n  Cardinality extends ArrayCardinality = \"many\",\n> = Cardinality extends \"atleastone\" ? [T[\"_output\"], ...T[\"_output\"][]] : T[\"_output\"][];\n\nexport class ZodArray<T extends ZodTypeAny, Cardinality extends ArrayCardinality = \"many\"> extends ZodType<\n  arrayOutputType<T, Cardinality>,\n  ZodArrayDef<T>,\n  Cardinality extends \"atleastone\" ? [T[\"_input\"], ...T[\"_input\"][]] : T[\"_input\"][]\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx, status } = this._processInputParams(input);\n\n    const def = this._def;\n\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    if (def.exactLength !== null) {\n      const tooBig = ctx.data.length > def.exactLength.value;\n      const tooSmall = ctx.data.length < def.exactLength.value;\n      if (tooBig || tooSmall) {\n        addIssueToContext(ctx, {\n          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n          minimum: (tooSmall ? def.exactLength.value : undefined) as number,\n          maximum: (tooBig ? def.exactLength.value : undefined) as number,\n          type: \"array\",\n          inclusive: true,\n          exact: true,\n          message: def.exactLength.message,\n        });\n        status.dirty();\n      }\n    }\n\n    if (def.minLength !== null) {\n      if (ctx.data.length < def.minLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.minLength.message,\n        });\n        status.dirty();\n      }\n    }\n\n    if (def.maxLength !== null) {\n      if (ctx.data.length > def.maxLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.maxLength.message,\n        });\n        status.dirty();\n      }\n    }\n\n    if (ctx.common.async) {\n      return Promise.all(\n        ([...ctx.data] as any[]).map((item, i) => {\n          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        })\n      ).then((result) => {\n        return ParseStatus.mergeArray(status, result);\n      });\n    }\n\n    const result = ([...ctx.data] as any[]).map((item, i) => {\n      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n    });\n\n    return ParseStatus.mergeArray(status, result);\n  }\n\n  get element() {\n    return this._def.type;\n  }\n\n  min(minLength: number, message?: errorUtil.ErrMessage): this {\n    return new ZodArray({\n      ...this._def,\n      minLength: { value: minLength, message: errorUtil.toString(message) },\n    }) as any;\n  }\n\n  max(maxLength: number, message?: errorUtil.ErrMessage): this {\n    return new ZodArray({\n      ...this._def,\n      maxLength: { value: maxLength, message: errorUtil.toString(message) },\n    }) as any;\n  }\n\n  length(len: number, message?: errorUtil.ErrMessage): this {\n    return new ZodArray({\n      ...this._def,\n      exactLength: { value: len, message: errorUtil.toString(message) },\n    }) as any;\n  }\n\n  nonempty(message?: errorUtil.ErrMessage): ZodArray<T, \"atleastone\"> {\n    return this.min(1, message) as any;\n  }\n\n  static create = <El extends ZodTypeAny>(schema: El, params?: RawCreateParams): ZodArray<El> => {\n    return new ZodArray({\n      type: schema,\n      minLength: null,\n      maxLength: null,\n      exactLength: null,\n      typeName: ZodFirstPartyTypeKind.ZodArray,\n      ...processCreateParams(params),\n    });\n  };\n}\n\nexport type ZodNonEmptyArray<T extends ZodTypeAny> = ZodArray<T, \"atleastone\">;\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n//////////                     //////////\n//////////      ZodObject      //////////\n//////////                     //////////\n/////////////////////////////////////////\n/////////////////////////////////////////\n\nexport type UnknownKeysParam = \"passthrough\" | \"strict\" | \"strip\";\n\nexport interface ZodObjectDef<\n  T extends ZodRawShape = ZodRawShape,\n  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,\n  Catchall extends ZodTypeAny = ZodTypeAny,\n> extends ZodTypeDef {\n  typeName: ZodFirstPartyTypeKind.ZodObject;\n  shape: () => T;\n  catchall: Catchall;\n  unknownKeys: UnknownKeys;\n}\n\nexport type mergeTypes<A, B> = {\n  [k in keyof A | keyof B]: k extends keyof B ? B[k] : k extends keyof A ? A[k] : never;\n};\n\nexport type objectOutputType<\n  Shape extends ZodRawShape,\n  Catchall extends ZodTypeAny,\n  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,\n> = objectUtil.flatten<objectUtil.addQuestionMarks<baseObjectOutputType<Shape>>> &\n  CatchallOutput<Catchall> &\n  PassthroughType<UnknownKeys>;\n\nexport type baseObjectOutputType<Shape extends ZodRawShape> = {\n  [k in keyof Shape]: Shape[k][\"_output\"];\n};\n\nexport type objectInputType<\n  Shape extends ZodRawShape,\n  Catchall extends ZodTypeAny,\n  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,\n> = objectUtil.flatten<baseObjectInputType<Shape>> & CatchallInput<Catchall> & PassthroughType<UnknownKeys>;\nexport type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.addQuestionMarks<{\n  [k in keyof Shape]: Shape[k][\"_input\"];\n}>;\n\nexport type CatchallOutput<T extends ZodType> = ZodType extends T ? unknown : { [k: string]: T[\"_output\"] };\n\nexport type CatchallInput<T extends ZodType> = ZodType extends T ? unknown : { [k: string]: T[\"_input\"] };\n\nexport type PassthroughType<T extends UnknownKeysParam> = T extends \"passthrough\" ? { [k: string]: unknown } : unknown;\n\nexport type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U>\n  ? deoptional<U>\n  : T extends ZodNullable<infer U>\n    ? ZodNullable<deoptional<U>>\n    : T;\n\nexport type SomeZodObject = ZodObject<ZodRawShape, UnknownKeysParam, ZodTypeAny>;\n\nexport type noUnrecognized<Obj extends object, Shape extends object> = {\n  [k in keyof Obj]: k extends keyof Shape ? Obj[k] : never;\n};\n\nfunction deepPartialify(schema: ZodTypeAny): any {\n  if (schema instanceof ZodObject) {\n    const newShape: any = {};\n\n    for (const key in schema.shape) {\n      const fieldSchema = schema.shape[key];\n      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n    }\n    return new ZodObject({\n      ...schema._def,\n      shape: () => newShape,\n    }) as any;\n  } else if (schema instanceof ZodArray) {\n    return new ZodArray({\n      ...schema._def,\n      type: deepPartialify(schema.element),\n    });\n  } else if (schema instanceof ZodOptional) {\n    return ZodOptional.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodNullable) {\n    return ZodNullable.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodTuple) {\n    return ZodTuple.create(schema.items.map((item: any) => deepPartialify(item)));\n  } else {\n    return schema;\n  }\n}\n\nexport class ZodObject<\n  T extends ZodRawShape,\n  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,\n  Catchall extends ZodTypeAny = ZodTypeAny,\n  Output = objectOutputType<T, Catchall, UnknownKeys>,\n  Input = objectInputType<T, Catchall, UnknownKeys>,\n> extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {\n  private _cached: { shape: T; keys: string[] } | null = null;\n\n  _getCached(): { shape: T; keys: string[] } {\n    if (this._cached !== null) return this._cached;\n    const shape = this._def.shape();\n    const keys = util.objectKeys(shape);\n    this._cached = { shape, keys };\n    return this._cached;\n  }\n\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.object) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const { status, ctx } = this._processInputParams(input);\n\n    const { shape, keys: shapeKeys } = this._getCached();\n    const extraKeys: string[] = [];\n\n    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n      for (const key in ctx.data) {\n        if (!shapeKeys.includes(key)) {\n          extraKeys.push(key);\n        }\n      }\n    }\n\n    const pairs: {\n      key: ParseReturnType<any>;\n      value: ParseReturnType<any>;\n      alwaysSet?: boolean;\n    }[] = [];\n    for (const key of shapeKeys) {\n      const keyValidator = shape[key]!;\n      const value = ctx.data[key];\n      pairs.push({\n        key: { status: \"valid\", value: key },\n        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n        alwaysSet: key in ctx.data,\n      });\n    }\n\n    if (this._def.catchall instanceof ZodNever) {\n      const unknownKeys = this._def.unknownKeys;\n\n      if (unknownKeys === \"passthrough\") {\n        for (const key of extraKeys) {\n          pairs.push({\n            key: { status: \"valid\", value: key },\n            value: { status: \"valid\", value: ctx.data[key] },\n          });\n        }\n      } else if (unknownKeys === \"strict\") {\n        if (extraKeys.length > 0) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.unrecognized_keys,\n            keys: extraKeys,\n          });\n          status.dirty();\n        }\n      } else if (unknownKeys === \"strip\") {\n      } else {\n        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n      }\n    } else {\n      // run catchall validation\n      const catchall = this._def.catchall;\n\n      for (const key of extraKeys) {\n        const value = ctx.data[key];\n        pairs.push({\n          key: { status: \"valid\", value: key },\n          value: catchall._parse(\n            new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n          ),\n          alwaysSet: key in ctx.data,\n        });\n      }\n    }\n\n    if (ctx.common.async) {\n      return Promise.resolve()\n        .then(async () => {\n          const syncPairs: any[] = [];\n          for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n              key,\n              value,\n              alwaysSet: pair.alwaysSet,\n            });\n          }\n          return syncPairs;\n        })\n        .then((syncPairs) => {\n          return ParseStatus.mergeObjectSync(status, syncPairs);\n        });\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs as any);\n    }\n  }\n\n  get shape() {\n    return this._def.shape();\n  }\n\n  strict(message?: errorUtil.ErrMessage): ZodObject<T, \"strict\", Catchall> {\n    errorUtil.errToObj;\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"strict\",\n      ...(message !== undefined\n        ? {\n            errorMap: (issue, ctx) => {\n              const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n              if (issue.code === \"unrecognized_keys\")\n                return {\n                  message: errorUtil.errToObj(message).message ?? defaultError,\n                };\n              return {\n                message: defaultError,\n              };\n            },\n          }\n        : {}),\n    }) as any;\n  }\n\n  strip(): ZodObject<T, \"strip\", Catchall> {\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"strip\",\n    }) as any;\n  }\n\n  passthrough(): ZodObject<T, \"passthrough\", Catchall> {\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"passthrough\",\n    }) as any;\n  }\n\n  /**\n   * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n   * If you want to pass through unknown properties, use `.passthrough()` instead.\n   */\n  nonstrict = this.passthrough;\n\n  // const AugmentFactory =\n  //   <Def extends ZodObjectDef>(def: Def) =>\n  //   <Augmentation extends ZodRawShape>(\n  //     augmentation: Augmentation\n  //   ): ZodObject<\n  //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n  //     Def[\"unknownKeys\"],\n  //     Def[\"catchall\"]\n  //   > => {\n  //     return new ZodObject({\n  //       ...def,\n  //       shape: () => ({\n  //         ...def.shape(),\n  //         ...augmentation,\n  //       }),\n  //     }) as any;\n  //   };\n  extend<Augmentation extends ZodRawShape>(\n    augmentation: Augmentation\n  ): ZodObject<objectUtil.extendShape<T, Augmentation>, UnknownKeys, Catchall> {\n    return new ZodObject({\n      ...this._def,\n      shape: () => ({\n        ...this._def.shape(),\n        ...augmentation,\n      }),\n    }) as any;\n  }\n  // extend<\n  //   Augmentation extends ZodRawShape,\n  //   NewOutput extends util.flatten<{\n  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_output\"]\n  //       : k extends keyof Output\n  //       ? Output[k]\n  //       : never;\n  //   }>,\n  //   NewInput extends util.flatten<{\n  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_input\"]\n  //       : k extends keyof Input\n  //       ? Input[k]\n  //       : never;\n  //   }>\n  // >(\n  //   augmentation: Augmentation\n  // ): ZodObject<\n  //   extendShape<T, Augmentation>,\n  //   UnknownKeys,\n  //   Catchall,\n  //   NewOutput,\n  //   NewInput\n  // > {\n  //   return new ZodObject({\n  //     ...this._def,\n  //     shape: () => ({\n  //       ...this._def.shape(),\n  //       ...augmentation,\n  //     }),\n  //   }) as any;\n  // }\n  /**\n   * @deprecated Use `.extend` instead\n   *  */\n  augment = this.extend;\n\n  /**\n   * Prior to zod@1.0.12 there was a bug in the\n   * inferred type of merged objects. Please\n   * upgrade if you are experiencing issues.\n   */\n  merge<Incoming extends AnyZodObject, Augmentation extends Incoming[\"shape\"]>(\n    merging: Incoming\n  ): ZodObject<objectUtil.extendShape<T, Augmentation>, Incoming[\"_def\"][\"unknownKeys\"], Incoming[\"_def\"][\"catchall\"]> {\n    const merged: any = new ZodObject({\n      unknownKeys: merging._def.unknownKeys,\n      catchall: merging._def.catchall,\n      shape: () => ({\n        ...this._def.shape(),\n        ...merging._def.shape(),\n      }),\n      typeName: ZodFirstPartyTypeKind.ZodObject,\n    }) as any;\n    return merged;\n  }\n  // merge<\n  //   Incoming extends AnyZodObject,\n  //   Augmentation extends Incoming[\"shape\"],\n  //   NewOutput extends {\n  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_output\"]\n  //       : k extends keyof Output\n  //       ? Output[k]\n  //       : never;\n  //   },\n  //   NewInput extends {\n  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_input\"]\n  //       : k extends keyof Input\n  //       ? Input[k]\n  //       : never;\n  //   }\n  // >(\n  //   merging: Incoming\n  // ): ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"],\n  //   NewOutput,\n  //   NewInput\n  // > {\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n\n  setKey<Key extends string, Schema extends ZodTypeAny>(\n    key: Key,\n    schema: Schema\n  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> {\n    return this.augment({ [key]: schema }) as any;\n  }\n  // merge<Incoming extends AnyZodObject>(\n  //   merging: Incoming\n  // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n  // ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"]\n  // > {\n  //   // const mergedShape = objectUtil.mergeShapes(\n  //   //   this._def.shape(),\n  //   //   merging._def.shape()\n  //   // );\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n\n  catchall<Index extends ZodTypeAny>(index: Index): ZodObject<T, UnknownKeys, Index> {\n    return new ZodObject({\n      ...this._def,\n      catchall: index,\n    }) as any;\n  }\n\n  pick<Mask extends util.Exactly<{ [k in keyof T]?: true }, Mask>>(\n    mask: Mask\n  ): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall> {\n    const shape: any = {};\n\n    for (const key of util.objectKeys(mask)) {\n      if (mask[key] && this.shape[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n\n    return new ZodObject({\n      ...this._def,\n      shape: () => shape,\n    }) as any;\n  }\n\n  omit<Mask extends util.Exactly<{ [k in keyof T]?: true }, Mask>>(\n    mask: Mask\n  ): ZodObject<Omit<T, keyof Mask>, UnknownKeys, Catchall> {\n    const shape: any = {};\n\n    for (const key of util.objectKeys(this.shape)) {\n      if (!mask[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n\n    return new ZodObject({\n      ...this._def,\n      shape: () => shape,\n    }) as any;\n  }\n\n  /**\n   * @deprecated\n   */\n  deepPartial(): partialUtil.DeepPartial<this> {\n    return deepPartialify(this);\n  }\n\n  partial(): ZodObject<{ [k in keyof T]: ZodOptional<T[k]> }, UnknownKeys, Catchall>;\n  partial<Mask extends util.Exactly<{ [k in keyof T]?: true }, Mask>>(\n    mask: Mask\n  ): ZodObject<\n    objectUtil.noNever<{\n      [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];\n    }>,\n    UnknownKeys,\n    Catchall\n  >;\n  partial(mask?: any) {\n    const newShape: any = {};\n\n    for (const key of util.objectKeys(this.shape)) {\n      const fieldSchema = this.shape[key]!;\n\n      if (mask && !mask[key]) {\n        newShape[key] = fieldSchema;\n      } else {\n        newShape[key] = fieldSchema.optional();\n      }\n    }\n\n    return new ZodObject({\n      ...this._def,\n      shape: () => newShape,\n    }) as any;\n  }\n\n  required(): ZodObject<{ [k in keyof T]: deoptional<T[k]> }, UnknownKeys, Catchall>;\n  required<Mask extends util.Exactly<{ [k in keyof T]?: true }, Mask>>(\n    mask: Mask\n  ): ZodObject<\n    objectUtil.noNever<{\n      [k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];\n    }>,\n    UnknownKeys,\n    Catchall\n  >;\n  required(mask?: any) {\n    const newShape: any = {};\n\n    for (const key of util.objectKeys(this.shape)) {\n      if (mask && !mask[key]) {\n        newShape[key] = this.shape[key];\n      } else {\n        const fieldSchema = this.shape[key];\n        let newField = fieldSchema;\n\n        while (newField instanceof ZodOptional) {\n          newField = (newField as ZodOptional<any>)._def.innerType;\n        }\n\n        newShape[key] = newField;\n      }\n    }\n\n    return new ZodObject({\n      ...this._def,\n      shape: () => newShape,\n    }) as any;\n  }\n\n  keyof(): ZodEnum<enumUtil.UnionToTupleString<keyof T>> {\n    return createZodEnum(util.objectKeys(this.shape) as [string, ...string[]]) as any;\n  }\n\n  static create = <Shape extends ZodRawShape>(\n    shape: Shape,\n    params?: RawCreateParams\n  ): ZodObject<\n    Shape,\n    \"strip\",\n    ZodTypeAny,\n    objectOutputType<Shape, ZodTypeAny, \"strip\">,\n    objectInputType<Shape, ZodTypeAny, \"strip\">\n  > => {\n    return new ZodObject({\n      shape: () => shape,\n      unknownKeys: \"strip\",\n      catchall: ZodNever.create(),\n      typeName: ZodFirstPartyTypeKind.ZodObject,\n      ...processCreateParams(params),\n    }) as any;\n  };\n\n  static strictCreate = <Shape extends ZodRawShape>(\n    shape: Shape,\n    params?: RawCreateParams\n  ): ZodObject<Shape, \"strict\"> => {\n    return new ZodObject({\n      shape: () => shape,\n      unknownKeys: \"strict\",\n      catchall: ZodNever.create(),\n      typeName: ZodFirstPartyTypeKind.ZodObject,\n      ...processCreateParams(params),\n    }) as any;\n  };\n\n  static lazycreate = <Shape extends ZodRawShape>(\n    shape: () => Shape,\n    params?: RawCreateParams\n  ): ZodObject<Shape, \"strip\"> => {\n    return new ZodObject({\n      shape,\n      unknownKeys: \"strip\",\n      catchall: ZodNever.create(),\n      typeName: ZodFirstPartyTypeKind.ZodObject,\n      ...processCreateParams(params),\n    }) as any;\n  };\n}\n\nexport type AnyZodObject = ZodObject<any, any, any>;\n\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      ZodUnion      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nexport type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;\nexport interface ZodUnionDef<T extends ZodUnionOptions = Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>>\n  extends ZodTypeDef {\n  options: T;\n  typeName: ZodFirstPartyTypeKind.ZodUnion;\n}\n\nexport class ZodUnion<T extends ZodUnionOptions> extends ZodType<\n  T[number][\"_output\"],\n  ZodUnionDef<T>,\n  T[number][\"_input\"]\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n    const options = this._def.options;\n\n    function handleResults(results: { ctx: ParseContext; result: SyncParseReturnType<any> }[]) {\n      // return first issue-free validation if it exists\n      for (const result of results) {\n        if (result.result.status === \"valid\") {\n          return result.result;\n        }\n      }\n\n      for (const result of results) {\n        if (result.result.status === \"dirty\") {\n          // add issues from dirty option\n\n          ctx.common.issues.push(...result.ctx.common.issues);\n          return result.result;\n        }\n      }\n\n      // return invalid\n      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors,\n      });\n      return INVALID;\n    }\n\n    if (ctx.common.async) {\n      return Promise.all(\n        options.map(async (option) => {\n          const childCtx: ParseContext = {\n            ...ctx,\n            common: {\n              ...ctx.common,\n              issues: [],\n            },\n            parent: null,\n          };\n          return {\n            result: await option._parseAsync({\n              data: ctx.data,\n              path: ctx.path,\n              parent: childCtx,\n            }),\n            ctx: childCtx,\n          };\n        })\n      ).then(handleResults);\n    } else {\n      let dirty: undefined | { result: DIRTY<any>; ctx: ParseContext } = undefined;\n      const issues: ZodIssue[][] = [];\n      for (const option of options) {\n        const childCtx: ParseContext = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: [],\n          },\n          parent: null,\n        };\n        const result = option._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: childCtx,\n        });\n\n        if (result.status === \"valid\") {\n          return result;\n        } else if (result.status === \"dirty\" && !dirty) {\n          dirty = { result, ctx: childCtx };\n        }\n\n        if (childCtx.common.issues.length) {\n          issues.push(childCtx.common.issues);\n        }\n      }\n\n      if (dirty) {\n        ctx.common.issues.push(...dirty.ctx.common.issues);\n        return dirty.result;\n      }\n\n      const unionErrors = issues.map((issues) => new ZodError(issues));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors,\n      });\n\n      return INVALID;\n    }\n  }\n\n  get options() {\n    return this._def.options;\n  }\n\n  static create = <Options extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>>(\n    types: Options,\n    params?: RawCreateParams\n  ): ZodUnion<Options> => {\n    return new ZodUnion({\n      options: types,\n      typeName: ZodFirstPartyTypeKind.ZodUnion,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n\nconst getDiscriminator = <T extends ZodTypeAny>(type: T): Primitive[] => {\n  if (type instanceof ZodLazy) {\n    return getDiscriminator(type.schema);\n  } else if (type instanceof ZodEffects) {\n    return getDiscriminator(type.innerType());\n  } else if (type instanceof ZodLiteral) {\n    return [type.value];\n  } else if (type instanceof ZodEnum) {\n    return type.options;\n  } else if (type instanceof ZodNativeEnum) {\n    // eslint-disable-next-line ban/ban\n    return util.objectValues(type.enum);\n  } else if (type instanceof ZodDefault) {\n    return getDiscriminator(type._def.innerType);\n  } else if (type instanceof ZodUndefined) {\n    return [undefined];\n  } else if (type instanceof ZodNull) {\n    return [null];\n  } else if (type instanceof ZodOptional) {\n    return [undefined, ...getDiscriminator(type.unwrap())];\n  } else if (type instanceof ZodNullable) {\n    return [null, ...getDiscriminator(type.unwrap())];\n  } else if (type instanceof ZodBranded) {\n    return getDiscriminator(type.unwrap());\n  } else if (type instanceof ZodReadonly) {\n    return getDiscriminator(type.unwrap());\n  } else if (type instanceof ZodCatch) {\n    return getDiscriminator(type._def.innerType);\n  } else {\n    return [];\n  }\n};\n\nexport type ZodDiscriminatedUnionOption<Discriminator extends string> = ZodObject<\n  { [key in Discriminator]: ZodTypeAny } & ZodRawShape,\n  UnknownKeysParam,\n  ZodTypeAny\n>;\n\nexport interface ZodDiscriminatedUnionDef<\n  Discriminator extends string,\n  Options extends readonly ZodDiscriminatedUnionOption<string>[] = ZodDiscriminatedUnionOption<string>[],\n> extends ZodTypeDef {\n  discriminator: Discriminator;\n  options: Options;\n  optionsMap: Map<Primitive, ZodDiscriminatedUnionOption<any>>;\n  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;\n}\n\nexport class ZodDiscriminatedUnion<\n  Discriminator extends string,\n  Options extends readonly ZodDiscriminatedUnionOption<Discriminator>[],\n> extends ZodType<output<Options[number]>, ZodDiscriminatedUnionDef<Discriminator, Options>, input<Options[number]>> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const discriminator = this.discriminator;\n\n    const discriminatorValue: string = ctx.data[discriminator];\n\n    const option = this.optionsMap.get(discriminatorValue);\n\n    if (!option) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union_discriminator,\n        options: Array.from(this.optionsMap.keys()),\n        path: [discriminator],\n      });\n      return INVALID;\n    }\n\n    if (ctx.common.async) {\n      return option._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx,\n      }) as any;\n    } else {\n      return option._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx,\n      }) as any;\n    }\n  }\n\n  get discriminator() {\n    return this._def.discriminator;\n  }\n\n  get options() {\n    return this._def.options;\n  }\n\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n\n  /**\n   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n   * have a different value for each object in the union.\n   * @param discriminator the name of the discriminator property\n   * @param types an array of object schemas\n   * @param params\n   */\n  static create<\n    Discriminator extends string,\n    Types extends readonly [\n      ZodDiscriminatedUnionOption<Discriminator>,\n      ...ZodDiscriminatedUnionOption<Discriminator>[],\n    ],\n  >(\n    discriminator: Discriminator,\n    options: Types,\n    params?: RawCreateParams\n  ): ZodDiscriminatedUnion<Discriminator, Types> {\n    // Get all the valid discriminator values\n    const optionsMap: Map<Primitive, Types[number]> = new Map();\n\n    // try {\n    for (const type of options) {\n      const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n      if (!discriminatorValues.length) {\n        throw new Error(\n          `A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`\n        );\n      }\n      for (const value of discriminatorValues) {\n        if (optionsMap.has(value)) {\n          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n        }\n\n        optionsMap.set(value, type);\n      }\n    }\n\n    return new ZodDiscriminatedUnion<\n      Discriminator,\n      // DiscriminatorValue,\n      Types\n    >({\n      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n      discriminator,\n      options,\n      optionsMap,\n      ...processCreateParams(params),\n    });\n  }\n}\n\n///////////////////////////////////////////////\n///////////////////////////////////////////////\n//////////                           //////////\n//////////      ZodIntersection      //////////\n//////////                           //////////\n///////////////////////////////////////////////\n///////////////////////////////////////////////\nexport interface ZodIntersectionDef<T extends ZodTypeAny = ZodTypeAny, U extends ZodTypeAny = ZodTypeAny>\n  extends ZodTypeDef {\n  left: T;\n  right: U;\n  typeName: ZodFirstPartyTypeKind.ZodIntersection;\n}\n\nfunction mergeValues(a: any, b: any): { valid: true; data: any } | { valid: false } {\n  const aType = getParsedType(a);\n  const bType = getParsedType(b);\n\n  if (a === b) {\n    return { valid: true, data: a };\n  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n    const bKeys = util.objectKeys(b);\n    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n\n    const newObj: any = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newObj[key] = sharedValue.data;\n    }\n\n    return { valid: true, data: newObj };\n  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n    if (a.length !== b.length) {\n      return { valid: false };\n    }\n\n    const newArray: unknown[] = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n\n      newArray.push(sharedValue.data);\n    }\n\n    return { valid: true, data: newArray };\n  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n    return { valid: true, data: a };\n  } else {\n    return { valid: false };\n  }\n}\n\nexport class ZodIntersection<T extends ZodTypeAny, U extends ZodTypeAny> extends ZodType<\n  T[\"_output\"] & U[\"_output\"],\n  ZodIntersectionDef<T, U>,\n  T[\"_input\"] & U[\"_input\"]\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    const handleParsed = (\n      parsedLeft: SyncParseReturnType,\n      parsedRight: SyncParseReturnType\n    ): SyncParseReturnType<T & U> => {\n      if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n        return INVALID;\n      }\n\n      const merged = mergeValues(parsedLeft.value, parsedRight.value);\n\n      if (!merged.valid) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.invalid_intersection_types,\n        });\n        return INVALID;\n      }\n\n      if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n        status.dirty();\n      }\n\n      return { status: status.value, value: merged.data };\n    };\n\n    if (ctx.common.async) {\n      return Promise.all([\n        this._def.left._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        }),\n        this._def.right._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        }),\n      ]).then(([left, right]: any) => handleParsed(left, right));\n    } else {\n      return handleParsed(\n        this._def.left._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        }),\n        this._def.right._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        })\n      );\n    }\n  }\n\n  static create = <TSchema extends ZodTypeAny, USchema extends ZodTypeAny>(\n    left: TSchema,\n    right: USchema,\n    params?: RawCreateParams\n  ): ZodIntersection<TSchema, USchema> => {\n    return new ZodIntersection({\n      left: left,\n      right: right,\n      typeName: ZodFirstPartyTypeKind.ZodIntersection,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      ZodTuple      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nexport type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport type AssertArray<T> = T extends any[] ? T : never;\nexport type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{\n  [k in keyof T]: T[k] extends ZodType<any, any, any> ? T[k][\"_output\"] : never;\n}>;\nexport type OutputTypeOfTupleWithRest<\n  T extends ZodTupleItems | [],\n  Rest extends ZodTypeAny | null = null,\n> = Rest extends ZodTypeAny ? [...OutputTypeOfTuple<T>, ...Rest[\"_output\"][]] : OutputTypeOfTuple<T>;\n\nexport type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{\n  [k in keyof T]: T[k] extends ZodType<any, any, any> ? T[k][\"_input\"] : never;\n}>;\nexport type InputTypeOfTupleWithRest<\n  T extends ZodTupleItems | [],\n  Rest extends ZodTypeAny | null = null,\n> = Rest extends ZodTypeAny ? [...InputTypeOfTuple<T>, ...Rest[\"_input\"][]] : InputTypeOfTuple<T>;\n\nexport interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems, Rest extends ZodTypeAny | null = null>\n  extends ZodTypeDef {\n  items: T;\n  rest: Rest;\n  typeName: ZodFirstPartyTypeKind.ZodTuple;\n}\n\nexport type AnyZodTuple = ZodTuple<[ZodTypeAny, ...ZodTypeAny[]] | [], ZodTypeAny | null>;\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport class ZodTuple<\n  T extends ZodTupleItems | [] = ZodTupleItems,\n  Rest extends ZodTypeAny | null = null,\n> extends ZodType<OutputTypeOfTupleWithRest<T, Rest>, ZodTupleDef<T, Rest>, InputTypeOfTupleWithRest<T, Rest>> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    if (ctx.data.length < this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        minimum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\",\n      });\n\n      return INVALID;\n    }\n\n    const rest = this._def.rest;\n\n    if (!rest && ctx.data.length > this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_big,\n        maximum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\",\n      });\n      status.dirty();\n    }\n\n    const items = ([...ctx.data] as any[])\n      .map((item, itemIndex) => {\n        const schema = this._def.items[itemIndex] || this._def.rest;\n        if (!schema) return null as any as SyncParseReturnType<any>;\n        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n      })\n      .filter((x) => !!x); // filter nulls\n\n    if (ctx.common.async) {\n      return Promise.all(items).then((results) => {\n        return ParseStatus.mergeArray(status, results);\n      });\n    } else {\n      return ParseStatus.mergeArray(status, items as SyncParseReturnType[]);\n    }\n  }\n\n  get items() {\n    return this._def.items;\n  }\n\n  rest<RestSchema extends ZodTypeAny>(rest: RestSchema): ZodTuple<T, RestSchema> {\n    return new ZodTuple({\n      ...this._def,\n      rest,\n    });\n  }\n\n  static create = <Items extends [ZodTypeAny, ...ZodTypeAny[]] | []>(\n    schemas: Items,\n    params?: RawCreateParams\n  ): ZodTuple<Items, null> => {\n    if (!Array.isArray(schemas)) {\n      throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n      items: schemas,\n      typeName: ZodFirstPartyTypeKind.ZodTuple,\n      rest: null,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n//////////                     //////////\n//////////      ZodRecord      //////////\n//////////                     //////////\n/////////////////////////////////////////\n/////////////////////////////////////////\nexport interface ZodRecordDef<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny>\n  extends ZodTypeDef {\n  valueType: Value;\n  keyType: Key;\n  typeName: ZodFirstPartyTypeKind.ZodRecord;\n}\n\nexport type KeySchema = ZodType<string | number | symbol, any, any>;\nexport type RecordType<K extends string | number | symbol, V> = [string] extends [K]\n  ? Record<K, V>\n  : [number] extends [K]\n    ? Record<K, V>\n    : [symbol] extends [K]\n      ? Record<K, V>\n      : [BRAND<string | number | symbol>] extends [K]\n        ? Record<K, V>\n        : Partial<Record<K, V>>;\nexport class ZodRecord<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<\n  RecordType<Key[\"_output\"], Value[\"_output\"]>,\n  ZodRecordDef<Key, Value>,\n  RecordType<Key[\"_input\"], Value[\"_input\"]>\n> {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const pairs: {\n      key: ParseReturnType<any>;\n      value: ParseReturnType<any>;\n      alwaysSet: boolean;\n    }[] = [];\n\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n\n    for (const key in ctx.data) {\n      pairs.push({\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n        alwaysSet: key in ctx.data,\n      });\n    }\n\n    if (ctx.common.async) {\n      return ParseStatus.mergeObjectAsync(status, pairs);\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs as any);\n    }\n  }\n\n  get element() {\n    return this._def.valueType;\n  }\n\n  static create<Value extends ZodTypeAny>(valueType: Value, params?: RawCreateParams): ZodRecord<ZodString, Value>;\n  static create<Keys extends KeySchema, Value extends ZodTypeAny>(\n    keySchema: Keys,\n    valueType: Value,\n    params?: RawCreateParams\n  ): ZodRecord<Keys, Value>;\n  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {\n    if (second instanceof ZodType) {\n      return new ZodRecord({\n        keyType: first,\n        valueType: second,\n        typeName: ZodFirstPartyTypeKind.ZodRecord,\n        ...processCreateParams(third),\n      });\n    }\n\n    return new ZodRecord({\n      keyType: ZodString.create(),\n      valueType: first,\n      typeName: ZodFirstPartyTypeKind.ZodRecord,\n      ...processCreateParams(second),\n    });\n  }\n}\n\n//////////////////////////////////////\n//////////////////////////////////////\n//////////                  //////////\n//////////      ZodMap      //////////\n//////////                  //////////\n//////////////////////////////////////\n//////////////////////////////////////\nexport interface ZodMapDef<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny>\n  extends ZodTypeDef {\n  valueType: Value;\n  keyType: Key;\n  typeName: ZodFirstPartyTypeKind.ZodMap;\n}\n\nexport class ZodMap<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<\n  Map<Key[\"_output\"], Value[\"_output\"]>,\n  ZodMapDef<Key, Value>,\n  Map<Key[\"_input\"], Value[\"_input\"]>\n> {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.map) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.map,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n\n    const pairs = [...(ctx.data as Map<unknown, unknown>).entries()].map(([key, value], index) => {\n      return {\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n      };\n    });\n\n    if (ctx.common.async) {\n      const finalMap = new Map();\n      return Promise.resolve().then(async () => {\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          if (key.status === \"aborted\" || value.status === \"aborted\") {\n            return INVALID;\n          }\n          if (key.status === \"dirty\" || value.status === \"dirty\") {\n            status.dirty();\n          }\n\n          finalMap.set(key.value, value.value);\n        }\n        return { status: status.value, value: finalMap };\n      });\n    } else {\n      const finalMap = new Map();\n      for (const pair of pairs) {\n        const key = pair.key as SyncParseReturnType;\n        const value = pair.value as SyncParseReturnType;\n        if (key.status === \"aborted\" || value.status === \"aborted\") {\n          return INVALID;\n        }\n        if (key.status === \"dirty\" || value.status === \"dirty\") {\n          status.dirty();\n        }\n\n        finalMap.set(key.value, value.value);\n      }\n      return { status: status.value, value: finalMap };\n    }\n  }\n  static create = <KeySchema extends ZodTypeAny = ZodTypeAny, ValueSchema extends ZodTypeAny = ZodTypeAny>(\n    keyType: KeySchema,\n    valueType: ValueSchema,\n    params?: RawCreateParams\n  ): ZodMap<KeySchema, ValueSchema> => {\n    return new ZodMap({\n      valueType,\n      keyType,\n      typeName: ZodFirstPartyTypeKind.ZodMap,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n//////////////////////////////////////\n//////////////////////////////////////\n//////////                  //////////\n//////////      ZodSet      //////////\n//////////                  //////////\n//////////////////////////////////////\n//////////////////////////////////////\nexport interface ZodSetDef<Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n  valueType: Value;\n  typeName: ZodFirstPartyTypeKind.ZodSet;\n  minSize: { value: number; message?: string | undefined } | null;\n  maxSize: { value: number; message?: string | undefined } | null;\n}\n\nexport class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<\n  Set<Value[\"_output\"]>,\n  ZodSetDef<Value>,\n  Set<Value[\"_input\"]>\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.set) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.set,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const def = this._def;\n\n    if (def.minSize !== null) {\n      if (ctx.data.size < def.minSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.minSize.message,\n        });\n        status.dirty();\n      }\n    }\n\n    if (def.maxSize !== null) {\n      if (ctx.data.size > def.maxSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.maxSize.message,\n        });\n        status.dirty();\n      }\n    }\n\n    const valueType = this._def.valueType;\n\n    function finalizeSet(elements: SyncParseReturnType<any>[]) {\n      const parsedSet = new Set();\n      for (const element of elements) {\n        if (element.status === \"aborted\") return INVALID;\n        if (element.status === \"dirty\") status.dirty();\n        parsedSet.add(element.value);\n      }\n      return { status: status.value, value: parsedSet };\n    }\n\n    const elements = [...(ctx.data as Set<unknown>).values()].map((item, i) =>\n      valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i))\n    );\n\n    if (ctx.common.async) {\n      return Promise.all(elements).then((elements) => finalizeSet(elements));\n    } else {\n      return finalizeSet(elements as SyncParseReturnType[]);\n    }\n  }\n\n  min(minSize: number, message?: errorUtil.ErrMessage): this {\n    return new ZodSet({\n      ...this._def,\n      minSize: { value: minSize, message: errorUtil.toString(message) },\n    }) as any;\n  }\n\n  max(maxSize: number, message?: errorUtil.ErrMessage): this {\n    return new ZodSet({\n      ...this._def,\n      maxSize: { value: maxSize, message: errorUtil.toString(message) },\n    }) as any;\n  }\n\n  size(size: number, message?: errorUtil.ErrMessage): this {\n    return this.min(size, message).max(size, message) as any;\n  }\n\n  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {\n    return this.min(1, message) as any;\n  }\n\n  static create = <ValueSchema extends ZodTypeAny = ZodTypeAny>(\n    valueType: ValueSchema,\n    params?: RawCreateParams\n  ): ZodSet<ValueSchema> => {\n    return new ZodSet({\n      valueType,\n      minSize: null,\n      maxSize: null,\n      typeName: ZodFirstPartyTypeKind.ZodSet,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n///////////////////////////////////////////\n///////////////////////////////////////////\n//////////                       //////////\n//////////      ZodFunction      //////////\n//////////                       //////////\n///////////////////////////////////////////\n///////////////////////////////////////////\nexport interface ZodFunctionDef<\n  Args extends ZodTuple<any, any> = ZodTuple<any, any>,\n  Returns extends ZodTypeAny = ZodTypeAny,\n> extends ZodTypeDef {\n  args: Args;\n  returns: Returns;\n  typeName: ZodFirstPartyTypeKind.ZodFunction;\n}\n\nexport type OuterTypeOfFunction<\n  Args extends ZodTuple<any, any>,\n  Returns extends ZodTypeAny,\n> = Args[\"_input\"] extends Array<any> ? (...args: Args[\"_input\"]) => Returns[\"_output\"] : never;\n\nexport type InnerTypeOfFunction<\n  Args extends ZodTuple<any, any>,\n  Returns extends ZodTypeAny,\n> = Args[\"_output\"] extends Array<any> ? (...args: Args[\"_output\"]) => Returns[\"_input\"] : never;\n\nexport class ZodFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> extends ZodType<\n  OuterTypeOfFunction<Args, Returns>,\n  ZodFunctionDef<Args, Returns>,\n  InnerTypeOfFunction<Args, Returns>\n> {\n  _parse(input: ParseInput): ParseReturnType<any> {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.function) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.function,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    function makeArgsIssue(args: any, error: ZodError): ZodIssue {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter(\n          (x) => !!x\n        ),\n        issueData: {\n          code: ZodIssueCode.invalid_arguments,\n          argumentsError: error,\n        },\n      });\n    }\n\n    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter(\n          (x) => !!x\n        ),\n        issueData: {\n          code: ZodIssueCode.invalid_return_type,\n          returnTypeError: error,\n        },\n      });\n    }\n\n    const params = { errorMap: ctx.common.contextualErrorMap };\n    const fn = ctx.data;\n\n    if (this._def.returns instanceof ZodPromise) {\n      // Would love a way to avoid disabling this rule, but we need\n      // an alias (using an arrow function was what caused 2651).\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const me = this;\n      return OK(async function (this: any, ...args: any[]) {\n        const error = new ZodError([]);\n        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n          error.addIssue(makeArgsIssue(args, e));\n          throw error;\n        });\n        const result = await Reflect.apply(fn, this, parsedArgs as any);\n        const parsedReturns = await (me._def.returns as unknown as ZodPromise<ZodTypeAny>)._def.type\n          .parseAsync(result, params)\n          .catch((e) => {\n            error.addIssue(makeReturnsIssue(result, e));\n            throw error;\n          });\n        return parsedReturns;\n      });\n    } else {\n      // Would love a way to avoid disabling this rule, but we need\n      // an alias (using an arrow function was what caused 2651).\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const me = this;\n      return OK(function (this: any, ...args: any[]) {\n        const parsedArgs = me._def.args.safeParse(args, params);\n        if (!parsedArgs.success) {\n          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n        }\n        const result = Reflect.apply(fn, this, parsedArgs.data);\n        const parsedReturns = me._def.returns.safeParse(result, params);\n        if (!parsedReturns.success) {\n          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n        }\n        return parsedReturns.data;\n      }) as any;\n    }\n  }\n\n  parameters() {\n    return this._def.args;\n  }\n\n  returnType() {\n    return this._def.returns;\n  }\n\n  args<Items extends Parameters<(typeof ZodTuple)[\"create\"]>[0]>(\n    ...items: Items\n  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> {\n    return new ZodFunction({\n      ...this._def,\n      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,\n    });\n  }\n\n  returns<NewReturnType extends ZodType<any, any, any>>(returnType: NewReturnType): ZodFunction<Args, NewReturnType> {\n    return new ZodFunction({\n      ...this._def,\n      returns: returnType,\n    });\n  }\n\n  implement<F extends InnerTypeOfFunction<Args, Returns>>(\n    func: F\n  ): ReturnType<F> extends Returns[\"_output\"]\n    ? (...args: Args[\"_input\"]) => ReturnType<F>\n    : OuterTypeOfFunction<Args, Returns> {\n    const validatedFunc = this.parse(func);\n    return validatedFunc as any;\n  }\n\n  strictImplement(func: InnerTypeOfFunction<Args, Returns>): InnerTypeOfFunction<Args, Returns> {\n    const validatedFunc = this.parse(func);\n    return validatedFunc as any;\n  }\n\n  validate = this.implement;\n\n  static create(): ZodFunction<ZodTuple<[], ZodUnknown>, ZodUnknown>;\n  static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>>(args: T): ZodFunction<T, ZodUnknown>;\n  static create<T extends AnyZodTuple, U extends ZodTypeAny>(args: T, returns: U): ZodFunction<T, U>;\n  static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>, U extends ZodTypeAny = ZodUnknown>(\n    args: T,\n    returns: U,\n    params?: RawCreateParams\n  ): ZodFunction<T, U>;\n  static create(args?: AnyZodTuple, returns?: ZodTypeAny, params?: RawCreateParams) {\n    return new ZodFunction({\n      args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())) as any,\n      returns: returns || ZodUnknown.create(),\n      typeName: ZodFirstPartyTypeKind.ZodFunction,\n      ...processCreateParams(params),\n    }) as any;\n  }\n}\n\n///////////////////////////////////////\n///////////////////////////////////////\n//////////                   //////////\n//////////      ZodLazy      //////////\n//////////                   //////////\n///////////////////////////////////////\n///////////////////////////////////////\nexport interface ZodLazyDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n  getter: () => T;\n  typeName: ZodFirstPartyTypeKind.ZodLazy;\n}\n\nexport class ZodLazy<T extends ZodTypeAny> extends ZodType<output<T>, ZodLazyDef<T>, input<T>> {\n  get schema(): T {\n    return this._def.getter();\n  }\n\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n    const lazySchema = this._def.getter();\n    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n  }\n\n  static create = <Inner extends ZodTypeAny>(getter: () => Inner, params?: RawCreateParams): ZodLazy<Inner> => {\n    return new ZodLazy({\n      getter: getter,\n      typeName: ZodFirstPartyTypeKind.ZodLazy,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      ZodLiteral      //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\nexport interface ZodLiteralDef<T = any> extends ZodTypeDef {\n  value: T;\n  typeName: ZodFirstPartyTypeKind.ZodLiteral;\n}\n\nexport class ZodLiteral<T> extends ZodType<T, ZodLiteralDef<T>, T> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    if (input.data !== this._def.value) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_literal,\n        expected: this._def.value,\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n\n  get value() {\n    return this._def.value;\n  }\n\n  static create = <Value extends Primitive>(value: Value, params?: RawCreateParams): ZodLiteral<Value> => {\n    return new ZodLiteral({\n      value: value,\n      typeName: ZodFirstPartyTypeKind.ZodLiteral,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n///////////////////////////////////////\n///////////////////////////////////////\n//////////                   //////////\n//////////      ZodEnum      //////////\n//////////                   //////////\n///////////////////////////////////////\n///////////////////////////////////////\nexport type ArrayKeys = keyof any[];\nexport type Indices<T> = Exclude<keyof T, ArrayKeys>;\n\nexport type EnumValues<T extends string = string> = readonly [T, ...T[]];\n\nexport type Values<T extends EnumValues> = {\n  [k in T[number]]: k;\n};\n\nexport interface ZodEnumDef<T extends EnumValues = EnumValues> extends ZodTypeDef {\n  values: T;\n  typeName: ZodFirstPartyTypeKind.ZodEnum;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] };\n\nexport type FilterEnum<Values, ToExclude> = Values extends []\n  ? []\n  : Values extends [infer Head, ...infer Rest]\n    ? Head extends ToExclude\n      ? FilterEnum<Rest, ToExclude>\n      : [Head, ...FilterEnum<Rest, ToExclude>]\n    : never;\n\nexport type typecast<A, T> = A extends T ? A : never;\n\nfunction createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(\n  values: T,\n  params?: RawCreateParams\n): ZodEnum<Writeable<T>>;\nfunction createZodEnum<U extends string, T extends [U, ...U[]]>(values: T, params?: RawCreateParams): ZodEnum<T>;\nfunction createZodEnum(values: [string, ...string[]], params?: RawCreateParams) {\n  return new ZodEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodEnum,\n    ...processCreateParams(params),\n  });\n}\n\nexport class ZodEnum<T extends [string, ...string[]]> extends ZodType<T[number], ZodEnumDef<T>, T[number]> {\n  _cache: Set<T[number]> | undefined;\n\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    if (typeof input.data !== \"string\") {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues) as \"string\",\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type,\n      });\n      return INVALID;\n    }\n\n    if (!this._cache) {\n      this._cache = new Set(this._def.values);\n    }\n\n    if (!this._cache.has(input.data)) {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n\n  get options() {\n    return this._def.values;\n  }\n\n  get enum(): Values<T> {\n    const enumValues: any = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n\n  get Values(): Values<T> {\n    const enumValues: any = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n\n  get Enum(): Values<T> {\n    const enumValues: any = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n\n  extract<ToExtract extends readonly [T[number], ...T[number][]]>(\n    values: ToExtract,\n    newDef: RawCreateParams = this._def\n  ): ZodEnum<Writeable<ToExtract>> {\n    return ZodEnum.create(values, {\n      ...this._def,\n      ...newDef,\n    }) as any;\n  }\n\n  exclude<ToExclude extends readonly [T[number], ...T[number][]]>(\n    values: ToExclude,\n    newDef: RawCreateParams = this._def\n  ): ZodEnum<typecast<Writeable<FilterEnum<T, ToExclude[number]>>, [string, ...string[]]>> {\n    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)) as FilterEnum<T, ToExclude[number]>, {\n      ...this._def,\n      ...newDef,\n    }) as any;\n  }\n\n  static create = createZodEnum;\n}\n\n/////////////////////////////////////////////\n/////////////////////////////////////////////\n//////////                         //////////\n//////////      ZodNativeEnum      //////////\n//////////                         //////////\n/////////////////////////////////////////////\n/////////////////////////////////////////////\nexport interface ZodNativeEnumDef<T extends EnumLike = EnumLike> extends ZodTypeDef {\n  values: T;\n  typeName: ZodFirstPartyTypeKind.ZodNativeEnum;\n}\n\nexport type EnumLike = { [k: string]: string | number; [nu: number]: string };\n\nexport class ZodNativeEnum<T extends EnumLike> extends ZodType<T[keyof T], ZodNativeEnumDef<T>, T[keyof T]> {\n  _cache: Set<T[keyof T]> | undefined;\n  _parse(input: ParseInput): ParseReturnType<T[keyof T]> {\n    const nativeEnumValues = util.getValidEnumValues(this._def.values);\n\n    const ctx = this._getOrReturnCtx(input);\n    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues) as \"string\",\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type,\n      });\n      return INVALID;\n    }\n\n    if (!this._cache) {\n      this._cache = new Set(util.getValidEnumValues(this._def.values));\n    }\n\n    if (!this._cache.has(input.data)) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues,\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n\n  get enum() {\n    return this._def.values;\n  }\n\n  static create = <Elements extends EnumLike>(values: Elements, params?: RawCreateParams): ZodNativeEnum<Elements> => {\n    return new ZodNativeEnum({\n      values: values,\n      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      ZodPromise      //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\nexport interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n  type: T;\n  typeName: ZodFirstPartyTypeKind.ZodPromise;\n}\n\nexport class ZodPromise<T extends ZodTypeAny> extends ZodType<\n  Promise<T[\"_output\"]>,\n  ZodPromiseDef<T>,\n  Promise<T[\"_input\"]>\n> {\n  unwrap() {\n    return this._def.type;\n  }\n\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.promise,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n\n    return OK(\n      promisified.then((data: any) => {\n        return this._def.type.parseAsync(data, {\n          path: ctx.path,\n          errorMap: ctx.common.contextualErrorMap,\n        });\n      })\n    );\n  }\n\n  static create = <Inner extends ZodTypeAny>(schema: Inner, params?: RawCreateParams): ZodPromise<Inner> => {\n    return new ZodPromise({\n      type: schema,\n      typeName: ZodFirstPartyTypeKind.ZodPromise,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n//////////////////////////////////////////////\n//////////////////////////////////////////////\n//////////                          //////////\n//////////        ZodEffects        //////////\n//////////                          //////////\n//////////////////////////////////////////////\n//////////////////////////////////////////////\n\nexport type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;\nexport type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void | Promise<void>;\n\nexport type RefinementEffect<T> = {\n  type: \"refinement\";\n  refinement: (arg: T, ctx: RefinementCtx) => any;\n};\nexport type TransformEffect<T> = {\n  type: \"transform\";\n  transform: (arg: T, ctx: RefinementCtx) => any;\n};\nexport type PreprocessEffect<T> = {\n  type: \"preprocess\";\n  transform: (arg: T, ctx: RefinementCtx) => any;\n};\nexport type Effect<T> = RefinementEffect<T> | TransformEffect<T> | PreprocessEffect<T>;\n\nexport interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n  schema: T;\n  typeName: ZodFirstPartyTypeKind.ZodEffects;\n  effect: Effect<any>;\n}\n\nexport class ZodEffects<T extends ZodTypeAny, Output = output<T>, Input = input<T>> extends ZodType<\n  Output,\n  ZodEffectsDef<T>,\n  Input\n> {\n  innerType() {\n    return this._def.schema;\n  }\n\n  sourceType(): T {\n    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n      ? (this._def.schema as unknown as ZodEffects<T>).sourceType()\n      : (this._def.schema as T);\n  }\n\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { status, ctx } = this._processInputParams(input);\n\n    const effect = this._def.effect || null;\n\n    const checkCtx: RefinementCtx = {\n      addIssue: (arg: IssueData) => {\n        addIssueToContext(ctx, arg);\n        if (arg.fatal) {\n          status.abort();\n        } else {\n          status.dirty();\n        }\n      },\n      get path() {\n        return ctx.path;\n      },\n    };\n\n    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n\n    if (effect.type === \"preprocess\") {\n      const processed = effect.transform(ctx.data, checkCtx);\n\n      if (ctx.common.async) {\n        return Promise.resolve(processed).then(async (processed) => {\n          if (status.value === \"aborted\") return INVALID;\n\n          const result = await this._def.schema._parseAsync({\n            data: processed,\n            path: ctx.path,\n            parent: ctx,\n          });\n          if (result.status === \"aborted\") return INVALID;\n          if (result.status === \"dirty\") return DIRTY(result.value);\n          if (status.value === \"dirty\") return DIRTY(result.value);\n          return result;\n        });\n      } else {\n        if (status.value === \"aborted\") return INVALID;\n        const result = this._def.schema._parseSync({\n          data: processed,\n          path: ctx.path,\n          parent: ctx,\n        });\n        if (result.status === \"aborted\") return INVALID;\n        if (result.status === \"dirty\") return DIRTY(result.value);\n        if (status.value === \"dirty\") return DIRTY(result.value);\n        return result;\n      }\n    }\n    if (effect.type === \"refinement\") {\n      const executeRefinement = (acc: unknown): any => {\n        const result = effect.refinement(acc, checkCtx);\n        if (ctx.common.async) {\n          return Promise.resolve(result);\n        }\n        if (result instanceof Promise) {\n          throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        }\n        return acc;\n      };\n\n      if (ctx.common.async === false) {\n        const inner = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        });\n        if (inner.status === \"aborted\") return INVALID;\n        if (inner.status === \"dirty\") status.dirty();\n\n        // return value is ignored\n        executeRefinement(inner.value);\n        return { status: status.value, value: inner.value };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n          if (inner.status === \"aborted\") return INVALID;\n          if (inner.status === \"dirty\") status.dirty();\n\n          return executeRefinement(inner.value).then(() => {\n            return { status: status.value, value: inner.value };\n          });\n        });\n      }\n    }\n\n    if (effect.type === \"transform\") {\n      if (ctx.common.async === false) {\n        const base = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        });\n\n        if (!isValid(base)) return INVALID;\n\n        const result = effect.transform(base.value, checkCtx);\n        if (result instanceof Promise) {\n          throw new Error(\n            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`\n          );\n        }\n\n        return { status: status.value, value: result };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n          if (!isValid(base)) return INVALID;\n\n          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n            status: status.value,\n            value: result,\n          }));\n        });\n      }\n    }\n\n    util.assertNever(effect);\n  }\n\n  static create = <I extends ZodTypeAny>(\n    schema: I,\n    effect: Effect<I[\"_output\"]>,\n    params?: RawCreateParams\n  ): ZodEffects<I, I[\"_output\"]> => {\n    return new ZodEffects({\n      schema,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect,\n      ...processCreateParams(params),\n    });\n  };\n\n  static createWithPreprocess = <I extends ZodTypeAny>(\n    preprocess: (arg: unknown, ctx: RefinementCtx) => unknown,\n    schema: I,\n    params?: RawCreateParams\n  ): ZodEffects<I, I[\"_output\"], unknown> => {\n    return new ZodEffects({\n      schema,\n      effect: { type: \"preprocess\", transform: preprocess },\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      ...processCreateParams(params),\n    });\n  };\n}\n\nexport { ZodEffects as ZodTransformer };\n\n///////////////////////////////////////////\n///////////////////////////////////////////\n//////////                       //////////\n//////////      ZodOptional      //////////\n//////////                       //////////\n///////////////////////////////////////////\n///////////////////////////////////////////\nexport interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n  innerType: T;\n  typeName: ZodFirstPartyTypeKind.ZodOptional;\n}\n\nexport type ZodOptionalType<T extends ZodTypeAny> = ZodOptional<T>;\n\nexport class ZodOptional<T extends ZodTypeAny> extends ZodType<\n  T[\"_output\"] | undefined,\n  ZodOptionalDef<T>,\n  T[\"_input\"] | undefined\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.undefined) {\n      return OK(undefined);\n    }\n    return this._def.innerType._parse(input);\n  }\n\n  unwrap() {\n    return this._def.innerType;\n  }\n\n  static create = <Inner extends ZodTypeAny>(type: Inner, params?: RawCreateParams): ZodOptional<Inner> => {\n    return new ZodOptional({\n      innerType: type,\n      typeName: ZodFirstPartyTypeKind.ZodOptional,\n      ...processCreateParams(params),\n    }) as any;\n  };\n}\n\n///////////////////////////////////////////\n///////////////////////////////////////////\n//////////                       //////////\n//////////      ZodNullable      //////////\n//////////                       //////////\n///////////////////////////////////////////\n///////////////////////////////////////////\nexport interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n  innerType: T;\n  typeName: ZodFirstPartyTypeKind.ZodNullable;\n}\n\nexport type ZodNullableType<T extends ZodTypeAny> = ZodNullable<T>;\n\nexport class ZodNullable<T extends ZodTypeAny> extends ZodType<\n  T[\"_output\"] | null,\n  ZodNullableDef<T>,\n  T[\"_input\"] | null\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.null) {\n      return OK(null);\n    }\n    return this._def.innerType._parse(input);\n  }\n\n  unwrap() {\n    return this._def.innerType;\n  }\n\n  static create = <Inner extends ZodTypeAny>(type: Inner, params?: RawCreateParams): ZodNullable<Inner> => {\n    return new ZodNullable({\n      innerType: type,\n      typeName: ZodFirstPartyTypeKind.ZodNullable,\n      ...processCreateParams(params),\n    }) as any;\n  };\n}\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////       ZodDefault       //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\nexport interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n  innerType: T;\n  defaultValue: () => util.noUndefined<T[\"_input\"]>;\n  typeName: ZodFirstPartyTypeKind.ZodDefault;\n}\n\nexport class ZodDefault<T extends ZodTypeAny> extends ZodType<\n  util.noUndefined<T[\"_output\"]>,\n  ZodDefaultDef<T>,\n  T[\"_input\"] | undefined\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n    let data = ctx.data;\n    if (ctx.parsedType === ZodParsedType.undefined) {\n      data = this._def.defaultValue();\n    }\n    return this._def.innerType._parse({\n      data,\n      path: ctx.path,\n      parent: ctx,\n    });\n  }\n\n  removeDefault() {\n    return this._def.innerType;\n  }\n\n  static create = <Inner extends ZodTypeAny>(\n    type: Inner,\n    params: RawCreateParams & {\n      default: Inner[\"_input\"] | (() => util.noUndefined<Inner[\"_input\"]>);\n    }\n  ): ZodDefault<Inner> => {\n    return new ZodDefault({\n      innerType: type,\n      typeName: ZodFirstPartyTypeKind.ZodDefault,\n      defaultValue: typeof params.default === \"function\" ? params.default : () => params.default as any,\n      ...processCreateParams(params),\n    }) as any;\n  };\n}\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////       ZodCatch       //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\nexport interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n  innerType: T;\n  catchValue: (ctx: { error: ZodError; input: unknown }) => T[\"_input\"];\n  typeName: ZodFirstPartyTypeKind.ZodCatch;\n}\n\nexport class ZodCatch<T extends ZodTypeAny> extends ZodType<\n  T[\"_output\"],\n  ZodCatchDef<T>,\n  unknown // any input will pass validation // T[\"_input\"]\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n\n    // newCtx is used to not collect issues from inner types in ctx\n    const newCtx: ParseContext = {\n      ...ctx,\n      common: {\n        ...ctx.common,\n        issues: [],\n      },\n    };\n\n    const result = this._def.innerType._parse({\n      data: newCtx.data,\n      path: newCtx.path,\n      parent: {\n        ...newCtx,\n      },\n    });\n\n    if (isAsync(result)) {\n      return result.then((result) => {\n        return {\n          status: \"valid\",\n          value:\n            result.status === \"valid\"\n              ? result.value\n              : this._def.catchValue({\n                  get error() {\n                    return new ZodError(newCtx.common.issues);\n                  },\n                  input: newCtx.data,\n                }),\n        };\n      });\n    } else {\n      return {\n        status: \"valid\",\n        value:\n          result.status === \"valid\"\n            ? result.value\n            : this._def.catchValue({\n                get error() {\n                  return new ZodError(newCtx.common.issues);\n                },\n                input: newCtx.data,\n              }),\n      };\n    }\n  }\n\n  removeCatch() {\n    return this._def.innerType;\n  }\n\n  static create = <Inner extends ZodTypeAny>(\n    type: Inner,\n    params: RawCreateParams & {\n      catch: Inner[\"_output\"] | (() => Inner[\"_output\"]);\n    }\n  ): ZodCatch<Inner> => {\n    return new ZodCatch({\n      innerType: type,\n      typeName: ZodFirstPartyTypeKind.ZodCatch,\n      catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n//////////                     //////////\n//////////      ZodNaN         //////////\n//////////                     //////////\n/////////////////////////////////////////\n/////////////////////////////////////////\n\nexport interface ZodNaNDef extends ZodTypeDef {\n  typeName: ZodFirstPartyTypeKind.ZodNaN;\n}\n\nexport class ZodNaN extends ZodType<number, ZodNaNDef, number> {\n  _parse(input: ParseInput): ParseReturnType<any> {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.nan) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.nan,\n        received: ctx.parsedType,\n      });\n      return INVALID;\n    }\n\n    return { status: \"valid\", value: input.data };\n  }\n\n  static create = (params?: RawCreateParams): ZodNaN => {\n    return new ZodNaN({\n      typeName: ZodFirstPartyTypeKind.ZodNaN,\n      ...processCreateParams(params),\n    });\n  };\n}\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      ZodBranded      //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n\nexport interface ZodBrandedDef<T extends ZodTypeAny> extends ZodTypeDef {\n  type: T;\n  typeName: ZodFirstPartyTypeKind.ZodBranded;\n}\n\nexport const BRAND: unique symbol = Symbol(\"zod_brand\");\nexport type BRAND<T extends string | number | symbol> = {\n  [BRAND]: { [k in T]: true };\n};\n\nexport class ZodBranded<T extends ZodTypeAny, B extends string | number | symbol> extends ZodType<\n  T[\"_output\"] & BRAND<B>,\n  ZodBrandedDef<T>,\n  T[\"_input\"]\n> {\n  _parse(input: ParseInput): ParseReturnType<any> {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx,\n    });\n  }\n\n  unwrap() {\n    return this._def.type;\n  }\n}\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////      ZodPipeline       //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\n\nexport interface ZodPipelineDef<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodTypeDef {\n  in: A;\n  out: B;\n  typeName: ZodFirstPartyTypeKind.ZodPipeline;\n}\n\nexport class ZodPipeline<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodType<\n  B[\"_output\"],\n  ZodPipelineDef<A, B>,\n  A[\"_input\"]\n> {\n  _parse(input: ParseInput): ParseReturnType<any> {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.common.async) {\n      const handleAsync = async () => {\n        const inResult = await this._def.in._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx,\n        });\n        if (inResult.status === \"aborted\") return INVALID;\n        if (inResult.status === \"dirty\") {\n          status.dirty();\n          return DIRTY(inResult.value);\n        } else {\n          return this._def.out._parseAsync({\n            data: inResult.value,\n            path: ctx.path,\n            parent: ctx,\n          });\n        }\n      };\n      return handleAsync();\n    } else {\n      const inResult = this._def.in._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx,\n      });\n      if (inResult.status === \"aborted\") return INVALID;\n      if (inResult.status === \"dirty\") {\n        status.dirty();\n        return {\n          status: \"dirty\",\n          value: inResult.value,\n        };\n      } else {\n        return this._def.out._parseSync({\n          data: inResult.value,\n          path: ctx.path,\n          parent: ctx,\n        });\n      }\n    }\n  }\n\n  static create<ASchema extends ZodTypeAny, BSchema extends ZodTypeAny>(\n    a: ASchema,\n    b: BSchema\n  ): ZodPipeline<ASchema, BSchema> {\n    return new ZodPipeline({\n      in: a,\n      out: b,\n      typeName: ZodFirstPartyTypeKind.ZodPipeline,\n    });\n  }\n}\n\n///////////////////////////////////////////\n///////////////////////////////////////////\n//////////                       //////////\n//////////      ZodReadonly      //////////\n//////////                       //////////\n///////////////////////////////////////////\n///////////////////////////////////////////\ntype BuiltIn =\n  | (((...args: any[]) => any) | (new (...args: any[]) => any))\n  | { readonly [Symbol.toStringTag]: string }\n  | Date\n  | Error\n  | Generator\n  | Promise<unknown>\n  | RegExp;\n\ntype MakeReadonly<T> = T extends Map<infer K, infer V>\n  ? ReadonlyMap<K, V>\n  : T extends Set<infer V>\n    ? ReadonlySet<V>\n    : T extends [infer Head, ...infer Tail]\n      ? readonly [Head, ...Tail]\n      : T extends Array<infer V>\n        ? ReadonlyArray<V>\n        : T extends BuiltIn\n          ? T\n          : Readonly<T>;\n\nexport interface ZodReadonlyDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n  innerType: T;\n  typeName: ZodFirstPartyTypeKind.ZodReadonly;\n}\n\nexport class ZodReadonly<T extends ZodTypeAny> extends ZodType<\n  MakeReadonly<T[\"_output\"]>,\n  ZodReadonlyDef<T>,\n  MakeReadonly<T[\"_input\"]>\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const result = this._def.innerType._parse(input);\n    const freeze = (data: ParseReturnType<this[\"_output\"]>) => {\n      if (isValid(data)) {\n        data.value = Object.freeze(data.value);\n      }\n      return data;\n    };\n    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n  }\n\n  static create = <Inner extends ZodTypeAny>(type: Inner, params?: RawCreateParams): ZodReadonly<Inner> => {\n    return new ZodReadonly({\n      innerType: type,\n      typeName: ZodFirstPartyTypeKind.ZodReadonly,\n      ...processCreateParams(params),\n    }) as any;\n  };\n\n  unwrap() {\n    return this._def.innerType;\n  }\n}\n\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params: unknown, data: unknown) {\n  const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n\n  const p2 = typeof p === \"string\" ? { message: p } : p;\n  return p2;\n}\ntype CustomParams = CustomErrorParams & { fatal?: boolean };\nexport function custom<T>(\n  check?: (data: any) => any,\n  _params: string | CustomParams | ((input: any) => CustomParams) = {},\n  /**\n   * @deprecated\n   *\n   * Pass `fatal` into the params object instead:\n   *\n   * ```ts\n   * z.string().custom((val) => val.length > 5, { fatal: false })\n   * ```\n   *\n   */\n  fatal?: boolean\n): ZodType<T, ZodTypeDef, T> {\n  if (check)\n    return ZodAny.create().superRefine((data, ctx) => {\n      const r = check(data);\n      if (r instanceof Promise) {\n        return r.then((r) => {\n          if (!r) {\n            const params = cleanParams(_params, data);\n            const _fatal = params.fatal ?? fatal ?? true;\n            ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n          }\n        });\n      }\n      if (!r) {\n        const params = cleanParams(_params, data);\n        const _fatal = params.fatal ?? fatal ?? true;\n        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n      }\n      return;\n    });\n  return ZodAny.create();\n}\n\nexport { ZodType as Schema, ZodType as ZodSchema };\n\nexport const late = {\n  object: ZodObject.lazycreate,\n};\n\nexport enum ZodFirstPartyTypeKind {\n  ZodString = \"ZodString\",\n  ZodNumber = \"ZodNumber\",\n  ZodNaN = \"ZodNaN\",\n  ZodBigInt = \"ZodBigInt\",\n  ZodBoolean = \"ZodBoolean\",\n  ZodDate = \"ZodDate\",\n  ZodSymbol = \"ZodSymbol\",\n  ZodUndefined = \"ZodUndefined\",\n  ZodNull = \"ZodNull\",\n  ZodAny = \"ZodAny\",\n  ZodUnknown = \"ZodUnknown\",\n  ZodNever = \"ZodNever\",\n  ZodVoid = \"ZodVoid\",\n  ZodArray = \"ZodArray\",\n  ZodObject = \"ZodObject\",\n  ZodUnion = \"ZodUnion\",\n  ZodDiscriminatedUnion = \"ZodDiscriminatedUnion\",\n  ZodIntersection = \"ZodIntersection\",\n  ZodTuple = \"ZodTuple\",\n  ZodRecord = \"ZodRecord\",\n  ZodMap = \"ZodMap\",\n  ZodSet = \"ZodSet\",\n  ZodFunction = \"ZodFunction\",\n  ZodLazy = \"ZodLazy\",\n  ZodLiteral = \"ZodLiteral\",\n  ZodEnum = \"ZodEnum\",\n  ZodEffects = \"ZodEffects\",\n  ZodNativeEnum = \"ZodNativeEnum\",\n  ZodOptional = \"ZodOptional\",\n  ZodNullable = \"ZodNullable\",\n  ZodDefault = \"ZodDefault\",\n  ZodCatch = \"ZodCatch\",\n  ZodPromise = \"ZodPromise\",\n  ZodBranded = \"ZodBranded\",\n  ZodPipeline = \"ZodPipeline\",\n  ZodReadonly = \"ZodReadonly\",\n}\nexport type ZodFirstPartySchemaTypes =\n  | ZodString\n  | ZodNumber\n  | ZodNaN\n  | ZodBigInt\n  | ZodBoolean\n  | ZodDate\n  | ZodUndefined\n  | ZodNull\n  | ZodAny\n  | ZodUnknown\n  | ZodNever\n  | ZodVoid\n  | ZodArray<any, any>\n  | ZodObject<any, any, any>\n  | ZodUnion<any>\n  | ZodDiscriminatedUnion<any, any>\n  | ZodIntersection<any, any>\n  | ZodTuple<any, any>\n  | ZodRecord<any, any>\n  | ZodMap<any>\n  | ZodSet<any>\n  | ZodFunction<any, any>\n  | ZodLazy<any>\n  | ZodLiteral<any>\n  | ZodEnum<any>\n  | ZodEffects<any, any, any>\n  | ZodNativeEnum<any>\n  | ZodOptional<any>\n  | ZodNullable<any>\n  | ZodDefault<any>\n  | ZodCatch<any>\n  | ZodPromise<any>\n  | ZodBranded<any, any>\n  | ZodPipeline<any, any>\n  | ZodReadonly<any>\n  | ZodSymbol;\n\n// requires TS 4.4+\nabstract class Class {\n  constructor(..._: any[]) {}\n}\nconst instanceOfType = <T extends typeof Class>(\n  // const instanceOfType = <T extends new (...args: any[]) => any>(\n  cls: T,\n  params: CustomParams = {\n    message: `Input not instance of ${cls.name}`,\n  }\n) => custom<InstanceType<T>>((data) => data instanceof cls, params);\n\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\n\nexport const coerce = {\n  string: ((arg) => ZodString.create({ ...arg, coerce: true })) as (typeof ZodString)[\"create\"],\n  number: ((arg) => ZodNumber.create({ ...arg, coerce: true })) as (typeof ZodNumber)[\"create\"],\n  boolean: ((arg) =>\n    ZodBoolean.create({\n      ...arg,\n      coerce: true,\n    })) as (typeof ZodBoolean)[\"create\"],\n  bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })) as (typeof ZodBigInt)[\"create\"],\n  date: ((arg) => ZodDate.create({ ...arg, coerce: true })) as (typeof ZodDate)[\"create\"],\n};\n\nexport {\n  anyType as any,\n  arrayType as array,\n  bigIntType as bigint,\n  booleanType as boolean,\n  dateType as date,\n  discriminatedUnionType as discriminatedUnion,\n  effectsType as effect,\n  enumType as enum,\n  functionType as function,\n  instanceOfType as instanceof,\n  intersectionType as intersection,\n  lazyType as lazy,\n  literalType as literal,\n  mapType as map,\n  nanType as nan,\n  nativeEnumType as nativeEnum,\n  neverType as never,\n  nullType as null,\n  nullableType as nullable,\n  numberType as number,\n  objectType as object,\n  oboolean,\n  onumber,\n  optionalType as optional,\n  ostring,\n  pipelineType as pipeline,\n  preprocessType as preprocess,\n  promiseType as promise,\n  recordType as record,\n  setType as set,\n  strictObjectType as strictObject,\n  stringType as string,\n  symbolType as symbol,\n  effectsType as transformer,\n  tupleType as tuple,\n  undefinedType as undefined,\n  unionType as union,\n  unknownType as unknown,\n  voidType as void,\n};\n\nexport const NEVER = INVALID as never;\n",
    "symbols": [
      {
        "name": "ParseInputLazyPath",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 62,
        "endLine": 85
      },
      {
        "name": "processCreateParams",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 123,
        "endLine": 143
      },
      {
        "name": "ZodType",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 158,
        "endLine": 535
      },
      {
        "name": "ZodType._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 170,
        "endLine": 170
      },
      {
        "name": "ZodType._getType",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 172,
        "endLine": 174
      },
      {
        "name": "ZodType._getOrReturnCtx",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 176,
        "endLine": 189
      },
      {
        "name": "ZodType._processInputParams",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 191,
        "endLine": 208
      },
      {
        "name": "ZodType._parseSync",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 210,
        "endLine": 216
      },
      {
        "name": "ZodType._parseAsync",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 218,
        "endLine": 221
      },
      {
        "name": "ZodType.parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 223,
        "endLine": 227
      },
      {
        "name": "ZodType.safeParse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 229,
        "endLine": 245
      },
      {
        "name": "ZodType.\"~validate\"",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 247,
        "endLine": 290
      },
      {
        "name": "ZodType.parseAsync",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 292,
        "endLine": 296
      },
      {
        "name": "ZodType.safeParseAsync",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 298,
        "endLine": 318
      },
      {
        "name": "ZodType.refine",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 331,
        "endLine": 368
      },
      {
        "name": "ZodType.refinement",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 378,
        "endLine": 390
      },
      {
        "name": "ZodType._refinement",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 392,
        "endLine": 398
      },
      {
        "name": "ZodType.superRefine",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 405,
        "endLine": 409
      },
      {
        "name": "ZodType.optional",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 444,
        "endLine": 446
      },
      {
        "name": "ZodType.nullable",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 447,
        "endLine": 449
      },
      {
        "name": "ZodType.nullish",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 450,
        "endLine": 452
      },
      {
        "name": "ZodType.array",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 453,
        "endLine": 455
      },
      {
        "name": "ZodType.promise",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 456,
        "endLine": 458
      },
      {
        "name": "ZodType.or",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 460,
        "endLine": 462
      },
      {
        "name": "ZodType.and",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 464,
        "endLine": 466
      },
      {
        "name": "ZodType.transform",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 468,
        "endLine": 477
      },
      {
        "name": "ZodType.default",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 481,
        "endLine": 490
      },
      {
        "name": "ZodType.brand",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 493,
        "endLine": 499
      },
      {
        "name": "ZodType.catch",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 503,
        "endLine": 512
      },
      {
        "name": "ZodType.describe",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 514,
        "endLine": 520
      },
      {
        "name": "ZodType.pipe",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 522,
        "endLine": 524
      },
      {
        "name": "ZodType.readonly",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 525,
        "endLine": 527
      },
      {
        "name": "ZodType.isOptional",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 529,
        "endLine": 531
      },
      {
        "name": "ZodType.isNullable",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 532,
        "endLine": 534
      },
      {
        "name": "timeRegexSource",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 652,
        "endLine": 662
      },
      {
        "name": "timeRegex",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 664,
        "endLine": 670
      },
      {
        "name": "datetimeRegex",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 673,
        "endLine": 685
      },
      {
        "name": "isValidIP",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 687,
        "endLine": 696
      },
      {
        "name": "isValidJWT",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 698,
        "endLine": 717
      },
      {
        "name": "isValidCidr",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 719,
        "endLine": 728
      },
      {
        "name": "ZodString",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 730,
        "endLine": 1335
      },
      {
        "name": "ZodString._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 731,
        "endLine": 1038
      },
      {
        "name": "ZodString._regex",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1040,
        "endLine": 1046
      },
      {
        "name": "ZodString._addCheck",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1048,
        "endLine": 1053
      },
      {
        "name": "ZodString.email",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1055,
        "endLine": 1057
      },
      {
        "name": "ZodString.url",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1059,
        "endLine": 1061
      },
      {
        "name": "ZodString.emoji",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1063,
        "endLine": 1065
      },
      {
        "name": "ZodString.uuid",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1067,
        "endLine": 1069
      },
      {
        "name": "ZodString.nanoid",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1070,
        "endLine": 1072
      },
      {
        "name": "ZodString.cuid",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1073,
        "endLine": 1075
      },
      {
        "name": "ZodString.cuid2",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1077,
        "endLine": 1079
      },
      {
        "name": "ZodString.ulid",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1080,
        "endLine": 1082
      },
      {
        "name": "ZodString.base64",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1083,
        "endLine": 1085
      },
      {
        "name": "ZodString.base64url",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1086,
        "endLine": 1092
      },
      {
        "name": "ZodString.jwt",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1094,
        "endLine": 1096
      },
      {
        "name": "ZodString.ip",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1098,
        "endLine": 1100
      },
      {
        "name": "ZodString.cidr",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1102,
        "endLine": 1104
      },
      {
        "name": "ZodString.datetime",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1106,
        "endLine": 1133
      },
      {
        "name": "ZodString.date",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1135,
        "endLine": 1137
      },
      {
        "name": "ZodString.time",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1139,
        "endLine": 1159
      },
      {
        "name": "ZodString.duration",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1161,
        "endLine": 1163
      },
      {
        "name": "ZodString.regex",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1165,
        "endLine": 1171
      },
      {
        "name": "ZodString.includes",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1173,
        "endLine": 1180
      },
      {
        "name": "ZodString.startsWith",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1182,
        "endLine": 1188
      },
      {
        "name": "ZodString.endsWith",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1190,
        "endLine": 1196
      },
      {
        "name": "ZodString.min",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1198,
        "endLine": 1204
      },
      {
        "name": "ZodString.max",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1206,
        "endLine": 1212
      },
      {
        "name": "ZodString.length",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1214,
        "endLine": 1220
      },
      {
        "name": "ZodString.nonempty",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1225,
        "endLine": 1227
      },
      {
        "name": "ZodString.trim",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1229,
        "endLine": 1234
      },
      {
        "name": "ZodString.toLowerCase",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1236,
        "endLine": 1241
      },
      {
        "name": "ZodString.toUpperCase",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1243,
        "endLine": 1248
      },
      {
        "name": "floatSafeRemainder",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1352,
        "endLine": 1359
      },
      {
        "name": "ZodNumber",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1367,
        "endLine": 1613
      },
      {
        "name": "ZodNumber._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1368,
        "endLine": 1451
      },
      {
        "name": "ZodNumber.gte",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1462,
        "endLine": 1464
      },
      {
        "name": "ZodNumber.gt",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1467,
        "endLine": 1469
      },
      {
        "name": "ZodNumber.lte",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1471,
        "endLine": 1473
      },
      {
        "name": "ZodNumber.lt",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1476,
        "endLine": 1478
      },
      {
        "name": "ZodNumber.setLimit",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1480,
        "endLine": 1493
      },
      {
        "name": "ZodNumber._addCheck",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1495,
        "endLine": 1500
      },
      {
        "name": "ZodNumber.int",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1502,
        "endLine": 1507
      },
      {
        "name": "ZodNumber.positive",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1509,
        "endLine": 1516
      },
      {
        "name": "ZodNumber.negative",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1518,
        "endLine": 1525
      },
      {
        "name": "ZodNumber.nonpositive",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1527,
        "endLine": 1534
      },
      {
        "name": "ZodNumber.nonnegative",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1536,
        "endLine": 1543
      },
      {
        "name": "ZodNumber.multipleOf",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1545,
        "endLine": 1551
      },
      {
        "name": "ZodNumber.finite",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1554,
        "endLine": 1559
      },
      {
        "name": "ZodNumber.safe",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1561,
        "endLine": 1573
      },
      {
        "name": "ZodBigInt",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1633,
        "endLine": 1817
      },
      {
        "name": "ZodBigInt._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1634,
        "endLine": 1693
      },
      {
        "name": "ZodBigInt._getInvalidInput",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1695,
        "endLine": 1703
      },
      {
        "name": "ZodBigInt.gte",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1714,
        "endLine": 1716
      },
      {
        "name": "ZodBigInt.gt",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1719,
        "endLine": 1721
      },
      {
        "name": "ZodBigInt.lte",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1723,
        "endLine": 1725
      },
      {
        "name": "ZodBigInt.lt",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1728,
        "endLine": 1730
      },
      {
        "name": "ZodBigInt.setLimit",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1732,
        "endLine": 1745
      },
      {
        "name": "ZodBigInt._addCheck",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1747,
        "endLine": 1752
      },
      {
        "name": "ZodBigInt.positive",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1754,
        "endLine": 1761
      },
      {
        "name": "ZodBigInt.negative",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1763,
        "endLine": 1770
      },
      {
        "name": "ZodBigInt.nonpositive",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1772,
        "endLine": 1779
      },
      {
        "name": "ZodBigInt.nonnegative",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1781,
        "endLine": 1788
      },
      {
        "name": "ZodBigInt.multipleOf",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1790,
        "endLine": 1796
      },
      {
        "name": "ZodBoolean",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1831,
        "endLine": 1857
      },
      {
        "name": "ZodBoolean._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1832,
        "endLine": 1848
      },
      {
        "name": "ZodDate",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1875,
        "endLine": 1994
      },
      {
        "name": "ZodDate._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1876,
        "endLine": 1939
      },
      {
        "name": "ZodDate._addCheck",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1941,
        "endLine": 1946
      },
      {
        "name": "ZodDate.min",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1948,
        "endLine": 1954
      },
      {
        "name": "ZodDate.max",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 1956,
        "endLine": 1962
      },
      {
        "name": "ZodSymbol",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2007,
        "endLine": 2029
      },
      {
        "name": "ZodSymbol._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2008,
        "endLine": 2021
      },
      {
        "name": "ZodUndefined",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2042,
        "endLine": 2064
      },
      {
        "name": "ZodUndefined._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2043,
        "endLine": 2055
      },
      {
        "name": "ZodNull",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2077,
        "endLine": 2097
      },
      {
        "name": "ZodNull._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2078,
        "endLine": 2090
      },
      {
        "name": "ZodAny",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2110,
        "endLine": 2122
      },
      {
        "name": "ZodAny._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2113,
        "endLine": 2115
      },
      {
        "name": "ZodUnknown",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2135,
        "endLine": 2148
      },
      {
        "name": "ZodUnknown._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2138,
        "endLine": 2140
      },
      {
        "name": "ZodNever",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2161,
        "endLine": 2177
      },
      {
        "name": "ZodNever._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2162,
        "endLine": 2170
      },
      {
        "name": "ZodVoid",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2190,
        "endLine": 2211
      },
      {
        "name": "ZodVoid._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2191,
        "endLine": 2203
      },
      {
        "name": "ZodArray",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2234,
        "endLine": 2354
      },
      {
        "name": "ZodArray._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2239,
        "endLine": 2313
      },
      {
        "name": "ZodArray.min",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2319,
        "endLine": 2324
      },
      {
        "name": "ZodArray.max",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2326,
        "endLine": 2331
      },
      {
        "name": "ZodArray.length",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2333,
        "endLine": 2338
      },
      {
        "name": "ZodArray.nonempty",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2340,
        "endLine": 2342
      },
      {
        "name": "deepPartialify",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2422,
        "endLine": 2448
      },
      {
        "name": "ZodObject",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2450,
        "endLine": 2922
      },
      {
        "name": "ZodObject._getCached",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2459,
        "endLine": 2465
      },
      {
        "name": "ZodObject._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2467,
        "endLine": 2566
      },
      {
        "name": "ZodObject.strict",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2572,
        "endLine": 2592
      },
      {
        "name": "ZodObject.strip",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2594,
        "endLine": 2599
      },
      {
        "name": "ZodObject.passthrough",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2601,
        "endLine": 2606
      },
      {
        "name": "ZodObject.extend",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2631,
        "endLine": 2641
      },
      {
        "name": "ZodObject.merge",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2685,
        "endLine": 2698
      },
      {
        "name": "ZodObject.setKey",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2735,
        "endLine": 2740
      },
      {
        "name": "ZodObject.catchall",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2763,
        "endLine": 2768
      },
      {
        "name": "ZodObject.pick",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2770,
        "endLine": 2785
      },
      {
        "name": "ZodObject.omit",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2787,
        "endLine": 2802
      },
      {
        "name": "ZodObject.deepPartial",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2807,
        "endLine": 2809
      },
      {
        "name": "ZodObject.partial",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2821,
        "endLine": 2838
      },
      {
        "name": "ZodObject.required",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2850,
        "endLine": 2872
      },
      {
        "name": "ZodObject.keyof",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2874,
        "endLine": 2876
      },
      {
        "name": "ZodUnion",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2940,
        "endLine": 3055
      },
      {
        "name": "ZodUnion._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2945,
        "endLine": 3039
      },
      {
        "name": "handleResults",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 2949,
        "endLine": 2974
      },
      {
        "name": "ZodDiscriminatedUnion",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3114,
        "endLine": 3223
      },
      {
        "name": "ZodDiscriminatedUnion._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3118,
        "endLine": 3158
      },
      {
        "name": "ZodDiscriminatedUnion.create",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3180,
        "endLine": 3222
      },
      {
        "name": "mergeValues",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3239,
        "endLine": 3283
      },
      {
        "name": "ZodIntersection",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3285,
        "endLine": 3357
      },
      {
        "name": "ZodIntersection._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3290,
        "endLine": 3343
      },
      {
        "name": "ZodTuple",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3393,
        "endLine": 3475
      },
      {
        "name": "ZodTuple._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3397,
        "endLine": 3448
      },
      {
        "name": "ZodTuple.rest",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3454,
        "endLine": 3459
      },
      {
        "name": "ZodRecord",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3501,
        "endLine": 3574
      },
      {
        "name": "ZodRecord._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3512,
        "endLine": 3545
      },
      {
        "name": "ZodRecord.create",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3557,
        "endLine": 3573
      },
      {
        "name": "ZodMap",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3590,
        "endLine": 3668
      },
      {
        "name": "ZodMap._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3601,
        "endLine": 3655
      },
      {
        "name": "ZodSet",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3684,
        "endLine": 3787
      },
      {
        "name": "ZodSet._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3689,
        "endLine": 3751
      },
      {
        "name": "ZodSet.min",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3753,
        "endLine": 3758
      },
      {
        "name": "ZodSet.max",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3760,
        "endLine": 3765
      },
      {
        "name": "ZodSet.size",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3767,
        "endLine": 3769
      },
      {
        "name": "ZodSet.nonempty",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3771,
        "endLine": 3773
      },
      {
        "name": "finalizeSet",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3732,
        "endLine": 3740
      },
      {
        "name": "ZodFunction",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3815,
        "endLine": 3958
      },
      {
        "name": "ZodFunction._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3820,
        "endLine": 3900
      },
      {
        "name": "ZodFunction.parameters",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3902,
        "endLine": 3904
      },
      {
        "name": "ZodFunction.returnType",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3906,
        "endLine": 3908
      },
      {
        "name": "ZodFunction.args",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3910,
        "endLine": 3917
      },
      {
        "name": "ZodFunction.returns",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3919,
        "endLine": 3924
      },
      {
        "name": "ZodFunction.implement",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3926,
        "endLine": 3933
      },
      {
        "name": "ZodFunction.strictImplement",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3935,
        "endLine": 3938
      },
      {
        "name": "ZodFunction.create",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3950,
        "endLine": 3957
      },
      {
        "name": "makeArgsIssue",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3831,
        "endLine": 3843
      },
      {
        "name": "makeReturnsIssue",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3845,
        "endLine": 3857
      },
      {
        "name": "ZodLazy",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3972,
        "endLine": 3990
      },
      {
        "name": "ZodLazy._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 3977,
        "endLine": 3981
      },
      {
        "name": "ZodLiteral",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4004,
        "endLine": 4029
      },
      {
        "name": "ZodLiteral._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4005,
        "endLine": 4016
      },
      {
        "name": "createZodEnum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4064,
        "endLine": 4067
      },
      {
        "name": "createZodEnum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4068,
        "endLine": 4068
      },
      {
        "name": "createZodEnum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4069,
        "endLine": 4075
      },
      {
        "name": "ZodEnum",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4077,
        "endLine": 4159
      },
      {
        "name": "ZodEnum._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4080,
        "endLine": 4108
      },
      {
        "name": "ZodEnum.extract",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4138,
        "endLine": 4146
      },
      {
        "name": "ZodEnum.exclude",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4148,
        "endLine": 4156
      },
      {
        "name": "ZodNativeEnum",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4175,
        "endLine": 4219
      },
      {
        "name": "ZodNativeEnum._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4177,
        "endLine": 4206
      },
      {
        "name": "ZodPromise",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4233,
        "endLine": 4272
      },
      {
        "name": "ZodPromise.unwrap",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4238,
        "endLine": 4240
      },
      {
        "name": "ZodPromise._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4242,
        "endLine": 4263
      },
      {
        "name": "ZodEffects",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4305,
        "endLine": 4465
      },
      {
        "name": "ZodEffects.innerType",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4310,
        "endLine": 4312
      },
      {
        "name": "ZodEffects.sourceType",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4314,
        "endLine": 4318
      },
      {
        "name": "ZodEffects._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4320,
        "endLine": 4438
      },
      {
        "name": "ZodOptional",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4483,
        "endLine": 4507
      },
      {
        "name": "ZodOptional._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4488,
        "endLine": 4494
      },
      {
        "name": "ZodOptional.unwrap",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4496,
        "endLine": 4498
      },
      {
        "name": "ZodNullable",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4523,
        "endLine": 4547
      },
      {
        "name": "ZodNullable._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4528,
        "endLine": 4534
      },
      {
        "name": "ZodNullable.unwrap",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4536,
        "endLine": 4538
      },
      {
        "name": "ZodDefault",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4562,
        "endLine": 4597
      },
      {
        "name": "ZodDefault._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4567,
        "endLine": 4578
      },
      {
        "name": "ZodDefault.removeDefault",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4580,
        "endLine": 4582
      },
      {
        "name": "ZodCatch",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4612,
        "endLine": 4685
      },
      {
        "name": "ZodCatch._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4617,
        "endLine": 4666
      },
      {
        "name": "ZodCatch.removeCatch",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4668,
        "endLine": 4670
      },
      {
        "name": "ZodNaN",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4699,
        "endLine": 4721
      },
      {
        "name": "ZodNaN._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4700,
        "endLine": 4713
      },
      {
        "name": "ZodBranded",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4741,
        "endLine": 4759
      },
      {
        "name": "ZodBranded._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4746,
        "endLine": 4754
      },
      {
        "name": "ZodBranded.unwrap",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4756,
        "endLine": 4758
      },
      {
        "name": "ZodPipeline",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4775,
        "endLine": 4835
      },
      {
        "name": "ZodPipeline._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4780,
        "endLine": 4823
      },
      {
        "name": "ZodPipeline.create",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4825,
        "endLine": 4834
      },
      {
        "name": "ZodReadonly",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4870,
        "endLine": 4897
      },
      {
        "name": "ZodReadonly._parse",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4875,
        "endLine": 4884
      },
      {
        "name": "ZodReadonly.unwrap",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4894,
        "endLine": 4896
      },
      {
        "name": "cleanParams",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4906,
        "endLine": 4911
      },
      {
        "name": "custom",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 4913,
        "endLine": 4948
      },
      {
        "name": "Class",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/types.ts",
        "startLine": 5033,
        "endLine": 5035
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/ZodError.ts",
    "content": "import type { Primitive } from \"./helpers/typeAliases.js\";\nimport { util, type ZodParsedType } from \"./helpers/util.js\";\nimport type { TypeOf, ZodType } from \"./index.js\";\n\ntype allKeys<T> = T extends any ? keyof T : never;\n\nexport type inferFlattenedErrors<T extends ZodType<any, any, any>, U = string> = typeToFlattenedError<TypeOf<T>, U>;\nexport type typeToFlattenedError<T, U = string> = {\n  formErrors: U[];\n  fieldErrors: {\n    [P in allKeys<T>]?: U[];\n  };\n};\n\nexport const ZodIssueCode = util.arrayToEnum([\n  \"invalid_type\",\n  \"invalid_literal\",\n  \"custom\",\n  \"invalid_union\",\n  \"invalid_union_discriminator\",\n  \"invalid_enum_value\",\n  \"unrecognized_keys\",\n  \"invalid_arguments\",\n  \"invalid_return_type\",\n  \"invalid_date\",\n  \"invalid_string\",\n  \"too_small\",\n  \"too_big\",\n  \"invalid_intersection_types\",\n  \"not_multiple_of\",\n  \"not_finite\",\n]);\n\nexport type ZodIssueCode = keyof typeof ZodIssueCode;\n\nexport type ZodIssueBase = {\n  path: (string | number)[];\n  message?: string | undefined;\n};\n\nexport interface ZodInvalidTypeIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_type;\n  expected: ZodParsedType;\n  received: ZodParsedType;\n}\n\nexport interface ZodInvalidLiteralIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_literal;\n  expected: unknown;\n  received: unknown;\n}\n\nexport interface ZodUnrecognizedKeysIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.unrecognized_keys;\n  keys: string[];\n}\n\nexport interface ZodInvalidUnionIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_union;\n  unionErrors: ZodError[];\n}\n\nexport interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_union_discriminator;\n  options: Primitive[];\n}\n\nexport interface ZodInvalidEnumValueIssue extends ZodIssueBase {\n  received: string | number;\n  code: typeof ZodIssueCode.invalid_enum_value;\n  options: (string | number)[];\n}\n\nexport interface ZodInvalidArgumentsIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_arguments;\n  argumentsError: ZodError;\n}\n\nexport interface ZodInvalidReturnTypeIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_return_type;\n  returnTypeError: ZodError;\n}\n\nexport interface ZodInvalidDateIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_date;\n}\n\nexport type StringValidation =\n  | \"email\"\n  | \"url\"\n  | \"emoji\"\n  | \"uuid\"\n  | \"nanoid\"\n  | \"regex\"\n  | \"cuid\"\n  | \"cuid2\"\n  | \"ulid\"\n  | \"datetime\"\n  | \"date\"\n  | \"time\"\n  | \"duration\"\n  | \"ip\"\n  | \"cidr\"\n  | \"base64\"\n  | \"jwt\"\n  | \"base64url\"\n  | { includes: string; position?: number | undefined }\n  | { startsWith: string }\n  | { endsWith: string };\n\nexport interface ZodInvalidStringIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_string;\n  validation: StringValidation;\n}\n\nexport interface ZodTooSmallIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.too_small;\n  minimum: number | bigint;\n  inclusive: boolean;\n  exact?: boolean;\n  type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\" | \"bigint\";\n}\n\nexport interface ZodTooBigIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.too_big;\n  maximum: number | bigint;\n  inclusive: boolean;\n  exact?: boolean;\n  type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\" | \"bigint\";\n}\n\nexport interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.invalid_intersection_types;\n}\n\nexport interface ZodNotMultipleOfIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.not_multiple_of;\n  multipleOf: number | bigint;\n}\n\nexport interface ZodNotFiniteIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.not_finite;\n}\n\nexport interface ZodCustomIssue extends ZodIssueBase {\n  code: typeof ZodIssueCode.custom;\n  params?: { [k: string]: any };\n}\n\nexport type DenormalizedError = { [k: string]: DenormalizedError | string[] };\n\nexport type ZodIssueOptionalMessage =\n  | ZodInvalidTypeIssue\n  | ZodInvalidLiteralIssue\n  | ZodUnrecognizedKeysIssue\n  | ZodInvalidUnionIssue\n  | ZodInvalidUnionDiscriminatorIssue\n  | ZodInvalidEnumValueIssue\n  | ZodInvalidArgumentsIssue\n  | ZodInvalidReturnTypeIssue\n  | ZodInvalidDateIssue\n  | ZodInvalidStringIssue\n  | ZodTooSmallIssue\n  | ZodTooBigIssue\n  | ZodInvalidIntersectionTypesIssue\n  | ZodNotMultipleOfIssue\n  | ZodNotFiniteIssue\n  | ZodCustomIssue;\n\nexport type ZodIssue = ZodIssueOptionalMessage & {\n  fatal?: boolean | undefined;\n  message: string;\n};\n\nexport const quotelessJson = (obj: any) => {\n  const json = JSON.stringify(obj, null, 2);\n  return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\n\ntype recursiveZodFormattedError<T> = T extends [any, ...any[]]\n  ? { [K in keyof T]?: ZodFormattedError<T[K]> }\n  : T extends any[]\n    ? { [k: number]: ZodFormattedError<T[number]> }\n    : T extends object\n      ? { [K in keyof T]?: ZodFormattedError<T[K]> }\n      : unknown;\n\nexport type ZodFormattedError<T, U = string> = {\n  _errors: U[];\n} & recursiveZodFormattedError<NonNullable<T>>;\n\nexport type inferFormattedError<T extends ZodType<any, any, any>, U = string> = ZodFormattedError<TypeOf<T>, U>;\n\nexport class ZodError<T = any> extends Error {\n  issues: ZodIssue[] = [];\n\n  get errors() {\n    return this.issues;\n  }\n\n  constructor(issues: ZodIssue[]) {\n    super();\n\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      // eslint-disable-next-line ban/ban\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      (this as any).__proto__ = actualProto;\n    }\n    this.name = \"ZodError\";\n    this.issues = issues;\n  }\n\n  format(): ZodFormattedError<T>;\n  format<U>(mapper: (issue: ZodIssue) => U): ZodFormattedError<T, U>;\n  format(_mapper?: any) {\n    const mapper: (issue: ZodIssue) => any =\n      _mapper ||\n      function (issue: ZodIssue) {\n        return issue.message;\n      };\n    const fieldErrors: ZodFormattedError<T> = { _errors: [] } as any;\n    const processError = (error: ZodError) => {\n      for (const issue of error.issues) {\n        if (issue.code === \"invalid_union\") {\n          issue.unionErrors.map(processError);\n        } else if (issue.code === \"invalid_return_type\") {\n          processError(issue.returnTypeError);\n        } else if (issue.code === \"invalid_arguments\") {\n          processError(issue.argumentsError);\n        } else if (issue.path.length === 0) {\n          (fieldErrors as any)._errors.push(mapper(issue));\n        } else {\n          let curr: any = fieldErrors;\n          let i = 0;\n          while (i < issue.path.length) {\n            const el = issue.path[i]!;\n            const terminal = i === issue.path.length - 1;\n\n            if (!terminal) {\n              curr[el] = curr[el] || { _errors: [] };\n              // if (typeof el === \"string\") {\n              //   curr[el] = curr[el] || { _errors: [] };\n              // } else if (typeof el === \"number\") {\n              //   const errorArray: any = [];\n              //   errorArray._errors = [];\n              //   curr[el] = curr[el] || errorArray;\n              // }\n            } else {\n              curr[el] = curr[el] || { _errors: [] };\n              curr[el]._errors.push(mapper(issue));\n            }\n\n            curr = curr[el];\n            i++;\n          }\n        }\n      }\n    };\n\n    processError(this);\n    return fieldErrors;\n  }\n\n  static create = (issues: ZodIssue[]) => {\n    const error = new ZodError(issues);\n    return error;\n  };\n\n  static assert(value: unknown): asserts value is ZodError {\n    if (!(value instanceof ZodError)) {\n      throw new Error(`Not a ZodError: ${value}`);\n    }\n  }\n\n  override toString() {\n    return this.message;\n  }\n  override get message() {\n    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n  }\n\n  get isEmpty(): boolean {\n    return this.issues.length === 0;\n  }\n\n  addIssue = (sub: ZodIssue) => {\n    this.issues = [...this.issues, sub];\n  };\n\n  addIssues = (subs: ZodIssue[] = []) => {\n    this.issues = [...this.issues, ...subs];\n  };\n\n  flatten(): typeToFlattenedError<T>;\n  flatten<U>(mapper?: (issue: ZodIssue) => U): typeToFlattenedError<T, U>;\n  flatten<U = string>(mapper: (issue: ZodIssue) => U = (issue: ZodIssue) => issue.message as any): any {\n    const fieldErrors: any = {};\n    const formErrors: U[] = [];\n    for (const sub of this.issues) {\n      if (sub.path.length > 0) {\n        const firstEl = sub.path[0]!;\n        fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n        fieldErrors[firstEl].push(mapper(sub));\n      } else {\n        formErrors.push(mapper(sub));\n      }\n    }\n    return { formErrors, fieldErrors };\n  }\n\n  get formErrors() {\n    return this.flatten();\n  }\n}\n\ntype stripPath<T extends object> = T extends any ? util.OmitKeys<T, \"path\"> : never;\n\nexport type IssueData = stripPath<ZodIssueOptionalMessage> & {\n  path?: (string | number)[];\n  fatal?: boolean | undefined;\n};\n\nexport type ErrorMapCtx = {\n  defaultError: string;\n  data: any;\n};\n\nexport type ZodErrorMap = (issue: ZodIssueOptionalMessage, _ctx: ErrorMapCtx) => { message: string };\n",
    "symbols": [
      {
        "name": "ZodError",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/ZodError.ts",
        "startLine": 194,
        "endLine": 316
      },
      {
        "name": "ZodError.format",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/ZodError.ts",
        "startLine": 217,
        "endLine": 264
      },
      {
        "name": "ZodError.assert",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/ZodError.ts",
        "startLine": 271,
        "endLine": 275
      },
      {
        "name": "ZodError.toString",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/ZodError.ts",
        "startLine": 277,
        "endLine": 279
      },
      {
        "name": "ZodError.flatten",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/ZodError.ts",
        "startLine": 298,
        "endLine": 311
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/index.ts",
    "content": "import z4 from \"./classic/index.js\";\nexport * from \"./classic/index.js\";\n\nexport default z4;\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4-mini/index.ts",
    "content": "export * from \"../v4/mini/index.js\";\n",
    "symbols": []
  },
  {
    "path": "node_modules/madge/test/typescript/custom-paths/import.ts",
    "content": "import heading from '@shortcut/require';\nimport fortyTwo from './subfolder';\n\nclass ImportClass {\n    constructor(public greeting: string) { }\n    greet() {\n        return \"<h1>\" + this.greeting + \"</h1>\";\n    }\n};\n",
    "symbols": [
      {
        "name": "ImportClass",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/custom-paths/import.ts",
        "startLine": 4,
        "endLine": 9
      },
      {
        "name": "ImportClass.greet",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/custom-paths/import.ts",
        "startLine": 6,
        "endLine": 8
      }
    ]
  },
  {
    "path": "node_modules/madge/test/typescript/with-config/index.ts",
    "content": "",
    "symbols": []
  },
  {
    "path": "node_modules/precinct/node_modules/detective-postcss/src/index.ts",
    "content": "import * as d from 'debug';\nimport { parse, AtRule } from 'postcss';\nimport * as postCssValuesParser from 'postcss-values-parser';\nimport isUrl = require('is-url');\n\nconst debug = d('detective-postcss');\n\nfunction detective(src, options: detective.Options = { url: false }) {\n    let references = [];\n    let root;\n    try {\n        root = parse(src);\n    } catch (e) {\n        throw new detective.MalformedCssError();\n    }\n    root.walkAtRules(rule => {\n        let file = null;\n        if (isImportRule(rule)) {\n            const firstNode = parseValue(rule.params).first;\n            file = getValueOrUrl(firstNode);\n            if (file) {\n                debug(`found %s of %s`, '@import', file);\n            }\n        }\n        if (isValueRule(rule)) {\n            const lastNode = parseValue(rule.params).last;\n            if (isFrom(lastNode.prev())) {\n                file = getValueOrUrl(lastNode);\n                if (file) {\n                    debug(`found %s of %s`, '@value with import', file);\n                }\n            }\n            if (options.url && isUrlNode(lastNode)) {\n                file = getValueOrUrl(lastNode);\n                if (file) {\n                    debug(`found %s of %s`, 'url() with import', file);\n                }\n            }\n        }\n        file && references.push(file);\n    });\n    if (options.url) {\n        root.walkDecls(decl => {\n            const { nodes } = parseValue(decl.value);\n            const files = nodes.filter(isUrlNode).map(getValueOrUrl);\n            if (files) {\n                files.forEach(file =>\n                    debug(`found %s of %s`, 'url() with import', file)\n                );\n                references = references.concat(files);\n            }\n        });\n    }\n    return references;\n}\n\nfunction parseValue(value: string) {\n    return postCssValuesParser(value).parse().first;\n}\n\nfunction getValueOrUrl(node: postCssValuesParser.Node) {\n    let ret;\n    if (isUrlNode(node)) {\n        // ['(', 'file', ')']\n        ret = node.nodes[1].value;\n    } else {\n        ret = node.value;\n    }\n    // is-url sometimes gets data: URLs wrong\n    return !isUrl(ret) && !ret.startsWith('data:') && ret;\n}\n\nfunction isUrlNode(node: postCssValuesParser.Node) {\n    return node.type === 'func' && node.value === 'url';\n}\n\nfunction isValueRule(rule: AtRule) {\n    return rule.name === 'value';\n}\n\nfunction isImportRule(rule: AtRule) {\n    return rule.name === 'import';\n}\n\nfunction isFrom(node: postCssValuesParser.Node) {\n    return node.type == 'word' && node.value === 'from';\n}\n\nnamespace detective {\n    export interface Options {\n        url: boolean;\n    }\n\n    export class MalformedCssError extends Error {}\n}\n\nexport = detective;\n",
    "symbols": [
      {
        "name": "detective",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts",
        "startLine": 8,
        "endLine": 55
      },
      {
        "name": "parseValue",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts",
        "startLine": 57,
        "endLine": 59
      },
      {
        "name": "getValueOrUrl",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts",
        "startLine": 61,
        "endLine": 71
      },
      {
        "name": "isUrlNode",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts",
        "startLine": 73,
        "endLine": 75
      },
      {
        "name": "isValueRule",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts",
        "startLine": 77,
        "endLine": 79
      },
      {
        "name": "isImportRule",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts",
        "startLine": 81,
        "endLine": 83
      },
      {
        "name": "isFrom",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts",
        "startLine": 85,
        "endLine": 87
      },
      {
        "name": "MalformedCssError",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/src/index.ts",
        "startLine": 94,
        "endLine": 94
      }
    ]
  },
  {
    "path": "node_modules/precinct/node_modules/detective-postcss/tests/index.spec.ts",
    "content": "import detective = require('../src');\n\nfunction assert(source: string, deps: string[], options?: detective.Options) {\n    expect(detective(source, options)).toEqual(deps);\n}\n\ndescribe('node-detective-postcss', () => {\n    describe('@import', () => {\n        it('detects simple imports', () => {\n            assert('@import \"foo.css\"', ['foo.css']);\n        });\n\n        describe('url()', () => {\n            it('works with url()', () => {\n                assert('@import url(\"navigation.css\");', ['navigation.css']);\n            });\n\n            it('works with single quotes', () => {\n                assert(\"@import url('navigation.css');\", ['navigation.css']);\n            });\n\n            it('works with no quotes', () => {\n                assert('@import url(navigation.css);', ['navigation.css']);\n            });\n        });\n\n        it('detects multiple imports', () => {\n            assert('@import \"1.css\"; @import \"2.css\"; @import \"3.css\"', [\n                '1.css',\n                '2.css',\n                '3.css',\n            ]);\n        });\n\n        it('ignores media', () => {\n            assert('@import \"printstyle.css\" print;', ['printstyle.css']);\n        });\n\n        it('ignores media query', () => {\n            assert('@import \"bar.css\" (min-width: 25em);', ['bar.css']);\n        });\n\n        it('ignores both', () => {\n            assert('@import \"mobstyle.css\" screen and (max-width: 768px);', [\n                'mobstyle.css',\n            ]);\n        });\n\n        it('ignores URLs', () => {\n            assert(\n                \"@import url('https://fonts.googleapis.com/css?family=Roboto:300,400');\",\n                []\n            );\n        });\n\n        it('does not touch the paths', () => {\n            assert('@import \"../../././bla.css\"', ['../../././bla.css']);\n        });\n    });\n\n    describe('@value', () => {\n        // see https://github.com/css-modules/postcss-icss-values\n        it('extracts from single values', () => {\n            assert(\"@value primary from 'colors.css';\", ['colors.css']);\n        });\n\n        it('works with url()', () => {\n            assert(\"@value primary from url('colors.css');\", ['colors.css']);\n        });\n\n        it('extracts from multiple values', () => {\n            assert(\"@value primary, secondary from 'colors.css';\", [\n                'colors.css',\n            ]);\n        });\n\n        it('works with aliases', () => {\n            assert(\n                \"@value small as bp-small, large as bp-large from 'breakpoints.css';\",\n                ['breakpoints.css']\n            );\n        });\n\n        it('works with grouped aliases', () => {\n            assert(\n                \"@value (small as t-small, large as t-large) from 'typo.css';\",\n                ['typo.css']\n            );\n        });\n\n        it('leaves simple definitions alone', () => {\n            assert('@value mine: #fff;', []);\n        });\n\n        it('leaves calculated definitions alone', () => {\n            assert('@value mine: calc(1px + 4px)', []);\n        });\n    });\n\n    describe('declarations', () => {\n        it('ignores url() by default', () => {\n            assert('.x { background: url(bla.png) }', []);\n        });\n\n        it('filters out url() for direct usages', () => {\n            assert('.x { background: url(bla.png) }', ['bla.png'], {\n                url: true,\n            });\n        });\n\n        it('filters out url() for deeper nested ones', () => {\n            assert(\n                \".x { list-style: lower-roman url('../img/shape.png') outside; }\",\n                ['../img/shape.png'],\n                { url: true }\n            );\n        });\n\n        it('finds url() in cursor definitions', () => {\n            assert(\n                '.x { cursor: url(cursor1.png) 4 12, auto; }',\n                ['cursor1.png'],\n                { url: true }\n            );\n        });\n\n        it('finds url() in @font-face', () => {\n            assert(\n                '@font-face { font-family: myFirstFont; src: url(sansation_light.woff); }',\n                ['sansation_light.woff'],\n                { url: true }\n            );\n        });\n\n        it('finds url() in @value definitions', () => {\n            assert('@value x: url(bummer.png)', ['bummer.png'], { url: true });\n        });\n\n        it('ignores base64 data: urls', () => {\n            assert(\n                '.x { background: url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)}',\n                []\n            );\n        });\n\n        it('ignores SVG data: urls', () => {\n            const css = `svg {\n                -webkit-mask-image: url('data:image/svg+xml;utf8,<svg viewBox=\"0 0 32 32\" width=\"32\" height=\"32\" xmlns=\"http://www.w3.org/2000/svg\"><defs><mask id=\"mask\"><rect x=\"0\" y=\"0\" width=\"32\" height=\"32\" fill=\"#fff\"/><rect x=\"14\" y=\"-10\" width=\"40\" height=\"20\" rx=\"10\" fill=\"#000\"/></mask></defs><rect x=\"0\" y=\"0\" width=\"32\" height=\"32\" mask=\"url(#mask)\"/></svg>');\n            }`;\n            assert(css, []);\n        });\n    });\n\n    describe('error handling', () => {\n        it('works for broken CSS', () => {\n            expect(() => detective('--')).toThrow(detective.MalformedCssError);\n        });\n    });\n});\n",
    "symbols": [
      {
        "name": "assert",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/precinct/node_modules/detective-postcss/tests/index.spec.ts",
        "startLine": 3,
        "endLine": 5
      }
    ]
  },
  {
    "path": "node_modules/tsconfig-paths/src/__tests__/data/match-path-data.ts",
    "content": "import { join, dirname } from \"path\";\nimport { removeExtension } from \"../../filesystem\";\n\nexport interface OneTest {\n  readonly name: string;\n  readonly only?: boolean;\n  readonly skip?: boolean;\n  readonly absoluteBaseUrl: string;\n  readonly paths: { [key: string]: Array<string> };\n  readonly mainFields?: string[];\n  readonly addMatchAll?: boolean;\n  readonly existingFiles: ReadonlyArray<string>;\n  readonly requestedModule: string;\n  readonly extensions: ReadonlyArray<string>;\n  readonly packageJson?: {};\n  readonly expectedPath: string | undefined;\n}\n\nconst defaultExtensionsWhenRunningInTsNode = [\n  \".js\",\n  \".json\",\n  \".node\",\n  \".ts\",\n  \".tsx\",\n];\n\nexport const tests: ReadonlyArray<OneTest> = [\n  {\n    name: \"should locate path that matches with star and exists\",\n    absoluteBaseUrl: \"/root/\",\n    paths: {\n      \"lib/*\": [\"location/*\"],\n    },\n    existingFiles: [join(\"/root\", \"location\", \"mylib\", \"index.ts\")],\n    requestedModule: \"lib/mylib\",\n    expectedPath: dirname(join(\"/root\", \"location\", \"mylib\", \"index.ts\")),\n    extensions: defaultExtensionsWhenRunningInTsNode,\n  },\n  {\n    name: \"should resolve to correct path when many are specified\",\n    absoluteBaseUrl: \"/root/\",\n    paths: {\n      \"lib/*\": [\"foo1/*\", \"foo2/*\", \"location/*\", \"foo3/*\"],\n    },\n    existingFiles: [join(\"/root\", \"location\", \"mylib\", \"index.ts\")],\n    requestedModule: \"lib/mylib\",\n    extensions: [\".ts\"],\n    expectedPath: dirname(join(\"/root\", \"location\", \"mylib\", \"index.ts\")),\n  },\n  {\n    name:\n      \"should locate path that matches with star and prioritize pattern with longest prefix\",\n    absoluteBaseUrl: \"/root/\",\n    paths: {\n      \"*\": [\"location/*\"],\n      \"lib/*\": [\"location/*\"],\n    },\n    existingFiles: [\n      join(\"/root\", \"location\", \"lib\", \"mylib\", \"index.ts\"),\n      join(\"/root\", \"location\", \"mylib\", \"index.ts\"),\n    ],\n    requestedModule: \"lib/mylib\",\n    expectedPath: dirname(join(\"/root\", \"location\", \"mylib\", \"index.ts\")),\n    extensions: defaultExtensionsWhenRunningInTsNode,\n  },\n  {\n    name: \"should locate path that matches with star and exists with extension\",\n    absoluteBaseUrl: \"/root/\",\n    paths: { \"lib/*\": [\"location/*\"] },\n    existingFiles: [join(\"/root\", \"location\", \"mylib.myext\")],\n    requestedModule: \"lib/mylib\",\n    extensions: [\".js\", \".myext\"],\n    expectedPath: removeExtension(join(\"/root\", \"location\", \"mylib.myext\")),\n  },\n  {\n    name: \"should resolve request with extension specified\",\n    absoluteBaseUrl: \"/root/\",\n    paths: { \"lib/*\": [\"location/*\"] },\n    existingFiles: [join(\"/root\", \"location\", \"test.jpg\")],\n    requestedModule: \"lib/test.jpg\",\n    expectedPath: join(\"/root\", \"location\", \"test.jpg\"),\n    extensions: defaultExtensionsWhenRunningInTsNode,\n  },\n  {\n    name: \"should locate path that matches without star and exists\",\n    absoluteBaseUrl: \"/root/\",\n    paths: {\n      \"lib/foo\": [\"location/foo\"],\n    },\n    existingFiles: [join(\"/root\", \"location\", \"foo.ts\")],\n    requestedModule: \"lib/foo\",\n    expectedPath: removeExtension(join(\"/root\", \"location\", \"foo.ts\")),\n    extensions: defaultExtensionsWhenRunningInTsNode,\n  },\n  {\n    name: \"should resolve to parent folder when filename is in subfolder\",\n    absoluteBaseUrl: \"/root/\",\n    paths: { \"lib/*\": [\"location/*\"] },\n    existingFiles: [join(\"/root\", \"location\", \"mylib\", \"index.ts\")],\n    requestedModule: \"lib/mylib\",\n    expectedPath: dirname(join(\"/root\", \"location\", \"mylib\", \"index.ts\")),\n    extensions: defaultExtensionsWhenRunningInTsNode,\n  },\n  {\n    name: \"should resolve from main field in package.json\",\n    absoluteBaseUrl: \"/root/\",\n    paths: { \"lib/*\": [\"location/*\"] },\n    existingFiles: [join(\"/root\", \"location\", \"mylib\", \"kalle.ts\")],\n    packageJson: { main: \"./kalle.ts\" },\n    requestedModule: \"lib/mylib\",\n    expectedPath: join(\"/root\", \"location\", \"mylib\", \"kalle.ts\"),\n    extensions: defaultExtensionsWhenRunningInTsNode,\n  },\n  {\n    name: \"should resolve from main field in package.json (js)\",\n    absoluteBaseUrl: \"/root\",\n    paths: { \"lib/*\": [\"location/*\"] },\n    existingFiles: [join(\"/root\", \"location\", \"mylib.js\", \"kalle.js\")],\n    packageJson: { main: \"./kalle.js\" },\n    requestedModule: \"lib/mylib.js\",\n    extensions: [\".ts\", \".js\"],\n    expectedPath: join(\"/root\", \"location\", \"mylib.js\", \"kalle.js\"),\n  },\n  {\n    name: \"should resolve from list of fields by priority in package.json\",\n    absoluteBaseUrl: \"/root/\",\n    paths: { \"lib/*\": [\"location/*\"] },\n    mainFields: [\"missing\", \"browser\", \"main\"],\n    packageJson: { main: \"./main.js\", browser: \"./browser.js\" },\n    existingFiles: [\n      join(\"/root\", \"location\", \"mylibjs\", \"main.js\"), // mainFilePath\n      join(\"/root\", \"location\", \"mylibjs\", \"browser.js\"), // browserFilePath\n    ],\n    extensions: [\".ts\", \".js\"],\n    requestedModule: \"lib/mylibjs\",\n    expectedPath: join(\"/root\", \"location\", \"mylibjs\", \"browser.js\"),\n  },\n  {\n    name: \"should ignore field mappings to missing files in package.json\",\n    absoluteBaseUrl: \"/root/\",\n    paths: { \"lib/*\": [\"location/*\"] },\n    mainFields: [\"browser\", \"main\"],\n    existingFiles: [join(\"/root\", \"location\", \"mylibjs\", \"kalle.js\")],\n    requestedModule: \"lib/mylibjs\",\n    packageJson: {\n      main: \"./kalle.js\",\n      browser: \"./nope.js\",\n    },\n    extensions: [\".ts\", \".js\"],\n    expectedPath: join(\"/root\", \"location\", \"mylibjs\", \"kalle.js\"),\n  },\n  {\n    name: \"should ignore advanced field mappings in package.json\",\n    absoluteBaseUrl: \"/root/\",\n    paths: { \"lib/*\": [\"location/*\"] },\n    existingFiles: [\n      join(\"/root\", \"location\", \"mylibjs\", \"kalle.js\"),\n      join(\"/root\", \"location\", \"mylibjs\", \"browser.js\"),\n    ],\n    requestedModule: \"lib/mylibjs\",\n    packageJson: {\n      main: \"./kalle.js\",\n      browser: { mylibjs: \"./browser.js\", \"./kalle.js\": \"./browser.js\" },\n    },\n    extensions: [\".ts\", \".js\"],\n    expectedPath: join(\"/root\", \"location\", \"mylibjs\", \"kalle.js\"),\n  },\n  {\n    name: \"should resolve to with the help of baseUrl when not explicitly set\",\n    absoluteBaseUrl: \"/root/\",\n    paths: {},\n    existingFiles: [join(\"/root\", \"mylib\", \"index.ts\")],\n    requestedModule: \"mylib\",\n    expectedPath: dirname(join(\"/root\", \"mylib\", \"index.ts\")),\n    extensions: defaultExtensionsWhenRunningInTsNode,\n  },\n  {\n    name: \"should not resolve with the help of baseUrl when asked not to\",\n    absoluteBaseUrl: \"/root/\",\n    paths: {},\n    addMatchAll: false,\n    existingFiles: [join(\"/root\", \"mylib\", \"index.ts\")],\n    requestedModule: \"mylib\",\n    expectedPath: undefined,\n    extensions: defaultExtensionsWhenRunningInTsNode,\n  },\n  {\n    name: \"should not locate path that does not match\",\n    absoluteBaseUrl: \"/root/\",\n    paths: { \"lib/*\": [\"location/*\"] },\n    existingFiles: [join(\"root\", \"location\", \"mylib\")],\n    requestedModule: \"mylib\",\n    expectedPath: undefined,\n    extensions: defaultExtensionsWhenRunningInTsNode,\n  },\n  {\n    name: \"should not resolve typings file (index.d.ts)\",\n    absoluteBaseUrl: \"/root/\",\n    paths: {\n      \"lib/*\": [\"location/*\"],\n    },\n    existingFiles: [join(\"/root\", \"location\", \"mylib\", \"index.d.ts\")],\n    requestedModule: \"lib/mylib\",\n    expectedPath: undefined,\n    extensions: defaultExtensionsWhenRunningInTsNode,\n  },\n  {\n    name: \"should resolve main file with cjs file extension\",\n    absoluteBaseUrl: \"/root/\",\n    paths: {},\n    existingFiles: [join(\"/root\", \"mylib\", \"index.cjs\")],\n    packageJson: {\n      main: \"./index.cjs\",\n    },\n    requestedModule: \"mylib\",\n    expectedPath: join(\"/root\", \"mylib\", \"index.cjs\"),\n    extensions: defaultExtensionsWhenRunningInTsNode,\n  },\n];\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/benchmarks/datetime.ts",
    "content": "import Benchmark from \"benchmark\";\n\nconst datetimeValidationSuite = new Benchmark.Suite(\"datetime\");\n\nconst DATA = \"2021-01-01\";\nconst MONTHS_31 = new Set([1, 3, 5, 7, 8, 10, 12]);\nconst MONTHS_30 = new Set([4, 6, 9, 11]);\n\nconst simpleDatetimeRegex = /^(\\d{4})-(\\d{2})-(\\d{2})$/;\nconst datetimeRegexNoLeapYearValidation =\n  /^\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))$/;\nconst datetimeRegexWithLeapYearValidation =\n  /^((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))$/;\n\ndatetimeValidationSuite\n  .add(\"new Date()\", () => {\n    return !Number.isNaN(new Date(DATA).getTime());\n  })\n  .add(\"regex (no validation)\", () => {\n    return simpleDatetimeRegex.test(DATA);\n  })\n  .add(\"regex (no leap year)\", () => {\n    return datetimeRegexNoLeapYearValidation.test(DATA);\n  })\n  .add(\"regex (w/ leap year)\", () => {\n    return datetimeRegexWithLeapYearValidation.test(DATA);\n  })\n  .add(\"capture groups + code\", () => {\n    const match = DATA.match(simpleDatetimeRegex);\n    if (!match) return false;\n\n    // Extract year, month, and day from the capture groups\n    const year = Number.parseInt(match[1], 10);\n    const month = Number.parseInt(match[2], 10); // month is 0-indexed in JavaScript Date, so subtract 1\n    const day = Number.parseInt(match[3], 10);\n\n    if (month === 2) {\n      if ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0) {\n        return day <= 29;\n      }\n      return day <= 28;\n    }\n    if (MONTHS_30.has(month)) {\n      return day <= 30;\n    }\n    if (MONTHS_31.has(month)) {\n      return day <= 31;\n    }\n    return false;\n  })\n\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${datetimeValidationSuite.name!}: ${e.target}`);\n  });\n\nexport default {\n  suites: [datetimeValidationSuite],\n};\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/benchmarks/discriminatedUnion.ts",
    "content": "import Benchmark from \"benchmark\";\n\nimport { z } from \"zod/v3\";\n\nconst doubleSuite = new Benchmark.Suite(\"z.discriminatedUnion: double\");\nconst manySuite = new Benchmark.Suite(\"z.discriminatedUnion: many\");\n\nconst aSchema = z.object({\n  type: z.literal(\"a\"),\n});\nconst objA = {\n  type: \"a\",\n};\n\nconst bSchema = z.object({\n  type: z.literal(\"b\"),\n});\nconst objB = {\n  type: \"b\",\n};\n\nconst cSchema = z.object({\n  type: z.literal(\"c\"),\n});\nconst objC = {\n  type: \"c\",\n};\n\nconst dSchema = z.object({\n  type: z.literal(\"d\"),\n});\n\nconst double = z.discriminatedUnion(\"type\", [aSchema, bSchema]);\nconst many = z.discriminatedUnion(\"type\", [aSchema, bSchema, cSchema, dSchema]);\n\ndoubleSuite\n  .add(\"valid: a\", () => {\n    double.parse(objA);\n  })\n  .add(\"valid: b\", () => {\n    double.parse(objB);\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      double.parse(null);\n    } catch (_err) {}\n  })\n  .add(\"invalid: wrong shape\", () => {\n    try {\n      double.parse(objC);\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(doubleSuite as any).name}: ${e.target}`);\n  });\n\nmanySuite\n  .add(\"valid: a\", () => {\n    many.parse(objA);\n  })\n  .add(\"valid: c\", () => {\n    many.parse(objC);\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      many.parse(null);\n    } catch (_err) {}\n  })\n  .add(\"invalid: wrong shape\", () => {\n    try {\n      many.parse({ type: \"unknown\" });\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(manySuite as any).name}: ${e.target}`);\n  });\n\nexport default {\n  suites: [doubleSuite, manySuite],\n};\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/benchmarks/index.ts",
    "content": "import type Benchmark from \"benchmark\";\n\nimport datetimeBenchmarks from \"./datetime.js\";\nimport discriminatedUnionBenchmarks from \"./discriminatedUnion.js\";\nimport ipv4Benchmarks from \"./ipv4.js\";\nimport objectBenchmarks from \"./object.js\";\nimport primitiveBenchmarks from \"./primitives.js\";\nimport realworld from \"./realworld.js\";\nimport stringBenchmarks from \"./string.js\";\nimport unionBenchmarks from \"./union.js\";\n\nconst argv = process.argv.slice(2);\nlet suites: Benchmark.Suite[] = [];\n\nif (!argv.length) {\n  suites = [\n    ...realworld.suites,\n    ...primitiveBenchmarks.suites,\n    ...stringBenchmarks.suites,\n    ...objectBenchmarks.suites,\n    ...unionBenchmarks.suites,\n    ...discriminatedUnionBenchmarks.suites,\n  ];\n} else {\n  if (argv.includes(\"--realworld\")) {\n    suites.push(...realworld.suites);\n  }\n  if (argv.includes(\"--primitives\")) {\n    suites.push(...primitiveBenchmarks.suites);\n  }\n  if (argv.includes(\"--string\")) {\n    suites.push(...stringBenchmarks.suites);\n  }\n  if (argv.includes(\"--object\")) {\n    suites.push(...objectBenchmarks.suites);\n  }\n  if (argv.includes(\"--union\")) {\n    suites.push(...unionBenchmarks.suites);\n  }\n  if (argv.includes(\"--discriminatedUnion\")) {\n    suites.push(...datetimeBenchmarks.suites);\n  }\n  if (argv.includes(\"--datetime\")) {\n    suites.push(...datetimeBenchmarks.suites);\n  }\n  if (argv.includes(\"--ipv4\")) {\n    suites.push(...ipv4Benchmarks.suites);\n  }\n}\n\nfor (const suite of suites) {\n  suite.run({});\n}\n\n// exit on Ctrl-C\nprocess.on(\"SIGINT\", function () {\n  console.log(\"Exiting...\");\n  process.exit();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/benchmarks/ipv4.ts",
    "content": "import Benchmark from \"benchmark\";\n\nconst suite = new Benchmark.Suite(\"ipv4\");\n\nconst DATA = \"127.0.0.1\";\nconst ipv4RegexA =\n  /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;\nconst ipv4RegexB =\n  /^(?:(?:(?=(25[0-5]))\\1|(?=(2[0-4][0-9]))\\2|(?=(1[0-9]{2}))\\3|(?=([0-9]{1,2}))\\4)\\.){3}(?:(?=(25[0-5]))\\5|(?=(2[0-4][0-9]))\\6|(?=(1[0-9]{2}))\\7|(?=([0-9]{1,2}))\\8)$/;\nconst ipv4RegexC = /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/;\nconst ipv4RegexD = /^(\\b25[0-5]|\\b2[0-4][0-9]|\\b[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/;\nconst ipv4RegexE = /^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.){3}(25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)$/;\nconst ipv4RegexF = /^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}$/;\nconst ipv4RegexG = /^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)(\\.(?!$)|$)){4}$/;\nconst ipv4RegexH = /^((25[0-5]|(2[0-4]|1[0-9]|[1-9]|)[0-9])(\\.(?!$)|$)){4}$/;\nconst ipv4RegexI =\n  /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\n\nsuite\n  .add(\"A\", () => {\n    return ipv4RegexA.test(DATA);\n  })\n  .add(\"B\", () => {\n    return ipv4RegexB.test(DATA);\n  })\n  .add(\"C\", () => {\n    return ipv4RegexC.test(DATA);\n  })\n  .add(\"D\", () => {\n    return ipv4RegexD.test(DATA);\n  })\n  .add(\"E\", () => {\n    return ipv4RegexE.test(DATA);\n  })\n  .add(\"F\", () => {\n    return ipv4RegexF.test(DATA);\n  })\n  .add(\"G\", () => {\n    return ipv4RegexG.test(DATA);\n  })\n  .add(\"H\", () => {\n    return ipv4RegexH.test(DATA);\n  })\n  .add(\"I\", () => {\n    return ipv4RegexI.test(DATA);\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${suite.name!}: ${e.target}`);\n  });\n\nexport default {\n  suites: [suite],\n};\n\nif (require.main === module) {\n  suite.run();\n}\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/benchmarks/object.ts",
    "content": "import Benchmark from \"benchmark\";\n\nimport { z } from \"zod/v3\";\n\nconst emptySuite = new Benchmark.Suite(\"z.object: empty\");\nconst shortSuite = new Benchmark.Suite(\"z.object: short\");\nconst longSuite = new Benchmark.Suite(\"z.object: long\");\n\nconst empty = z.object({});\nconst short = z.object({\n  string: z.string(),\n});\nconst long = z.object({\n  string: z.string(),\n  number: z.number(),\n  boolean: z.boolean(),\n});\n\nemptySuite\n  .add(\"valid\", () => {\n    empty.parse({});\n  })\n  .add(\"valid: extra keys\", () => {\n    empty.parse({ string: \"string\" });\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      empty.parse(null);\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(emptySuite as any).name}: ${e.target}`);\n  });\n\nshortSuite\n  .add(\"valid\", () => {\n    short.parse({ string: \"string\" });\n  })\n  .add(\"valid: extra keys\", () => {\n    short.parse({ string: \"string\", number: 42 });\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      short.parse(null);\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(shortSuite as any).name}: ${e.target}`);\n  });\n\nlongSuite\n  .add(\"valid\", () => {\n    long.parse({ string: \"string\", number: 42, boolean: true });\n  })\n  .add(\"valid: extra keys\", () => {\n    long.parse({ string: \"string\", number: 42, boolean: true, list: [] });\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      long.parse(null);\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(longSuite as any).name}: ${e.target}`);\n  });\n\nexport default {\n  suites: [emptySuite, shortSuite, longSuite],\n};\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/benchmarks/primitives.ts",
    "content": "import Benchmark from \"benchmark\";\n\nimport { z } from \"zod/v3\";\nimport { Mocker } from \"../tests/Mocker.js\";\n\nconst val = new Mocker();\n\nconst enumSuite = new Benchmark.Suite(\"z.enum\");\nconst enumSchema = z.enum([\"a\", \"b\", \"c\"]);\n\nenumSuite\n  .add(\"valid\", () => {\n    enumSchema.parse(\"a\");\n  })\n  .add(\"invalid\", () => {\n    try {\n      enumSchema.parse(\"x\");\n    } catch (_e: any) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`z.enum: ${e.target}`);\n  });\n\nconst longEnumSuite = new Benchmark.Suite(\"long z.enum\");\nconst longEnumSchema = z.enum([\n  \"one\",\n  \"two\",\n  \"three\",\n  \"four\",\n  \"five\",\n  \"six\",\n  \"seven\",\n  \"eight\",\n  \"nine\",\n  \"ten\",\n  \"eleven\",\n  \"twelve\",\n  \"thirteen\",\n  \"fourteen\",\n  \"fifteen\",\n  \"sixteen\",\n  \"seventeen\",\n]);\n\nlongEnumSuite\n  .add(\"valid\", () => {\n    longEnumSchema.parse(\"five\");\n  })\n  .add(\"invalid\", () => {\n    try {\n      longEnumSchema.parse(\"invalid\");\n    } catch (_e: any) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`long z.enum: ${e.target}`);\n  });\n\nconst undefinedSuite = new Benchmark.Suite(\"z.undefined\");\nconst undefinedSchema = z.undefined();\n\nundefinedSuite\n  .add(\"valid\", () => {\n    undefinedSchema.parse(undefined);\n  })\n  .add(\"invalid\", () => {\n    try {\n      undefinedSchema.parse(1);\n    } catch (_e: any) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`z.undefined: ${e.target}`);\n  });\n\nconst literalSuite = new Benchmark.Suite(\"z.literal\");\nconst short = \"short\";\nconst bad = \"bad\";\nconst literalSchema = z.literal(\"short\");\n\nliteralSuite\n  .add(\"valid\", () => {\n    literalSchema.parse(short);\n  })\n  .add(\"invalid\", () => {\n    try {\n      literalSchema.parse(bad);\n    } catch (_e: any) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`z.literal: ${e.target}`);\n  });\n\nconst numberSuite = new Benchmark.Suite(\"z.number\");\nconst numberSchema = z.number().int();\n\nnumberSuite\n  .add(\"valid\", () => {\n    numberSchema.parse(1);\n  })\n  .add(\"invalid type\", () => {\n    try {\n      numberSchema.parse(\"bad\");\n    } catch (_e: any) {}\n  })\n  .add(\"invalid number\", () => {\n    try {\n      numberSchema.parse(0.5);\n    } catch (_e: any) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`z.number: ${e.target}`);\n  });\n\nconst dateSuite = new Benchmark.Suite(\"z.date\");\n\nconst plainDate = z.date();\nconst minMaxDate = z.date().min(new Date(\"2021-01-01\")).max(new Date(\"2030-01-01\"));\n\ndateSuite\n  .add(\"valid\", () => {\n    plainDate.parse(new Date());\n  })\n  .add(\"invalid\", () => {\n    try {\n      plainDate.parse(1);\n    } catch (_e: any) {}\n  })\n  .add(\"valid min and max\", () => {\n    minMaxDate.parse(new Date(\"2023-01-01\"));\n  })\n  .add(\"invalid min\", () => {\n    try {\n      minMaxDate.parse(new Date(\"2019-01-01\"));\n    } catch (_e: any) {}\n  })\n  .add(\"invalid max\", () => {\n    try {\n      minMaxDate.parse(new Date(\"2031-01-01\"));\n    } catch (_e: any) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`z.date: ${e.target}`);\n  });\n\nconst symbolSuite = new Benchmark.Suite(\"z.symbol\");\nconst symbolSchema = z.symbol();\n\nsymbolSuite\n  .add(\"valid\", () => {\n    symbolSchema.parse(val.symbol);\n  })\n  .add(\"invalid\", () => {\n    try {\n      symbolSchema.parse(1);\n    } catch (_e: any) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`z.symbol: ${e.target}`);\n  });\n\nexport default {\n  suites: [enumSuite, longEnumSuite, undefinedSuite, literalSuite, numberSuite, dateSuite, symbolSuite],\n};\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/benchmarks/realworld.ts",
    "content": "import Benchmark from \"benchmark\";\n\nimport { z } from \"zod/v3\";\n\nconst shortSuite = new Benchmark.Suite(\"realworld\");\n\nconst People = z.array(\n  z.object({\n    type: z.literal(\"person\"),\n    hair: z.enum([\"blue\", \"brown\"]),\n    active: z.boolean(),\n    name: z.string(),\n    age: z.number().int(),\n    hobbies: z.array(z.string()),\n    address: z.object({\n      street: z.string(),\n      zip: z.string(),\n      country: z.string(),\n    }),\n  })\n);\n\nlet i = 0;\n\nfunction num() {\n  return ++i;\n}\n\nfunction str() {\n  return (++i % 100).toString(16);\n}\n\nfunction array<T>(fn: () => T): T[] {\n  return Array.from({ length: ++i % 10 }, () => fn());\n}\n\nconst people = Array.from({ length: 100 }, () => {\n  return {\n    type: \"person\",\n    hair: i % 2 ? \"blue\" : \"brown\",\n    active: !!(i % 2),\n    name: str(),\n    age: num(),\n    hobbies: array(str),\n    address: {\n      street: str(),\n      zip: str(),\n      country: str(),\n    },\n  };\n});\n\nshortSuite\n  .add(\"valid\", () => {\n    People.parse(people);\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(shortSuite as any).name}: ${e.target}`);\n  });\n\nexport default {\n  suites: [shortSuite],\n};\n",
    "symbols": [
      {
        "name": "num",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/benchmarks/realworld.ts",
        "startLine": 25,
        "endLine": 27
      },
      {
        "name": "str",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/benchmarks/realworld.ts",
        "startLine": 29,
        "endLine": 31
      },
      {
        "name": "array",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/benchmarks/realworld.ts",
        "startLine": 33,
        "endLine": 35
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/benchmarks/string.ts",
    "content": "import Benchmark from \"benchmark\";\n\nimport { z } from \"zod/v3\";\n\nconst SUITE_NAME = \"z.string\";\nconst suite = new Benchmark.Suite(SUITE_NAME);\n\nconst empty = \"\";\nconst short = \"short\";\nconst long = \"long\".repeat(256);\nconst manual = (str: unknown) => {\n  if (typeof str !== \"string\") {\n    throw new Error(\"Not a string\");\n  }\n\n  return str;\n};\nconst stringSchema = z.string();\nconst optionalStringSchema = z.string().optional();\nconst optionalNullableStringSchema = z.string().optional().nullable();\n\nsuite\n  .add(\"empty string\", () => {\n    stringSchema.parse(empty);\n  })\n  .add(\"short string\", () => {\n    stringSchema.parse(short);\n  })\n  .add(\"long string\", () => {\n    stringSchema.parse(long);\n  })\n  .add(\"optional string\", () => {\n    optionalStringSchema.parse(long);\n  })\n  .add(\"nullable string\", () => {\n    optionalNullableStringSchema.parse(long);\n  })\n  .add(\"nullable (null) string\", () => {\n    optionalNullableStringSchema.parse(null);\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      stringSchema.parse(null);\n    } catch (_err) {}\n  })\n  .add(\"manual parser: long\", () => {\n    manual(long);\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${SUITE_NAME}: ${e.target}`);\n  });\n\nexport default {\n  suites: [suite],\n};\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/benchmarks/union.ts",
    "content": "import Benchmark from \"benchmark\";\n\nimport { z } from \"zod/v3\";\n\nconst doubleSuite = new Benchmark.Suite(\"z.union: double\");\nconst manySuite = new Benchmark.Suite(\"z.union: many\");\n\nconst aSchema = z.object({\n  type: z.literal(\"a\"),\n});\nconst objA = {\n  type: \"a\",\n};\n\nconst bSchema = z.object({\n  type: z.literal(\"b\"),\n});\nconst objB = {\n  type: \"b\",\n};\n\nconst cSchema = z.object({\n  type: z.literal(\"c\"),\n});\nconst objC = {\n  type: \"c\",\n};\n\nconst dSchema = z.object({\n  type: z.literal(\"d\"),\n});\n\nconst double = z.union([aSchema, bSchema]);\nconst many = z.union([aSchema, bSchema, cSchema, dSchema]);\n\ndoubleSuite\n  .add(\"valid: a\", () => {\n    double.parse(objA);\n  })\n  .add(\"valid: b\", () => {\n    double.parse(objB);\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      double.parse(null);\n    } catch (_err) {}\n  })\n  .add(\"invalid: wrong shape\", () => {\n    try {\n      double.parse(objC);\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(doubleSuite as any).name}: ${e.target}`);\n  });\n\nmanySuite\n  .add(\"valid: a\", () => {\n    many.parse(objA);\n  })\n  .add(\"valid: c\", () => {\n    many.parse(objC);\n  })\n  .add(\"invalid: null\", () => {\n    try {\n      many.parse(null);\n    } catch (_err) {}\n  })\n  .add(\"invalid: wrong shape\", () => {\n    try {\n      many.parse({ type: \"unknown\" });\n    } catch (_err) {}\n  })\n  .on(\"cycle\", (e: Benchmark.Event) => {\n    console.log(`${(manySuite as any).name}: ${e.target}`);\n  });\n\nexport default {\n  suites: [doubleSuite, manySuite],\n};\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/helpers/enumUtil.ts",
    "content": "export namespace enumUtil {\n  type UnionToIntersectionFn<T> = (T extends unknown ? (k: () => T) => void : never) extends (\n    k: infer Intersection\n  ) => void\n    ? Intersection\n    : never;\n\n  type GetUnionLast<T> = UnionToIntersectionFn<T> extends () => infer Last ? Last : never;\n\n  type UnionToTuple<T, Tuple extends unknown[] = []> = [T] extends [never]\n    ? Tuple\n    : UnionToTuple<Exclude<T, GetUnionLast<T>>, [GetUnionLast<T>, ...Tuple]>;\n\n  type CastToStringTuple<T> = T extends [string, ...string[]] ? T : never;\n\n  export type UnionToTupleString<T> = CastToStringTuple<UnionToTuple<T>>;\n}\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/helpers/errorUtil.ts",
    "content": "export namespace errorUtil {\n  export type ErrMessage = string | { message?: string | undefined };\n  export const errToObj = (message?: ErrMessage): { message?: string | undefined } =>\n    typeof message === \"string\" ? { message } : message || {};\n  // biome-ignore lint:\n  export const toString = (message?: ErrMessage): string | undefined =>\n    typeof message === \"string\" ? message : message?.message;\n}\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
    "content": "import type { IssueData, ZodErrorMap, ZodIssue } from \"../ZodError.js\";\nimport { getErrorMap } from \"../errors.js\";\nimport defaultErrorMap from \"../locales/en.js\";\nimport type { ZodParsedType } from \"./util.js\";\n\nexport const makeIssue = (params: {\n  data: any;\n  path: (string | number)[];\n  errorMaps: ZodErrorMap[];\n  issueData: IssueData;\n}): ZodIssue => {\n  const { data, path, errorMaps, issueData } = params;\n  const fullPath = [...path, ...(issueData.path || [])];\n  const fullIssue = {\n    ...issueData,\n    path: fullPath,\n  };\n\n  if (issueData.message !== undefined) {\n    return {\n      ...issueData,\n      path: fullPath,\n      message: issueData.message,\n    };\n  }\n\n  let errorMessage = \"\";\n  const maps = errorMaps\n    .filter((m) => !!m)\n    .slice()\n    .reverse();\n  for (const map of maps) {\n    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n  }\n\n  return {\n    ...issueData,\n    path: fullPath,\n    message: errorMessage,\n  };\n};\n\nexport type ParseParams = {\n  path: (string | number)[];\n  errorMap: ZodErrorMap;\n  async: boolean;\n};\n\nexport type ParsePathComponent = string | number;\nexport type ParsePath = ParsePathComponent[];\nexport const EMPTY_PATH: ParsePath = [];\n\nexport interface ParseContext {\n  readonly common: {\n    readonly issues: ZodIssue[];\n    readonly contextualErrorMap?: ZodErrorMap | undefined;\n    readonly async: boolean;\n  };\n  readonly path: ParsePath;\n  readonly schemaErrorMap?: ZodErrorMap | undefined;\n  readonly parent: ParseContext | null;\n  readonly data: any;\n  readonly parsedType: ZodParsedType;\n}\n\nexport type ParseInput = {\n  data: any;\n  path: (string | number)[];\n  parent: ParseContext;\n};\n\nexport function addIssueToContext(ctx: ParseContext, issueData: IssueData): void {\n  const overrideMap = getErrorMap();\n  const issue = makeIssue({\n    issueData: issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [\n      ctx.common.contextualErrorMap, // contextual error map is first priority\n      ctx.schemaErrorMap, // then schema-bound map if available\n      overrideMap, // then global override map\n      overrideMap === defaultErrorMap ? undefined : defaultErrorMap, // then global default map\n    ].filter((x) => !!x),\n  });\n  ctx.common.issues.push(issue);\n}\n\nexport type ObjectPair = {\n  key: SyncParseReturnType<any>;\n  value: SyncParseReturnType<any>;\n};\nexport class ParseStatus {\n  value: \"aborted\" | \"dirty\" | \"valid\" = \"valid\";\n  dirty(): void {\n    if (this.value === \"valid\") this.value = \"dirty\";\n  }\n  abort(): void {\n    if (this.value !== \"aborted\") this.value = \"aborted\";\n  }\n\n  static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType {\n    const arrayValue: any[] = [];\n    for (const s of results) {\n      if (s.status === \"aborted\") return INVALID;\n      if (s.status === \"dirty\") status.dirty();\n      arrayValue.push(s.value);\n    }\n\n    return { status: status.value, value: arrayValue };\n  }\n\n  static async mergeObjectAsync(\n    status: ParseStatus,\n    pairs: { key: ParseReturnType<any>; value: ParseReturnType<any> }[]\n  ): Promise<SyncParseReturnType<any>> {\n    const syncPairs: ObjectPair[] = [];\n    for (const pair of pairs) {\n      const key = await pair.key;\n      const value = await pair.value;\n      syncPairs.push({\n        key,\n        value,\n      });\n    }\n    return ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n\n  static mergeObjectSync(\n    status: ParseStatus,\n    pairs: {\n      key: SyncParseReturnType<any>;\n      value: SyncParseReturnType<any>;\n      alwaysSet?: boolean;\n    }[]\n  ): SyncParseReturnType {\n    const finalObject: any = {};\n    for (const pair of pairs) {\n      const { key, value } = pair;\n      if (key.status === \"aborted\") return INVALID;\n      if (value.status === \"aborted\") return INVALID;\n      if (key.status === \"dirty\") status.dirty();\n      if (value.status === \"dirty\") status.dirty();\n\n      if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n        finalObject[key.value] = value.value;\n      }\n    }\n\n    return { status: status.value, value: finalObject };\n  }\n}\nexport interface ParseResult {\n  status: \"aborted\" | \"dirty\" | \"valid\";\n  data: any;\n}\n\nexport type INVALID = { status: \"aborted\" };\nexport const INVALID: INVALID = Object.freeze({\n  status: \"aborted\",\n});\n\nexport type DIRTY<T> = { status: \"dirty\"; value: T };\nexport const DIRTY = <T>(value: T): DIRTY<T> => ({ status: \"dirty\", value });\n\nexport type OK<T> = { status: \"valid\"; value: T };\nexport const OK = <T>(value: T): OK<T> => ({ status: \"valid\", value });\n\nexport type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;\nexport type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;\nexport type ParseReturnType<T> = SyncParseReturnType<T> | AsyncParseReturnType<T>;\n\nexport const isAborted = (x: ParseReturnType<any>): x is INVALID => (x as any).status === \"aborted\";\nexport const isDirty = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> => (x as any).status === \"dirty\";\nexport const isValid = <T>(x: ParseReturnType<T>): x is OK<T> => (x as any).status === \"valid\";\nexport const isAsync = <T>(x: ParseReturnType<T>): x is AsyncParseReturnType<T> =>\n  typeof Promise !== \"undefined\" && x instanceof Promise;\n",
    "symbols": [
      {
        "name": "addIssueToContext",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
        "startLine": 72,
        "endLine": 86
      },
      {
        "name": "ParseStatus",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
        "startLine": 92,
        "endLine": 151
      },
      {
        "name": "ParseStatus.dirty",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
        "startLine": 94,
        "endLine": 96
      },
      {
        "name": "ParseStatus.abort",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
        "startLine": 97,
        "endLine": 99
      },
      {
        "name": "ParseStatus.mergeArray",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
        "startLine": 101,
        "endLine": 110
      },
      {
        "name": "ParseStatus.mergeObjectAsync",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
        "startLine": 112,
        "endLine": 126
      },
      {
        "name": "ParseStatus.mergeObjectSync",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/parseUtil.ts",
        "startLine": 128,
        "endLine": 150
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/helpers/partialUtil.ts",
    "content": "import type {\n  ZodArray,\n  ZodNullable,\n  ZodObject,\n  ZodOptional,\n  ZodRawShape,\n  ZodTuple,\n  ZodTupleItems,\n  ZodTypeAny,\n} from \"../types.js\";\n\nexport namespace partialUtil {\n  export type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<ZodRawShape>\n    ? ZodObject<\n        { [k in keyof T[\"shape\"]]: ZodOptional<DeepPartial<T[\"shape\"][k]>> },\n        T[\"_def\"][\"unknownKeys\"],\n        T[\"_def\"][\"catchall\"]\n      >\n    : T extends ZodArray<infer Type, infer Card>\n      ? ZodArray<DeepPartial<Type>, Card>\n      : T extends ZodOptional<infer Type>\n        ? ZodOptional<DeepPartial<Type>>\n        : T extends ZodNullable<infer Type>\n          ? ZodNullable<DeepPartial<Type>>\n          : T extends ZodTuple<infer Items>\n            ? {\n                [k in keyof Items]: Items[k] extends ZodTypeAny ? DeepPartial<Items[k]> : never;\n              } extends infer PI\n              ? PI extends ZodTupleItems\n                ? ZodTuple<PI>\n                : never\n              : never\n            : T;\n}\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/helpers/typeAliases.ts",
    "content": "export type Primitive = string | number | symbol | bigint | boolean | null | undefined;\nexport type Scalars = Primitive | Primitive[];\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/helpers/util.ts",
    "content": "export namespace util {\n  type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;\n\n  export type isAny<T> = 0 extends 1 & T ? true : false;\n  export const assertEqual = <A, B>(_: AssertEqual<A, B>): void => {};\n  export function assertIs<T>(_arg: T): void {}\n  export function assertNever(_x: never): never {\n    throw new Error();\n  }\n\n  export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n  export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;\n  export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n  export type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;\n  export type InexactPartial<T> = { [k in keyof T]?: T[k] | undefined };\n  export const arrayToEnum = <T extends string, U extends [T, ...T[]]>(items: U): { [k in U[number]]: k } => {\n    const obj: any = {};\n    for (const item of items) {\n      obj[item] = item;\n    }\n    return obj;\n  };\n\n  export const getValidEnumValues = (obj: any): any[] => {\n    const validKeys = objectKeys(obj).filter((k: any) => typeof obj[obj[k]] !== \"number\");\n    const filtered: any = {};\n    for (const k of validKeys) {\n      filtered[k] = obj[k];\n    }\n    return objectValues(filtered);\n  };\n\n  export const objectValues = (obj: any): any[] => {\n    return objectKeys(obj).map(function (e) {\n      return obj[e];\n    });\n  };\n\n  export const objectKeys: ObjectConstructor[\"keys\"] =\n    typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n      ? (obj: any) => Object.keys(obj) // eslint-disable-line ban/ban\n      : (object: any) => {\n          const keys = [];\n          for (const key in object) {\n            if (Object.prototype.hasOwnProperty.call(object, key)) {\n              keys.push(key);\n            }\n          }\n          return keys;\n        };\n\n  export const find = <T>(arr: T[], checker: (arg: T) => any): T | undefined => {\n    for (const item of arr) {\n      if (checker(item)) return item;\n    }\n    return undefined;\n  };\n\n  export type identity<T> = objectUtil.identity<T>;\n  export type flatten<T> = objectUtil.flatten<T>;\n\n  export type noUndefined<T> = T extends undefined ? never : T;\n\n  export const isInteger: NumberConstructor[\"isInteger\"] =\n    typeof Number.isInteger === \"function\"\n      ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n      : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n\n  export function joinValues<T extends any[]>(array: T, separator = \" | \"): string {\n    return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n  }\n\n  export const jsonStringifyReplacer = (_: string, value: any): any => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  };\n}\n\nexport namespace objectUtil {\n  export type MergeShapes<U, V> =\n    // fast path when there is no keys overlap\n    keyof U & keyof V extends never\n      ? U & V\n      : {\n          [k in Exclude<keyof U, keyof V>]: U[k];\n        } & V;\n\n  type optionalKeys<T extends object> = {\n    [k in keyof T]: undefined extends T[k] ? k : never;\n  }[keyof T];\n  type requiredKeys<T extends object> = {\n    [k in keyof T]: undefined extends T[k] ? never : k;\n  }[keyof T];\n  export type addQuestionMarks<T extends object, _O = any> = {\n    [K in requiredKeys<T>]: T[K];\n  } & {\n    [K in optionalKeys<T>]?: T[K];\n  } & { [k in keyof T]?: unknown };\n\n  export type identity<T> = T;\n  export type flatten<T> = identity<{ [k in keyof T]: T[k] }>;\n\n  export type noNeverKeys<T> = {\n    [k in keyof T]: [T[k]] extends [never] ? never : k;\n  }[keyof T];\n\n  export type noNever<T> = identity<{\n    [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;\n  }>;\n\n  export const mergeShapes = <U, T>(first: U, second: T): T & U => {\n    return {\n      ...first,\n      ...second, // second overwrites first\n    };\n  };\n\n  export type extendShape<A extends object, B extends object> = keyof A & keyof B extends never // fast path when there is no keys overlap\n    ? A & B\n    : {\n        [K in keyof A as K extends keyof B ? never : K]: A[K];\n      } & {\n        [K in keyof B]: B[K];\n      };\n}\n\nexport const ZodParsedType: {\n  string: \"string\";\n  nan: \"nan\";\n  number: \"number\";\n  integer: \"integer\";\n  float: \"float\";\n  boolean: \"boolean\";\n  date: \"date\";\n  bigint: \"bigint\";\n  symbol: \"symbol\";\n  function: \"function\";\n  undefined: \"undefined\";\n  null: \"null\";\n  array: \"array\";\n  object: \"object\";\n  unknown: \"unknown\";\n  promise: \"promise\";\n  void: \"void\";\n  never: \"never\";\n  map: \"map\";\n  set: \"set\";\n} = util.arrayToEnum([\n  \"string\",\n  \"nan\",\n  \"number\",\n  \"integer\",\n  \"float\",\n  \"boolean\",\n  \"date\",\n  \"bigint\",\n  \"symbol\",\n  \"function\",\n  \"undefined\",\n  \"null\",\n  \"array\",\n  \"object\",\n  \"unknown\",\n  \"promise\",\n  \"void\",\n  \"never\",\n  \"map\",\n  \"set\",\n]);\n\nexport type ZodParsedType = keyof typeof ZodParsedType;\n\nexport const getParsedType = (data: any): ZodParsedType => {\n  const t = typeof data;\n\n  switch (t) {\n    case \"undefined\":\n      return ZodParsedType.undefined;\n\n    case \"string\":\n      return ZodParsedType.string;\n\n    case \"number\":\n      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n\n    case \"boolean\":\n      return ZodParsedType.boolean;\n\n    case \"function\":\n      return ZodParsedType.function;\n\n    case \"bigint\":\n      return ZodParsedType.bigint;\n\n    case \"symbol\":\n      return ZodParsedType.symbol;\n\n    case \"object\":\n      if (Array.isArray(data)) {\n        return ZodParsedType.array;\n      }\n      if (data === null) {\n        return ZodParsedType.null;\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return ZodParsedType.promise;\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return ZodParsedType.map;\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return ZodParsedType.set;\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return ZodParsedType.date;\n      }\n      return ZodParsedType.object;\n\n    default:\n      return ZodParsedType.unknown;\n  }\n};\n",
    "symbols": [
      {
        "name": "assertIs",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/util.ts",
        "startLine": 6,
        "endLine": 6
      },
      {
        "name": "assertNever",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/util.ts",
        "startLine": 7,
        "endLine": 9
      },
      {
        "name": "joinValues",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/helpers/util.ts",
        "startLine": 69,
        "endLine": 71
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/locales/en.ts",
    "content": "import { type ZodErrorMap, ZodIssueCode } from \"../ZodError.js\";\nimport { util, ZodParsedType } from \"../helpers/util.js\";\n\nconst errorMap: ZodErrorMap = (issue, _ctx) => {\n  let message: string;\n  switch (issue.code) {\n    case ZodIssueCode.invalid_type:\n      if (issue.received === ZodParsedType.undefined) {\n        message = \"Required\";\n      } else {\n        message = `Expected ${issue.expected}, received ${issue.received}`;\n      }\n      break;\n    case ZodIssueCode.invalid_literal:\n      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n      break;\n    case ZodIssueCode.unrecognized_keys:\n      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n      break;\n    case ZodIssueCode.invalid_union:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_union_discriminator:\n      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n      break;\n    case ZodIssueCode.invalid_enum_value:\n      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n      break;\n    case ZodIssueCode.invalid_arguments:\n      message = `Invalid function arguments`;\n      break;\n    case ZodIssueCode.invalid_return_type:\n      message = `Invalid function return type`;\n      break;\n    case ZodIssueCode.invalid_date:\n      message = `Invalid date`;\n      break;\n    case ZodIssueCode.invalid_string:\n      if (typeof issue.validation === \"object\") {\n        if (\"includes\" in issue.validation) {\n          message = `Invalid input: must include \"${issue.validation.includes}\"`;\n\n          if (typeof issue.validation.position === \"number\") {\n            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n          }\n        } else if (\"startsWith\" in issue.validation) {\n          message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n        } else if (\"endsWith\" in issue.validation) {\n          message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n        } else {\n          util.assertNever(issue.validation);\n        }\n      } else if (issue.validation !== \"regex\") {\n        message = `Invalid ${issue.validation}`;\n      } else {\n        message = \"Invalid\";\n      }\n      break;\n    case ZodIssueCode.too_small:\n      if (issue.type === \"array\")\n        message = `Array must contain ${\n          issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`\n        } ${issue.minimum} element(s)`;\n      else if (issue.type === \"string\")\n        message = `String must contain ${\n          issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`\n        } ${issue.minimum} character(s)`;\n      else if (issue.type === \"number\")\n        message = `Number must be ${\n          issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `\n        }${issue.minimum}`;\n      else if (issue.type === \"bigint\")\n        message = `Number must be ${\n          issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `\n        }${issue.minimum}`;\n      else if (issue.type === \"date\")\n        message = `Date must be ${\n          issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `\n        }${new Date(Number(issue.minimum))}`;\n      else message = \"Invalid input\";\n      break;\n    case ZodIssueCode.too_big:\n      if (issue.type === \"array\")\n        message = `Array must contain ${\n          issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`\n        } ${issue.maximum} element(s)`;\n      else if (issue.type === \"string\")\n        message = `String must contain ${\n          issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`\n        } ${issue.maximum} character(s)`;\n      else if (issue.type === \"number\")\n        message = `Number must be ${\n          issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`\n        } ${issue.maximum}`;\n      else if (issue.type === \"bigint\")\n        message = `BigInt must be ${\n          issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`\n        } ${issue.maximum}`;\n      else if (issue.type === \"date\")\n        message = `Date must be ${\n          issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`\n        } ${new Date(Number(issue.maximum))}`;\n      else message = \"Invalid input\";\n      break;\n    case ZodIssueCode.custom:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_intersection_types:\n      message = `Intersection results could not be merged`;\n      break;\n    case ZodIssueCode.not_multiple_of:\n      message = `Number must be a multiple of ${issue.multipleOf}`;\n      break;\n    case ZodIssueCode.not_finite:\n      message = \"Number must be finite\";\n      break;\n    default:\n      message = _ctx.defaultError;\n      util.assertNever(issue);\n  }\n  return { message };\n};\n\nexport default errorMap;\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/all-errors.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst Test = z.object({\n  f1: z.number(),\n  f2: z.string().optional(),\n  f3: z.string().nullable(),\n  f4: z.array(z.object({ t: z.union([z.string(), z.boolean()]) })),\n});\ntype TestFlattenedErrors = z.inferFlattenedErrors<typeof Test, { message: string; code: number }>;\ntype TestFormErrors = z.inferFlattenedErrors<typeof Test>;\n\ntest(\"default flattened errors type inference\", () => {\n  type TestTypeErrors = {\n    formErrors: string[];\n    fieldErrors: { [P in keyof z.TypeOf<typeof Test>]?: string[] | undefined };\n  };\n\n  util.assertEqual<z.inferFlattenedErrors<typeof Test>, TestTypeErrors>(true);\n  util.assertEqual<z.inferFlattenedErrors<typeof Test, { message: string }>, TestTypeErrors>(false);\n});\n\ntest(\"custom flattened errors type inference\", () => {\n  type ErrorType = { message: string; code: number };\n  type TestTypeErrors = {\n    formErrors: ErrorType[];\n    fieldErrors: {\n      [P in keyof z.TypeOf<typeof Test>]?: ErrorType[] | undefined;\n    };\n  };\n\n  util.assertEqual<z.inferFlattenedErrors<typeof Test>, TestTypeErrors>(false);\n  util.assertEqual<z.inferFlattenedErrors<typeof Test, { message: string; code: number }>, TestTypeErrors>(true);\n  util.assertEqual<z.inferFlattenedErrors<typeof Test, { message: string }>, TestTypeErrors>(false);\n});\n\ntest(\"form errors type inference\", () => {\n  type TestTypeErrors = {\n    formErrors: string[];\n    fieldErrors: { [P in keyof z.TypeOf<typeof Test>]?: string[] | undefined };\n  };\n\n  util.assertEqual<z.inferFlattenedErrors<typeof Test>, TestTypeErrors>(true);\n});\n\ntest(\".flatten() type assertion\", () => {\n  const parsed = Test.safeParse({}) as z.SafeParseError<void>;\n  const validFlattenedErrors: TestFlattenedErrors = parsed.error.flatten(() => ({ message: \"\", code: 0 }));\n  // @ts-expect-error should fail assertion between `TestFlattenedErrors` and unmapped `flatten()`.\n  const invalidFlattenedErrors: TestFlattenedErrors = parsed.error.flatten();\n  const validFormErrors: TestFormErrors = parsed.error.flatten();\n  // @ts-expect-error should fail assertion between `TestFormErrors` and mapped `flatten()`.\n  const invalidFormErrors: TestFormErrors = parsed.error.flatten(() => ({\n    message: \"string\",\n    code: 0,\n  }));\n\n  [validFlattenedErrors, invalidFlattenedErrors, validFormErrors, invalidFormErrors];\n});\n\ntest(\".formErrors type assertion\", () => {\n  const parsed = Test.safeParse({}) as z.SafeParseError<void>;\n  const validFormErrors: TestFormErrors = parsed.error.formErrors;\n  // @ts-expect-error should fail assertion between `TestFlattenedErrors` and `.formErrors`.\n  const invalidFlattenedErrors: TestFlattenedErrors = parsed.error.formErrors;\n\n  [validFormErrors, invalidFlattenedErrors];\n});\n\ntest(\"all errors\", () => {\n  const propertySchema = z.string();\n  const schema = z\n    .object({\n      a: propertySchema,\n      b: propertySchema,\n    })\n    .refine(\n      (val) => {\n        return val.a === val.b;\n      },\n      { message: \"Must be equal\" }\n    );\n\n  try {\n    schema.parse({\n      a: \"asdf\",\n      b: \"qwer\",\n    });\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      expect(error.flatten()).toEqual({\n        formErrors: [\"Must be equal\"],\n        fieldErrors: {},\n      });\n    }\n  }\n\n  try {\n    schema.parse({\n      a: null,\n      b: null,\n    });\n  } catch (_error) {\n    const error = _error as z.ZodError;\n    expect(error.flatten()).toEqual({\n      formErrors: [],\n      fieldErrors: {\n        a: [\"Expected string, received null\"],\n        b: [\"Expected string, received null\"],\n      },\n    });\n\n    expect(error.flatten((iss) => iss.message.toUpperCase())).toEqual({\n      formErrors: [],\n      fieldErrors: {\n        a: [\"EXPECTED STRING, RECEIVED NULL\"],\n        b: [\"EXPECTED STRING, RECEIVED NULL\"],\n      },\n    });\n    // Test identity\n\n    expect(error.flatten((i: z.ZodIssue) => i)).toEqual({\n      formErrors: [],\n      fieldErrors: {\n        a: [\n          {\n            code: \"invalid_type\",\n            expected: \"string\",\n            message: \"Expected string, received null\",\n            path: [\"a\"],\n            received: \"null\",\n          },\n        ],\n        b: [\n          {\n            code: \"invalid_type\",\n            expected: \"string\",\n            message: \"Expected string, received null\",\n            path: [\"b\"],\n            received: \"null\",\n          },\n        ],\n      },\n    });\n    // Test mapping\n    expect(error.flatten((i: z.ZodIssue) => i.message.length)).toEqual({\n      formErrors: [],\n      fieldErrors: {\n        a: [\"Expected string, received null\".length],\n        b: [\"Expected string, received null\".length],\n      },\n    });\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/anyunknown.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"check any inference\", () => {\n  const t1 = z.any();\n  t1.optional();\n  t1.nullable();\n  type t1 = z.infer<typeof t1>;\n  util.assertEqual<t1, any>(true);\n});\n\ntest(\"check unknown inference\", () => {\n  const t1 = z.unknown();\n  t1.optional();\n  t1.nullable();\n  type t1 = z.infer<typeof t1>;\n  util.assertEqual<t1, unknown>(true);\n});\n\ntest(\"check never inference\", () => {\n  const t1 = z.never();\n  expect(() => t1.parse(undefined)).toThrow();\n  expect(() => t1.parse(\"asdf\")).toThrow();\n  expect(() => t1.parse(null)).toThrow();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/array.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst minTwo = z.string().array().min(2);\nconst maxTwo = z.string().array().max(2);\nconst justTwo = z.string().array().length(2);\nconst intNum = z.string().array().nonempty();\nconst nonEmptyMax = z.string().array().nonempty().max(2);\n\ntype t1 = z.infer<typeof nonEmptyMax>;\nutil.assertEqual<[string, ...string[]], t1>(true);\n\ntype t2 = z.infer<typeof minTwo>;\nutil.assertEqual<string[], t2>(true);\n\ntest(\"passing validations\", () => {\n  minTwo.parse([\"a\", \"a\"]);\n  minTwo.parse([\"a\", \"a\", \"a\"]);\n  maxTwo.parse([\"a\", \"a\"]);\n  maxTwo.parse([\"a\"]);\n  justTwo.parse([\"a\", \"a\"]);\n  intNum.parse([\"a\"]);\n  nonEmptyMax.parse([\"a\"]);\n});\n\ntest(\"failing validations\", () => {\n  expect(() => minTwo.parse([\"a\"])).toThrow();\n  expect(() => maxTwo.parse([\"a\", \"a\", \"a\"])).toThrow();\n  expect(() => justTwo.parse([\"a\"])).toThrow();\n  expect(() => justTwo.parse([\"a\", \"a\", \"a\"])).toThrow();\n  expect(() => intNum.parse([])).toThrow();\n  expect(() => nonEmptyMax.parse([])).toThrow();\n  expect(() => nonEmptyMax.parse([\"a\", \"a\", \"a\"])).toThrow();\n});\n\ntest(\"parse empty array in nonempty\", () => {\n  expect(() =>\n    z\n      .array(z.string())\n      .nonempty()\n      .parse([] as any)\n  ).toThrow();\n});\n\ntest(\"get element\", () => {\n  justTwo.element.parse(\"asdf\");\n  expect(() => justTwo.element.parse(12)).toThrow();\n});\n\ntest(\"continue parsing despite array size error\", () => {\n  const schema = z.object({\n    people: z.string().array().min(2),\n  });\n\n  const result = schema.safeParse({\n    people: [123],\n  });\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues.length).toEqual(2);\n  }\n});\n\ntest(\"parse should fail given sparse array\", () => {\n  const schema = z.array(z.string()).nonempty().min(1).max(3);\n\n  expect(() => schema.parse(new Array(3))).toThrow();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/async-parsing.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\n/// string\nconst stringSchema = z.string();\n\ntest(\"string async parse\", async () => {\n  const goodData = \"XXX\";\n  const badData = 12;\n\n  const goodResult = await stringSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await stringSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// number\nconst numberSchema = z.number();\ntest(\"number async parse\", async () => {\n  const goodData = 1234.2353;\n  const badData = \"1234\";\n\n  const goodResult = await numberSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await numberSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// bigInt\nconst bigIntSchema = z.bigint();\ntest(\"bigInt async parse\", async () => {\n  const goodData = BigInt(145);\n  const badData = 134;\n\n  const goodResult = await bigIntSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await bigIntSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// boolean\nconst booleanSchema = z.boolean();\ntest(\"boolean async parse\", async () => {\n  const goodData = true;\n  const badData = 1;\n\n  const goodResult = await booleanSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await booleanSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// date\nconst dateSchema = z.date();\ntest(\"date async parse\", async () => {\n  const goodData = new Date();\n  const badData = new Date().toISOString();\n\n  const goodResult = await dateSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await dateSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// undefined\nconst undefinedSchema = z.undefined();\ntest(\"undefined async parse\", async () => {\n  const goodData = undefined;\n  const badData = \"XXX\";\n\n  const goodResult = await undefinedSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(undefined);\n\n  const badResult = await undefinedSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// null\nconst nullSchema = z.null();\ntest(\"null async parse\", async () => {\n  const goodData = null;\n  const badData = undefined;\n\n  const goodResult = await nullSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await nullSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// any\nconst anySchema = z.any();\ntest(\"any async parse\", async () => {\n  const goodData = [{}];\n  // const badData = 'XXX';\n\n  const goodResult = await anySchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  // const badResult = await anySchema.safeParseAsync(badData);\n  // expect(badResult.success).toBe(false);\n  // if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// unknown\nconst unknownSchema = z.unknown();\ntest(\"unknown async parse\", async () => {\n  const goodData = [\"asdf\", 124, () => {}];\n  // const badData = 'XXX';\n\n  const goodResult = await unknownSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  // const badResult = await unknownSchema.safeParseAsync(badData);\n  // expect(badResult.success).toBe(false);\n  // if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// void\nconst voidSchema = z.void();\ntest(\"void async parse\", async () => {\n  const goodData = undefined;\n  const badData = 0;\n\n  const goodResult = await voidSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await voidSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// array\nconst arraySchema = z.array(z.string());\ntest(\"array async parse\", async () => {\n  const goodData = [\"XXX\"];\n  const badData = \"XXX\";\n\n  const goodResult = await arraySchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await arraySchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// object\nconst objectSchema = z.object({ string: z.string() });\ntest(\"object async parse\", async () => {\n  const goodData = { string: \"XXX\" };\n  const badData = { string: 12 };\n\n  const goodResult = await objectSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await objectSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// union\nconst unionSchema = z.union([z.string(), z.undefined()]);\ntest(\"union async parse\", async () => {\n  const goodData = undefined;\n  const badData = null;\n\n  const goodResult = await unionSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await unionSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// record\nconst recordSchema = z.record(z.object({}));\ntest(\"record async parse\", async () => {\n  const goodData = { adsf: {}, asdf: {} };\n  const badData = [{}];\n\n  const goodResult = await recordSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await recordSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// function\nconst functionSchema = z.function();\ntest(\"function async parse\", async () => {\n  const goodData = () => {};\n  const badData = \"XXX\";\n\n  const goodResult = await functionSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(typeof goodResult.data).toEqual(\"function\");\n\n  const badResult = await functionSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// literal\nconst literalSchema = z.literal(\"asdf\");\ntest(\"literal async parse\", async () => {\n  const goodData = \"asdf\";\n  const badData = \"asdff\";\n\n  const goodResult = await literalSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await literalSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// enum\nconst enumSchema = z.enum([\"fish\", \"whale\"]);\ntest(\"enum async parse\", async () => {\n  const goodData = \"whale\";\n  const badData = \"leopard\";\n\n  const goodResult = await enumSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await enumSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// nativeEnum\nenum nativeEnumTest {\n  asdf = \"qwer\",\n}\n// @ts-ignore\nconst nativeEnumSchema = z.nativeEnum(nativeEnumTest);\ntest(\"nativeEnum async parse\", async () => {\n  const goodData = nativeEnumTest.asdf;\n  const badData = \"asdf\";\n\n  const goodResult = await nativeEnumSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await nativeEnumSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// promise\nconst promiseSchema = z.promise(z.number());\ntest(\"promise async parse good\", async () => {\n  const goodData = Promise.resolve(123);\n\n  const goodResult = await promiseSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) {\n    expect(goodResult.data).toBeInstanceOf(Promise);\n    const data = await goodResult.data;\n    expect(data).toEqual(123);\n    // expect(goodResult.data).resolves.toEqual(124);\n    // return goodResult.data;\n  } else {\n    throw new Error(\"success should be true\");\n  }\n});\n\ntest(\"promise async parse bad\", async () => {\n  const badData = Promise.resolve(\"XXX\");\n  const badResult = await promiseSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(true);\n  if (badResult.success) {\n    await expect(badResult.data).rejects.toBeInstanceOf(z.ZodError);\n  } else {\n    throw new Error(\"success should be true\");\n  }\n});\n\ntest(\"async validation non-empty strings\", async () => {\n  const base = z.object({\n    hello: z.string().refine((x) => x && x.length > 0),\n    foo: z.string().refine((x) => x && x.length > 0),\n  });\n\n  const testval = { hello: \"\", foo: \"\" };\n  const result1 = base.safeParse(testval);\n  const result2 = base.safeParseAsync(testval);\n\n  const r1 = result1;\n  await result2.then((r2) => {\n    if (r1.success === false && r2.success === false) expect(r1.error.issues.length).toBe(r2.error.issues.length); // <--- r1 has length 2, r2 has length 1\n  });\n});\n\ntest(\"async validation multiple errors 1\", async () => {\n  const base = z.object({\n    hello: z.string(),\n    foo: z.number(),\n  });\n\n  const testval = { hello: 3, foo: \"hello\" };\n  const result1 = base.safeParse(testval);\n  const result2 = base.safeParseAsync(testval);\n\n  const r1 = result1;\n  await result2.then((r2) => {\n    if (r1.success === false && r2.success === false) expect(r2.error.issues.length).toBe(r1.error.issues.length);\n  });\n});\n\ntest(\"async validation multiple errors 2\", async () => {\n  const base = (is_async?: boolean) =>\n    z.object({\n      hello: z.string(),\n      foo: z.object({\n        bar: z.number().refine(is_async ? async () => false : () => false),\n      }),\n    });\n\n  const testval = { hello: 3, foo: { bar: 4 } };\n  const result1 = base().safeParse(testval);\n  const result2 = base(true).safeParseAsync(testval);\n\n  const r1 = result1;\n  await result2.then((r2) => {\n    if (r1.success === false && r2.success === false) expect(r2.error.issues.length).toBe(r1.error.issues.length);\n  });\n});\n\ntest(\"ensure early async failure prevents follow-up refinement checks\", async () => {\n  let count = 0;\n  const base = z.object({\n    hello: z.string(),\n    foo: z\n      .number()\n      .refine(async () => {\n        count++;\n        return true;\n      })\n      .refine(async () => {\n        count++;\n        return true;\n      }, \"Good\"),\n  });\n\n  const testval = { hello: \"bye\", foo: 3 };\n  const result = await base.safeParseAsync(testval);\n  if (result.success === false) {\n    expect(result.error.issues.length).toBe(1);\n    expect(count).toBe(1);\n  }\n\n  // await result.then((r) => {\n  //   if (r.success === false) expect(r.error.issues.length).toBe(1);\n  //   expect(count).toBe(2);\n  // });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/async-refinements.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"parse async test\", async () => {\n  const schema1 = z.string().refine(async (_val) => false);\n  expect(() => schema1.parse(\"asdf\")).toThrow();\n\n  const schema2 = z.string().refine((_val) => Promise.resolve(true));\n  return await expect(() => schema2.parse(\"asdf\")).toThrow();\n});\n\ntest(\"parseAsync async test\", async () => {\n  const schema1 = z.string().refine(async (_val) => true);\n  await schema1.parseAsync(\"asdf\");\n\n  const schema2 = z.string().refine(async (_val) => false);\n  return await expect(schema2.parseAsync(\"asdf\")).rejects.toBeDefined();\n  // expect(async () => await schema2.parseAsync('asdf')).toThrow();\n});\n\ntest(\"parseAsync async test\", async () => {\n  // expect.assertions(2);\n\n  const schema1 = z.string().refine((_val) => Promise.resolve(true));\n  const v1 = await schema1.parseAsync(\"asdf\");\n  expect(v1).toEqual(\"asdf\");\n\n  const schema2 = z.string().refine((_val) => Promise.resolve(false));\n  await expect(schema2.parseAsync(\"asdf\")).rejects.toBeDefined();\n\n  const schema3 = z.string().refine((_val) => Promise.resolve(true));\n  await expect(schema3.parseAsync(\"asdf\")).resolves.toEqual(\"asdf\");\n  return await expect(schema3.parseAsync(\"qwer\")).resolves.toEqual(\"qwer\");\n});\n\ntest(\"parseAsync async with value\", async () => {\n  const schema1 = z.string().refine(async (val) => {\n    return val.length > 5;\n  });\n  await expect(schema1.parseAsync(\"asdf\")).rejects.toBeDefined();\n\n  const v = await schema1.parseAsync(\"asdf123\");\n  return await expect(v).toEqual(\"asdf123\");\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/base.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"type guard\", () => {\n  const stringToNumber = z.string().transform((arg) => arg.length);\n\n  const s1 = z.object({\n    stringToNumber,\n  });\n  type t1 = z.input<typeof s1>;\n\n  const data = { stringToNumber: \"asdf\" };\n  const parsed = s1.safeParse(data);\n  if (parsed.success) {\n    util.assertEqual<typeof data, t1>(true);\n  }\n});\n\ntest(\"test this binding\", () => {\n  const callback = (predicate: (val: string) => boolean) => {\n    return predicate(\"hello\");\n  };\n\n  expect(callback((value) => z.string().safeParse(value).success)).toBe(true); // true\n  expect(callback((value) => z.string().safeParse(value).success)).toBe(true); // true\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/bigint.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst gtFive = z.bigint().gt(BigInt(5));\nconst gteFive = z.bigint().gte(BigInt(5));\nconst ltFive = z.bigint().lt(BigInt(5));\nconst lteFive = z.bigint().lte(BigInt(5));\nconst positive = z.bigint().positive();\nconst negative = z.bigint().negative();\nconst nonnegative = z.bigint().nonnegative();\nconst nonpositive = z.bigint().nonpositive();\nconst multipleOfFive = z.bigint().multipleOf(BigInt(5));\n\ntest(\"passing validations\", () => {\n  z.bigint().parse(BigInt(1));\n  z.bigint().parse(BigInt(0));\n  z.bigint().parse(BigInt(-1));\n  gtFive.parse(BigInt(6));\n  gteFive.parse(BigInt(5));\n  gteFive.parse(BigInt(6));\n  ltFive.parse(BigInt(4));\n  lteFive.parse(BigInt(5));\n  lteFive.parse(BigInt(4));\n  positive.parse(BigInt(3));\n  negative.parse(BigInt(-2));\n  nonnegative.parse(BigInt(0));\n  nonnegative.parse(BigInt(7));\n  nonpositive.parse(BigInt(0));\n  nonpositive.parse(BigInt(-12));\n  multipleOfFive.parse(BigInt(15));\n});\n\ntest(\"failing validations\", () => {\n  expect(() => gtFive.parse(BigInt(5))).toThrow();\n  expect(() => gteFive.parse(BigInt(4))).toThrow();\n  expect(() => ltFive.parse(BigInt(5))).toThrow();\n  expect(() => lteFive.parse(BigInt(6))).toThrow();\n  expect(() => positive.parse(BigInt(0))).toThrow();\n  expect(() => positive.parse(BigInt(-2))).toThrow();\n  expect(() => negative.parse(BigInt(0))).toThrow();\n  expect(() => negative.parse(BigInt(3))).toThrow();\n  expect(() => nonnegative.parse(BigInt(-1))).toThrow();\n  expect(() => nonpositive.parse(BigInt(1))).toThrow();\n  expect(() => multipleOfFive.parse(BigInt(13))).toThrow();\n});\n\ntest(\"min max getters\", () => {\n  expect(z.bigint().min(BigInt(5)).minValue).toEqual(BigInt(5));\n  expect(z.bigint().min(BigInt(5)).min(BigInt(10)).minValue).toEqual(BigInt(10));\n\n  expect(z.bigint().max(BigInt(5)).maxValue).toEqual(BigInt(5));\n  expect(z.bigint().max(BigInt(5)).max(BigInt(1)).maxValue).toEqual(BigInt(1));\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/branded.test.ts",
    "content": "// @ts-ignore TS6133\nimport { test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"branded types\", () => {\n  const mySchema = z\n    .object({\n      name: z.string(),\n    })\n    .brand<\"superschema\">();\n\n  // simple branding\n  type MySchema = z.infer<typeof mySchema>;\n  util.assertEqual<MySchema, { name: string } & { [z.BRAND]: { superschema: true } }>(true);\n\n  const doStuff = (arg: MySchema) => arg;\n  doStuff(mySchema.parse({ name: \"hello there\" }));\n\n  // inheritance\n  const extendedSchema = mySchema.brand<\"subschema\">();\n  type ExtendedSchema = z.infer<typeof extendedSchema>;\n  util.assertEqual<ExtendedSchema, { name: string } & z.BRAND<\"superschema\"> & z.BRAND<\"subschema\">>(true);\n\n  doStuff(extendedSchema.parse({ name: \"hello again\" }));\n\n  // number branding\n  const numberSchema = z.number().brand<42>();\n  type NumberSchema = z.infer<typeof numberSchema>;\n  util.assertEqual<NumberSchema, number & { [z.BRAND]: { 42: true } }>(true);\n\n  // symbol branding\n  const MyBrand: unique symbol = Symbol(\"hello\");\n  type MyBrand = typeof MyBrand;\n  const symbolBrand = z.number().brand<\"sup\">().brand<typeof MyBrand>();\n  type SymbolBrand = z.infer<typeof symbolBrand>;\n  // number & { [z.BRAND]: { sup: true, [MyBrand]: true } }\n  util.assertEqual<SymbolBrand, number & z.BRAND<\"sup\"> & z.BRAND<MyBrand>>(true);\n\n  // keeping brands out of input types\n  const age = z.number().brand<\"age\">();\n\n  type Age = z.infer<typeof age>;\n  type AgeInput = z.input<typeof age>;\n\n  util.assertEqual<AgeInput, Age>(false);\n  util.assertEqual<number, AgeInput>(true);\n  util.assertEqual<number & z.BRAND<\"age\">, Age>(true);\n\n  // @ts-expect-error\n  doStuff({ name: \"hello there!\" });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/catch.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport { z } from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"basic catch\", () => {\n  expect(z.string().catch(\"default\").parse(undefined)).toBe(\"default\");\n});\n\ntest(\"catch fn does not run when parsing succeeds\", () => {\n  let isCalled = false;\n  const cb = () => {\n    isCalled = true;\n    return \"asdf\";\n  };\n  expect(z.string().catch(cb).parse(\"test\")).toBe(\"test\");\n  expect(isCalled).toEqual(false);\n});\n\ntest(\"basic catch async\", async () => {\n  const result = await z.string().catch(\"default\").parseAsync(1243);\n  expect(result).toBe(\"default\");\n});\n\ntest(\"catch replace wrong types\", () => {\n  expect(z.string().catch(\"default\").parse(true)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(true)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(15)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse([])).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(new Map())).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(new Set())).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse({})).toBe(\"default\");\n});\n\ntest(\"catch with transform\", () => {\n  const stringWithDefault = z\n    .string()\n    .transform((val) => val.toUpperCase())\n    .catch(\"default\");\n  expect(stringWithDefault.parse(undefined)).toBe(\"default\");\n  expect(stringWithDefault.parse(15)).toBe(\"default\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodCatch);\n  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodEffects);\n  expect(stringWithDefault._def.innerType._def.schema).toBeInstanceOf(z.ZodSchema);\n\n  type inp = z.input<typeof stringWithDefault>;\n  util.assertEqual<inp, unknown>(true);\n  type out = z.output<typeof stringWithDefault>;\n  util.assertEqual<out, string>(true);\n});\n\ntest(\"catch on existing optional\", () => {\n  const stringWithDefault = z.string().optional().catch(\"asdf\");\n  expect(stringWithDefault.parse(undefined)).toBe(undefined);\n  expect(stringWithDefault.parse(15)).toBe(\"asdf\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodCatch);\n  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodOptional);\n  expect(stringWithDefault._def.innerType._def.innerType).toBeInstanceOf(z.ZodString);\n\n  type inp = z.input<typeof stringWithDefault>;\n  util.assertEqual<inp, unknown>(true);\n  type out = z.output<typeof stringWithDefault>;\n  util.assertEqual<out, string | undefined>(true);\n});\n\ntest(\"optional on catch\", () => {\n  const stringWithDefault = z.string().catch(\"asdf\").optional();\n\n  type inp = z.input<typeof stringWithDefault>;\n  util.assertEqual<inp, unknown>(true);\n  type out = z.output<typeof stringWithDefault>;\n  util.assertEqual<out, string | undefined>(true);\n});\n\ntest(\"complex chain example\", () => {\n  const complex = z\n    .string()\n    .catch(\"asdf\")\n    .transform((val) => val + \"!\")\n    .transform((val) => val.toUpperCase())\n    .catch(\"qwer\")\n    .removeCatch()\n    .optional()\n    .catch(\"asdfasdf\");\n\n  expect(complex.parse(\"qwer\")).toBe(\"QWER!\");\n  expect(complex.parse(15)).toBe(\"ASDF!\");\n  expect(complex.parse(true)).toBe(\"ASDF!\");\n});\n\ntest(\"removeCatch\", () => {\n  const stringWithRemovedDefault = z.string().catch(\"asdf\").removeCatch();\n\n  type out = z.output<typeof stringWithRemovedDefault>;\n  util.assertEqual<out, string>(true);\n});\n\ntest(\"nested\", () => {\n  const inner = z.string().catch(\"asdf\");\n  const outer = z.object({ inner }).catch({\n    inner: \"asdf\",\n  });\n  type input = z.input<typeof outer>;\n  util.assertEqual<input, unknown>(true);\n  type out = z.output<typeof outer>;\n  util.assertEqual<out, { inner: string }>(true);\n  expect(outer.parse(undefined)).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({})).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({ inner: undefined })).toEqual({ inner: \"asdf\" });\n});\n\ntest(\"chained catch\", () => {\n  const stringWithDefault = z.string().catch(\"inner\").catch(\"outer\");\n  const result = stringWithDefault.parse(undefined);\n  expect(result).toEqual(\"inner\");\n  const resultDiff = stringWithDefault.parse(5);\n  expect(resultDiff).toEqual(\"inner\");\n});\n\ntest(\"factory\", () => {\n  z.ZodCatch.create(z.string(), {\n    catch: \"asdf\",\n  }).parse(undefined);\n});\n\ntest(\"native enum\", () => {\n  enum Fruits {\n    apple = \"apple\",\n    orange = \"orange\",\n  }\n\n  const schema = z.object({\n    fruit: z.nativeEnum(Fruits).catch(Fruits.apple),\n  });\n\n  expect(schema.parse({})).toEqual({ fruit: Fruits.apple });\n  expect(schema.parse({ fruit: 15 })).toEqual({ fruit: Fruits.apple });\n});\n\ntest(\"enum\", () => {\n  const schema = z.object({\n    fruit: z.enum([\"apple\", \"orange\"]).catch(\"apple\"),\n  });\n\n  expect(schema.parse({})).toEqual({ fruit: \"apple\" });\n  expect(schema.parse({ fruit: true })).toEqual({ fruit: \"apple\" });\n  expect(schema.parse({ fruit: 15 })).toEqual({ fruit: \"apple\" });\n});\n\ntest(\"reported issues with nested usage\", () => {\n  const schema = z.object({\n    string: z.string(),\n    obj: z.object({\n      sub: z.object({\n        lit: z.literal(\"a\"),\n        subCatch: z.number().catch(23),\n      }),\n      midCatch: z.number().catch(42),\n    }),\n    number: z.number().catch(0),\n    bool: z.boolean(),\n  });\n\n  try {\n    schema.parse({\n      string: {},\n      obj: {\n        sub: {\n          lit: \"b\",\n          subCatch: \"24\",\n        },\n        midCatch: 444,\n      },\n      number: \"\",\n      bool: \"yes\",\n    });\n  } catch (error) {\n    const issues = (error as z.ZodError).issues;\n\n    expect(issues.length).toEqual(3);\n    expect(issues[0].message).toMatch(\"string\");\n    expect(issues[1].message).toMatch(\"literal\");\n    expect(issues[2].message).toMatch(\"boolean\");\n  }\n});\n\ntest(\"catch error\", () => {\n  let catchError: z.ZodError | undefined = undefined;\n\n  const schema = z.object({\n    age: z.number(),\n    name: z.string().catch((ctx) => {\n      catchError = ctx.error;\n\n      return \"John Doe\";\n    }),\n  });\n\n  const result = schema.safeParse({\n    age: null,\n    name: null,\n  });\n\n  expect(result.success).toEqual(false);\n  expect(!result.success && result.error.issues.length).toEqual(1);\n  expect(!result.success && result.error.issues[0].message).toMatch(\"number\");\n\n  expect(catchError).toBeInstanceOf(z.ZodError);\n  expect(catchError !== undefined && (catchError as z.ZodError).issues.length).toEqual(1);\n  expect(catchError !== undefined && (catchError as z.ZodError).issues[0].message).toMatch(\"string\");\n});\n\ntest(\"ctx.input\", () => {\n  const schema = z.string().catch((ctx) => {\n    return String(ctx.input);\n  });\n\n  expect(schema.parse(123)).toEqual(\"123\");\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/coerce.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"string coercion\", () => {\n  const schema = z.coerce.string();\n  expect(schema.parse(\"sup\")).toEqual(\"sup\");\n  expect(schema.parse(\"\")).toEqual(\"\");\n  expect(schema.parse(12)).toEqual(\"12\");\n  expect(schema.parse(0)).toEqual(\"0\");\n  expect(schema.parse(-12)).toEqual(\"-12\");\n  expect(schema.parse(3.14)).toEqual(\"3.14\");\n  expect(schema.parse(BigInt(15))).toEqual(\"15\");\n  expect(schema.parse(Number.NaN)).toEqual(\"NaN\");\n  expect(schema.parse(Number.POSITIVE_INFINITY)).toEqual(\"Infinity\");\n  expect(schema.parse(Number.NEGATIVE_INFINITY)).toEqual(\"-Infinity\");\n  expect(schema.parse(true)).toEqual(\"true\");\n  expect(schema.parse(false)).toEqual(\"false\");\n  expect(schema.parse(null)).toEqual(\"null\");\n  expect(schema.parse(undefined)).toEqual(\"undefined\");\n  expect(schema.parse({ hello: \"world!\" })).toEqual(\"[object Object]\");\n  expect(schema.parse([\"item\", \"another_item\"])).toEqual(\"item,another_item\");\n  expect(schema.parse([])).toEqual(\"\");\n  expect(schema.parse(new Date(\"2022-01-01T00:00:00.000Z\"))).toEqual(new Date(\"2022-01-01T00:00:00.000Z\").toString());\n});\n\ntest(\"number coercion\", () => {\n  const schema = z.coerce.number();\n  expect(schema.parse(\"12\")).toEqual(12);\n  expect(schema.parse(\"0\")).toEqual(0);\n  expect(schema.parse(\"-12\")).toEqual(-12);\n  expect(schema.parse(\"3.14\")).toEqual(3.14);\n  expect(schema.parse(\"\")).toEqual(0);\n  expect(() => schema.parse(\"NOT_A_NUMBER\")).toThrow(); // z.ZodError\n  expect(schema.parse(12)).toEqual(12);\n  expect(schema.parse(0)).toEqual(0);\n  expect(schema.parse(-12)).toEqual(-12);\n  expect(schema.parse(3.14)).toEqual(3.14);\n  expect(schema.parse(BigInt(15))).toEqual(15);\n  expect(() => schema.parse(Number.NaN)).toThrow(); // z.ZodError\n  expect(schema.parse(Number.POSITIVE_INFINITY)).toEqual(Number.POSITIVE_INFINITY);\n  expect(schema.parse(Number.NEGATIVE_INFINITY)).toEqual(Number.NEGATIVE_INFINITY);\n  expect(schema.parse(true)).toEqual(1);\n  expect(schema.parse(false)).toEqual(0);\n  expect(schema.parse(null)).toEqual(0);\n  expect(() => schema.parse(undefined)).toThrow(); // z.ZodError\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // z.ZodError\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // z.ZodError\n  expect(schema.parse([])).toEqual(0);\n  expect(schema.parse(new Date(1670139203496))).toEqual(1670139203496);\n});\n\ntest(\"boolean coercion\", () => {\n  const schema = z.coerce.boolean();\n  expect(schema.parse(\"true\")).toEqual(true);\n  expect(schema.parse(\"false\")).toEqual(true);\n  expect(schema.parse(\"0\")).toEqual(true);\n  expect(schema.parse(\"1\")).toEqual(true);\n  expect(schema.parse(\"\")).toEqual(false);\n  expect(schema.parse(1)).toEqual(true);\n  expect(schema.parse(0)).toEqual(false);\n  expect(schema.parse(-1)).toEqual(true);\n  expect(schema.parse(3.14)).toEqual(true);\n  expect(schema.parse(BigInt(15))).toEqual(true);\n  expect(schema.parse(Number.NaN)).toEqual(false);\n  expect(schema.parse(Number.POSITIVE_INFINITY)).toEqual(true);\n  expect(schema.parse(Number.NEGATIVE_INFINITY)).toEqual(true);\n  expect(schema.parse(true)).toEqual(true);\n  expect(schema.parse(false)).toEqual(false);\n  expect(schema.parse(null)).toEqual(false);\n  expect(schema.parse(undefined)).toEqual(false);\n  expect(schema.parse({ hello: \"world!\" })).toEqual(true);\n  expect(schema.parse([\"item\", \"another_item\"])).toEqual(true);\n  expect(schema.parse([])).toEqual(true);\n  expect(schema.parse(new Date(1670139203496))).toEqual(true);\n});\n\ntest(\"bigint coercion\", () => {\n  const schema = z.coerce.bigint();\n  expect(schema.parse(\"5\")).toEqual(BigInt(5));\n  expect(schema.parse(\"0\")).toEqual(BigInt(0));\n  expect(schema.parse(\"-5\")).toEqual(BigInt(-5));\n  expect(() => schema.parse(\"3.14\")).toThrow(); // not a z.ZodError!\n  expect(schema.parse(\"\")).toEqual(BigInt(0));\n  expect(() => schema.parse(\"NOT_A_NUMBER\")).toThrow(); // not a z.ZodError!\n  expect(schema.parse(5)).toEqual(BigInt(5));\n  expect(schema.parse(0)).toEqual(BigInt(0));\n  expect(schema.parse(-5)).toEqual(BigInt(-5));\n  expect(() => schema.parse(3.14)).toThrow(); // not a z.ZodError!\n  expect(schema.parse(BigInt(5))).toEqual(BigInt(5));\n  expect(() => schema.parse(Number.NaN)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.POSITIVE_INFINITY)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.NEGATIVE_INFINITY)).toThrow(); // not a z.ZodError!\n  expect(schema.parse(true)).toEqual(BigInt(1));\n  expect(schema.parse(false)).toEqual(BigInt(0));\n  expect(() => schema.parse(null)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(undefined)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // not a z.ZodError!\n  expect(schema.parse([])).toEqual(BigInt(0));\n  expect(schema.parse(new Date(1670139203496))).toEqual(BigInt(1670139203496));\n});\n\ntest(\"date coercion\", () => {\n  const schema = z.coerce.date();\n  expect(schema.parse(new Date().toDateString())).toBeInstanceOf(Date);\n  expect(schema.parse(new Date().toISOString())).toBeInstanceOf(Date);\n  expect(schema.parse(new Date().toUTCString())).toBeInstanceOf(Date);\n  expect(schema.parse(\"5\")).toBeInstanceOf(Date);\n  expect(schema.parse(\"2000-01-01\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"0\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"-5\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"3.14\")).toBeInstanceOf(Date);\n  expect(() => schema.parse(\"\")).toThrow(); // z.ZodError\n  expect(() => schema.parse(\"NOT_A_DATE\")).toThrow(); // z.ZodError\n  expect(schema.parse(5)).toBeInstanceOf(Date);\n  expect(schema.parse(0)).toBeInstanceOf(Date);\n  expect(schema.parse(-5)).toBeInstanceOf(Date);\n  expect(schema.parse(3.14)).toBeInstanceOf(Date);\n  expect(() => schema.parse(BigInt(5))).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.NaN)).toThrow(); // z.ZodError\n  expect(() => schema.parse(Number.POSITIVE_INFINITY)).toThrow(); // z.ZodError\n  expect(() => schema.parse(Number.NEGATIVE_INFINITY)).toThrow(); // z.ZodError\n  expect(schema.parse(true)).toBeInstanceOf(Date);\n  expect(schema.parse(false)).toBeInstanceOf(Date);\n  expect(schema.parse(null)).toBeInstanceOf(Date);\n  expect(() => schema.parse(undefined)).toThrow(); // z.ZodError\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // z.ZodError\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // z.ZodError\n  expect(() => schema.parse([])).toThrow(); // z.ZodError\n  expect(schema.parse(new Date())).toBeInstanceOf(Date);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/complex.test.ts",
    "content": "import { test } from \"vitest\";\nimport * as z from \"zod/v3\";\n\nconst crazySchema = z.object({\n  tuple: z.tuple([\n    z.string().nullable().optional(),\n    z.number().nullable().optional(),\n    z.boolean().nullable().optional(),\n    z.null().nullable().optional(),\n    z.undefined().nullable().optional(),\n    z.literal(\"1234\").nullable().optional(),\n  ]),\n  merged: z\n    .object({\n      k1: z.string().optional(),\n    })\n    .merge(z.object({ k1: z.string().nullable(), k2: z.number() })),\n  union: z.array(z.union([z.literal(\"asdf\"), z.literal(12)])).nonempty(),\n  array: z.array(z.number()),\n  // sumTransformer: z.transformer(z.array(z.number()), z.number(), (arg) => {\n  //   return arg.reduce((a, b) => a + b, 0);\n  // }),\n  sumMinLength: z.array(z.number()).refine((arg) => arg.length > 5),\n  intersection: z.intersection(z.object({ p1: z.string().optional() }), z.object({ p1: z.number().optional() })),\n  enum: z.intersection(z.enum([\"zero\", \"one\"]), z.enum([\"one\", \"two\"])),\n  nonstrict: z.object({ points: z.number() }).nonstrict(),\n  numProm: z.promise(z.number()),\n  lenfun: z.function(z.tuple([z.string()]), z.boolean()),\n});\n\n// const asyncCrazySchema = crazySchema.extend({\n//   // async_transform: z.transformer(\n//   //   z.array(z.number()),\n//   //   z.number(),\n//   //   async (arg) => {\n//   //     return arg.reduce((a, b) => a + b, 0);\n//   //   }\n//   // ),\n//   async_refine: z.array(z.number()).refine(async (arg) => arg.length > 5),\n// });\n\ntest(\"parse\", () => {\n  crazySchema.parse({\n    tuple: [\"asdf\", 1234, true, null, undefined, \"1234\"],\n    merged: { k1: \"asdf\", k2: 12 },\n    union: [\"asdf\", 12, \"asdf\", 12, \"asdf\", 12],\n    array: [12, 15, 16],\n    // sumTransformer: [12, 15, 16],\n    sumMinLength: [12, 15, 16, 98, 24, 63],\n    intersection: {},\n    enum: \"one\",\n    nonstrict: { points: 1234 },\n    numProm: Promise.resolve(12),\n    lenfun: (x: string) => x.length,\n  });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/custom.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"passing validations\", () => {\n  const example1 = z.custom<number>((x) => typeof x === \"number\");\n  example1.parse(1234);\n  expect(() => example1.parse({})).toThrow();\n});\n\ntest(\"string params\", () => {\n  const example1 = z.custom<number>((x) => typeof x !== \"number\", \"customerr\");\n  const result = example1.safeParse(1234);\n  expect(result.success).toEqual(false);\n  // @ts-ignore\n  expect(JSON.stringify(result.error).includes(\"customerr\")).toEqual(true);\n});\n\ntest(\"async validations\", async () => {\n  const example1 = z.custom<number>(async (x) => {\n    return typeof x === \"number\";\n  });\n  const r1 = await example1.safeParseAsync(1234);\n  expect(r1.success).toEqual(true);\n  expect(r1.data).toEqual(1234);\n\n  const r2 = await example1.safeParseAsync(\"asdf\");\n  expect(r2.success).toEqual(false);\n  expect(r2.error!.issues.length).toEqual(1);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/date.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst beforeBenchmarkDate = new Date(2022, 10, 4);\nconst benchmarkDate = new Date(2022, 10, 5);\nconst afterBenchmarkDate = new Date(2022, 10, 6);\n\nconst minCheck = z.date().min(benchmarkDate);\nconst maxCheck = z.date().max(benchmarkDate);\n\ntest(\"passing validations\", () => {\n  minCheck.parse(benchmarkDate);\n  minCheck.parse(afterBenchmarkDate);\n\n  maxCheck.parse(benchmarkDate);\n  maxCheck.parse(beforeBenchmarkDate);\n});\n\ntest(\"failing validations\", () => {\n  expect(() => minCheck.parse(beforeBenchmarkDate)).toThrow();\n  expect(() => maxCheck.parse(afterBenchmarkDate)).toThrow();\n});\n\ntest(\"min max getters\", () => {\n  expect(minCheck.minDate).toEqual(benchmarkDate);\n  expect(minCheck.min(afterBenchmarkDate).minDate).toEqual(afterBenchmarkDate);\n\n  expect(maxCheck.maxDate).toEqual(benchmarkDate);\n  expect(maxCheck.max(beforeBenchmarkDate).maxDate).toEqual(beforeBenchmarkDate);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/deepmasking.test.ts",
    "content": "// @ts-ignore TS6133\nimport { test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"test\", () => {\n  z;\n});\n\n// const fish = z.object({\n//   name: z.string(),\n//   props: z.object({\n//     color: z.string(),\n//     numScales: z.number(),\n//   }),\n// });\n\n// const nonStrict = z\n//   .object({\n//     name: z.string(),\n//     color: z.string(),\n//   })\n//   .nonstrict();\n\n// test('object pick type', () => {\n//   const modNonStrictFish = nonStrict.omit({ name: true });\n//   modNonStrictFish.parse({ color: 'asdf' });\n\n//   const bad1 = () => fish.pick({ props: { unknown: true } } as any);\n//   const bad2 = () => fish.omit({ name: true, props: { unknown: true } } as any);\n\n//   expect(bad1).toThrow();\n//   expect(bad2).toThrow();\n// });\n\n// test('f1', () => {\n//   const f1 = fish.pick(true);\n//   f1.parse({ name: 'a', props: { color: 'b', numScales: 3 } });\n// });\n// test('f2', () => {\n//   const f2 = fish.pick({ props: true });\n//   f2.parse({ props: { color: 'asdf', numScales: 1 } });\n//   const badcheck2 = () => f2.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);\n//   expect(badcheck2).toThrow();\n// });\n// test('f3', () => {\n//   const f3 = fish.pick({ props: { color: true } });\n//   f3.parse({ props: { color: 'b' } });\n//   const badcheck3 = () => f3.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);\n//   expect(badcheck3).toThrow();\n// });\n// test('f4', () => {\n//   const badcheck4 = () => fish.pick({ props: { color: true, unknown: true } });\n//   expect(badcheck4).toThrow();\n// });\n// test('f6', () => {\n//   const f6 = fish.omit({ props: true });\n//   const badcheck6 = () => f6.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);\n//   f6.parse({ name: 'adsf' });\n//   expect(badcheck6).toThrow();\n// });\n// test('f7', () => {\n//   const f7 = fish.omit({ props: { color: true } });\n//   f7.parse({ name: 'a', props: { numScales: 3 } });\n//   const badcheck7 = () => f7.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);\n//   expect(badcheck7).toThrow();\n// });\n// test('f8', () => {\n//   const badcheck8 = () => fish.omit({ props: { color: true, unknown: true } });\n//   expect(badcheck8).toThrow();\n// });\n// test('f9', () => {\n//   const f9 = nonStrict.pick(true);\n//   f9.parse({ name: 'a', color: 'asdf' });\n// });\n// test('f10', () => {\n//   const f10 = nonStrict.pick({ name: true });\n//   f10.parse({ name: 'a' });\n//   const val = f10.parse({ name: 'a', color: 'b' });\n//   expect(val).toEqual({ name: 'a' });\n// });\n// test('f12', () => {\n//   const badfcheck12 = () => nonStrict.omit({ color: true, asdf: true });\n//   expect(badfcheck12).toThrow();\n// });\n\n// test('array masking', () => {\n//   const fishArray = z.array(fish);\n//   const modFishArray = fishArray.pick({\n//     name: true,\n//     props: {\n//       numScales: true,\n//     },\n//   });\n\n//   modFishArray.parse([{ name: 'fish', props: { numScales: 12 } }]);\n//   const bad1 = () => modFishArray.parse([{ name: 'fish', props: { numScales: 12, color: 'asdf' } }] as any);\n//   expect(bad1).toThrow();\n// });\n\n// test('array masking', () => {\n//   const fishArray = z.array(fish);\n//   const fail = () =>\n//     fishArray.pick({\n//       name: true,\n//       props: {\n//         whatever: true,\n//       },\n//     } as any);\n//   expect(fail).toThrow();\n// });\n\n// test('array masking', () => {\n//   const fishArray = z.array(fish);\n//   const fail = () =>\n//     fishArray.omit({\n//       whateve: true,\n//     } as any);\n//   expect(fail).toThrow();\n// });\n\n// test('array masking', () => {\n//   const fishArray = z.array(fish);\n//   const modFishList = fishArray.omit({\n//     name: true,\n//     props: {\n//       color: true,\n//     },\n//   });\n\n//   modFishList.parse([{ props: { numScales: 12 } }]);\n//   const fail = () => modFishList.parse([{ name: 'hello', props: { numScales: 12 } }] as any);\n//   expect(fail).toThrow();\n// });\n\n// test('primitive array masking', () => {\n//   const fishArray = z.array(z.number());\n//   const fail = () => fishArray.pick({} as any);\n//   expect(fail).toThrow();\n// });\n\n// test('other array masking', () => {\n//   const fishArray = z.array(z.array(z.number()));\n//   const fail = () => fishArray.pick({} as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #1', () => {\n//   const fail = () => fish.pick(1 as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #2', () => {\n//   const fail = () => fish.pick([] as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #3', () => {\n//   const fail = () => fish.pick(false as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #4', () => {\n//   const fail = () => fish.pick('asdf' as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #5', () => {\n//   const fail = () => fish.omit(1 as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #6', () => {\n//   const fail = () => fish.omit([] as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #7', () => {\n//   const fail = () => fish.omit(false as any);\n//   expect(fail).toThrow();\n// });\n\n// test('invalid mask #8', () => {\n//   const fail = () => fish.omit('asdf' as any);\n//   expect(fail).toThrow();\n// });\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/default.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport { z } from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"basic defaults\", () => {\n  expect(z.string().default(\"default\").parse(undefined)).toBe(\"default\");\n});\n\ntest(\"default with transform\", () => {\n  const stringWithDefault = z\n    .string()\n    .transform((val) => val.toUpperCase())\n    .default(\"default\");\n  expect(stringWithDefault.parse(undefined)).toBe(\"DEFAULT\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodDefault);\n  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodEffects);\n  expect(stringWithDefault._def.innerType._def.schema).toBeInstanceOf(z.ZodSchema);\n\n  type inp = z.input<typeof stringWithDefault>;\n  util.assertEqual<inp, string | undefined>(true);\n  type out = z.output<typeof stringWithDefault>;\n  util.assertEqual<out, string>(true);\n});\n\ntest(\"default on existing optional\", () => {\n  const stringWithDefault = z.string().optional().default(\"asdf\");\n  expect(stringWithDefault.parse(undefined)).toBe(\"asdf\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodDefault);\n  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodOptional);\n  expect(stringWithDefault._def.innerType._def.innerType).toBeInstanceOf(z.ZodString);\n\n  type inp = z.input<typeof stringWithDefault>;\n  util.assertEqual<inp, string | undefined>(true);\n  type out = z.output<typeof stringWithDefault>;\n  util.assertEqual<out, string>(true);\n});\n\ntest(\"optional on default\", () => {\n  const stringWithDefault = z.string().default(\"asdf\").optional();\n\n  type inp = z.input<typeof stringWithDefault>;\n  util.assertEqual<inp, string | undefined>(true);\n  type out = z.output<typeof stringWithDefault>;\n  util.assertEqual<out, string | undefined>(true);\n});\n\ntest(\"complex chain example\", () => {\n  const complex = z\n    .string()\n    .default(\"asdf\")\n    .transform((val) => val.toUpperCase())\n    .default(\"qwer\")\n    .removeDefault()\n    .optional()\n    .default(\"asdfasdf\");\n\n  expect(complex.parse(undefined)).toBe(\"ASDFASDF\");\n});\n\ntest(\"removeDefault\", () => {\n  const stringWithRemovedDefault = z.string().default(\"asdf\").removeDefault();\n\n  type out = z.output<typeof stringWithRemovedDefault>;\n  util.assertEqual<out, string>(true);\n});\n\ntest(\"nested\", () => {\n  const inner = z.string().default(\"asdf\");\n  const outer = z.object({ inner }).default({\n    inner: undefined,\n  });\n  type input = z.input<typeof outer>;\n  util.assertEqual<input, { inner?: string | undefined } | undefined>(true);\n  type out = z.output<typeof outer>;\n  util.assertEqual<out, { inner: string }>(true);\n  expect(outer.parse(undefined)).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({})).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({ inner: undefined })).toEqual({ inner: \"asdf\" });\n});\n\ntest(\"chained defaults\", () => {\n  const stringWithDefault = z.string().default(\"inner\").default(\"outer\");\n  const result = stringWithDefault.parse(undefined);\n  expect(result).toEqual(\"outer\");\n});\n\ntest(\"factory\", () => {\n  expect(z.ZodDefault.create(z.string(), { default: \"asdf\" }).parse(undefined)).toEqual(\"asdf\");\n});\n\ntest(\"native enum\", () => {\n  enum Fruits {\n    apple = \"apple\",\n    orange = \"orange\",\n  }\n\n  const schema = z.object({\n    fruit: z.nativeEnum(Fruits).default(Fruits.apple),\n  });\n\n  expect(schema.parse({})).toEqual({ fruit: Fruits.apple });\n});\n\ntest(\"enum\", () => {\n  const schema = z.object({\n    fruit: z.enum([\"apple\", \"orange\"]).default(\"apple\"),\n  });\n\n  expect(schema.parse({})).toEqual({ fruit: \"apple\" });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/description.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst description = \"a description\";\n\ntest(\"passing `description` to schema should add a description\", () => {\n  expect(z.string({ description }).description).toEqual(description);\n  expect(z.number({ description }).description).toEqual(description);\n  expect(z.boolean({ description }).description).toEqual(description);\n});\n\ntest(\"`.describe` should add a description\", () => {\n  expect(z.string().describe(description).description).toEqual(description);\n  expect(z.number().describe(description).description).toEqual(description);\n  expect(z.boolean().describe(description).description).toEqual(description);\n});\n\ntest(\"description should carry over to chained schemas\", () => {\n  const schema = z.string({ description });\n  expect(schema.description).toEqual(description);\n  expect(schema.optional().description).toEqual(description);\n  expect(schema.optional().nullable().default(\"default\").description).toEqual(description);\n});\n\ntest(\"description should not carry over to chained array schema\", () => {\n  const schema = z.string().describe(description);\n\n  expect(schema.description).toEqual(description);\n  expect(schema.array().description).toEqual(undefined);\n  expect(z.array(schema).description).toEqual(undefined);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/discriminated-unions.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"valid\", () => {\n  expect(\n    z\n      .discriminatedUnion(\"type\", [\n        z.object({ type: z.literal(\"a\"), a: z.string() }),\n        z.object({ type: z.literal(\"b\"), b: z.string() }),\n      ])\n      .parse({ type: \"a\", a: \"abc\" })\n  ).toEqual({ type: \"a\", a: \"abc\" });\n});\n\ntest(\"valid - discriminator value of various primitive types\", () => {\n  const schema = z.discriminatedUnion(\"type\", [\n    z.object({ type: z.literal(\"1\"), val: z.literal(1) }),\n    z.object({ type: z.literal(1), val: z.literal(2) }),\n    z.object({ type: z.literal(BigInt(1)), val: z.literal(3) }),\n    z.object({ type: z.literal(\"true\"), val: z.literal(4) }),\n    z.object({ type: z.literal(true), val: z.literal(5) }),\n    z.object({ type: z.literal(\"null\"), val: z.literal(6) }),\n    z.object({ type: z.literal(null), val: z.literal(7) }),\n    z.object({ type: z.literal(\"undefined\"), val: z.literal(8) }),\n    z.object({ type: z.literal(undefined), val: z.literal(9) }),\n    z.object({ type: z.literal(\"transform\"), val: z.literal(10) }),\n    z.object({ type: z.literal(\"refine\"), val: z.literal(11) }),\n    z.object({ type: z.literal(\"superRefine\"), val: z.literal(12) }),\n  ]);\n\n  expect(schema.parse({ type: \"1\", val: 1 })).toEqual({ type: \"1\", val: 1 });\n  expect(schema.parse({ type: 1, val: 2 })).toEqual({ type: 1, val: 2 });\n  expect(schema.parse({ type: BigInt(1), val: 3 })).toEqual({\n    type: BigInt(1),\n    val: 3,\n  });\n  expect(schema.parse({ type: \"true\", val: 4 })).toEqual({\n    type: \"true\",\n    val: 4,\n  });\n  expect(schema.parse({ type: true, val: 5 })).toEqual({\n    type: true,\n    val: 5,\n  });\n  expect(schema.parse({ type: \"null\", val: 6 })).toEqual({\n    type: \"null\",\n    val: 6,\n  });\n  expect(schema.parse({ type: null, val: 7 })).toEqual({\n    type: null,\n    val: 7,\n  });\n  expect(schema.parse({ type: \"undefined\", val: 8 })).toEqual({\n    type: \"undefined\",\n    val: 8,\n  });\n  expect(schema.parse({ type: undefined, val: 9 })).toEqual({\n    type: undefined,\n    val: 9,\n  });\n});\n\ntest(\"invalid - null\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"b\"), b: z.string() }),\n    ]).parse(null);\n    throw new Error();\n  } catch (e: any) {\n    expect(JSON.parse(e.message)).toEqual([\n      {\n        code: z.ZodIssueCode.invalid_type,\n        expected: z.ZodParsedType.object,\n        message: \"Expected object, received null\",\n        received: z.ZodParsedType.null,\n        path: [],\n      },\n    ]);\n  }\n});\n\ntest(\"invalid discriminator value\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"b\"), b: z.string() }),\n    ]).parse({ type: \"x\", a: \"abc\" });\n    throw new Error();\n  } catch (e: any) {\n    expect(JSON.parse(e.message)).toEqual([\n      {\n        code: z.ZodIssueCode.invalid_union_discriminator,\n        options: [\"a\", \"b\"],\n        message: \"Invalid discriminator value. Expected 'a' | 'b'\",\n        path: [\"type\"],\n      },\n    ]);\n  }\n});\n\ntest(\"valid discriminator value, invalid data\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"b\"), b: z.string() }),\n    ]).parse({ type: \"a\", b: \"abc\" });\n    throw new Error();\n  } catch (e: any) {\n    expect(JSON.parse(e.message)).toEqual([\n      {\n        code: z.ZodIssueCode.invalid_type,\n        expected: z.ZodParsedType.string,\n        message: \"Required\",\n        path: [\"a\"],\n        received: z.ZodParsedType.undefined,\n      },\n    ]);\n  }\n});\n\ntest(\"wrong schema - missing discriminator\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ b: z.string() }) as any,\n    ]);\n    throw new Error();\n  } catch (e: any) {\n    expect(e.message.includes(\"could not be extracted\")).toBe(true);\n  }\n});\n\ntest(\"wrong schema - duplicate discriminator values\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"a\"), b: z.string() }),\n    ]);\n    throw new Error();\n  } catch (e: any) {\n    expect(e.message.includes(\"has duplicate value\")).toEqual(true);\n  }\n});\n\ntest(\"async - valid\", async () => {\n  expect(\n    await z\n      .discriminatedUnion(\"type\", [\n        z.object({\n          type: z.literal(\"a\"),\n          a: z\n            .string()\n            .refine(async () => true)\n            .transform(async (val) => Number(val)),\n        }),\n        z.object({\n          type: z.literal(\"b\"),\n          b: z.string(),\n        }),\n      ])\n      .parseAsync({ type: \"a\", a: \"1\" })\n  ).toEqual({ type: \"a\", a: 1 });\n});\n\ntest(\"async - invalid\", async () => {\n  try {\n    await z\n      .discriminatedUnion(\"type\", [\n        z.object({\n          type: z.literal(\"a\"),\n          a: z\n            .string()\n            .refine(async () => true)\n            .transform(async (val) => val),\n        }),\n        z.object({\n          type: z.literal(\"b\"),\n          b: z.string(),\n        }),\n      ])\n      .parseAsync({ type: \"a\", a: 1 });\n    throw new Error();\n  } catch (e: any) {\n    expect(JSON.parse(e.message)).toEqual([\n      {\n        code: \"invalid_type\",\n        expected: \"string\",\n        received: \"number\",\n        path: [\"a\"],\n        message: \"Expected string, received number\",\n      },\n    ]);\n  }\n});\n\ntest(\"valid - literals with .default or .preprocess\", () => {\n  const schema = z.discriminatedUnion(\"type\", [\n    z.object({\n      type: z.literal(\"foo\").default(\"foo\"),\n      a: z.string(),\n    }),\n    z.object({\n      type: z.literal(\"custom\"),\n      method: z.string(),\n    }),\n    z.object({\n      type: z.preprocess((val) => String(val), z.literal(\"bar\")),\n      c: z.string(),\n    }),\n  ]);\n  expect(schema.parse({ type: \"foo\", a: \"foo\" })).toEqual({\n    type: \"foo\",\n    a: \"foo\",\n  });\n});\n\ntest(\"enum and nativeEnum\", () => {\n  enum MyEnum {\n    d = 0,\n    e = \"e\",\n  }\n\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\"),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.enum([\"b\", \"c\"]),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.nativeEnum(MyEnum),\n      // Add other properties specific to this option\n    }),\n  ]);\n\n  // type schema = z.infer<typeof schema>;\n\n  schema.parse({ key: \"a\" });\n  schema.parse({ key: \"b\" });\n  schema.parse({ key: \"c\" });\n  schema.parse({ key: MyEnum.d });\n  schema.parse({ key: MyEnum.e });\n  schema.parse({ key: \"e\" });\n});\n\ntest(\"branded\", () => {\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\"),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.literal(\"b\").brand(\"asdfaf\"),\n      // Add other properties specific to this option\n    }),\n  ]);\n\n  // type schema = z.infer<typeof schema>;\n\n  schema.parse({ key: \"a\" });\n  schema.parse({ key: \"b\" });\n  expect(() => {\n    schema.parse({ key: \"c\" });\n  }).toThrow();\n});\n\ntest(\"optional and nullable\", () => {\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\").optional(),\n      a: z.literal(true),\n    }),\n    z.object({\n      key: z.literal(\"b\").nullable(),\n      b: z.literal(true),\n      // Add other properties specific to this option\n    }),\n  ]);\n\n  type schema = z.infer<typeof schema>;\n  z.util.assertEqual<schema, { key?: \"a\" | undefined; a: true } | { key: \"b\" | null; b: true }>(true);\n\n  schema.parse({ key: \"a\", a: true });\n  schema.parse({ key: undefined, a: true });\n  schema.parse({ key: \"b\", b: true });\n  schema.parse({ key: null, b: true });\n  expect(() => {\n    schema.parse({ key: null, a: true });\n  }).toThrow();\n  expect(() => {\n    schema.parse({ key: \"b\", a: true });\n  }).toThrow();\n\n  const value = schema.parse({ key: null, b: true });\n\n  if (!(\"key\" in value)) value.a;\n  if (value.key === undefined) value.a;\n  if (value.key === \"a\") value.a;\n  if (value.key === \"b\") value.b;\n  if (value.key === null) value.b;\n});\n\ntest(\"readonly array of options\", () => {\n  const options = [\n    z.object({ type: z.literal(\"x\"), val: z.literal(1) }),\n    z.object({ type: z.literal(\"y\"), val: z.literal(2) }),\n  ] as const;\n\n  expect(z.discriminatedUnion(\"type\", options).parse({ type: \"x\", val: 1 })).toEqual({ type: \"x\", val: 1 });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/enum.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"create enum\", () => {\n  const MyEnum = z.enum([\"Red\", \"Green\", \"Blue\"]);\n  expect(MyEnum.Values.Red).toEqual(\"Red\");\n  expect(MyEnum.Enum.Red).toEqual(\"Red\");\n  expect(MyEnum.enum.Red).toEqual(\"Red\");\n});\n\ntest(\"infer enum\", () => {\n  const MyEnum = z.enum([\"Red\", \"Green\", \"Blue\"]);\n  type MyEnum = z.infer<typeof MyEnum>;\n  util.assertEqual<MyEnum, \"Red\" | \"Green\" | \"Blue\">(true);\n});\n\ntest(\"get options\", () => {\n  expect(z.enum([\"tuna\", \"trout\"]).options).toEqual([\"tuna\", \"trout\"]);\n});\n\ntest(\"readonly enum\", () => {\n  const HTTP_SUCCESS = [\"200\", \"201\"] as const;\n  const arg = z.enum(HTTP_SUCCESS);\n  type arg = z.infer<typeof arg>;\n  util.assertEqual<arg, \"200\" | \"201\">(true);\n\n  arg.parse(\"201\");\n  expect(() => arg.parse(\"202\")).toThrow();\n});\n\ntest(\"error params\", () => {\n  const result = z.enum([\"test\"], { required_error: \"REQUIRED\" }).safeParse(undefined);\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"REQUIRED\");\n  }\n});\n\ntest(\"extract/exclude\", () => {\n  const foods = [\"Pasta\", \"Pizza\", \"Tacos\", \"Burgers\", \"Salad\"] as const;\n  const FoodEnum = z.enum(foods);\n  const ItalianEnum = FoodEnum.extract([\"Pasta\", \"Pizza\"]);\n  const UnhealthyEnum = FoodEnum.exclude([\"Salad\"]);\n  const EmptyFoodEnum = FoodEnum.exclude(foods);\n\n  util.assertEqual<z.infer<typeof ItalianEnum>, \"Pasta\" | \"Pizza\">(true);\n  util.assertEqual<z.infer<typeof UnhealthyEnum>, \"Pasta\" | \"Pizza\" | \"Tacos\" | \"Burgers\">(true);\n  // @ts-expect-error TS2344\n  util.assertEqual<typeof EmptyFoodEnum, z.ZodEnum<[]>>(true);\n  util.assertEqual<z.infer<typeof EmptyFoodEnum>, never>(true);\n});\n\ntest(\"error map in extract/exclude\", () => {\n  const foods = [\"Pasta\", \"Pizza\", \"Tacos\", \"Burgers\", \"Salad\"] as const;\n  const FoodEnum = z.enum(foods, {\n    errorMap: () => ({ message: \"This is not food!\" }),\n  });\n  const ItalianEnum = FoodEnum.extract([\"Pasta\", \"Pizza\"]);\n  const foodsError = FoodEnum.safeParse(\"Cucumbers\");\n  const italianError = ItalianEnum.safeParse(\"Tacos\");\n  if (!foodsError.success && !italianError.success) {\n    expect(foodsError.error.issues[0].message).toEqual(italianError.error.issues[0].message);\n  }\n\n  const UnhealthyEnum = FoodEnum.exclude([\"Salad\"], {\n    errorMap: () => ({ message: \"This is not healthy food!\" }),\n  });\n  const unhealthyError = UnhealthyEnum.safeParse(\"Salad\");\n  if (!unhealthyError.success) {\n    expect(unhealthyError.error.issues[0].message).toEqual(\"This is not healthy food!\");\n  }\n});\n\ntest(\"readonly in ZodEnumDef\", () => {\n  let _t!: z.ZodEnumDef<readonly [\"a\", \"b\"]>;\n  _t;\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/error.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { ZodError, ZodIssueCode } from \"../ZodError.js\";\nimport { ZodParsedType } from \"../helpers/util.js\";\n\ntest(\"error creation\", () => {\n  const err1 = ZodError.create([]);\n  err1.addIssue({\n    code: ZodIssueCode.invalid_type,\n    expected: ZodParsedType.object,\n    received: ZodParsedType.string,\n    path: [],\n    message: \"\",\n    fatal: true,\n  });\n  err1.isEmpty;\n\n  const err2 = ZodError.create(err1.issues);\n  const err3 = new ZodError([]);\n  err3.addIssues(err1.issues);\n  err3.addIssue(err1.issues[0]);\n  err1.message;\n  err2.message;\n  err3.message;\n});\n\nconst errorMap: z.ZodErrorMap = (error, ctx) => {\n  if (error.code === ZodIssueCode.invalid_type) {\n    if (error.expected === \"string\") {\n      return { message: \"bad type!\" };\n    }\n  }\n  if (error.code === ZodIssueCode.custom) {\n    return { message: `less-than-${error.params?.minimum}` };\n  }\n  return { message: ctx.defaultError };\n};\n\ntest(\"type error with custom error map\", () => {\n  try {\n    z.string().parse(234, { errorMap });\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n\n    expect(zerr.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);\n    expect(zerr.issues[0].message).toEqual(`bad type!`);\n  }\n});\n\ntest(\"refinement fail with params\", () => {\n  try {\n    z.number()\n      .refine((val) => val >= 3, {\n        params: { minimum: 3 },\n      })\n      .parse(2, { errorMap });\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues[0].code).toEqual(z.ZodIssueCode.custom);\n    expect(zerr.issues[0].message).toEqual(`less-than-3`);\n  }\n});\n\ntest(\"custom error with custom errormap\", () => {\n  try {\n    z.string()\n      .refine((val) => val.length > 12, {\n        params: { minimum: 13 },\n        message: \"override\",\n      })\n      .parse(\"asdf\", { errorMap });\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues[0].message).toEqual(\"override\");\n  }\n});\n\ntest(\"default error message\", () => {\n  try {\n    z.number()\n      .refine((x) => x > 3)\n      .parse(2);\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(\"Invalid input\");\n  }\n});\n\ntest(\"override error in refine\", () => {\n  try {\n    z.number()\n      .refine((x) => x > 3, \"override\")\n      .parse(2);\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(\"override\");\n  }\n});\n\ntest(\"override error in refinement\", () => {\n  try {\n    z.number()\n      .refine((x) => x > 3, {\n        message: \"override\",\n      })\n      .parse(2);\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(\"override\");\n  }\n});\n\ntest(\"array minimum\", () => {\n  try {\n    z.array(z.string()).min(3, \"tooshort\").parse([\"asdf\", \"qwer\"]);\n  } catch (err) {\n    const zerr: ZodError = err as any;\n    expect(zerr.issues[0].code).toEqual(ZodIssueCode.too_small);\n    expect(zerr.issues[0].message).toEqual(\"tooshort\");\n  }\n  try {\n    z.array(z.string()).min(3).parse([\"asdf\", \"qwer\"]);\n  } catch (err) {\n    const zerr: ZodError = err as any;\n    expect(zerr.issues[0].code).toEqual(ZodIssueCode.too_small);\n    expect(zerr.issues[0].message).toEqual(`Array must contain at least 3 element(s)`);\n  }\n});\n\n// implement test for semi-smart union logic that checks for type error on either left or right\n// test(\"union smart errors\", () => {\n//   // expect.assertions(2);\n\n//   const p1 = z\n//     .union([z.string(), z.number().refine((x) => x > 0)])\n//     .safeParse(-3.2);\n\n//   if (p1.success === true) throw new Error();\n//   expect(p1.success).toBe(false);\n//   expect(p1.error.issues[0].code).toEqual(ZodIssueCode.custom);\n\n//   const p2 = z.union([z.string(), z.number()]).safeParse(false);\n//   // .catch(err => expect(err.issues[0].code).toEqual(ZodIssueCode.invalid_union));\n//   if (p2.success === true) throw new Error();\n//   expect(p2.success).toBe(false);\n//   expect(p2.error.issues[0].code).toEqual(ZodIssueCode.invalid_union);\n// });\n\ntest(\"custom path in custom error map\", () => {\n  const schema = z.object({\n    items: z.array(z.string()).refine((data) => data.length > 3, {\n      path: [\"items-too-few\"],\n    }),\n  });\n\n  const errorMap: z.ZodErrorMap = (error) => {\n    expect(error.path.length).toBe(2);\n    return { message: \"doesnt matter\" };\n  };\n  const result = schema.safeParse({ items: [\"first\"] }, { errorMap });\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].path).toEqual([\"items\", \"items-too-few\"]);\n  }\n});\n\ntest(\"error metadata from value\", () => {\n  const dynamicRefine = z.string().refine(\n    (val) => val === val.toUpperCase(),\n    (val) => ({ params: { val } })\n  );\n\n  const result = dynamicRefine.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    const sub = result.error.issues[0];\n    expect(result.error.issues[0].code).toEqual(\"custom\");\n    if (sub.code === \"custom\") {\n      expect(sub.params!.val).toEqual(\"asdf\");\n    }\n  }\n});\n\n// test(\"don't call refine after validation failed\", () => {\n//   const asdf = z\n//     .union([\n//       z.number(),\n//       z.string().transform(z.number(), (val) => {\n//         return parseFloat(val);\n//       }),\n//     ])\n//     .refine((v) => v >= 1);\n\n//   expect(() => asdf.safeParse(\"foo\")).not.toThrow();\n// });\n\ntest(\"root level formatting\", () => {\n  const schema = z.string().email();\n  const result = schema.safeParse(\"asdfsdf\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.format()._errors).toEqual([\"Invalid email\"]);\n  }\n});\n\ntest(\"custom path\", () => {\n  const schema = z\n    .object({\n      password: z.string(),\n      confirm: z.string(),\n    })\n    .refine((val) => val.confirm === val.password, { path: [\"confirm\"] });\n\n  const result = schema.safeParse({\n    password: \"peanuts\",\n    confirm: \"qeanuts\",\n  });\n\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    // nested errors\n    const error = result.error.format();\n    expect(error._errors).toEqual([]);\n    expect(error.password?._errors).toEqual(undefined);\n    expect(error.confirm?._errors).toEqual([\"Invalid input\"]);\n  }\n});\n\ntest(\"custom path\", () => {\n  const schema = z\n    .object({\n      password: z.string().min(6),\n      confirm: z.string().min(6),\n    })\n    .refine((val) => val.confirm === val.password);\n\n  const result = schema.safeParse({\n    password: \"qwer\",\n    confirm: \"asdf\",\n  });\n\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues.length).toEqual(3);\n  }\n});\n\nconst schema = z.object({\n  inner: z.object({\n    name: z\n      .string()\n      .refine((val) => val.length > 5)\n      .array()\n      .refine((val) => val.length <= 1),\n  }),\n});\n\ntest(\"no abort early on refinements\", () => {\n  const invalidItem = {\n    inner: { name: [\"aasd\", \"asdfasdfasfd\"] },\n  };\n\n  const result1 = schema.safeParse(invalidItem);\n  expect(result1.success).toEqual(false);\n  if (!result1.success) {\n    expect(result1.error.issues.length).toEqual(2);\n  }\n});\ntest(\"formatting\", () => {\n  const invalidItem = {\n    inner: { name: [\"aasd\", \"asdfasdfasfd\"] },\n  };\n  const invalidArray = {\n    inner: { name: [\"asdfasdf\", \"asdfasdfasfd\"] },\n  };\n  const result1 = schema.safeParse(invalidItem);\n  const result2 = schema.safeParse(invalidArray);\n\n  expect(result1.success).toEqual(false);\n  expect(result2.success).toEqual(false);\n  if (!result1.success) {\n    const error = result1.error.format();\n\n    expect(error._errors).toEqual([]);\n    expect(error.inner?._errors).toEqual([]);\n    // expect(error.inner?.name?._errors).toEqual([\"Invalid input\"]);\n    // expect(error.inner?.name?.[0]._errors).toEqual([\"Invalid input\"]);\n    expect(error.inner?.name?.[1]).toEqual(undefined);\n  }\n  if (!result2.success) {\n    type FormattedError = z.inferFormattedError<typeof schema>;\n    const error: FormattedError = result2.error.format();\n    expect(error._errors).toEqual([]);\n    expect(error.inner?._errors).toEqual([]);\n    expect(error.inner?.name?._errors).toEqual([\"Invalid input\"]);\n    expect(error.inner?.name?.[0]).toEqual(undefined);\n    expect(error.inner?.name?.[1]).toEqual(undefined);\n    expect(error.inner?.name?.[2]).toEqual(undefined);\n  }\n\n  // test custom mapper\n  if (!result2.success) {\n    type FormattedError = z.inferFormattedError<typeof schema, number>;\n    const error: FormattedError = result2.error.format(() => 5);\n    expect(error._errors).toEqual([]);\n    expect(error.inner?._errors).toEqual([]);\n    expect(error.inner?.name?._errors).toEqual([5]);\n  }\n});\n\ntest(\"formatting with nullable and optional fields\", () => {\n  const nameSchema = z.string().refine((val) => val.length > 5);\n  const schema = z.object({\n    nullableObject: z.object({ name: nameSchema }).nullable(),\n    nullableArray: z.array(nameSchema).nullable(),\n    nullableTuple: z.tuple([nameSchema, nameSchema, z.number()]).nullable(),\n    optionalObject: z.object({ name: nameSchema }).optional(),\n    optionalArray: z.array(nameSchema).optional(),\n    optionalTuple: z.tuple([nameSchema, nameSchema, z.number()]).optional(),\n  });\n  const invalidItem = {\n    nullableObject: { name: \"abcd\" },\n    nullableArray: [\"abcd\"],\n    nullableTuple: [\"abcd\", \"abcd\", 1],\n    optionalObject: { name: \"abcd\" },\n    optionalArray: [\"abcd\"],\n    optionalTuple: [\"abcd\", \"abcd\", 1],\n  };\n  const result = schema.safeParse(invalidItem);\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    type FormattedError = z.inferFormattedError<typeof schema>;\n    const error: FormattedError = result.error.format();\n    expect(error._errors).toEqual([]);\n    expect(error.nullableObject?._errors).toEqual([]);\n    expect(error.nullableObject?.name?._errors).toEqual([\"Invalid input\"]);\n    expect(error.nullableArray?._errors).toEqual([]);\n    expect(error.nullableArray?.[0]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.nullableTuple?._errors).toEqual([]);\n    expect(error.nullableTuple?.[0]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.nullableTuple?.[1]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.optionalObject?._errors).toEqual([]);\n    expect(error.optionalObject?.name?._errors).toEqual([\"Invalid input\"]);\n    expect(error.optionalArray?._errors).toEqual([]);\n    expect(error.optionalArray?.[0]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.optionalTuple?._errors).toEqual([]);\n    expect(error.optionalTuple?.[0]?._errors).toEqual([\"Invalid input\"]);\n    expect(error.optionalTuple?.[1]?._errors).toEqual([\"Invalid input\"]);\n  }\n});\n\nconst stringWithCustomError = z.string({\n  errorMap: (issue, ctx) => ({\n    message: issue.code === \"invalid_type\" ? (ctx.data ? \"Invalid name\" : \"Name is required\") : ctx.defaultError,\n  }),\n});\n\ntest(\"schema-bound error map\", () => {\n  const result = stringWithCustomError.safeParse(1234);\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"Invalid name\");\n  }\n\n  const result2 = stringWithCustomError.safeParse(undefined);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].message).toEqual(\"Name is required\");\n  }\n\n  // support contextual override\n  const result3 = stringWithCustomError.safeParse(undefined, {\n    errorMap: () => ({ message: \"OVERRIDE\" }),\n  });\n  expect(result3.success).toEqual(false);\n  if (!result3.success) {\n    expect(result3.error.issues[0].message).toEqual(\"OVERRIDE\");\n  }\n});\n\ntest(\"overrideErrorMap\", () => {\n  // support overrideErrorMap\n  z.setErrorMap(() => ({ message: \"OVERRIDE\" }));\n  const result4 = stringWithCustomError.min(10).safeParse(\"tooshort\");\n  expect(result4.success).toEqual(false);\n  if (!result4.success) {\n    expect(result4.error.issues[0].message).toEqual(\"OVERRIDE\");\n  }\n  z.setErrorMap(z.defaultErrorMap);\n});\n\ntest(\"invalid and required\", () => {\n  const str = z.string({\n    invalid_type_error: \"Invalid name\",\n    required_error: \"Name is required\",\n  });\n  const result1 = str.safeParse(1234);\n  expect(result1.success).toEqual(false);\n  if (!result1.success) {\n    expect(result1.error.issues[0].message).toEqual(\"Invalid name\");\n  }\n  const result2 = str.safeParse(undefined);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].message).toEqual(\"Name is required\");\n  }\n});\n\ntest(\"Fallback to default required error\", () => {\n  const str = z.string({\n    invalid_type_error: \"Invalid name\",\n    // required_error: \"Name is required\",\n  });\n\n  const result2 = str.safeParse(undefined);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].message).toEqual(\"Required\");\n  }\n});\n\ntest(\"invalid and required and errorMap\", () => {\n  expect(() => {\n    return z.string({\n      invalid_type_error: \"Invalid name\",\n      required_error: \"Name is required\",\n      errorMap: () => ({ message: \"OVERRIDE\" }),\n    });\n  }).toThrow();\n});\n\ntest(\"strict error message\", () => {\n  const errorMsg = \"Invalid object\";\n  const obj = z.object({ x: z.string() }).strict(errorMsg);\n  const result = obj.safeParse({ x: \"a\", y: \"b\" });\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(errorMsg);\n  }\n});\n\ntest(\"enum error message, invalid enum elementstring\", () => {\n  try {\n    z.enum([\"Tuna\", \"Trout\"]).parse(\"Salmon\");\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(\"Invalid enum value. Expected 'Tuna' | 'Trout', received 'Salmon'\");\n  }\n});\n\ntest(\"enum error message, invalid type\", () => {\n  try {\n    z.enum([\"Tuna\", \"Trout\"]).parse(12);\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(\"Expected 'Tuna' | 'Trout', received number\");\n  }\n});\n\ntest(\"nativeEnum default error message\", () => {\n  enum Fish {\n    Tuna = \"Tuna\",\n    Trout = \"Trout\",\n  }\n  try {\n    z.nativeEnum(Fish).parse(\"Salmon\");\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(\"Invalid enum value. Expected 'Tuna' | 'Trout', received 'Salmon'\");\n  }\n});\n\ntest(\"literal default error message\", () => {\n  try {\n    z.literal(\"Tuna\").parse(\"Trout\");\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(`Invalid literal value, expected \"Tuna\"`);\n  }\n});\n\ntest(\"literal bigint default error message\", () => {\n  try {\n    z.literal(BigInt(12)).parse(BigInt(13));\n  } catch (err) {\n    const zerr: z.ZodError = err as any;\n    expect(zerr.issues.length).toEqual(1);\n    expect(zerr.issues[0].message).toEqual(`Invalid literal value, expected \"12\"`);\n  }\n});\n\ntest(\"enum with message returns the custom error message\", () => {\n  const schema = z.enum([\"apple\", \"banana\"], {\n    message: \"the value provided is invalid\",\n  });\n\n  const result1 = schema.safeParse(\"berries\");\n  expect(result1.success).toEqual(false);\n  if (!result1.success) {\n    expect(result1.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n\n  const result2 = schema.safeParse(undefined);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n\n  const result3 = schema.safeParse(\"banana\");\n  expect(result3.success).toEqual(true);\n\n  const result4 = schema.safeParse(null);\n  expect(result4.success).toEqual(false);\n  if (!result4.success) {\n    expect(result4.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n});\n\ntest(\"when the message is falsy, it is used as is provided\", () => {\n  const schema = z.string().max(1, { message: \"\" });\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"\");\n  }\n});\n\n// test(\"dont short circuit on continuable errors\", () => {\n//   const user = z\n//     .object({\n//       password: z.string().min(6),\n//       confirm: z.string(),\n//     })\n//     .refine((data) => data.password === data.confirm, {\n//       message: \"Passwords don't match\",\n//       path: [\"confirm\"],\n//     });\n//   const result = user.safeParse({ password: \"asdf\", confirm: \"qwer\" });\n//   if (!result.success) {\n//     expect(result.error.issues.length).toEqual(2);\n//   }\n// });\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/firstparty.test.ts",
    "content": "// @ts-ignore TS6133\nimport { test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"first party switch\", () => {\n  const myType = z.string() as z.ZodFirstPartySchemaTypes;\n  const def = myType._def;\n\n  switch (def.typeName) {\n    case z.ZodFirstPartyTypeKind.ZodString:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodNumber:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodNaN:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodBigInt:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodBoolean:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodDate:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodUndefined:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodNull:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodAny:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodUnknown:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodNever:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodVoid:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodArray:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodObject:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodUnion:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodIntersection:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodTuple:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodRecord:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodMap:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodSet:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodFunction:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodLazy:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodLiteral:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodEnum:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodEffects:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodNativeEnum:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodOptional:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodNullable:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodDefault:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodCatch:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodPromise:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodBranded:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodPipeline:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodSymbol:\n      break;\n    case z.ZodFirstPartyTypeKind.ZodReadonly:\n      break;\n    default:\n      util.assertNever(def);\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/firstpartyschematypes.test.ts",
    "content": "// @ts-ignore TS6133\nimport { test } from \"vitest\";\n\nimport type { ZodFirstPartySchemaTypes, ZodFirstPartyTypeKind } from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"Identify missing [ZodFirstPartySchemaTypes]\", () => {\n  type ZodFirstPartySchemaForType<T extends ZodFirstPartyTypeKind> = ZodFirstPartySchemaTypes extends infer Schema\n    ? Schema extends { _def: { typeName: T } }\n      ? Schema\n      : never\n    : never;\n  type ZodMappedTypes = {\n    [key in ZodFirstPartyTypeKind]: ZodFirstPartySchemaForType<key>;\n  };\n  type ZodFirstPartySchemaTypesMissingFromUnion = keyof {\n    [key in keyof ZodMappedTypes as ZodMappedTypes[key] extends { _def: never } ? key : never]: unknown;\n  };\n\n  util.assertEqual<ZodFirstPartySchemaTypesMissingFromUnion, never>(true);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/function.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst args1 = z.tuple([z.string()]);\nconst returns1 = z.number();\nconst func1 = z.function(args1, returns1);\n\ntest(\"function parsing\", () => {\n  const parsed = func1.parse((arg: any) => arg.length);\n  parsed(\"asdf\");\n});\n\ntest(\"parsed function fail 1\", () => {\n  const parsed = func1.parse((x: string) => x);\n  expect(() => parsed(\"asdf\")).toThrow();\n});\n\ntest(\"parsed function fail 2\", () => {\n  const parsed = func1.parse((x: string) => x);\n  expect(() => parsed(13 as any)).toThrow();\n});\n\ntest(\"function inference 1\", () => {\n  type func1 = z.TypeOf<typeof func1>;\n  util.assertEqual<func1, (k: string) => number>(true);\n});\n\ntest(\"method parsing\", () => {\n  const methodObject = z.object({\n    property: z.number(),\n    method: z.function().args(z.string()).returns(z.number()),\n  });\n  const methodInstance = {\n    property: 3,\n    method: function (s: string) {\n      return s.length + this.property;\n    },\n  };\n  const parsed = methodObject.parse(methodInstance);\n  expect(parsed.method(\"length=8\")).toBe(11); // 8 length + 3 property\n});\n\ntest(\"async method parsing\", async () => {\n  const methodObject = z.object({\n    property: z.number(),\n    method: z.function().args(z.string()).returns(z.promise(z.number())),\n  });\n  const methodInstance = {\n    property: 3,\n    method: async function (s: string) {\n      return s.length + this.property;\n    },\n  };\n  const parsed = methodObject.parse(methodInstance);\n  expect(await parsed.method(\"length=8\")).toBe(11); // 8 length + 3 property\n});\n\ntest(\"args method\", () => {\n  const t1 = z.function();\n  type t1 = z.infer<typeof t1>;\n  util.assertEqual<t1, (...args_1: unknown[]) => unknown>(true);\n\n  const t2 = t1.args(z.string());\n  type t2 = z.infer<typeof t2>;\n  util.assertEqual<t2, (arg: string, ...args_1: unknown[]) => unknown>(true);\n\n  const t3 = t2.returns(z.boolean());\n  type t3 = z.infer<typeof t3>;\n  util.assertEqual<t3, (arg: string, ...args_1: unknown[]) => boolean>(true);\n});\n\nconst args2 = z.tuple([\n  z.object({\n    f1: z.number(),\n    f2: z.string().nullable(),\n    f3: z.array(z.boolean().optional()).optional(),\n  }),\n]);\nconst returns2 = z.union([z.string(), z.number()]);\n\nconst func2 = z.function(args2, returns2);\n\ntest(\"function inference 2\", () => {\n  type func2 = z.TypeOf<typeof func2>;\n  util.assertEqual<\n    func2,\n    (arg: {\n      f1: number;\n      f2: string | null;\n      f3?: (boolean | undefined)[] | undefined;\n    }) => string | number\n  >(true);\n});\n\ntest(\"valid function run\", () => {\n  const validFunc2Instance = func2.validate((_x) => {\n    return \"adf\" as any;\n  });\n\n  const checker = () => {\n    validFunc2Instance({\n      f1: 21,\n      f2: \"asdf\",\n      f3: [true, false],\n    });\n  };\n\n  checker();\n});\n\ntest(\"input validation error\", () => {\n  const invalidFuncInstance = func2.validate((_x) => {\n    return \"adf\" as any;\n  });\n\n  const checker = () => {\n    invalidFuncInstance(\"Invalid_input\" as any);\n  };\n\n  expect(checker).toThrow();\n});\n\ntest(\"output validation error\", () => {\n  const invalidFuncInstance = func2.validate((_x) => {\n    return [\"this\", \"is\", \"not\", \"valid\", \"output\"] as any;\n  });\n\n  const checker = () => {\n    invalidFuncInstance({\n      f1: 21,\n      f2: \"asdf\",\n      f3: [true, false],\n    });\n  };\n\n  expect(checker).toThrow();\n});\n\nz.function(z.tuple([z.string()])).args()._def.args;\n\ntest(\"special function error codes\", () => {\n  const checker = z.function(z.tuple([z.string()]), z.boolean()).implement((arg) => {\n    return arg.length as any;\n  });\n  try {\n    checker(\"12\" as any);\n  } catch (err) {\n    const zerr = err as z.ZodError;\n    const first = zerr.issues[0];\n    if (first.code !== z.ZodIssueCode.invalid_return_type) throw new Error();\n\n    expect(first.returnTypeError).toBeInstanceOf(z.ZodError);\n  }\n\n  try {\n    checker(12 as any);\n  } catch (err) {\n    const zerr = err as z.ZodError;\n    const first = zerr.issues[0];\n    if (first.code !== z.ZodIssueCode.invalid_arguments) throw new Error();\n    expect(first.argumentsError).toBeInstanceOf(z.ZodError);\n  }\n});\n\ntest(\"function with async refinements\", async () => {\n  const func = z\n    .function()\n    .args(z.string().refine(async (val) => val.length > 10))\n    .returns(z.promise(z.number().refine(async (val) => val > 10)))\n    .implement(async (val) => {\n      return val.length;\n    });\n  const results = [];\n  try {\n    await func(\"asdfasdf\");\n    results.push(\"success\");\n  } catch (_err) {\n    results.push(\"fail\");\n  }\n  try {\n    await func(\"asdflkjasdflkjsf\");\n    results.push(\"success\");\n  } catch (_err) {\n    results.push(\"fail\");\n  }\n\n  expect(results).toEqual([\"fail\", \"success\"]);\n});\n\ntest(\"non async function with async refinements should fail\", async () => {\n  const func = z\n    .function()\n    .args(z.string().refine(async (val) => val.length > 10))\n    .returns(z.number().refine(async (val) => val > 10))\n    .implement((val) => {\n      return val.length;\n    });\n\n  const results = [];\n  try {\n    await func(\"asdasdfasdffasdf\");\n    results.push(\"success\");\n  } catch (_err) {\n    results.push(\"fail\");\n  }\n\n  expect(results).toEqual([\"fail\"]);\n});\n\ntest(\"allow extra parameters\", () => {\n  const maxLength5 = z\n    .function()\n    .args(z.string())\n    .returns(z.boolean())\n    .implement((str, _arg, _qewr) => {\n      return str.length <= 5;\n    });\n\n  const filteredList = [\"apple\", \"orange\", \"pear\", \"banana\", \"strawberry\"].filter(maxLength5);\n  expect(filteredList.length).toEqual(2);\n});\n\ntest(\"params and returnType getters\", () => {\n  const func = z.function().args(z.string()).returns(z.string());\n\n  func.parameters().items[0].parse(\"asdf\");\n  func.returnType().parse(\"asdf\");\n});\n\ntest(\"inference with transforms\", () => {\n  const funcSchema = z\n    .function()\n    .args(z.string().transform((val) => val.length))\n    .returns(z.object({ val: z.number() }));\n  const myFunc = funcSchema.implement((val) => {\n    return { val, extra: \"stuff\" };\n  });\n  myFunc(\"asdf\");\n\n  util.assertEqual<typeof myFunc, (arg: string, ...args_1: unknown[]) => { val: number; extra: string }>(true);\n});\n\ntest(\"fallback to OuterTypeOfFunction\", () => {\n  const funcSchema = z\n    .function()\n    .args(z.string().transform((val) => val.length))\n    .returns(z.object({ arg: z.number() }).transform((val) => val.arg));\n\n  const myFunc = funcSchema.implement((val) => {\n    return { arg: val, arg2: false };\n  });\n\n  util.assertEqual<typeof myFunc, (arg: string, ...args_1: unknown[]) => number>(true);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/generics.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"generics\", () => {\n  async function stripOuter<TData extends z.ZodTypeAny>(schema: TData, data: unknown) {\n    return z\n      .object({\n        nested: schema, // as z.ZodTypeAny,\n      })\n      .transform((data) => {\n        return data.nested!;\n      })\n      .parse({ nested: data });\n  }\n\n  const result = stripOuter(z.object({ a: z.string() }), { a: \"asdf\" });\n  util.assertEqual<typeof result, Promise<{ a: string }>>(true);\n});\n\n// test(\"assignability\", () => {\n//   const createSchemaAndParse = <K extends string, VS extends z.ZodString>(\n//     key: K,\n//     valueSchema: VS,\n//     data: unknown\n//   ) => {\n//     const schema = z.object({\n//       [key]: valueSchema,\n//     } as { [k in K]: VS });\n//     return { [key]: valueSchema };\n//     const parsed = schema.parse(data);\n//     return parsed;\n//     // const inferred: z.infer<z.ZodObject<{ [k in K]: VS }>> = parsed;\n//     // return inferred;\n//   };\n//   const parsed = createSchemaAndParse(\"foo\", z.string(), { foo: \"\" });\n//   util.assertEqual<typeof parsed, { foo: string }>(true);\n// });\n\ntest(\"nested no undefined\", () => {\n  const inner = z.string().or(z.array(z.string()));\n  const outer = z.object({ inner });\n  type outerSchema = z.infer<typeof outer>;\n  z.util.assertEqual<outerSchema, { inner: string | string[] }>(true);\n  expect(outer.safeParse({ inner: undefined }).success).toEqual(false);\n});\n",
    "symbols": [
      {
        "name": "stripOuter",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/generics.test.ts",
        "startLine": 8,
        "endLine": 17
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/instanceof.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"instanceof\", async () => {\n  class Test {}\n  class Subtest extends Test {}\n  abstract class AbstractBar {\n    constructor(public val: string) {}\n  }\n  class Bar extends AbstractBar {}\n\n  const TestSchema = z.instanceof(Test);\n  const SubtestSchema = z.instanceof(Subtest);\n  const AbstractSchema = z.instanceof(AbstractBar);\n  const BarSchema = z.instanceof(Bar);\n\n  TestSchema.parse(new Test());\n  TestSchema.parse(new Subtest());\n  SubtestSchema.parse(new Subtest());\n  AbstractSchema.parse(new Bar(\"asdf\"));\n  const bar = BarSchema.parse(new Bar(\"asdf\"));\n  expect(bar.val).toEqual(\"asdf\");\n\n  await expect(() => SubtestSchema.parse(new Test())).toThrow(/Input not instance of Subtest/);\n  await expect(() => TestSchema.parse(12)).toThrow(/Input not instance of Test/);\n\n  util.assertEqual<Test, z.infer<typeof TestSchema>>(true);\n});\n\ntest(\"instanceof fatal\", () => {\n  const schema = z.instanceof(Date).refine((d) => d.toString());\n  const res = schema.safeParse(null);\n  expect(res.success).toBe(false);\n});\n",
    "symbols": [
      {
        "name": "Test",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/instanceof.test.ts",
        "startLine": 8,
        "endLine": 8
      },
      {
        "name": "Subtest",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/instanceof.test.ts",
        "startLine": 9,
        "endLine": 9
      },
      {
        "name": "AbstractBar",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/instanceof.test.ts",
        "startLine": 10,
        "endLine": 12
      },
      {
        "name": "Bar",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/instanceof.test.ts",
        "startLine": 13,
        "endLine": 13
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/intersection.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"object intersection\", () => {\n  const BaseTeacher = z.object({\n    subjects: z.array(z.string()),\n  });\n  const HasID = z.object({ id: z.string() });\n\n  const Teacher = z.intersection(BaseTeacher.passthrough(), HasID); // BaseTeacher.merge(HasID);\n  const data = {\n    subjects: [\"math\"],\n    id: \"asdfasdf\",\n  };\n  expect(Teacher.parse(data)).toEqual(data);\n  expect(() => Teacher.parse({ subject: data.subjects })).toThrow();\n  expect(Teacher.parse({ ...data, extra: 12 })).toEqual({ ...data, extra: 12 });\n\n  expect(() => z.intersection(BaseTeacher.strict(), HasID).parse({ ...data, extra: 12 })).toThrow();\n});\n\ntest(\"deep intersection\", () => {\n  const Animal = z.object({\n    properties: z.object({\n      is_animal: z.boolean(),\n    }),\n  });\n  const Cat = z\n    .object({\n      properties: z.object({\n        jumped: z.boolean(),\n      }),\n    })\n    .and(Animal);\n\n  type _Cat = z.infer<typeof Cat>;\n  // const cat:Cat = 'asdf' as any;\n  const cat = Cat.parse({ properties: { is_animal: true, jumped: true } });\n  expect(cat.properties).toEqual({ is_animal: true, jumped: true });\n});\n\ntest(\"deep intersection of arrays\", async () => {\n  const Author = z.object({\n    posts: z.array(\n      z.object({\n        post_id: z.number(),\n      })\n    ),\n  });\n  const Registry = z\n    .object({\n      posts: z.array(\n        z.object({\n          title: z.string(),\n        })\n      ),\n    })\n    .and(Author);\n\n  const posts = [\n    { post_id: 1, title: \"Novels\" },\n    { post_id: 2, title: \"Fairy tales\" },\n  ];\n  const cat = Registry.parse({ posts });\n  expect(cat.posts).toEqual(posts);\n  const asyncCat = await Registry.parseAsync({ posts });\n  expect(asyncCat.posts).toEqual(posts);\n});\n\ntest(\"invalid intersection types\", async () => {\n  const numberIntersection = z.intersection(\n    z.number(),\n    z.number().transform((x) => x + 1)\n  );\n\n  const syncResult = numberIntersection.safeParse(1234);\n  expect(syncResult.success).toEqual(false);\n  if (!syncResult.success) {\n    expect(syncResult.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_intersection_types);\n  }\n\n  const asyncResult = await numberIntersection.spa(1234);\n  expect(asyncResult.success).toEqual(false);\n  if (!asyncResult.success) {\n    expect(asyncResult.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_intersection_types);\n  }\n});\n\ntest(\"invalid array merge\", async () => {\n  const stringArrInt = z.intersection(\n    z.string().array(),\n    z\n      .string()\n      .array()\n      .transform((val) => [...val, \"asdf\"])\n  );\n  const syncResult = stringArrInt.safeParse([\"asdf\", \"qwer\"]);\n  expect(syncResult.success).toEqual(false);\n  if (!syncResult.success) {\n    expect(syncResult.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_intersection_types);\n  }\n\n  const asyncResult = await stringArrInt.spa([\"asdf\", \"qwer\"]);\n  expect(asyncResult.success).toEqual(false);\n  if (!asyncResult.success) {\n    expect(asyncResult.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_intersection_types);\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/language-server.source.ts",
    "content": "import * as z from \"zod/v3\";\n\nexport const filePath = __filename;\n\n// z.object()\n\nexport const Test = z.object({\n  f1: z.number(),\n});\n\nexport type Test = z.infer<typeof Test>;\n\nexport const instanceOfTest: Test = {\n  f1: 1,\n};\n\n// z.object().merge()\n\nexport const TestMerge = z\n  .object({\n    f2: z.string().optional(),\n  })\n  .merge(Test);\n\nexport type TestMerge = z.infer<typeof TestMerge>;\n\nexport const instanceOfTestMerge: TestMerge = {\n  f1: 1,\n  f2: \"string\",\n};\n\n// z.union()\n\nexport const TestUnion = z.union([\n  z.object({\n    f2: z.string().optional(),\n  }),\n  Test,\n]);\n\nexport type TestUnion = z.infer<typeof TestUnion>;\n\nexport const instanceOfTestUnion: TestUnion = {\n  f1: 1,\n  f2: \"string\",\n};\n\n// z.object().partial()\n\nexport const TestPartial = Test.partial();\n\nexport type TestPartial = z.infer<typeof TestPartial>;\n\nexport const instanceOfTestPartial: TestPartial = {\n  f1: 1,\n};\n\n// z.object().pick()\n\nexport const TestPick = TestMerge.pick({ f1: true });\n\nexport type TestPick = z.infer<typeof TestPick>;\n\nexport const instanceOfTestPick: TestPick = {\n  f1: 1,\n};\n\n// z.object().omit()\n\nexport const TestOmit = TestMerge.omit({ f2: true });\n\nexport type TestOmit = z.infer<typeof TestOmit>;\n\nexport const instanceOfTestOmit: TestOmit = {\n  f1: 1,\n};\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/language-server.test.ts",
    "content": "import { test } from \"vitest\";\n// import path from \"path\";\n// import { Node, Project, SyntaxKind } from \"ts-morph\";\n\n// import { filePath } from \"./language-server.source\";\n\n// The following tool is helpful for understanding the TypeScript AST associated with these tests:\n// https://ts-ast-viewer.com/ (just copy the contents of language-server.source into the viewer)\n\ntest(\"\", () => {});\n// describe(\"Executing Go To Definition (and therefore Find Usages and Rename Refactoring) using an IDE works on inferred object properties\", () => {\n//   // Compile file developmentEnvironment.source\n//   const project = new Project({\n//     tsConfigFilePath: path.join(__dirname, \"..\", \"..\", \"tsconfig.json\"),\n//     skipAddingFilesFromTsConfig: true,\n//   });\n//   const sourceFile = project.addSourceFileAtPath(filePath);\n\n//   test(\"works for object properties inferred from z.object()\", () => {\n//     // Find usage of Test.f1 property\n//     const instanceVariable =\n//       sourceFile.getVariableDeclarationOrThrow(\"instanceOfTest\");\n//     const propertyBeingAssigned = getPropertyBeingAssigned(\n//       instanceVariable,\n//       \"f1\"\n//     );\n\n//     // Find definition of Test.f1 property\n//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//       SyntaxKind.VariableDeclaration\n//     );\n\n//     // Assert that find definition returned the Zod definition of Test\n//     expect(definitionOfProperty?.getText()).toEqual(\"f1: z.number()\");\n//     expect(parentOfProperty?.getName()).toEqual(\"Test\");\n//   });\n\n//   // test(\"works for first object properties inferred from z.object().merge()\", () => {\n//   //   // Find usage of TestMerge.f1 property\n//   //   const instanceVariable = sourceFile.getVariableDeclarationOrThrow(\n//   //     \"instanceOfTestMerge\"\n//   //   );\n//   //   const propertyBeingAssigned = getPropertyBeingAssigned(\n//   //     instanceVariable,\n//   //     \"f1\"\n//   //   );\n\n//   //   // Find definition of TestMerge.f1 property\n//   //   const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//   //   const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//   //     SyntaxKind.VariableDeclaration\n//   //   );\n\n//   //   // Assert that find definition returned the Zod definition of Test\n//   //   expect(definitionOfProperty?.getText()).toEqual(\"f1: z.number()\");\n//   //   expect(parentOfProperty?.getName()).toEqual(\"Test\");\n//   // });\n\n//   // test(\"works for second object properties inferred from z.object().merge()\", () => {\n//   //   // Find usage of TestMerge.f2 property\n//   //   const instanceVariable = sourceFile.getVariableDeclarationOrThrow(\n//   //     \"instanceOfTestMerge\"\n//   //   );\n//   //   const propertyBeingAssigned = getPropertyBeingAssigned(\n//   //     instanceVariable,\n//   //     \"f2\"\n//   //   );\n\n//   //   // Find definition of TestMerge.f2 property\n//   //   const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//   //   const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//   //     SyntaxKind.VariableDeclaration\n//   //   );\n\n//   //   // Assert that find definition returned the Zod definition of TestMerge\n//   //   expect(definitionOfProperty?.getText()).toEqual(\n//   //     \"f2: z.string().optional()\"\n//   //   );\n//   //   expect(parentOfProperty?.getName()).toEqual(\"TestMerge\");\n//   // });\n\n//   test(\"works for first object properties inferred from z.union()\", () => {\n//     // Find usage of TestUnion.f1 property\n//     const instanceVariable = sourceFile.getVariableDeclarationOrThrow(\n//       \"instanceOfTestUnion\"\n//     );\n//     const propertyBeingAssigned = getPropertyBeingAssigned(\n//       instanceVariable,\n//       \"f1\"\n//     );\n\n//     // Find definition of TestUnion.f1 property\n//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//       SyntaxKind.VariableDeclaration\n//     );\n\n//     // Assert that find definition returned the Zod definition of Test\n//     expect(definitionOfProperty?.getText()).toEqual(\"f1: z.number()\");\n//     expect(parentOfProperty?.getName()).toEqual(\"Test\");\n//   });\n\n//   test(\"works for second object properties inferred from z.union()\", () => {\n//     // Find usage of TestUnion.f2 property\n//     const instanceVariable = sourceFile.getVariableDeclarationOrThrow(\n//       \"instanceOfTestUnion\"\n//     );\n//     const propertyBeingAssigned = getPropertyBeingAssigned(\n//       instanceVariable,\n//       \"f2\"\n//     );\n\n//     // Find definition of TestUnion.f2 property\n//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//       SyntaxKind.VariableDeclaration\n//     );\n\n//     // Assert that find definition returned the Zod definition of TestUnion\n//     expect(definitionOfProperty?.getText()).toEqual(\n//       \"f2: z.string().optional()\"\n//     );\n//     expect(parentOfProperty?.getName()).toEqual(\"TestUnion\");\n//   });\n\n//   test(\"works for object properties inferred from z.object().partial()\", () => {\n//     // Find usage of TestPartial.f1 property\n//     const instanceVariable = sourceFile.getVariableDeclarationOrThrow(\n//       \"instanceOfTestPartial\"\n//     );\n//     const propertyBeingAssigned = getPropertyBeingAssigned(\n//       instanceVariable,\n//       \"f1\"\n//     );\n\n//     // Find definition of TestPartial.f1 property\n//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//       SyntaxKind.VariableDeclaration\n//     );\n\n//     // Assert that find definition returned the Zod definition of Test\n//     expect(definitionOfProperty?.getText()).toEqual(\"f1: z.number()\");\n//     expect(parentOfProperty?.getName()).toEqual(\"Test\");\n//   });\n\n//   test(\"works for object properties inferred from z.object().pick()\", () => {\n//     // Find usage of TestPick.f1 property\n//     const instanceVariable =\n//       sourceFile.getVariableDeclarationOrThrow(\"instanceOfTestPick\");\n//     const propertyBeingAssigned = getPropertyBeingAssigned(\n//       instanceVariable,\n//       \"f1\"\n//     );\n\n//     // Find definition of TestPick.f1 property\n//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//       SyntaxKind.VariableDeclaration\n//     );\n\n//     // Assert that find definition returned the Zod definition of Test\n//     expect(definitionOfProperty?.getText()).toEqual(\"f1: z.number()\");\n//     expect(parentOfProperty?.getName()).toEqual(\"Test\");\n//   });\n\n//   test(\"works for object properties inferred from z.object().omit()\", () => {\n//     // Find usage of TestOmit.f1 property\n//     const instanceVariable =\n//       sourceFile.getVariableDeclarationOrThrow(\"instanceOfTestOmit\");\n//     const propertyBeingAssigned = getPropertyBeingAssigned(\n//       instanceVariable,\n//       \"f1\"\n//     );\n\n//     // Find definition of TestOmit.f1 property\n//     const definitionOfProperty = propertyBeingAssigned?.getDefinitionNodes()[0];\n//     const parentOfProperty = definitionOfProperty?.getFirstAncestorByKind(\n//       SyntaxKind.VariableDeclaration\n//     );\n\n//     // Assert that find definition returned the Zod definition of Test\n//     expect(definitionOfProperty?.getText()).toEqual(\"f1: z.number()\");\n//     expect(parentOfProperty?.getName()).toEqual(\"Test\");\n//   });\n// });\n\n// const getPropertyBeingAssigned = (node: Node, name: string) => {\n//   const propertyAssignment = node.forEachDescendant((descendent) =>\n//     Node.isPropertyAssignment(descendent) && descendent.getName() == name\n//       ? descendent\n//       : undefined\n//   );\n\n//   if (propertyAssignment == null)\n//     fail(`Could not find property assignment with name ${name}`);\n\n//   const propertyLiteral = propertyAssignment.getFirstDescendantByKind(\n//     SyntaxKind.Identifier\n//   );\n\n//   if (propertyLiteral == null)\n//     fail(`Could not find property literal with name ${name}`);\n\n//   return propertyLiteral;\n// };\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/literal.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst literalTuna = z.literal(\"tuna\");\nconst literalFortyTwo = z.literal(42);\nconst literalTrue = z.literal(true);\n\nconst terrificSymbol = Symbol(\"terrific\");\nconst literalTerrificSymbol = z.literal(terrificSymbol);\n\ntest(\"passing validations\", () => {\n  literalTuna.parse(\"tuna\");\n  literalFortyTwo.parse(42);\n  literalTrue.parse(true);\n  literalTerrificSymbol.parse(terrificSymbol);\n});\n\ntest(\"failing validations\", () => {\n  expect(() => literalTuna.parse(\"shark\")).toThrow();\n  expect(() => literalFortyTwo.parse(43)).toThrow();\n  expect(() => literalTrue.parse(false)).toThrow();\n  expect(() => literalTerrificSymbol.parse(Symbol(\"terrific\"))).toThrow();\n});\n\ntest(\"invalid_literal should have `received` field with data\", () => {\n  const data = \"shark\";\n  const result = literalTuna.safeParse(data);\n  if (!result.success) {\n    const issue = result.error.issues[0];\n    if (issue.code === \"invalid_literal\") {\n      expect(issue.received).toBe(data);\n    }\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/map.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { ZodIssueCode } from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst stringMap = z.map(z.string(), z.string());\ntype stringMap = z.infer<typeof stringMap>;\n\ntest(\"type inference\", () => {\n  util.assertEqual<stringMap, Map<string, string>>(true);\n});\n\ntest(\"valid parse\", () => {\n  const result = stringMap.safeParse(\n    new Map([\n      [\"first\", \"foo\"],\n      [\"second\", \"bar\"],\n    ])\n  );\n  expect(result.success).toEqual(true);\n  if (result.success) {\n    expect(result.data.has(\"first\")).toEqual(true);\n    expect(result.data.has(\"second\")).toEqual(true);\n    expect(result.data.get(\"first\")).toEqual(\"foo\");\n    expect(result.data.get(\"second\")).toEqual(\"bar\");\n  }\n});\n\ntest(\"valid parse async\", async () => {\n  const result = await stringMap.spa(\n    new Map([\n      [\"first\", \"foo\"],\n      [\"second\", \"bar\"],\n    ])\n  );\n  expect(result.success).toEqual(true);\n  if (result.success) {\n    expect(result.data.has(\"first\")).toEqual(true);\n    expect(result.data.has(\"second\")).toEqual(true);\n    expect(result.data.get(\"first\")).toEqual(\"foo\");\n    expect(result.data.get(\"second\")).toEqual(\"bar\");\n  }\n});\n\ntest(\"throws when a Set is given\", () => {\n  const result = stringMap.safeParse(new Set([]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);\n  }\n});\n\ntest(\"throws when the given map has invalid key and invalid input\", () => {\n  const result = stringMap.safeParse(new Map([[42, Symbol()]]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);\n    expect(result.error.issues[0].path).toEqual([0, \"key\"]);\n    expect(result.error.issues[1].code).toEqual(ZodIssueCode.invalid_type);\n    expect(result.error.issues[1].path).toEqual([0, \"value\"]);\n  }\n});\n\ntest(\"throws when the given map has multiple invalid entries\", () => {\n  // const result = stringMap.safeParse(new Map([[42, Symbol()]]));\n\n  const result = stringMap.safeParse(\n    new Map([\n      [1, \"foo\"],\n      [\"bar\", 2],\n    ] as [any, any][]) as Map<any, any>\n  );\n\n  // const result = stringMap.safeParse(new Map([[42, Symbol()]]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);\n    expect(result.error.issues[0].path).toEqual([0, \"key\"]);\n    expect(result.error.issues[1].code).toEqual(ZodIssueCode.invalid_type);\n    expect(result.error.issues[1].path).toEqual([1, \"value\"]);\n  }\n});\n\ntest(\"dirty\", async () => {\n  const map = z.map(\n    z.string().refine((val) => val === val.toUpperCase(), {\n      message: \"Keys must be uppercase\",\n    }),\n    z.string()\n  );\n  const result = await map.spa(\n    new Map([\n      [\"first\", \"foo\"],\n      [\"second\", \"bar\"],\n    ])\n  );\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);\n    expect(result.error.issues[0].message).toEqual(\"Keys must be uppercase\");\n    expect(result.error.issues[1].code).toEqual(z.ZodIssueCode.custom);\n    expect(result.error.issues[1].message).toEqual(\"Keys must be uppercase\");\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/masking.test.ts",
    "content": "// @ts-ignore TS6133\nimport { test } from \"vitest\";\n\ntest(\"masking test\", () => {});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/mocker.test.ts",
    "content": "// @ts-ignore TS6133\nimport { test } from \"vitest\";\n\nimport { Mocker } from \"./Mocker.js\";\n\ntest(\"mocker\", () => {\n  const mocker = new Mocker();\n  mocker.string;\n  mocker.number;\n  mocker.boolean;\n  mocker.null;\n  mocker.undefined;\n  mocker.stringOptional;\n  mocker.stringNullable;\n  mocker.numberOptional;\n  mocker.numberNullable;\n  mocker.booleanOptional;\n  mocker.booleanNullable;\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/Mocker.ts",
    "content": "function getRandomInt(max: number) {\n  return Math.floor(Math.random() * Math.floor(max));\n}\n\nconst testSymbol = Symbol(\"test\");\n\nexport class Mocker {\n  pick = (...args: any[]): any => {\n    return args[getRandomInt(args.length)];\n  };\n\n  get string(): string {\n    return Math.random().toString(36).substring(7);\n  }\n  get number(): number {\n    return Math.random() * 100;\n  }\n  get bigint(): bigint {\n    return BigInt(Math.floor(Math.random() * 10000));\n  }\n  get boolean(): boolean {\n    return Math.random() < 0.5;\n  }\n  get date(): Date {\n    return new Date(Math.floor(Date.now() * Math.random()));\n  }\n  get symbol(): symbol {\n    return testSymbol;\n  }\n  get null(): null {\n    return null;\n  }\n  get undefined(): undefined {\n    return undefined;\n  }\n  get stringOptional(): string | undefined {\n    return this.pick(this.string, this.undefined);\n  }\n  get stringNullable(): string | null {\n    return this.pick(this.string, this.null);\n  }\n  get numberOptional(): number | undefined {\n    return this.pick(this.number, this.undefined);\n  }\n  get numberNullable(): number | null {\n    return this.pick(this.number, this.null);\n  }\n  get booleanOptional(): boolean | undefined {\n    return this.pick(this.boolean, this.undefined);\n  }\n  get booleanNullable(): boolean | null {\n    return this.pick(this.boolean, this.null);\n  }\n}\n",
    "symbols": [
      {
        "name": "getRandomInt",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/Mocker.ts",
        "startLine": 1,
        "endLine": 3
      },
      {
        "name": "Mocker",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/Mocker.ts",
        "startLine": 7,
        "endLine": 54
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/nan.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst schema = z.nan();\n\ntest(\"passing validations\", () => {\n  schema.parse(Number.NaN);\n  schema.parse(Number(\"Not a number\"));\n});\n\ntest(\"failing validations\", () => {\n  expect(() => schema.parse(5)).toThrow();\n  expect(() => schema.parse(\"John\")).toThrow();\n  expect(() => schema.parse(true)).toThrow();\n  expect(() => schema.parse(null)).toThrow();\n  expect(() => schema.parse(undefined)).toThrow();\n  expect(() => schema.parse({})).toThrow();\n  expect(() => schema.parse([])).toThrow();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/nativeEnum.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"nativeEnum test with consts\", () => {\n  const Fruits: { Apple: \"apple\"; Banana: \"banana\" } = {\n    Apple: \"apple\",\n    Banana: \"banana\",\n  };\n  const fruitEnum = z.nativeEnum(Fruits);\n  type fruitEnum = z.infer<typeof fruitEnum>;\n  fruitEnum.parse(\"apple\");\n  fruitEnum.parse(\"banana\");\n  fruitEnum.parse(Fruits.Apple);\n  fruitEnum.parse(Fruits.Banana);\n  util.assertEqual<fruitEnum, \"apple\" | \"banana\">(true);\n});\n\ntest(\"nativeEnum test with real enum\", () => {\n  enum Fruits {\n    Apple = \"apple\",\n    Banana = \"banana\",\n  }\n  // @ts-ignore\n  const fruitEnum = z.nativeEnum(Fruits);\n  type fruitEnum = z.infer<typeof fruitEnum>;\n  fruitEnum.parse(\"apple\");\n  fruitEnum.parse(\"banana\");\n  fruitEnum.parse(Fruits.Apple);\n  fruitEnum.parse(Fruits.Banana);\n  util.assertIs<fruitEnum extends Fruits ? true : false>(true);\n});\n\ntest(\"nativeEnum test with const with numeric keys\", () => {\n  const FruitValues = {\n    Apple: 10,\n    Banana: 20,\n    // @ts-ignore\n  } as const;\n  const fruitEnum = z.nativeEnum(FruitValues);\n  type fruitEnum = z.infer<typeof fruitEnum>;\n  fruitEnum.parse(10);\n  fruitEnum.parse(20);\n  fruitEnum.parse(FruitValues.Apple);\n  fruitEnum.parse(FruitValues.Banana);\n  util.assertEqual<fruitEnum, 10 | 20>(true);\n});\n\ntest(\"from enum\", () => {\n  enum Fruits {\n    Cantaloupe = 0,\n    Apple = \"apple\",\n    Banana = \"banana\",\n  }\n\n  const FruitEnum = z.nativeEnum(Fruits as any);\n  type _FruitEnum = z.infer<typeof FruitEnum>;\n  FruitEnum.parse(Fruits.Cantaloupe);\n  FruitEnum.parse(Fruits.Apple);\n  FruitEnum.parse(\"apple\");\n  FruitEnum.parse(0);\n  expect(() => FruitEnum.parse(1)).toThrow();\n  expect(() => FruitEnum.parse(\"Apple\")).toThrow();\n  expect(() => FruitEnum.parse(\"Cantaloupe\")).toThrow();\n});\n\ntest(\"from const\", () => {\n  const Greek = {\n    Alpha: \"a\",\n    Beta: \"b\",\n    Gamma: 3,\n    // @ts-ignore\n  } as const;\n\n  const GreekEnum = z.nativeEnum(Greek);\n  type _GreekEnum = z.infer<typeof GreekEnum>;\n  GreekEnum.parse(\"a\");\n  GreekEnum.parse(\"b\");\n  GreekEnum.parse(3);\n  expect(() => GreekEnum.parse(\"v\")).toThrow();\n  expect(() => GreekEnum.parse(\"Alpha\")).toThrow();\n  expect(() => GreekEnum.parse(2)).toThrow();\n\n  expect(GreekEnum.enum.Alpha).toEqual(\"a\");\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/nullable.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nfunction checkErrors(a: z.ZodTypeAny, bad: any) {\n  let expected: any;\n  try {\n    a.parse(bad);\n  } catch (error) {\n    expected = (error as z.ZodError).formErrors;\n  }\n  try {\n    a.nullable().parse(bad);\n  } catch (error) {\n    expect((error as z.ZodError).formErrors).toEqual(expected);\n  }\n}\n\ntest(\"Should have error messages appropriate for the underlying type\", () => {\n  checkErrors(z.string().min(2), 1);\n  z.string().min(2).nullable().parse(null);\n  checkErrors(z.number().gte(2), 1);\n  z.number().gte(2).nullable().parse(null);\n  checkErrors(z.boolean(), \"\");\n  z.boolean().nullable().parse(null);\n  checkErrors(z.null(), null);\n  z.null().nullable().parse(null);\n  checkErrors(z.null(), {});\n  z.null().nullable().parse(null);\n  checkErrors(z.object({}), 1);\n  z.object({}).nullable().parse(null);\n  checkErrors(z.tuple([]), 1);\n  z.tuple([]).nullable().parse(null);\n  checkErrors(z.unknown(), 1);\n  z.unknown().nullable().parse(null);\n});\n\ntest(\"unwrap\", () => {\n  const unwrapped = z.string().nullable().unwrap();\n  expect(unwrapped).toBeInstanceOf(z.ZodString);\n});\n",
    "symbols": [
      {
        "name": "checkErrors",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/nullable.test.ts",
        "startLine": 6,
        "endLine": 18
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/number.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst gtFive = z.number().gt(5);\nconst gteFive = z.number().gte(-5).gte(5);\nconst minFive = z.number().min(0).min(5);\nconst ltFive = z.number().lte(10).lt(5);\nconst lteFive = z.number().lte(5);\nconst maxFive = z.number().max(10).max(5);\nconst intNum = z.number().int();\nconst positive = z.number().positive();\nconst negative = z.number().negative();\nconst nonpositive = z.number().nonpositive();\nconst nonnegative = z.number().nonnegative();\nconst multipleOfFive = z.number().multipleOf(5);\nconst multipleOfNegativeFive = z.number().multipleOf(-5);\nconst finite = z.number().finite();\nconst safe = z.number().safe();\nconst stepPointOne = z.number().step(0.1);\nconst stepPointZeroZeroZeroOne = z.number().step(0.0001);\nconst stepSixPointFour = z.number().step(6.4);\n\ntest(\"passing validations\", () => {\n  z.number().parse(1);\n  z.number().parse(1.5);\n  z.number().parse(0);\n  z.number().parse(-1.5);\n  z.number().parse(-1);\n  z.number().parse(Number.POSITIVE_INFINITY);\n  z.number().parse(Number.NEGATIVE_INFINITY);\n  gtFive.parse(6);\n  gtFive.parse(Number.POSITIVE_INFINITY);\n  gteFive.parse(5);\n  gteFive.parse(Number.POSITIVE_INFINITY);\n  minFive.parse(5);\n  minFive.parse(Number.POSITIVE_INFINITY);\n  ltFive.parse(4);\n  ltFive.parse(Number.NEGATIVE_INFINITY);\n  lteFive.parse(5);\n  lteFive.parse(Number.NEGATIVE_INFINITY);\n  maxFive.parse(5);\n  maxFive.parse(Number.NEGATIVE_INFINITY);\n  intNum.parse(4);\n  positive.parse(1);\n  positive.parse(Number.POSITIVE_INFINITY);\n  negative.parse(-1);\n  negative.parse(Number.NEGATIVE_INFINITY);\n  nonpositive.parse(0);\n  nonpositive.parse(-1);\n  nonpositive.parse(Number.NEGATIVE_INFINITY);\n  nonnegative.parse(0);\n  nonnegative.parse(1);\n  nonnegative.parse(Number.POSITIVE_INFINITY);\n  multipleOfFive.parse(15);\n  multipleOfFive.parse(-15);\n  multipleOfNegativeFive.parse(-15);\n  multipleOfNegativeFive.parse(15);\n  finite.parse(123);\n  safe.parse(Number.MIN_SAFE_INTEGER);\n  safe.parse(Number.MAX_SAFE_INTEGER);\n  stepPointOne.parse(6);\n  stepPointOne.parse(6.1);\n  stepPointOne.parse(6.1);\n  stepSixPointFour.parse(12.8);\n  stepPointZeroZeroZeroOne.parse(3.01);\n});\n\ntest(\"failing validations\", () => {\n  expect(() => ltFive.parse(5)).toThrow();\n  expect(() => lteFive.parse(6)).toThrow();\n  expect(() => maxFive.parse(6)).toThrow();\n  expect(() => gtFive.parse(5)).toThrow();\n  expect(() => gteFive.parse(4)).toThrow();\n  expect(() => minFive.parse(4)).toThrow();\n  expect(() => intNum.parse(3.14)).toThrow();\n  expect(() => positive.parse(0)).toThrow();\n  expect(() => positive.parse(-1)).toThrow();\n  expect(() => negative.parse(0)).toThrow();\n  expect(() => negative.parse(1)).toThrow();\n  expect(() => nonpositive.parse(1)).toThrow();\n  expect(() => nonnegative.parse(-1)).toThrow();\n  expect(() => multipleOfFive.parse(7.5)).toThrow();\n  expect(() => multipleOfFive.parse(-7.5)).toThrow();\n  expect(() => multipleOfNegativeFive.parse(-7.5)).toThrow();\n  expect(() => multipleOfNegativeFive.parse(7.5)).toThrow();\n  expect(() => finite.parse(Number.POSITIVE_INFINITY)).toThrow();\n  expect(() => finite.parse(Number.NEGATIVE_INFINITY)).toThrow();\n  expect(() => safe.parse(Number.MIN_SAFE_INTEGER - 1)).toThrow();\n  expect(() => safe.parse(Number.MAX_SAFE_INTEGER + 1)).toThrow();\n\n  expect(() => stepPointOne.parse(6.11)).toThrow();\n  expect(() => stepPointOne.parse(6.1000000001)).toThrow();\n  expect(() => stepSixPointFour.parse(6.41)).toThrow();\n});\n\ntest(\"parse NaN\", () => {\n  expect(() => z.number().parse(Number.NaN)).toThrow();\n});\n\ntest(\"min max getters\", () => {\n  expect(z.number().minValue).toBeNull;\n  expect(ltFive.minValue).toBeNull;\n  expect(lteFive.minValue).toBeNull;\n  expect(maxFive.minValue).toBeNull;\n  expect(negative.minValue).toBeNull;\n  expect(nonpositive.minValue).toBeNull;\n  expect(intNum.minValue).toBeNull;\n  expect(multipleOfFive.minValue).toBeNull;\n  expect(finite.minValue).toBeNull;\n  expect(gtFive.minValue).toEqual(5);\n  expect(gteFive.minValue).toEqual(5);\n  expect(minFive.minValue).toEqual(5);\n  expect(minFive.min(10).minValue).toEqual(10);\n  expect(positive.minValue).toEqual(0);\n  expect(nonnegative.minValue).toEqual(0);\n  expect(safe.minValue).toEqual(Number.MIN_SAFE_INTEGER);\n\n  expect(z.number().maxValue).toBeNull;\n  expect(gtFive.maxValue).toBeNull;\n  expect(gteFive.maxValue).toBeNull;\n  expect(minFive.maxValue).toBeNull;\n  expect(positive.maxValue).toBeNull;\n  expect(nonnegative.maxValue).toBeNull;\n  expect(intNum.minValue).toBeNull;\n  expect(multipleOfFive.minValue).toBeNull;\n  expect(finite.minValue).toBeNull;\n  expect(ltFive.maxValue).toEqual(5);\n  expect(lteFive.maxValue).toEqual(5);\n  expect(maxFive.maxValue).toEqual(5);\n  expect(maxFive.max(1).maxValue).toEqual(1);\n  expect(negative.maxValue).toEqual(0);\n  expect(nonpositive.maxValue).toEqual(0);\n  expect(safe.maxValue).toEqual(Number.MAX_SAFE_INTEGER);\n});\n\ntest(\"int getter\", () => {\n  expect(z.number().isInt).toEqual(false);\n  expect(z.number().multipleOf(1.5).isInt).toEqual(false);\n  expect(gtFive.isInt).toEqual(false);\n  expect(gteFive.isInt).toEqual(false);\n  expect(minFive.isInt).toEqual(false);\n  expect(positive.isInt).toEqual(false);\n  expect(nonnegative.isInt).toEqual(false);\n  expect(finite.isInt).toEqual(false);\n  expect(ltFive.isInt).toEqual(false);\n  expect(lteFive.isInt).toEqual(false);\n  expect(maxFive.isInt).toEqual(false);\n  expect(negative.isInt).toEqual(false);\n  expect(nonpositive.isInt).toEqual(false);\n  expect(safe.isInt).toEqual(false);\n\n  expect(intNum.isInt).toEqual(true);\n  expect(multipleOfFive.isInt).toEqual(true);\n});\n\ntest(\"finite getter\", () => {\n  expect(z.number().isFinite).toEqual(false);\n  expect(gtFive.isFinite).toEqual(false);\n  expect(gteFive.isFinite).toEqual(false);\n  expect(minFive.isFinite).toEqual(false);\n  expect(positive.isFinite).toEqual(false);\n  expect(nonnegative.isFinite).toEqual(false);\n  expect(ltFive.isFinite).toEqual(false);\n  expect(lteFive.isFinite).toEqual(false);\n  expect(maxFive.isFinite).toEqual(false);\n  expect(negative.isFinite).toEqual(false);\n  expect(nonpositive.isFinite).toEqual(false);\n\n  expect(finite.isFinite).toEqual(true);\n  expect(intNum.isFinite).toEqual(true);\n  expect(multipleOfFive.isFinite).toEqual(true);\n  expect(z.number().min(5).max(10).isFinite).toEqual(true);\n  expect(safe.isFinite).toEqual(true);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/object-augmentation.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"object augmentation\", () => {\n  const Animal = z\n    .object({\n      species: z.string(),\n    })\n    .augment({\n      population: z.number(),\n    });\n  // overwrites `species`\n  const ModifiedAnimal = Animal.augment({\n    species: z.array(z.string()),\n  });\n  ModifiedAnimal.parse({\n    species: [\"asd\"],\n    population: 1324,\n  });\n\n  const bad = () =>\n    ModifiedAnimal.parse({\n      species: \"asdf\",\n      population: 1324,\n    } as any);\n  expect(bad).toThrow();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/object-in-es5-env.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst RealSet = Set;\nconst RealMap = Map;\nconst RealDate = Date;\n\ntest(\"doesn’t throw when Date is undefined\", () => {\n  delete (globalThis as any).Date;\n  const result = z.object({}).safeParse({});\n  expect(result.success).toEqual(true);\n  globalThis.Date = RealDate;\n});\n\ntest(\"doesn’t throw when Set is undefined\", () => {\n  delete (globalThis as any).Set;\n  const result = z.object({}).safeParse({});\n  expect(result.success).toEqual(true);\n  globalThis.Set = RealSet;\n});\n\ntest(\"doesn’t throw when Map is undefined\", () => {\n  delete (globalThis as any).Map;\n  const result = z.object({}).safeParse({});\n  expect(result.success).toEqual(true);\n  globalThis.Map = RealMap;\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/object.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst Test = z.object({\n  f1: z.number(),\n  f2: z.string().optional(),\n  f3: z.string().nullable(),\n  f4: z.array(z.object({ t: z.union([z.string(), z.boolean()]) })),\n});\n\ntest(\"object type inference\", () => {\n  type TestType = {\n    f1: number;\n    f2?: string | undefined;\n    f3: string | null;\n    f4: { t: string | boolean }[];\n  };\n\n  util.assertEqual<z.TypeOf<typeof Test>, TestType>(true);\n});\n\ntest(\"unknown throw\", () => {\n  const asdf: unknown = 35;\n  expect(() => Test.parse(asdf)).toThrow();\n});\n\ntest(\"shape() should return schema of particular key\", () => {\n  const f1Schema = Test.shape.f1;\n  const f2Schema = Test.shape.f2;\n  const f3Schema = Test.shape.f3;\n  const f4Schema = Test.shape.f4;\n\n  expect(f1Schema).toBeInstanceOf(z.ZodNumber);\n  expect(f2Schema).toBeInstanceOf(z.ZodOptional);\n  expect(f3Schema).toBeInstanceOf(z.ZodNullable);\n  expect(f4Schema).toBeInstanceOf(z.ZodArray);\n});\n\ntest(\"correct parsing\", () => {\n  Test.parse({\n    f1: 12,\n    f2: \"string\",\n    f3: \"string\",\n    f4: [\n      {\n        t: \"string\",\n      },\n    ],\n  });\n\n  Test.parse({\n    f1: 12,\n    f3: null,\n    f4: [\n      {\n        t: false,\n      },\n    ],\n  });\n});\n\ntest(\"incorrect #1\", () => {\n  expect(() => Test.parse({} as any)).toThrow();\n});\n\ntest(\"nonstrict by default\", () => {\n  z.object({ points: z.number() }).parse({\n    points: 2314,\n    unknown: \"asdf\",\n  });\n});\n\nconst data = {\n  points: 2314,\n  unknown: \"asdf\",\n};\n\ntest(\"strip by default\", () => {\n  const val = z.object({ points: z.number() }).parse(data);\n  expect(val).toEqual({ points: 2314 });\n});\n\ntest(\"unknownkeys override\", () => {\n  const val = z.object({ points: z.number() }).strict().passthrough().strip().nonstrict().parse(data);\n\n  expect(val).toEqual(data);\n});\n\ntest(\"passthrough unknown\", () => {\n  const val = z.object({ points: z.number() }).passthrough().parse(data);\n\n  expect(val).toEqual(data);\n});\n\ntest(\"strip unknown\", () => {\n  const val = z.object({ points: z.number() }).strip().parse(data);\n\n  expect(val).toEqual({ points: 2314 });\n});\n\ntest(\"strict\", () => {\n  const val = z.object({ points: z.number() }).strict().safeParse(data);\n\n  expect(val.success).toEqual(false);\n});\n\ntest(\"catchall inference\", () => {\n  const o1 = z\n    .object({\n      first: z.string(),\n    })\n    .catchall(z.number());\n\n  const d1 = o1.parse({ first: \"asdf\", num: 1243 });\n  util.assertEqual<number, (typeof d1)[\"asdf\"]>(true);\n  util.assertEqual<string, (typeof d1)[\"first\"]>(true);\n});\n\ntest(\"catchall overrides strict\", () => {\n  const o1 = z.object({ first: z.string().optional() }).strict().catchall(z.number());\n\n  // should run fine\n  // setting a catchall overrides the unknownKeys behavior\n  o1.parse({\n    asdf: 1234,\n  });\n\n  // should only run catchall validation\n  // against unknown keys\n  o1.parse({\n    first: \"asdf\",\n    asdf: 1234,\n  });\n});\n\ntest(\"catchall overrides strict\", () => {\n  const o1 = z\n    .object({\n      first: z.string(),\n    })\n    .strict()\n    .catchall(z.number());\n\n  // should run fine\n  // setting a catchall overrides the unknownKeys behavior\n  o1.parse({\n    first: \"asdf\",\n    asdf: 1234,\n  });\n});\n\ntest(\"test that optional keys are unset\", async () => {\n  const SNamedEntity = z.object({\n    id: z.string(),\n    set: z.string().optional(),\n    unset: z.string().optional(),\n  });\n  const result = await SNamedEntity.parse({\n    id: \"asdf\",\n    set: undefined,\n  });\n  // eslint-disable-next-line ban/ban\n  expect(Object.keys(result)).toEqual([\"id\", \"set\"]);\n});\n\ntest(\"test catchall parsing\", async () => {\n  const result = z.object({ name: z.string() }).catchall(z.number()).parse({ name: \"Foo\", validExtraKey: 61 });\n\n  expect(result).toEqual({ name: \"Foo\", validExtraKey: 61 });\n\n  const result2 = z\n    .object({ name: z.string() })\n    .catchall(z.number())\n    .safeParse({ name: \"Foo\", validExtraKey: 61, invalid: \"asdf\" });\n\n  expect(result2.success).toEqual(false);\n});\n\ntest(\"test nonexistent keys\", async () => {\n  const Schema = z.union([z.object({ a: z.string() }), z.object({ b: z.number() })]);\n  const obj = { a: \"A\" };\n  const result = await Schema.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21\n  expect(result.success).toBe(true);\n});\n\ntest(\"test async union\", async () => {\n  const Schema2 = z.union([\n    z.object({\n      ty: z.string(),\n    }),\n    z.object({\n      ty: z.number(),\n    }),\n  ]);\n\n  const obj = { ty: \"A\" };\n  const result = await Schema2.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21\n  expect(result.success).toEqual(true);\n});\n\ntest(\"test inferred merged type\", async () => {\n  const asdf = z.object({ a: z.string() }).merge(z.object({ a: z.number() }));\n  type asdf = z.infer<typeof asdf>;\n  util.assertEqual<asdf, { a: number }>(true);\n});\n\ntest(\"inferred merged object type with optional properties\", async () => {\n  const Merged = z\n    .object({ a: z.string(), b: z.string().optional() })\n    .merge(z.object({ a: z.string().optional(), b: z.string() }));\n  type Merged = z.infer<typeof Merged>;\n  util.assertEqual<Merged, { a?: string; b: string }>(true);\n  // todo\n  // util.assertEqual<Merged, { a?: string; b: string }>(true);\n});\n\ntest(\"inferred unioned object type with optional properties\", async () => {\n  const Unioned = z.union([\n    z.object({ a: z.string(), b: z.string().optional() }),\n    z.object({ a: z.string().optional(), b: z.string() }),\n  ]);\n  type Unioned = z.infer<typeof Unioned>;\n  util.assertEqual<Unioned, { a: string; b?: string } | { a?: string; b: string }>(true);\n});\n\ntest(\"inferred enum type\", async () => {\n  const Enum = z.object({ a: z.string(), b: z.string().optional() }).keyof();\n\n  expect(Enum.Values).toEqual({\n    a: \"a\",\n    b: \"b\",\n  });\n  expect(Enum.enum).toEqual({\n    a: \"a\",\n    b: \"b\",\n  });\n  expect(Enum._def.values).toEqual([\"a\", \"b\"]);\n  type Enum = z.infer<typeof Enum>;\n  util.assertEqual<Enum, \"a\" | \"b\">(true);\n});\n\ntest(\"inferred partial object type with optional properties\", async () => {\n  const Partial = z.object({ a: z.string(), b: z.string().optional() }).partial();\n  type Partial = z.infer<typeof Partial>;\n  util.assertEqual<Partial, { a?: string; b?: string }>(true);\n});\n\ntest(\"inferred picked object type with optional properties\", async () => {\n  const Picked = z.object({ a: z.string(), b: z.string().optional() }).pick({ b: true });\n  type Picked = z.infer<typeof Picked>;\n  util.assertEqual<Picked, { b?: string }>(true);\n});\n\ntest(\"inferred type for unknown/any keys\", () => {\n  const myType = z.object({\n    anyOptional: z.any().optional(),\n    anyRequired: z.any(),\n    unknownOptional: z.unknown().optional(),\n    unknownRequired: z.unknown(),\n  });\n  type myType = z.infer<typeof myType>;\n  util.assertEqual<\n    myType,\n    {\n      anyOptional?: any;\n      anyRequired?: any;\n      unknownOptional?: unknown;\n      unknownRequired?: unknown;\n    }\n  >(true);\n});\n\ntest(\"setKey\", () => {\n  const base = z.object({ name: z.string() });\n  const withNewKey = base.setKey(\"age\", z.number());\n\n  type withNewKey = z.infer<typeof withNewKey>;\n  util.assertEqual<withNewKey, { name: string; age: number }>(true);\n  withNewKey.parse({ name: \"asdf\", age: 1234 });\n});\n\ntest(\"strictcreate\", async () => {\n  const strictObj = z.strictObject({\n    name: z.string(),\n  });\n\n  const syncResult = strictObj.safeParse({ name: \"asdf\", unexpected: 13 });\n  expect(syncResult.success).toEqual(false);\n\n  const asyncResult = await strictObj.spa({ name: \"asdf\", unexpected: 13 });\n  expect(asyncResult.success).toEqual(false);\n});\n\ntest(\"object with refine\", async () => {\n  const schema = z\n    .object({\n      a: z.string().default(\"foo\"),\n      b: z.number(),\n    })\n    .refine(() => true);\n  expect(schema.parse({ b: 5 })).toEqual({ b: 5, a: \"foo\" });\n  const result = await schema.parseAsync({ b: 5 });\n  expect(result).toEqual({ b: 5, a: \"foo\" });\n});\n\ntest(\"intersection of object with date\", async () => {\n  const schema = z.object({\n    a: z.date(),\n  });\n  expect(schema.and(schema).parse({ a: new Date(1637353595983) })).toEqual({\n    a: new Date(1637353595983),\n  });\n  const result = await schema.parseAsync({ a: new Date(1637353595983) });\n  expect(result).toEqual({ a: new Date(1637353595983) });\n});\n\ntest(\"intersection of object with refine with date\", async () => {\n  const schema = z\n    .object({\n      a: z.date(),\n    })\n    .refine(() => true);\n  expect(schema.and(schema).parse({ a: new Date(1637353595983) })).toEqual({\n    a: new Date(1637353595983),\n  });\n  const result = await schema.parseAsync({ a: new Date(1637353595983) });\n  expect(result).toEqual({ a: new Date(1637353595983) });\n});\n\ntest(\"constructor key\", () => {\n  const person = z\n    .object({\n      name: z.string(),\n    })\n    .strict();\n\n  expect(() =>\n    person.parse({\n      name: \"bob dylan\",\n      constructor: 61,\n    })\n  ).toThrow();\n});\n\ntest(\"constructor key\", () => {\n  const Example = z.object({\n    prop: z.string(),\n    opt: z.number().optional(),\n    arr: z.string().array(),\n  });\n\n  type Example = z.infer<typeof Example>;\n  util.assertEqual<keyof Example, \"prop\" | \"opt\" | \"arr\">(true);\n});\n\ntest(\"unknownkeys merging\", () => {\n  // This one is \"strict\"\n  const schemaA = z\n    .object({\n      a: z.string(),\n    })\n    .strict();\n\n  // This one is \"strip\"\n  const schemaB = z\n    .object({\n      b: z.string(),\n    })\n    .catchall(z.string());\n\n  const mergedSchema = schemaA.merge(schemaB);\n  type mergedSchema = typeof mergedSchema;\n  util.assertEqual<mergedSchema[\"_def\"][\"unknownKeys\"], \"strip\">(true);\n  expect(mergedSchema._def.unknownKeys).toEqual(\"strip\");\n\n  util.assertEqual<mergedSchema[\"_def\"][\"catchall\"], z.ZodString>(true);\n  expect(mergedSchema._def.catchall instanceof z.ZodString).toEqual(true);\n});\n\nconst personToExtend = z.object({\n  firstName: z.string(),\n  lastName: z.string(),\n});\n\ntest(\"extend() should return schema with new key\", () => {\n  const PersonWithNickname = personToExtend.extend({ nickName: z.string() });\n  type PersonWithNickname = z.infer<typeof PersonWithNickname>;\n\n  const expected = { firstName: \"f\", nickName: \"n\", lastName: \"l\" };\n  const actual = PersonWithNickname.parse(expected);\n\n  expect(actual).toEqual(expected);\n  util.assertEqual<keyof PersonWithNickname, \"firstName\" | \"lastName\" | \"nickName\">(true);\n  util.assertEqual<PersonWithNickname, { firstName: string; lastName: string; nickName: string }>(true);\n});\n\ntest(\"extend() should have power to override existing key\", () => {\n  const PersonWithNumberAsLastName = personToExtend.extend({\n    lastName: z.number(),\n  });\n  type PersonWithNumberAsLastName = z.infer<typeof PersonWithNumberAsLastName>;\n\n  const expected = { firstName: \"f\", lastName: 42 };\n  const actual = PersonWithNumberAsLastName.parse(expected);\n\n  expect(actual).toEqual(expected);\n  util.assertEqual<PersonWithNumberAsLastName, { firstName: string; lastName: number }>(true);\n});\n\ntest(\"passthrough index signature\", () => {\n  const a = z.object({ a: z.string() });\n  type a = z.infer<typeof a>;\n  util.assertEqual<{ a: string }, a>(true);\n  const b = a.passthrough();\n  type b = z.infer<typeof b>;\n  util.assertEqual<{ a: string } & { [k: string]: unknown }, b>(true);\n});\n\ntest(\"xor\", () => {\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n  type XOR<T, U> = T extends object ? (U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : U) : T;\n\n  type A = { name: string; a: number };\n  type B = { name: string; b: number };\n  type C = XOR<A, B>;\n  type Outer = { data: C };\n\n  const _Outer: z.ZodType<Outer> = z.object({\n    data: z.union([z.object({ name: z.string(), a: z.number() }), z.object({ name: z.string(), b: z.number() })]),\n  });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/optional.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nfunction checkErrors(a: z.ZodTypeAny, bad: any) {\n  let expected: any;\n  try {\n    a.parse(bad);\n  } catch (error) {\n    expected = (error as z.ZodError).formErrors;\n  }\n  try {\n    a.optional().parse(bad);\n  } catch (error) {\n    expect((error as z.ZodError).formErrors).toEqual(expected);\n  }\n}\n\ntest(\"Should have error messages appropriate for the underlying type\", () => {\n  checkErrors(z.string().min(2), 1);\n  z.string().min(2).optional().parse(undefined);\n  checkErrors(z.number().gte(2), 1);\n  z.number().gte(2).optional().parse(undefined);\n  checkErrors(z.boolean(), \"\");\n  z.boolean().optional().parse(undefined);\n  checkErrors(z.undefined(), null);\n  z.undefined().optional().parse(undefined);\n  checkErrors(z.null(), {});\n  z.null().optional().parse(undefined);\n  checkErrors(z.object({}), 1);\n  z.object({}).optional().parse(undefined);\n  checkErrors(z.tuple([]), 1);\n  z.tuple([]).optional().parse(undefined);\n  checkErrors(z.unknown(), 1);\n  z.unknown().optional().parse(undefined);\n});\n\ntest(\"unwrap\", () => {\n  const unwrapped = z.string().optional().unwrap();\n  expect(unwrapped).toBeInstanceOf(z.ZodString);\n});\n",
    "symbols": [
      {
        "name": "checkErrors",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/optional.test.ts",
        "startLine": 6,
        "endLine": 18
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/parser.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"parse strict object with unknown keys\", () => {\n  expect(() =>\n    z\n      .object({ name: z.string() })\n      .strict()\n      .parse({ name: \"bill\", unknownKey: 12 } as any)\n  ).toThrow();\n});\n\ntest(\"parse nonstrict object with unknown keys\", () => {\n  z.object({ name: z.string() }).nonstrict().parse({ name: \"bill\", unknownKey: 12 });\n});\n\ntest(\"invalid left side of intersection\", () => {\n  expect(() => z.intersection(z.string(), z.number()).parse(12 as any)).toThrow();\n});\n\ntest(\"invalid right side of intersection\", () => {\n  expect(() => z.intersection(z.string(), z.number()).parse(\"12\" as any)).toThrow();\n});\n\ntest(\"parsing non-array in tuple schema\", () => {\n  expect(() => z.tuple([]).parse(\"12\" as any)).toThrow();\n});\n\ntest(\"incorrect num elements in tuple\", () => {\n  expect(() => z.tuple([]).parse([\"asdf\"] as any)).toThrow();\n});\n\ntest(\"invalid enum value\", () => {\n  expect(() => z.enum([\"Blue\"]).parse(\"Red\" as any)).toThrow();\n});\n\ntest(\"parsing unknown\", () => {\n  z.string().parse(\"Red\" as unknown);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/parseUtil.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport { type SyncParseReturnType, isAborted, isDirty, isValid } from \"../helpers/parseUtil.js\";\n\ntest(\"parseUtil isInvalid should use structural typing\", () => {\n  // Test for issue #556: https://github.com/colinhacks/zod/issues/556\n  const aborted: SyncParseReturnType = { status: \"aborted\" };\n  const dirty: SyncParseReturnType = { status: \"dirty\", value: \"whatever\" };\n  const valid: SyncParseReturnType = { status: \"valid\", value: \"whatever\" };\n\n  expect(isAborted(aborted)).toBe(true);\n  expect(isAborted(dirty)).toBe(false);\n  expect(isAborted(valid)).toBe(false);\n\n  expect(isDirty(aborted)).toBe(false);\n  expect(isDirty(dirty)).toBe(true);\n  expect(isDirty(valid)).toBe(false);\n\n  expect(isValid(aborted)).toBe(false);\n  expect(isValid(dirty)).toBe(false);\n  expect(isValid(valid)).toBe(true);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/partials.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { ZodNullable, ZodOptional } from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst nested = z.object({\n  name: z.string(),\n  age: z.number(),\n  outer: z.object({\n    inner: z.string(),\n  }),\n  array: z.array(z.object({ asdf: z.string() })),\n});\n\ntest(\"shallow inference\", () => {\n  const shallow = nested.partial();\n  type shallow = z.infer<typeof shallow>;\n  type correct = {\n    name?: string | undefined;\n    age?: number | undefined;\n    outer?: { inner: string } | undefined;\n    array?: { asdf: string }[];\n  };\n  util.assertEqual<shallow, correct>(true);\n});\n\ntest(\"shallow partial parse\", () => {\n  const shallow = nested.partial();\n  shallow.parse({});\n  shallow.parse({\n    name: \"asdf\",\n    age: 23143,\n  });\n});\n\ntest(\"deep partial inference\", () => {\n  const deep = nested.deepPartial();\n  const asdf = deep.shape.array.unwrap().element.shape.asdf.unwrap();\n  asdf.parse(\"asdf\");\n  type deep = z.infer<typeof deep>;\n  type correct = {\n    array?: { asdf?: string }[];\n    name?: string | undefined;\n    age?: number | undefined;\n    outer?: { inner?: string | undefined } | undefined;\n  };\n\n  util.assertEqual<deep, correct>(true);\n});\n\ntest(\"deep partial parse\", () => {\n  const deep = nested.deepPartial();\n\n  expect(deep.shape.name instanceof z.ZodOptional).toBe(true);\n  expect(deep.shape.outer instanceof z.ZodOptional).toBe(true);\n  expect(deep.shape.outer._def.innerType instanceof z.ZodObject).toBe(true);\n  expect(deep.shape.outer._def.innerType.shape.inner instanceof z.ZodOptional).toBe(true);\n  expect(deep.shape.outer._def.innerType.shape.inner._def.innerType instanceof z.ZodString).toBe(true);\n});\n\ntest(\"deep partial runtime tests\", () => {\n  const deep = nested.deepPartial();\n  deep.parse({});\n  deep.parse({\n    outer: {},\n  });\n  deep.parse({\n    name: \"asdf\",\n    age: 23143,\n    outer: {\n      inner: \"adsf\",\n    },\n  });\n});\n\ntest(\"deep partial optional/nullable\", () => {\n  const schema = z\n    .object({\n      name: z.string().optional(),\n      age: z.number().nullable(),\n    })\n    .deepPartial();\n\n  expect(schema.shape.name.unwrap()).toBeInstanceOf(ZodOptional);\n  expect(schema.shape.age.unwrap()).toBeInstanceOf(ZodNullable);\n});\n\ntest(\"deep partial tuple\", () => {\n  const schema = z\n    .object({\n      tuple: z.tuple([\n        z.object({\n          name: z.string().optional(),\n          age: z.number().nullable(),\n        }),\n      ]),\n    })\n    .deepPartial();\n\n  expect(schema.shape.tuple.unwrap().items[0].shape.name).toBeInstanceOf(ZodOptional);\n});\n\ntest(\"deep partial inference\", () => {\n  const mySchema = z.object({\n    name: z.string(),\n    array: z.array(z.object({ asdf: z.string() })),\n    tuple: z.tuple([z.object({ value: z.string() })]),\n  });\n\n  const partialed = mySchema.deepPartial();\n  type partialed = z.infer<typeof partialed>;\n  type expected = {\n    name?: string | undefined;\n    array?:\n      | {\n          asdf?: string | undefined;\n        }[]\n      | undefined;\n    tuple?: [{ value?: string }] | undefined;\n  };\n  util.assertEqual<expected, partialed>(true);\n});\n\ntest(\"required\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    nullableField: z.number().nullable(),\n    nullishField: z.string().nullish(),\n  });\n\n  const requiredObject = object.required();\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);\n  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNumber);\n  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(requiredObject.shape.nullableField).toBeInstanceOf(z.ZodNullable);\n  expect(requiredObject.shape.nullishField).toBeInstanceOf(z.ZodNullable);\n});\n\ntest(\"required inference\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    nullableField: z.number().nullable(),\n    nullishField: z.string().nullish(),\n  });\n\n  const requiredObject = object.required();\n\n  type required = z.infer<typeof requiredObject>;\n  type expected = {\n    name: string;\n    age: number;\n    field: string;\n    nullableField: number | null;\n    nullishField: string | null;\n  };\n  util.assertEqual<expected, required>(true);\n});\n\ntest(\"required with mask\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string().optional(),\n  });\n\n  const requiredObject = object.required({ age: true });\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);\n  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNumber);\n  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);\n});\n\ntest(\"required with mask -- ignore falsy values\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string().optional(),\n  });\n\n  // @ts-expect-error\n  const requiredObject = object.required({ age: true, country: false });\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);\n  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNumber);\n  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);\n});\n\ntest(\"partial with mask\", async () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string(),\n  });\n\n  const masked = object.partial({ age: true, field: true, name: true }).strict();\n\n  expect(masked.shape.name).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.age).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.field).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.country).toBeInstanceOf(z.ZodString);\n\n  masked.parse({ country: \"US\" });\n  await masked.parseAsync({ country: \"US\" });\n});\n\ntest(\"partial with mask -- ignore falsy values\", async () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string(),\n  });\n\n  // @ts-expect-error\n  const masked = object.partial({ name: true, country: false }).strict();\n\n  expect(masked.shape.name).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.age).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(masked.shape.country).toBeInstanceOf(z.ZodString);\n\n  masked.parse({ country: \"US\" });\n  await masked.parseAsync({ country: \"US\" });\n});\n\ntest(\"deeppartial array\", () => {\n  const schema = z.object({ array: z.string().array().min(42) }).deepPartial();\n\n  // works as expected\n  schema.parse({});\n\n  // should be false, but is true\n  expect(schema.safeParse({ array: [] }).success).toBe(false);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/pickomit.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst fish = z.object({\n  name: z.string(),\n  age: z.number(),\n  nested: z.object({}),\n});\n\ntest(\"pick type inference\", () => {\n  const nameonlyFish = fish.pick({ name: true });\n  type nameonlyFish = z.infer<typeof nameonlyFish>;\n  util.assertEqual<nameonlyFish, { name: string }>(true);\n});\n\ntest(\"pick parse - success\", () => {\n  const nameonlyFish = fish.pick({ name: true });\n  nameonlyFish.parse({ name: \"bob\" });\n\n  // @ts-expect-error checking runtime picks `name` only.\n  const anotherNameonlyFish = fish.pick({ name: true, age: false });\n  anotherNameonlyFish.parse({ name: \"bob\" });\n});\n\ntest(\"pick parse - fail\", () => {\n  fish.pick({ name: true }).parse({ name: \"12\" } as any);\n  fish.pick({ name: true }).parse({ name: \"bob\", age: 12 } as any);\n  fish.pick({ age: true }).parse({ age: 12 } as any);\n\n  const nameonlyFish = fish.pick({ name: true }).strict();\n  const bad1 = () => nameonlyFish.parse({ name: 12 } as any);\n  const bad2 = () => nameonlyFish.parse({ name: \"bob\", age: 12 } as any);\n  const bad3 = () => nameonlyFish.parse({ age: 12 } as any);\n\n  // @ts-expect-error checking runtime picks `name` only.\n  const anotherNameonlyFish = fish.pick({ name: true, age: false }).strict();\n  const bad4 = () => anotherNameonlyFish.parse({ name: \"bob\", age: 12 } as any);\n\n  expect(bad1).toThrow();\n  expect(bad2).toThrow();\n  expect(bad3).toThrow();\n  expect(bad4).toThrow();\n});\n\ntest(\"omit type inference\", () => {\n  const nonameFish = fish.omit({ name: true });\n  type nonameFish = z.infer<typeof nonameFish>;\n  util.assertEqual<nonameFish, { age: number; nested: {} }>(true);\n});\n\ntest(\"omit parse - success\", () => {\n  const nonameFish = fish.omit({ name: true });\n  nonameFish.parse({ age: 12, nested: {} });\n\n  // @ts-expect-error checking runtime omits `name` only.\n  const anotherNonameFish = fish.omit({ name: true, age: false });\n  anotherNonameFish.parse({ age: 12, nested: {} });\n});\n\ntest(\"omit parse - fail\", () => {\n  const nonameFish = fish.omit({ name: true });\n  const bad1 = () => nonameFish.parse({ name: 12 } as any);\n  const bad2 = () => nonameFish.parse({ age: 12 } as any);\n  const bad3 = () => nonameFish.parse({} as any);\n\n  // @ts-expect-error checking runtime omits `name` only.\n  const anotherNonameFish = fish.omit({ name: true, age: false });\n  const bad4 = () => anotherNonameFish.parse({ nested: {} } as any);\n\n  expect(bad1).toThrow();\n  expect(bad2).toThrow();\n  expect(bad3).toThrow();\n  expect(bad4).toThrow();\n});\n\ntest(\"nonstrict inference\", () => {\n  const laxfish = fish.pick({ name: true }).catchall(z.any());\n  type laxfish = z.infer<typeof laxfish>;\n  util.assertEqual<laxfish, { name: string } & { [k: string]: any }>(true);\n});\n\ntest(\"nonstrict parsing - pass\", () => {\n  const laxfish = fish.passthrough().pick({ name: true });\n  laxfish.parse({ name: \"asdf\", whatever: \"asdf\" });\n  laxfish.parse({ name: \"asdf\", age: 12, nested: {} });\n});\n\ntest(\"nonstrict parsing - fail\", () => {\n  const laxfish = fish.passthrough().pick({ name: true });\n  const bad = () => laxfish.parse({ whatever: \"asdf\" } as any);\n  expect(bad).toThrow();\n});\n\ntest(\"pick/omit/required/partial - do not allow unknown keys\", () => {\n  const schema = z.object({\n    name: z.string(),\n    age: z.number(),\n  });\n\n  // @ts-expect-error\n  schema.pick({ $unknown: true });\n  // @ts-expect-error\n  schema.omit({ $unknown: true });\n  // @ts-expect-error\n  schema.required({ $unknown: true });\n  // @ts-expect-error\n  schema.partial({ $unknown: true });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/pipeline.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"string to number pipeline\", () => {\n  const schema = z.string().transform(Number).pipe(z.number());\n  expect(schema.parse(\"1234\")).toEqual(1234);\n});\n\ntest(\"string to number pipeline async\", async () => {\n  const schema = z\n    .string()\n    .transform(async (val) => Number(val))\n    .pipe(z.number());\n  expect(await schema.parseAsync(\"1234\")).toEqual(1234);\n});\n\ntest(\"break if dirty\", () => {\n  const schema = z\n    .string()\n    .refine((c) => c === \"1234\")\n    .transform(async (val) => Number(val))\n    .pipe(z.number().refine((v) => v < 100));\n  const r1: any = schema.safeParse(\"12345\");\n  expect(r1.error.issues.length).toBe(1);\n  const r2: any = schema.safeParse(\"3\");\n  expect(r2.error.issues.length).toBe(1);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/preprocess.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"preprocess\", () => {\n  const schema = z.preprocess((data) => [data], z.string().array());\n\n  const value = schema.parse(\"asdf\");\n  expect(value).toEqual([\"asdf\"]);\n  util.assertEqual<(typeof schema)[\"_input\"], unknown>(true);\n});\n\ntest(\"async preprocess\", async () => {\n  const schema = z.preprocess(async (data) => [data], z.string().array());\n\n  const value = await schema.parseAsync(\"asdf\");\n  expect(value).toEqual([\"asdf\"]);\n});\n\ntest(\"preprocess ctx.addIssue with parse\", () => {\n  expect(() => {\n    z.preprocess((data, ctx) => {\n      ctx.addIssue({\n        code: \"custom\",\n        message: `${data} is not one of our allowed strings`,\n      });\n      return data;\n    }, z.string()).parse(\"asdf\");\n  }).toThrow(\n    JSON.stringify(\n      [\n        {\n          code: \"custom\",\n          message: \"asdf is not one of our allowed strings\",\n          path: [],\n        },\n      ],\n      null,\n      2\n    )\n  );\n});\n\ntest(\"preprocess ctx.addIssue non-fatal by default\", () => {\n  try {\n    z.preprocess((data, ctx) => {\n      ctx.addIssue({\n        code: \"custom\",\n        message: `custom error`,\n      });\n      return data;\n    }, z.string()).parse(1234);\n  } catch (err) {\n    z.ZodError.assert(err);\n    expect(err.issues.length).toEqual(2);\n  }\n});\n\ntest(\"preprocess ctx.addIssue fatal true\", () => {\n  try {\n    z.preprocess((data, ctx) => {\n      ctx.addIssue({\n        code: \"custom\",\n        message: `custom error`,\n        fatal: true,\n      });\n      return data;\n    }, z.string()).parse(1234);\n  } catch (err) {\n    z.ZodError.assert(err);\n    expect(err.issues.length).toEqual(1);\n  }\n});\n\ntest(\"async preprocess ctx.addIssue with parse\", async () => {\n  const schema = z.preprocess(async (data, ctx) => {\n    ctx.addIssue({\n      code: \"custom\",\n      message: `custom error`,\n    });\n    return data;\n  }, z.string());\n\n  expect(await schema.safeParseAsync(\"asdf\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"message\": \"custom error\",\n        \"path\": []\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"preprocess ctx.addIssue with parseAsync\", async () => {\n  const result = await z\n    .preprocess(async (data, ctx) => {\n      ctx.addIssue({\n        code: \"custom\",\n        message: `${data} is not one of our allowed strings`,\n      });\n      return data;\n    }, z.string())\n    .safeParseAsync(\"asdf\");\n\n  expect(JSON.parse(JSON.stringify(result))).toEqual({\n    success: false,\n    error: {\n      issues: [\n        {\n          code: \"custom\",\n          message: \"asdf is not one of our allowed strings\",\n          path: [],\n        },\n      ],\n      name: \"ZodError\",\n    },\n  });\n});\n\ntest(\"z.NEVER in preprocess\", () => {\n  const foo = z.preprocess((val, ctx) => {\n    if (!val) {\n      ctx.addIssue({ code: z.ZodIssueCode.custom, message: \"bad\" });\n      return z.NEVER;\n    }\n    return val;\n  }, z.number());\n\n  type foo = z.infer<typeof foo>;\n  util.assertEqual<foo, number>(true);\n  const arg = foo.safeParse(undefined);\n  expect(arg.error!.issues).toHaveLength(2);\n  expect(arg.error!.issues[0].message).toEqual(\"bad\");\n});\ntest(\"preprocess as the second property of object\", () => {\n  const schema = z.object({\n    nonEmptyStr: z.string().min(1),\n    positiveNum: z.preprocess((v) => Number(v), z.number().positive()),\n  });\n  const result = schema.safeParse({\n    nonEmptyStr: \"\",\n    positiveNum: \"\",\n  });\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.too_small);\n    expect(result.error.issues[1].code).toEqual(z.ZodIssueCode.too_small);\n  }\n});\n\ntest(\"preprocess validates with sibling errors\", () => {\n  expect(() => {\n    z.object({\n      // Must be first\n      missing: z.string().refine(() => false),\n      preprocess: z.preprocess((data: any) => data?.trim(), z.string().regex(/ asdf/)),\n    }).parse({ preprocess: \" asdf\" });\n  }).toThrow(\n    JSON.stringify(\n      [\n        {\n          code: \"invalid_type\",\n          expected: \"string\",\n          received: \"undefined\",\n          path: [\"missing\"],\n          message: \"Required\",\n        },\n        {\n          validation: \"regex\",\n          code: \"invalid_string\",\n          message: \"Invalid\",\n          path: [\"preprocess\"],\n        },\n      ],\n      null,\n      2\n    )\n  );\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/primitive.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\nimport { Mocker } from \"./Mocker.js\";\n\nconst literalStringSchema = z.literal(\"asdf\");\nconst literalNumberSchema = z.literal(12);\nconst literalBooleanSchema = z.literal(true);\nconst literalBigIntSchema = z.literal(BigInt(42));\nconst MySymbol = Symbol(\"stuff\");\nconst literalSymbolSchema = z.literal(MySymbol);\nconst stringSchema = z.string();\nconst numberSchema = z.number();\nconst bigintSchema = z.bigint();\nconst booleanSchema = z.boolean();\nconst dateSchema = z.date();\nconst symbolSchema = z.symbol();\n\nconst nullSchema = z.null();\nconst undefinedSchema = z.undefined();\nconst stringSchemaOptional = z.string().optional();\nconst stringSchemaNullable = z.string().nullable();\nconst numberSchemaOptional = z.number().optional();\nconst numberSchemaNullable = z.number().nullable();\nconst bigintSchemaOptional = z.bigint().optional();\nconst bigintSchemaNullable = z.bigint().nullable();\nconst booleanSchemaOptional = z.boolean().optional();\nconst booleanSchemaNullable = z.boolean().nullable();\nconst dateSchemaOptional = z.date().optional();\nconst dateSchemaNullable = z.date().nullable();\nconst symbolSchemaOptional = z.symbol().optional();\nconst symbolSchemaNullable = z.symbol().nullable();\n\nconst val = new Mocker();\n\ntest(\"literal string correct\", () => {\n  expect(literalStringSchema.parse(\"asdf\")).toBe(\"asdf\");\n});\n\ntest(\"literal string incorrect\", () => {\n  const f = () => literalStringSchema.parse(\"not_asdf\");\n  expect(f).toThrow();\n});\n\ntest(\"literal string number\", () => {\n  const f = () => literalStringSchema.parse(123);\n  expect(f).toThrow();\n});\n\ntest(\"literal string boolean\", () => {\n  const f = () => literalStringSchema.parse(true);\n  expect(f).toThrow();\n});\n\ntest(\"literal string boolean\", () => {\n  const f = () => literalStringSchema.parse(true);\n  expect(f).toThrow();\n});\n\ntest(\"literal string object\", () => {\n  const f = () => literalStringSchema.parse({});\n  expect(f).toThrow();\n});\n\ntest(\"literal number correct\", () => {\n  expect(literalNumberSchema.parse(12)).toBe(12);\n});\n\ntest(\"literal number incorrect\", () => {\n  const f = () => literalNumberSchema.parse(13);\n  expect(f).toThrow();\n});\n\ntest(\"literal number number\", () => {\n  const f = () => literalNumberSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"literal number boolean\", () => {\n  const f = () => literalNumberSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"literal number object\", () => {\n  const f = () => literalStringSchema.parse({});\n  expect(f).toThrow();\n});\n\ntest(\"literal boolean correct\", () => {\n  expect(literalBooleanSchema.parse(true)).toBe(true);\n});\n\ntest(\"literal boolean incorrect\", () => {\n  const f = () => literalBooleanSchema.parse(false);\n  expect(f).toThrow();\n});\n\ntest(\"literal boolean number\", () => {\n  const f = () => literalBooleanSchema.parse(\"asdf\");\n  expect(f).toThrow();\n});\n\ntest(\"literal boolean boolean\", () => {\n  const f = () => literalBooleanSchema.parse(123);\n  expect(f).toThrow();\n});\n\ntest(\"literal boolean object\", () => {\n  const f = () => literalBooleanSchema.parse({});\n  expect(f).toThrow();\n});\n\ntest(\"literal bigint correct\", () => {\n  expect(literalBigIntSchema.parse(BigInt(42))).toBe(BigInt(42));\n});\n\ntest(\"literal bigint incorrect\", () => {\n  const f = () => literalBigIntSchema.parse(BigInt(43));\n  expect(f).toThrow();\n});\n\ntest(\"literal bigint number\", () => {\n  const f = () => literalBigIntSchema.parse(\"asdf\");\n  expect(f).toThrow();\n});\n\ntest(\"literal bigint boolean\", () => {\n  const f = () => literalBigIntSchema.parse(123);\n  expect(f).toThrow();\n});\n\ntest(\"literal bigint object\", () => {\n  const f = () => literalBigIntSchema.parse({});\n  expect(f).toThrow();\n});\n\ntest(\"literal symbol\", () => {\n  util.assertEqual<z.infer<typeof literalSymbolSchema>, typeof MySymbol>(true);\n  literalSymbolSchema.parse(MySymbol);\n  expect(() => literalSymbolSchema.parse(Symbol(\"asdf\"))).toThrow();\n});\n\ntest(\"parse stringSchema string\", () => {\n  stringSchema.parse(val.string);\n});\n\ntest(\"parse stringSchema number\", () => {\n  const f = () => stringSchema.parse(val.number);\n  expect(f).toThrow();\n});\n\ntest(\"parse stringSchema boolean\", () => {\n  const f = () => stringSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"parse stringSchema undefined\", () => {\n  const f = () => stringSchema.parse(val.undefined);\n  expect(f).toThrow();\n});\n\ntest(\"parse stringSchema null\", () => {\n  const f = () => stringSchema.parse(val.null);\n  expect(f).toThrow();\n});\n\ntest(\"parse numberSchema string\", () => {\n  const f = () => numberSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"parse numberSchema number\", () => {\n  numberSchema.parse(val.number);\n});\n\ntest(\"parse numberSchema bigint\", () => {\n  const f = () => numberSchema.parse(val.bigint);\n  expect(f).toThrow();\n});\n\ntest(\"parse numberSchema boolean\", () => {\n  const f = () => numberSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"parse numberSchema undefined\", () => {\n  const f = () => numberSchema.parse(val.undefined);\n  expect(f).toThrow();\n});\n\ntest(\"parse numberSchema null\", () => {\n  const f = () => numberSchema.parse(val.null);\n  expect(f).toThrow();\n});\n\ntest(\"parse bigintSchema string\", () => {\n  const f = () => bigintSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"parse bigintSchema number\", () => {\n  const f = () => bigintSchema.parse(val.number);\n  expect(f).toThrow();\n});\n\ntest(\"parse bigintSchema bigint\", () => {\n  bigintSchema.parse(val.bigint);\n});\n\ntest(\"parse bigintSchema boolean\", () => {\n  const f = () => bigintSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"parse bigintSchema undefined\", () => {\n  const f = () => bigintSchema.parse(val.undefined);\n  expect(f).toThrow();\n});\n\ntest(\"parse bigintSchema null\", () => {\n  const f = () => bigintSchema.parse(val.null);\n  expect(f).toThrow();\n});\n\ntest(\"parse booleanSchema string\", () => {\n  const f = () => booleanSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"parse booleanSchema number\", () => {\n  const f = () => booleanSchema.parse(val.number);\n  expect(f).toThrow();\n});\n\ntest(\"parse booleanSchema boolean\", () => {\n  booleanSchema.parse(val.boolean);\n});\n\ntest(\"parse booleanSchema undefined\", () => {\n  const f = () => booleanSchema.parse(val.undefined);\n  expect(f).toThrow();\n});\n\ntest(\"parse booleanSchema null\", () => {\n  const f = () => booleanSchema.parse(val.null);\n  expect(f).toThrow();\n});\n\n// ==============\n\ntest(\"parse dateSchema string\", () => {\n  const f = () => dateSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"parse dateSchema number\", () => {\n  const f = () => dateSchema.parse(val.number);\n  expect(f).toThrow();\n});\n\ntest(\"parse dateSchema boolean\", () => {\n  const f = () => dateSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"parse dateSchema date\", () => {\n  dateSchema.parse(val.date);\n});\n\ntest(\"parse dateSchema undefined\", () => {\n  const f = () => dateSchema.parse(val.undefined);\n  expect(f).toThrow();\n});\n\ntest(\"parse dateSchema null\", () => {\n  const f = () => dateSchema.parse(val.null);\n  expect(f).toThrow();\n});\n\ntest(\"parse dateSchema invalid date\", async () => {\n  try {\n    await dateSchema.parseAsync(new Date(\"invalid\"));\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].code).toEqual(z.ZodIssueCode.invalid_date);\n  }\n});\n// ==============\n\ntest(\"parse symbolSchema string\", () => {\n  const f = () => symbolSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"parse symbolSchema number\", () => {\n  const f = () => symbolSchema.parse(val.number);\n  expect(f).toThrow();\n});\n\ntest(\"parse symbolSchema boolean\", () => {\n  const f = () => symbolSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"parse symbolSchema date\", () => {\n  const f = () => symbolSchema.parse(val.date);\n  expect(f).toThrow();\n});\n\ntest(\"parse symbolSchema symbol\", () => {\n  symbolSchema.parse(val.symbol);\n});\n\ntest(\"parse symbolSchema undefined\", () => {\n  const f = () => symbolSchema.parse(val.undefined);\n  expect(f).toThrow();\n});\n\ntest(\"parse symbolSchema null\", () => {\n  const f = () => symbolSchema.parse(val.null);\n  expect(f).toThrow();\n});\n\n// ==============\n\ntest(\"parse undefinedSchema string\", () => {\n  const f = () => undefinedSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"parse undefinedSchema number\", () => {\n  const f = () => undefinedSchema.parse(val.number);\n  expect(f).toThrow();\n});\n\ntest(\"parse undefinedSchema boolean\", () => {\n  const f = () => undefinedSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"parse undefinedSchema undefined\", () => {\n  undefinedSchema.parse(val.undefined);\n});\n\ntest(\"parse undefinedSchema null\", () => {\n  const f = () => undefinedSchema.parse(val.null);\n  expect(f).toThrow();\n});\n\ntest(\"parse nullSchema string\", () => {\n  const f = () => nullSchema.parse(val.string);\n  expect(f).toThrow();\n});\n\ntest(\"parse nullSchema number\", () => {\n  const f = () => nullSchema.parse(val.number);\n  expect(f).toThrow();\n});\n\ntest(\"parse nullSchema boolean\", () => {\n  const f = () => nullSchema.parse(val.boolean);\n  expect(f).toThrow();\n});\n\ntest(\"parse nullSchema undefined\", () => {\n  const f = () => nullSchema.parse(val.undefined);\n  expect(f).toThrow();\n});\n\ntest(\"parse nullSchema null\", () => {\n  nullSchema.parse(val.null);\n});\n\ntest(\"primitive inference\", () => {\n  util.assertEqual<z.TypeOf<typeof literalStringSchema>, \"asdf\">(true);\n  util.assertEqual<z.TypeOf<typeof literalNumberSchema>, 12>(true);\n  util.assertEqual<z.TypeOf<typeof literalBooleanSchema>, true>(true);\n  util.assertEqual<z.TypeOf<typeof literalBigIntSchema>, bigint>(true);\n  util.assertEqual<z.TypeOf<typeof stringSchema>, string>(true);\n  util.assertEqual<z.TypeOf<typeof numberSchema>, number>(true);\n  util.assertEqual<z.TypeOf<typeof bigintSchema>, bigint>(true);\n  util.assertEqual<z.TypeOf<typeof booleanSchema>, boolean>(true);\n  util.assertEqual<z.TypeOf<typeof dateSchema>, Date>(true);\n  util.assertEqual<z.TypeOf<typeof symbolSchema>, symbol>(true);\n\n  util.assertEqual<z.TypeOf<typeof nullSchema>, null>(true);\n  util.assertEqual<z.TypeOf<typeof undefinedSchema>, undefined>(true);\n  util.assertEqual<z.TypeOf<typeof stringSchemaOptional>, string | undefined>(true);\n  util.assertEqual<z.TypeOf<typeof stringSchemaNullable>, string | null>(true);\n  util.assertEqual<z.TypeOf<typeof numberSchemaOptional>, number | undefined>(true);\n  util.assertEqual<z.TypeOf<typeof numberSchemaNullable>, number | null>(true);\n  util.assertEqual<z.TypeOf<typeof bigintSchemaOptional>, bigint | undefined>(true);\n  util.assertEqual<z.TypeOf<typeof bigintSchemaNullable>, bigint | null>(true);\n  util.assertEqual<z.TypeOf<typeof booleanSchemaOptional>, boolean | undefined>(true);\n  util.assertEqual<z.TypeOf<typeof booleanSchemaNullable>, boolean | null>(true);\n  util.assertEqual<z.TypeOf<typeof dateSchemaOptional>, Date | undefined>(true);\n  util.assertEqual<z.TypeOf<typeof dateSchemaNullable>, Date | null>(true);\n  util.assertEqual<z.TypeOf<typeof symbolSchemaOptional>, symbol | undefined>(true);\n  util.assertEqual<z.TypeOf<typeof symbolSchemaNullable>, symbol | null>(true);\n\n  // [\n  //   literalStringSchemaTest,\n  //   literalNumberSchemaTest,\n  //   literalBooleanSchemaTest,\n  //   literalBigIntSchemaTest,\n  //   stringSchemaTest,\n  //   numberSchemaTest,\n  //   bigintSchemaTest,\n  //   booleanSchemaTest,\n  //   dateSchemaTest,\n  //   symbolSchemaTest,\n\n  //   nullSchemaTest,\n  //   undefinedSchemaTest,\n  //   stringSchemaOptionalTest,\n  //   stringSchemaNullableTest,\n  //   numberSchemaOptionalTest,\n  //   numberSchemaNullableTest,\n  //   bigintSchemaOptionalTest,\n  //   bigintSchemaNullableTest,\n  //   booleanSchemaOptionalTest,\n  //   booleanSchemaNullableTest,\n  //   dateSchemaOptionalTest,\n  //   dateSchemaNullableTest,\n  //   symbolSchemaOptionalTest,\n  //   symbolSchemaNullableTest,\n\n  // ];\n});\n\ntest(\"get literal value\", () => {\n  expect(literalStringSchema.value).toEqual(\"asdf\");\n});\n\ntest(\"optional convenience method\", () => {\n  z.ostring().parse(undefined);\n  z.onumber().parse(undefined);\n  z.oboolean().parse(undefined);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/promise.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst promSchema = z.promise(\n  z.object({\n    name: z.string(),\n    age: z.number(),\n  })\n);\n\ntest(\"promise inference\", () => {\n  type promSchemaType = z.infer<typeof promSchema>;\n  util.assertEqual<promSchemaType, Promise<{ name: string; age: number }>>(true);\n});\n\ntest(\"promise parsing success\", async () => {\n  const pr = promSchema.parse(Promise.resolve({ name: \"Bobby\", age: 10 }));\n  expect(pr).toBeInstanceOf(Promise);\n  const result = await pr;\n  expect(typeof result).toBe(\"object\");\n  expect(typeof result.age).toBe(\"number\");\n  expect(typeof result.name).toBe(\"string\");\n});\n\ntest(\"promise parsing success 2\", () => {\n  const fakePromise = {\n    then() {\n      return this;\n    },\n    catch() {\n      return this;\n    },\n  };\n  promSchema.parse(fakePromise);\n});\n\ntest(\"promise parsing fail\", async () => {\n  const bad = promSchema.parse(Promise.resolve({ name: \"Bobby\", age: \"10\" }));\n  // return await expect(bad).resolves.toBe({ name: 'Bobby', age: '10' });\n  return await expect(bad).rejects.toBeInstanceOf(z.ZodError);\n  // done();\n});\n\ntest(\"promise parsing fail 2\", async () => {\n  const failPromise = promSchema.parse(Promise.resolve({ name: \"Bobby\", age: \"10\" }));\n  await expect(failPromise).rejects.toBeInstanceOf(z.ZodError);\n  // done();/z\n});\n\ntest(\"promise parsing fail\", () => {\n  const bad = () => promSchema.parse({ then: () => {}, catch: {} });\n  expect(bad).toThrow();\n});\n\n// test('sync promise parsing', () => {\n//   expect(() => z.promise(z.string()).parse(Promise.resolve('asfd'))).toThrow();\n// });\n\nconst asyncFunction = z.function(z.tuple([]), promSchema);\n\ntest(\"async function pass\", async () => {\n  const validatedFunction = asyncFunction.implement(async () => {\n    return { name: \"jimmy\", age: 14 };\n  });\n  await expect(validatedFunction()).resolves.toEqual({\n    name: \"jimmy\",\n    age: 14,\n  });\n});\n\ntest(\"async function fail\", async () => {\n  const validatedFunction = asyncFunction.implement(() => {\n    return Promise.resolve(\"asdf\" as any);\n  });\n  await expect(validatedFunction()).rejects.toBeInstanceOf(z.ZodError);\n});\n\ntest(\"async promise parsing\", () => {\n  const res = z.promise(z.number()).parseAsync(Promise.resolve(12));\n  expect(res).toBeInstanceOf(Promise);\n});\n\ntest(\"resolves\", () => {\n  const foo = z.literal(\"foo\");\n  const res = z.promise(foo);\n  expect(res.unwrap()).toEqual(foo);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/readonly.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nenum testEnum {\n  A = 0,\n  B = 1,\n}\n\nconst schemas = [\n  z.string().readonly(),\n  z.number().readonly(),\n  z.nan().readonly(),\n  z.bigint().readonly(),\n  z.boolean().readonly(),\n  z.date().readonly(),\n  z.undefined().readonly(),\n  z.null().readonly(),\n  z.any().readonly(),\n  z.unknown().readonly(),\n  z.void().readonly(),\n  z.function().args(z.string(), z.number()).readonly(),\n\n  z.array(z.string()).readonly(),\n  z.tuple([z.string(), z.number()]).readonly(),\n  z.map(z.string(), z.date()).readonly(),\n  z.set(z.promise(z.string())).readonly(),\n  z.record(z.string()).readonly(),\n  z.record(z.string(), z.number()).readonly(),\n  z.object({ a: z.string(), 1: z.number() }).readonly(),\n  z.nativeEnum(testEnum).readonly(),\n  z.promise(z.string()).readonly(),\n] as const;\n\ntest(\"flat inference\", () => {\n  util.assertEqual<z.infer<(typeof schemas)[0]>, string>(true);\n  util.assertEqual<z.infer<(typeof schemas)[1]>, number>(true);\n  util.assertEqual<z.infer<(typeof schemas)[2]>, number>(true);\n  util.assertEqual<z.infer<(typeof schemas)[3]>, bigint>(true);\n  util.assertEqual<z.infer<(typeof schemas)[4]>, boolean>(true);\n  util.assertEqual<z.infer<(typeof schemas)[5]>, Date>(true);\n  util.assertEqual<z.infer<(typeof schemas)[6]>, undefined>(true);\n  util.assertEqual<z.infer<(typeof schemas)[7]>, null>(true);\n  util.assertEqual<z.infer<(typeof schemas)[8]>, any>(true);\n  util.assertEqual<z.infer<(typeof schemas)[9]>, Readonly<unknown>>(true);\n  util.assertEqual<z.infer<(typeof schemas)[10]>, void>(true);\n  util.assertEqual<z.infer<(typeof schemas)[11]>, (args_0: string, args_1: number, ...args_2: unknown[]) => unknown>(\n    true\n  );\n  util.assertEqual<z.infer<(typeof schemas)[12]>, readonly string[]>(true);\n\n  util.assertEqual<z.infer<(typeof schemas)[13]>, readonly [string, number]>(true);\n  util.assertEqual<z.infer<(typeof schemas)[14]>, ReadonlyMap<string, Date>>(true);\n  util.assertEqual<z.infer<(typeof schemas)[15]>, ReadonlySet<Promise<string>>>(true);\n  util.assertEqual<z.infer<(typeof schemas)[16]>, Readonly<Record<string, string>>>(true);\n  util.assertEqual<z.infer<(typeof schemas)[17]>, Readonly<Record<string, number>>>(true);\n  util.assertEqual<z.infer<(typeof schemas)[18]>, { readonly a: string; readonly 1: number }>(true);\n  util.assertEqual<z.infer<(typeof schemas)[19]>, Readonly<testEnum>>(true);\n  util.assertEqual<z.infer<(typeof schemas)[20]>, Promise<string>>(true);\n});\n\n// test(\"deep inference\", () => {\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[0]>, string>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[1]>, number>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[2]>, number>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[3]>, bigint>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[4]>, boolean>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[5]>, Date>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[6]>, undefined>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[7]>, null>(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[8]>, any>(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[9]>,\n//     Readonly<unknown>\n//   >(true);\n//   util.assertEqual<z.infer<(typeof deepReadonlySchemas_0)[10]>, void>(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[11]>,\n//     (args_0: string, args_1: number, ...args_2: unknown[]) => unknown\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[12]>,\n//     readonly string[]\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[13]>,\n//     readonly [string, number]\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[14]>,\n//     ReadonlyMap<string, Date>\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[15]>,\n//     ReadonlySet<Promise<string>>\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[16]>,\n//     Readonly<Record<string, string>>\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[17]>,\n//     Readonly<Record<string, number>>\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[18]>,\n//     { readonly a: string; readonly 1: number }\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[19]>,\n//     Readonly<testEnum>\n//   >(true);\n//   util.assertEqual<\n//     z.infer<(typeof deepReadonlySchemas_0)[20]>,\n//     Promise<string>\n//   >(true);\n\n//   util.assertEqual<\n//     z.infer<typeof crazyDeepReadonlySchema>,\n//     ReadonlyMap<\n//       ReadonlySet<readonly [string, number]>,\n//       {\n//         readonly a: {\n//           readonly [x: string]: readonly any[];\n//         };\n//         readonly b: {\n//           readonly c: {\n//             readonly d: {\n//               readonly e: {\n//                 readonly f: {\n//                   readonly g?: {};\n//                 };\n//               };\n//             };\n//           };\n//         };\n//       }\n//     >\n//   >(true);\n// });\n\ntest(\"object freezing\", () => {\n  expect(Object.isFrozen(z.array(z.string()).readonly().parse([\"a\"]))).toBe(true);\n  expect(Object.isFrozen(z.tuple([z.string(), z.number()]).readonly().parse([\"a\", 1]))).toBe(true);\n  expect(\n    Object.isFrozen(\n      z\n        .map(z.string(), z.date())\n        .readonly()\n        .parse(new Map([[\"a\", new Date()]]))\n    )\n  ).toBe(true);\n  expect(\n    Object.isFrozen(\n      z\n        .set(z.promise(z.string()))\n        .readonly()\n        .parse(new Set([Promise.resolve(\"a\")]))\n    )\n  ).toBe(true);\n  expect(Object.isFrozen(z.record(z.string()).readonly().parse({ a: \"b\" }))).toBe(true);\n  expect(Object.isFrozen(z.record(z.string(), z.number()).readonly().parse({ a: 1 }))).toBe(true);\n  expect(Object.isFrozen(z.object({ a: z.string(), 1: z.number() }).readonly().parse({ a: \"b\", 1: 2 }))).toBe(true);\n  expect(Object.isFrozen(z.promise(z.string()).readonly().parse(Promise.resolve(\"a\")))).toBe(true);\n});\n\ntest(\"async object freezing\", async () => {\n  expect(Object.isFrozen(await z.array(z.string()).readonly().parseAsync([\"a\"]))).toBe(true);\n  expect(Object.isFrozen(await z.tuple([z.string(), z.number()]).readonly().parseAsync([\"a\", 1]))).toBe(true);\n  expect(\n    Object.isFrozen(\n      await z\n        .map(z.string(), z.date())\n        .readonly()\n        .parseAsync(new Map([[\"a\", new Date()]]))\n    )\n  ).toBe(true);\n  expect(\n    Object.isFrozen(\n      await z\n        .set(z.promise(z.string()))\n        .readonly()\n        .parseAsync(new Set([Promise.resolve(\"a\")]))\n    )\n  ).toBe(true);\n  expect(Object.isFrozen(await z.record(z.string()).readonly().parseAsync({ a: \"b\" }))).toBe(true);\n  expect(Object.isFrozen(await z.record(z.string(), z.number()).readonly().parseAsync({ a: 1 }))).toBe(true);\n  expect(\n    Object.isFrozen(await z.object({ a: z.string(), 1: z.number() }).readonly().parseAsync({ a: \"b\", 1: 2 }))\n  ).toBe(true);\n  expect(Object.isFrozen(await z.promise(z.string()).readonly().parseAsync(Promise.resolve(\"a\")))).toBe(true);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/record.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst booleanRecord = z.record(z.boolean());\ntype booleanRecord = z.infer<typeof booleanRecord>;\n\nconst recordWithEnumKeys = z.record(z.enum([\"Tuna\", \"Salmon\"]), z.string());\ntype recordWithEnumKeys = z.infer<typeof recordWithEnumKeys>;\n\nconst recordWithLiteralKeys = z.record(z.union([z.literal(\"Tuna\"), z.literal(\"Salmon\")]), z.string());\ntype recordWithLiteralKeys = z.infer<typeof recordWithLiteralKeys>;\n\ntest(\"type inference\", () => {\n  util.assertEqual<booleanRecord, Record<string, boolean>>(true);\n\n  util.assertEqual<recordWithEnumKeys, Partial<Record<\"Tuna\" | \"Salmon\", string>>>(true);\n\n  util.assertEqual<recordWithLiteralKeys, Partial<Record<\"Tuna\" | \"Salmon\", string>>>(true);\n});\n\ntest(\"methods\", () => {\n  booleanRecord.optional();\n  booleanRecord.nullable();\n});\n\ntest(\"string record parse - pass\", () => {\n  booleanRecord.parse({\n    k1: true,\n    k2: false,\n    1234: false,\n  });\n});\n\ntest(\"string record parse - fail\", () => {\n  const badCheck = () =>\n    booleanRecord.parse({\n      asdf: 1234,\n    } as any);\n  expect(badCheck).toThrow();\n\n  expect(() => booleanRecord.parse(\"asdf\")).toThrow();\n});\n\ntest(\"string record parse - fail\", () => {\n  const badCheck = () =>\n    booleanRecord.parse({\n      asdf: {},\n    } as any);\n  expect(badCheck).toThrow();\n});\n\ntest(\"string record parse - fail\", () => {\n  const badCheck = () =>\n    booleanRecord.parse({\n      asdf: [],\n    } as any);\n  expect(badCheck).toThrow();\n});\n\ntest(\"key schema\", () => {\n  const result1 = recordWithEnumKeys.parse({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n  expect(result1).toEqual({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  const result2 = recordWithLiteralKeys.parse({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n  expect(result2).toEqual({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  // shouldn't require us to specify all props in record\n  const result3 = recordWithEnumKeys.parse({\n    Tuna: \"abcd\",\n  });\n  expect(result3).toEqual({\n    Tuna: \"abcd\",\n  });\n\n  // shouldn't require us to specify all props in record\n  const result4 = recordWithLiteralKeys.parse({\n    Salmon: \"abcd\",\n  });\n  expect(result4).toEqual({\n    Salmon: \"abcd\",\n  });\n\n  expect(() =>\n    recordWithEnumKeys.parse({\n      Tuna: \"asdf\",\n      Salmon: \"asdf\",\n      Trout: \"asdf\",\n    })\n  ).toThrow();\n\n  expect(() =>\n    recordWithLiteralKeys.parse({\n      Tuna: \"asdf\",\n      Salmon: \"asdf\",\n\n      Trout: \"asdf\",\n    })\n  ).toThrow();\n});\n\n// test(\"record element\", () => {\n//   expect(booleanRecord.element).toBeInstanceOf(z.ZodBoolean);\n// });\n\ntest(\"key and value getters\", () => {\n  const rec = z.record(z.string(), z.number());\n\n  rec.keySchema.parse(\"asdf\");\n  rec.valueSchema.parse(1234);\n  rec.element.parse(1234);\n});\n\ntest(\"is not vulnerable to prototype pollution\", async () => {\n  const rec = z.record(\n    z.object({\n      a: z.string(),\n    })\n  );\n\n  const data = JSON.parse(`\n    {\n      \"__proto__\": {\n        \"a\": \"evil\"\n      },\n      \"b\": {\n        \"a\": \"good\"\n      }\n    }\n  `);\n\n  const obj1 = rec.parse(data);\n  expect(obj1.a).toBeUndefined();\n\n  const obj2 = rec.safeParse(data);\n  expect(obj2.success).toBe(true);\n  if (obj2.success) {\n    expect(obj2.data.a).toBeUndefined();\n  }\n\n  const obj3 = await rec.parseAsync(data);\n  expect(obj3.a).toBeUndefined();\n\n  const obj4 = await rec.safeParseAsync(data);\n  expect(obj4.success).toBe(true);\n  if (obj4.success) {\n    expect(obj4.data.a).toBeUndefined();\n  }\n});\n\ntest(\"dont parse undefined values\", () => {\n  const result1 = z.record(z.any()).parse({ foo: undefined });\n\n  expect(result1).toEqual({\n    foo: undefined,\n  });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/recursive.test.ts",
    "content": "// @ts-ignore TS6133\nimport { test } from \"vitest\";\n\nimport { z } from \"zod/v3\";\n\ninterface Category {\n  name: string;\n  subcategories: Category[];\n}\n\nconst testCategory: Category = {\n  name: \"I\",\n  subcategories: [\n    {\n      name: \"A\",\n      subcategories: [\n        {\n          name: \"1\",\n          subcategories: [\n            {\n              name: \"a\",\n              subcategories: [],\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\ntest(\"recursion with z.late.object\", () => {\n  const Category: z.ZodType<Category> = z.late.object(() => ({\n    name: z.string(),\n    subcategories: z.array(Category),\n  }));\n  Category.parse(testCategory);\n});\n\ntest(\"recursion with z.lazy\", () => {\n  const Category: z.ZodType<Category> = z.lazy(() =>\n    z.object({\n      name: z.string(),\n      subcategories: z.array(Category),\n    })\n  );\n  Category.parse(testCategory);\n});\n\ntest(\"schema getter\", () => {\n  z.lazy(() => z.string()).schema.parse(\"asdf\");\n});\n\ntype LinkedList = null | { value: number; next: LinkedList };\n\nconst linkedListExample = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null,\n      },\n    },\n  },\n};\n\ntest(\"recursion involving union type\", () => {\n  const LinkedListSchema: z.ZodType<LinkedList> = z.lazy(() =>\n    z.union([\n      z.null(),\n      z.object({\n        value: z.number(),\n        next: LinkedListSchema,\n      }),\n    ])\n  );\n  LinkedListSchema.parse(linkedListExample);\n});\n\n// interface A {\n//   val: number;\n//   b: B;\n// }\n\n// interface B {\n//   val: number;\n//   a: A;\n// }\n\n// const A: z.ZodType<A> = z.late.object(() => ({\n//   val: z.number(),\n//   b: B,\n// }));\n\n// const B: z.ZodType<B> = z.late.object(() => ({\n//   val: z.number(),\n//   a: A,\n// }));\n\n// const Alazy: z.ZodType<A> = z.lazy(() => z.object({\n//   val: z.number(),\n//   b: B,\n// }));\n\n// const Blazy: z.ZodType<B> = z.lazy(() => z.object({\n//   val: z.number(),\n//   a: A,\n// }));\n\n// const a: any = { val: 1 };\n// const b: any = { val: 2 };\n// a.b = b;\n// b.a = a;\n\n// test('valid check', () => {\n//   A.parse(a);\n//   B.parse(b);\n// });\n\n// test(\"valid check lazy\", () => {\n//   A.parse({val:1, b:});\n//   B.parse(b);\n// });\n\n// test('masking check', () => {\n//   const FragmentOnA = z\n//     .object({\n//       val: z.number(),\n//       b: z\n//         .object({\n//           val: z.number(),\n//           a: z\n//             .object({\n//               val: z.number(),\n//             })\n//             .nonstrict(),\n//         })\n//         .nonstrict(),\n//     })\n//     .nonstrict();\n\n//   const fragment = FragmentOnA.parse(a);\n//   fragment;\n// });\n\n// test('invalid check', () => {\n//   expect(() => A.parse({} as any)).toThrow();\n// });\n\n// test('schema getter', () => {\n//   (A as z.ZodLazy<any>).schema;\n// });\n\n// test(\"self recursion with cyclical data\", () => {\n//   interface Category {\n//     name: string;\n//     subcategories: Category[];\n//   }\n\n//   const Category: z.ZodType<Category> = z.late.object(() => ({\n//     name: z.string(),\n//     subcategories: z.array(Category),\n//   }));\n\n//   const untypedCategory: any = {\n//     name: \"Category A\",\n//   };\n//   // creating a cycle\n//   untypedCategory.subcategories = [untypedCategory];\n//   Category.parse(untypedCategory);\n// });\n\n// test(\"self recursion with base type\", () => {\n//   const BaseCategory = z.object({\n//     name: z.string(),\n//   });\n//   type BaseCategory = z.infer<typeof BaseCategory>;\n\n//   type Category = BaseCategory & { subcategories: Category[] };\n\n//   const Category: z.ZodType<Category> = z.late\n//     .object(() => ({\n//       subcategories: z.array(Category),\n//     }))\n//     .extend({\n//       name: z.string(),\n//     });\n\n//   const untypedCategory: any = {\n//     name: \"Category A\",\n//   };\n//   // creating a cycle\n//   untypedCategory.subcategories = [untypedCategory];\n//   Category.parse(untypedCategory); // parses successfully\n// });\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/refine.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { ZodIssueCode } from \"../ZodError.js\";\nimport { util } from \"../helpers/util.js\";\n\ntest(\"refinement\", () => {\n  const obj1 = z.object({\n    first: z.string(),\n    second: z.string(),\n  });\n  const obj2 = obj1.partial().strict();\n\n  const obj3 = obj2.refine((data) => data.first || data.second, \"Either first or second should be filled in.\");\n\n  expect(obj1 === (obj2 as any)).toEqual(false);\n  expect(obj2 === (obj3 as any)).toEqual(false);\n\n  expect(() => obj1.parse({})).toThrow();\n  expect(() => obj2.parse({ third: \"adsf\" })).toThrow();\n  expect(() => obj3.parse({})).toThrow();\n  obj3.parse({ first: \"a\" });\n  obj3.parse({ second: \"a\" });\n  obj3.parse({ first: \"a\", second: \"a\" });\n});\n\ntest(\"refinement 2\", () => {\n  const validationSchema = z\n    .object({\n      email: z.string().email(),\n      password: z.string(),\n      confirmPassword: z.string(),\n    })\n    .refine((data) => data.password === data.confirmPassword, \"Both password and confirmation must match\");\n\n  expect(() =>\n    validationSchema.parse({\n      email: \"aaaa@gmail.com\",\n      password: \"aaaaaaaa\",\n      confirmPassword: \"bbbbbbbb\",\n    })\n  ).toThrow();\n});\n\ntest(\"refinement type guard\", () => {\n  const validationSchema = z.object({\n    a: z.string().refine((s): s is \"a\" => s === \"a\"),\n  });\n  type Input = z.input<typeof validationSchema>;\n  type Schema = z.infer<typeof validationSchema>;\n\n  util.assertEqual<\"a\", Input[\"a\"]>(false);\n  util.assertEqual<string, Input[\"a\"]>(true);\n\n  util.assertEqual<\"a\", Schema[\"a\"]>(true);\n  util.assertEqual<string, Schema[\"a\"]>(false);\n});\n\ntest(\"refinement Promise\", async () => {\n  const validationSchema = z\n    .object({\n      email: z.string().email(),\n      password: z.string(),\n      confirmPassword: z.string(),\n    })\n    .refine(\n      (data) => Promise.resolve().then(() => data.password === data.confirmPassword),\n      \"Both password and confirmation must match\"\n    );\n\n  await validationSchema.parseAsync({\n    email: \"aaaa@gmail.com\",\n    password: \"password\",\n    confirmPassword: \"password\",\n  });\n});\n\ntest(\"custom path\", async () => {\n  const result = await z\n    .object({\n      password: z.string(),\n      confirm: z.string(),\n    })\n    .refine((data) => data.confirm === data.password, { path: [\"confirm\"] })\n    .spa({ password: \"asdf\", confirm: \"qewr\" });\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].path).toEqual([\"confirm\"]);\n  }\n});\n\ntest(\"use path in refinement context\", async () => {\n  const noNested = z.string()._refinement((_val, ctx) => {\n    if (ctx.path.length > 0) {\n      ctx.addIssue({\n        code: ZodIssueCode.custom,\n        message: `schema cannot be nested. path: ${ctx.path.join(\".\")}`,\n      });\n      return false;\n    } else {\n      return true;\n    }\n  });\n\n  const data = z.object({\n    foo: noNested,\n  });\n\n  const t1 = await noNested.spa(\"asdf\");\n  const t2 = await data.spa({ foo: \"asdf\" });\n\n  expect(t1.success).toBe(true);\n  expect(t2.success).toBe(false);\n  if (t2.success === false) {\n    expect(t2.error.issues[0].message).toEqual(\"schema cannot be nested. path: foo\");\n  }\n});\n\ntest(\"superRefine\", () => {\n  const Strings = z.array(z.string()).superRefine((val, ctx) => {\n    if (val.length > 3) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.too_big,\n        maximum: 3,\n        type: \"array\",\n        inclusive: true,\n        exact: true,\n        message: \"Too many items 😡\",\n      });\n    }\n\n    if (val.length !== new Set(val).size) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: `No duplicates allowed.`,\n      });\n    }\n  });\n\n  const result = Strings.safeParse([\"asfd\", \"asfd\", \"asfd\", \"asfd\"]);\n\n  expect(result.success).toEqual(false);\n  if (!result.success) expect(result.error.issues.length).toEqual(2);\n\n  Strings.parse([\"asfd\", \"qwer\"]);\n});\n\ntest(\"superRefine async\", async () => {\n  const Strings = z.array(z.string()).superRefine(async (val, ctx) => {\n    if (val.length > 3) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.too_big,\n        maximum: 3,\n        type: \"array\",\n        inclusive: true,\n        exact: true,\n        message: \"Too many items 😡\",\n      });\n    }\n\n    if (val.length !== new Set(val).size) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: `No duplicates allowed.`,\n      });\n    }\n  });\n\n  const result = await Strings.safeParseAsync([\"asfd\", \"asfd\", \"asfd\", \"asfd\"]);\n\n  expect(result.success).toEqual(false);\n  if (!result.success) expect(result.error.issues.length).toEqual(2);\n\n  Strings.parseAsync([\"asfd\", \"qwer\"]);\n});\n\ntest(\"superRefine - type narrowing\", () => {\n  type NarrowType = { type: string; age: number };\n  const schema = z\n    .object({\n      type: z.string(),\n      age: z.number(),\n    })\n    .nullable()\n    .superRefine((arg, ctx): arg is NarrowType => {\n      if (!arg) {\n        // still need to make a call to ctx.addIssue\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: \"cannot be null\",\n          fatal: true,\n        });\n        return false;\n      }\n      return true;\n    });\n\n  util.assertEqual<z.infer<typeof schema>, NarrowType>(true);\n\n  expect(schema.safeParse({ type: \"test\", age: 0 }).success).toEqual(true);\n  expect(schema.safeParse(null).success).toEqual(false);\n});\n\ntest(\"chained mixed refining types\", () => {\n  type firstRefinement = { first: string; second: number; third: true };\n  type secondRefinement = { first: \"bob\"; second: number; third: true };\n  type thirdRefinement = { first: \"bob\"; second: 33; third: true };\n  const schema = z\n    .object({\n      first: z.string(),\n      second: z.number(),\n      third: z.boolean(),\n    })\n    .nullable()\n    .refine((arg): arg is firstRefinement => !!arg?.third)\n    .superRefine((arg, ctx): arg is secondRefinement => {\n      util.assertEqual<typeof arg, firstRefinement>(true);\n      if (arg.first !== \"bob\") {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: \"`first` property must be `bob`\",\n        });\n        return false;\n      }\n      return true;\n    })\n    .refine((arg): arg is thirdRefinement => {\n      util.assertEqual<typeof arg, secondRefinement>(true);\n      return arg.second === 33;\n    });\n\n  util.assertEqual<z.infer<typeof schema>, thirdRefinement>(true);\n});\n\ntest(\"get inner type\", () => {\n  z.string()\n    .refine(() => true)\n    .innerType()\n    .parse(\"asdf\");\n});\n\ntest(\"chained refinements\", () => {\n  const objectSchema = z\n    .object({\n      length: z.number(),\n      size: z.number(),\n    })\n    .refine(({ length }) => length > 5, {\n      path: [\"length\"],\n      message: \"length greater than 5\",\n    })\n    .refine(({ size }) => size > 7, {\n      path: [\"size\"],\n      message: \"size greater than 7\",\n    });\n  const r1 = objectSchema.safeParse({\n    length: 4,\n    size: 9,\n  });\n  expect(r1.success).toEqual(false);\n  if (!r1.success) expect(r1.error.issues.length).toEqual(1);\n\n  const r2 = objectSchema.safeParse({\n    length: 4,\n    size: 3,\n  });\n  expect(r2.success).toEqual(false);\n  if (!r2.success) expect(r2.error.issues.length).toEqual(2);\n});\n\ntest(\"fatal superRefine\", () => {\n  const Strings = z\n    .string()\n    .superRefine((val, ctx) => {\n      if (val === \"\") {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: \"foo\",\n          fatal: true,\n        });\n      }\n    })\n    .superRefine((val, ctx) => {\n      if (val !== \" \") {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: \"bar\",\n        });\n      }\n    });\n\n  const result = Strings.safeParse(\"\");\n\n  expect(result.success).toEqual(false);\n  if (!result.success) expect(result.error.issues.length).toEqual(1);\n});\n\ntest(\"superRefine after skipped transform\", () => {\n  const schema = z\n    .string()\n    .regex(/^\\d+$/)\n    .transform((val) => Number(val))\n    .superRefine((val) => {\n      if (typeof val !== \"number\") {\n        throw new Error(\"Called without transform\");\n      }\n    });\n\n  const result = schema.safeParse(\"\");\n\n  expect(result.success).toEqual(false);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/safeparse.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nconst stringSchema = z.string();\n\ntest(\"safeparse fail\", () => {\n  const safe = stringSchema.safeParse(12);\n  expect(safe.success).toEqual(false);\n  expect(safe.error).toBeInstanceOf(z.ZodError);\n});\n\ntest(\"safeparse pass\", () => {\n  const safe = stringSchema.safeParse(\"12\");\n  expect(safe.success).toEqual(true);\n  expect(safe.data).toEqual(\"12\");\n});\n\ntest(\"safeparse unexpected error\", () => {\n  expect(() =>\n    stringSchema\n      .refine((data) => {\n        throw new Error(data);\n      })\n      .safeParse(\"12\")\n  ).toThrow();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/set.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { ZodIssueCode } from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst stringSet = z.set(z.string());\ntype stringSet = z.infer<typeof stringSet>;\n\nconst minTwo = z.set(z.string()).min(2);\nconst maxTwo = z.set(z.string()).max(2);\nconst justTwo = z.set(z.string()).size(2);\nconst nonEmpty = z.set(z.string()).nonempty();\nconst nonEmptyMax = z.set(z.string()).nonempty().max(2);\n\ntest(\"type inference\", () => {\n  util.assertEqual<stringSet, Set<string>>(true);\n});\n\ntest(\"valid parse\", () => {\n  const result = stringSet.safeParse(new Set([\"first\", \"second\"]));\n  expect(result.success).toEqual(true);\n  if (result.success) {\n    expect(result.data.has(\"first\")).toEqual(true);\n    expect(result.data.has(\"second\")).toEqual(true);\n    expect(result.data.has(\"third\")).toEqual(false);\n  }\n\n  expect(() => {\n    minTwo.parse(new Set([\"a\", \"b\"]));\n    minTwo.parse(new Set([\"a\", \"b\", \"c\"]));\n    maxTwo.parse(new Set([\"a\", \"b\"]));\n    maxTwo.parse(new Set([\"a\"]));\n    justTwo.parse(new Set([\"a\", \"b\"]));\n    nonEmpty.parse(new Set([\"a\"]));\n    nonEmptyMax.parse(new Set([\"a\"]));\n  }).not.toThrow();\n});\n\ntest(\"valid parse async\", async () => {\n  const result = await stringSet.spa(new Set([\"first\", \"second\"]));\n  expect(result.success).toEqual(true);\n  if (result.success) {\n    expect(result.data.has(\"first\")).toEqual(true);\n    expect(result.data.has(\"second\")).toEqual(true);\n    expect(result.data.has(\"third\")).toEqual(false);\n  }\n\n  const asyncResult = await stringSet.safeParse(new Set([\"first\", \"second\"]));\n  expect(asyncResult.success).toEqual(true);\n  if (asyncResult.success) {\n    expect(asyncResult.data.has(\"first\")).toEqual(true);\n    expect(asyncResult.data.has(\"second\")).toEqual(true);\n    expect(asyncResult.data.has(\"third\")).toEqual(false);\n  }\n});\n\ntest(\"valid parse: size-related methods\", () => {\n  expect(() => {\n    minTwo.parse(new Set([\"a\", \"b\"]));\n    minTwo.parse(new Set([\"a\", \"b\", \"c\"]));\n    maxTwo.parse(new Set([\"a\", \"b\"]));\n    maxTwo.parse(new Set([\"a\"]));\n    justTwo.parse(new Set([\"a\", \"b\"]));\n    nonEmpty.parse(new Set([\"a\"]));\n    nonEmptyMax.parse(new Set([\"a\"]));\n  }).not.toThrow();\n\n  const sizeZeroResult = stringSet.parse(new Set());\n  expect(sizeZeroResult.size).toBe(0);\n\n  const sizeTwoResult = minTwo.parse(new Set([\"a\", \"b\"]));\n  expect(sizeTwoResult.size).toBe(2);\n});\n\ntest(\"failing when parsing empty set in nonempty \", () => {\n  const result = nonEmpty.safeParse(new Set());\n  expect(result.success).toEqual(false);\n\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.too_small);\n  }\n});\n\ntest(\"failing when set is smaller than min() \", () => {\n  const result = minTwo.safeParse(new Set([\"just_one\"]));\n  expect(result.success).toEqual(false);\n\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.too_small);\n  }\n});\n\ntest(\"failing when set is bigger than max() \", () => {\n  const result = maxTwo.safeParse(new Set([\"one\", \"two\", \"three\"]));\n  expect(result.success).toEqual(false);\n\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.too_big);\n  }\n});\n\ntest(\"doesn’t throw when an empty set is given\", () => {\n  const result = stringSet.safeParse(new Set([]));\n  expect(result.success).toEqual(true);\n});\n\ntest(\"throws when a Map is given\", () => {\n  const result = stringSet.safeParse(new Map([]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);\n  }\n});\n\ntest(\"throws when the given set has invalid input\", () => {\n  const result = stringSet.safeParse(new Set([Symbol()]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);\n    expect(result.error.issues[0].path).toEqual([0]);\n  }\n});\n\ntest(\"throws when the given set has multiple invalid entries\", () => {\n  const result = stringSet.safeParse(new Set([1, 2] as any[]) as Set<any>);\n\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);\n    expect(result.error.issues[0].path).toEqual([0]);\n    expect(result.error.issues[1].code).toEqual(ZodIssueCode.invalid_type);\n    expect(result.error.issues[1].path).toEqual([1]);\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/standard-schema.test.ts",
    "content": "// import type { StandardSchemaV1 } from \"@standard-schema/spec\";\n// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\nimport type { StandardSchemaV1 } from \"../standard-schema.js\";\n\ntest(\"assignability\", () => {\n  const _s1: StandardSchemaV1 = z.string();\n  const _s2: StandardSchemaV1<string> = z.string();\n  const _s3: StandardSchemaV1<string, string> = z.string();\n  const _s4: StandardSchemaV1<unknown, string> = z.string();\n  [_s1, _s2, _s3, _s4];\n});\n\ntest(\"type inference\", () => {\n  const stringToNumber = z.string().transform((x) => x.length);\n  type input = StandardSchemaV1.InferInput<typeof stringToNumber>;\n  util.assertEqual<input, string>(true);\n  type output = StandardSchemaV1.InferOutput<typeof stringToNumber>;\n  util.assertEqual<output, number>(true);\n});\n\ntest(\"valid parse\", () => {\n  const schema = z.string();\n  const result = schema[\"~standard\"].validate(\"hello\");\n  if (result instanceof Promise) {\n    throw new Error(\"Expected sync result\");\n  }\n  expect(result.issues).toEqual(undefined);\n  if (result.issues) {\n    throw new Error(\"Expected no issues\");\n  } else {\n    expect(result.value).toEqual(\"hello\");\n  }\n});\n\ntest(\"invalid parse\", () => {\n  const schema = z.string();\n  const result = schema[\"~standard\"].validate(1234);\n  if (result instanceof Promise) {\n    throw new Error(\"Expected sync result\");\n  }\n  expect(result.issues).toBeDefined();\n  if (!result.issues) {\n    throw new Error(\"Expected issues\");\n  }\n  expect(result.issues.length).toEqual(1);\n  expect(result.issues[0].path).toEqual([]);\n});\n\ntest(\"valid parse async\", async () => {\n  const schema = z.string().refine(async () => true);\n  const _result = schema[\"~standard\"].validate(\"hello\");\n  if (_result instanceof Promise) {\n    const result = await _result;\n    expect(result.issues).toEqual(undefined);\n    if (result.issues) {\n      throw new Error(\"Expected no issues\");\n    } else {\n      expect(result.value).toEqual(\"hello\");\n    }\n  } else {\n    throw new Error(\"Expected async result\");\n  }\n});\n\ntest(\"invalid parse async\", async () => {\n  const schema = z.string().refine(async () => false);\n  const _result = schema[\"~standard\"].validate(\"hello\");\n  if (_result instanceof Promise) {\n    const result = await _result;\n    expect(result.issues).toBeDefined();\n    if (!result.issues) {\n      throw new Error(\"Expected issues\");\n    }\n    expect(result.issues.length).toEqual(1);\n    expect(result.issues[0].path).toEqual([]);\n  } else {\n    throw new Error(\"Expected async result\");\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/string.test.ts",
    "content": "import { Buffer } from \"node:buffer\";\n// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\nconst minFive = z.string().min(5, \"min5\");\nconst maxFive = z.string().max(5, \"max5\");\nconst justFive = z.string().length(5);\nconst nonempty = z.string().nonempty(\"nonempty\");\nconst includes = z.string().includes(\"includes\");\nconst includesFromIndex2 = z.string().includes(\"includes\", { position: 2 });\nconst startsWith = z.string().startsWith(\"startsWith\");\nconst endsWith = z.string().endsWith(\"endsWith\");\n\ntest(\"passing validations\", () => {\n  minFive.parse(\"12345\");\n  minFive.parse(\"123456\");\n  maxFive.parse(\"12345\");\n  maxFive.parse(\"1234\");\n  nonempty.parse(\"1\");\n  justFive.parse(\"12345\");\n  includes.parse(\"XincludesXX\");\n  includesFromIndex2.parse(\"XXXincludesXX\");\n  startsWith.parse(\"startsWithX\");\n  endsWith.parse(\"XendsWith\");\n});\n\ntest(\"failing validations\", () => {\n  expect(() => minFive.parse(\"1234\")).toThrow();\n  expect(() => maxFive.parse(\"123456\")).toThrow();\n  expect(() => nonempty.parse(\"\")).toThrow();\n  expect(() => justFive.parse(\"1234\")).toThrow();\n  expect(() => justFive.parse(\"123456\")).toThrow();\n  expect(() => includes.parse(\"XincludeXX\")).toThrow();\n  expect(() => includesFromIndex2.parse(\"XincludesXX\")).toThrow();\n  expect(() => startsWith.parse(\"x\")).toThrow();\n  expect(() => endsWith.parse(\"x\")).toThrow();\n});\n\ntest(\"email validations\", () => {\n  const validEmails = [\n    `email@domain.com`,\n    `firstname.lastname@domain.com`,\n    `email@subdomain.domain.com`,\n    `firstname+lastname@domain.com`,\n    `1234567890@domain.com`,\n    `email@domain-one.com`,\n    `_______@domain.com`,\n    `email@domain.name`,\n    `email@domain.co.jp`,\n    `firstname-lastname@domain.com`,\n    `very.common@example.com`,\n    `disposable.style.email.with+symbol@example.com`,\n    `other.email-with-hyphen@example.com`,\n    `fully-qualified-domain@example.com`,\n    `user.name+tag+sorting@example.com`,\n    `x@example.com`,\n    `mojojojo@asdf.example.com`,\n    `example-indeed@strange-example.com`,\n    `example@s.example`,\n    `user-@example.org`,\n    `user@my-example.com`,\n    `a@b.cd`,\n    `work+user@mail.com`,\n    `tom@test.te-st.com`,\n    `something@subdomain.domain-with-hyphens.tld`,\n    `common'name@domain.com`,\n    `francois@etu.inp-n7.fr`,\n  ];\n  const invalidEmails = [\n    // no \"printable characters\"\n    // `user%example.com@example.org`,\n    // `mailhost!username@example.org`,\n    // `test/test@test.com`,\n\n    // double @\n    `francois@@etu.inp-n7.fr`,\n    // do not support quotes\n    `\"email\"@domain.com`,\n    `\"e asdf sadf ?<>ail\"@domain.com`,\n    `\" \"@example.org`,\n    `\"john..doe\"@example.org`,\n    `\"very.(),:;<>[]\\\".VERY.\\\"very@\\\\ \\\"very\\\".unusual\"@strange.example.com`,\n    // do not support comma\n    `a,b@domain.com`,\n\n    // do not support IPv4\n    `email@123.123.123.123`,\n    `email@[123.123.123.123]`,\n    `postmaster@123.123.123.123`,\n    `user@[68.185.127.196]`,\n    `ipv4@[85.129.96.247]`,\n    `valid@[79.208.229.53]`,\n    `valid@[255.255.255.255]`,\n    `valid@[255.0.55.2]`,\n    `valid@[255.0.55.2]`,\n\n    // do not support ipv6\n    `hgrebert0@[IPv6:4dc8:ac7:ce79:8878:1290:6098:5c50:1f25]`,\n    `bshapiro4@[IPv6:3669:c709:e981:4884:59a3:75d1:166b:9ae]`,\n    `jsmith@[IPv6:2001:db8::1]`,\n    `postmaster@[IPv6:2001:0db8:85a3:0000:0000:8a2e:0370:7334]`,\n    `postmaster@[IPv6:2001:0db8:85a3:0000:0000:8a2e:0370:192.168.1.1]`,\n\n    // microsoft test cases\n    `plainaddress`,\n    `#@%^%#$@#$@#.com`,\n    `@domain.com`,\n    `Joe Smith &lt;email@domain.com&gt;`,\n    `email.domain.com`,\n    `email@domain@domain.com`,\n    `.email@domain.com`,\n    `email.@domain.com`,\n    `email..email@domain.com`,\n    `あいうえお@domain.com`,\n    `email@domain.com (Joe Smith)`,\n    `email@domain`,\n    `email@-domain.com`,\n    `email@111.222.333.44444`,\n    `email@domain..com`,\n    `Abc.example.com`,\n    `A@b@c@example.com`,\n    `colin..hacks@domain.com`,\n    `a\"b(c)d,e:f;g<h>i[j\\k]l@example.com`,\n    `just\"not\"right@example.com`,\n    `this is\"not\\allowed@example.com`,\n    `this\\ still\\\"not\\\\allowed@example.com`,\n\n    // random\n    `i_like_underscore@but_its_not_allowed_in_this_part.example.com`,\n    `QA[icon]CHOCOLATE[icon]@test.com`,\n    `invalid@-start.com`,\n    `invalid@end.com-`,\n    `a.b@c.d`,\n    `invalid@[1.1.1.-1]`,\n    `invalid@[68.185.127.196.55]`,\n    `temp@[192.168.1]`,\n    `temp@[9.18.122.]`,\n    `double..point@test.com`,\n    `asdad@test..com`,\n    `asdad@hghg...sd...au`,\n    `asdad@hghg........au`,\n    `invalid@[256.2.2.48]`,\n    `invalid@[256.2.2.48]`,\n    `invalid@[999.465.265.1]`,\n    `jkibbey4@[IPv6:82c4:19a8::70a9:2aac:557::ea69:d985:28d]`,\n    `mlivesay3@[9952:143f:b4df:2179:49a1:5e82:b92e:6b6]`,\n    `gbacher0@[IPv6:bc37:4d3f:5048:2e26:37cc:248e:df8e:2f7f:af]`,\n    `invalid@[IPv6:5348:4ed3:5d38:67fb:e9b:acd2:c13:192.168.256.1]`,\n    `test@.com`,\n    `aaaaaaaaaaaaaaalongemailthatcausesregexDoSvulnerability@test.c`,\n  ];\n  const emailSchema = z.string().email();\n\n  expect(\n    validEmails.every((email) => {\n      return emailSchema.safeParse(email).success;\n    })\n  ).toBe(true);\n  expect(\n    invalidEmails.every((email) => {\n      return emailSchema.safeParse(email).success === false;\n    })\n  ).toBe(true);\n});\n\nconst validBase64Strings = [\n  \"SGVsbG8gV29ybGQ=\", // \"Hello World\"\n  \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw==\", // \"This is an encoded string\"\n  \"TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcms=\", // \"Many hands make light work\"\n  \"UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // \"Patience is the key to success\"\n  \"QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // \"Base64 encoding is fun\"\n  \"MTIzNDU2Nzg5MA==\", // \"1234567890\"\n  \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=\", // \"abcdefghijklmnopqrstuvwxyz\"\n  \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo=\", // \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  \"ISIkJSMmJyonKCk=\", // \"!\\\"#$%&'()*\"\n  \"\", // Empty string is technically valid base64\n  \"w7/Dv8O+w74K\", // ÿÿþþ\n];\n\nfor (const str of validBase64Strings) {\n  test(`base64 should accept ${str}`, () => {\n    expect(z.string().base64().safeParse(str).success).toBe(true);\n  });\n}\n\nconst invalidBase64Strings = [\n  \"12345\", // Not padded correctly, not a multiple of 4 characters\n  \"12345===\", // Not padded correctly\n  \"SGVsbG8gV29ybGQ\", // Missing padding\n  \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw\", // Missing padding\n  \"!UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // Invalid character '!'\n  \"?QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // Invalid character '?'\n  \".MTIzND2Nzg5MC4=\", // Invalid character '.'\n  \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo\", // Missing padding\n  \"w7_Dv8O-w74K\", // Has - and _ characters (is base64url)\n];\n\nfor (const str of invalidBase64Strings) {\n  test(`base64 should reject ${str}`, () => {\n    expect(z.string().base64().safeParse(str).success).toBe(false);\n  });\n}\n\nconst validBase64URLStrings = [\n  \"SGVsbG8gV29ybGQ\", // \"Hello World\"\n  \"SGVsbG8gV29ybGQ=\", // \"Hello World\" with padding\n  \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw\", // \"This is an encoded string\"\n  \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw==\", // \"This is an encoded string\" with padding\n  \"TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcms\", // \"Many hands make light work\"\n  \"TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcms=\", // \"Many hands make light work\" with padding\n  \"UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // \"Patience is the key to success\"\n  \"QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg\", // \"Base64 encoding is fun\"\n  \"QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // \"Base64 encoding is fun\" with padding\n  \"MTIzNDU2Nzg5MA\", // \"1234567890\"\n  \"MTIzNDU2Nzg5MA==\", // \"1234567890\" with padding\n  \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo\", // \"abcdefghijklmnopqrstuvwxyz\"\n  \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=\", // \"abcdefghijklmnopqrstuvwxyz with padding\"\n  \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo\", // \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo=\", // \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" with padding\n  \"ISIkJSMmJyonKCk\", // \"!\\\"#$%&'()*\"\n  \"ISIkJSMmJyonKCk=\", // \"!\\\"#$%&'()*\" with padding\n  \"\", // Empty string is technically valid base64url\n  \"w7_Dv8O-w74K\", // ÿÿþþ\n  \"123456\",\n];\n\nfor (const str of validBase64URLStrings) {\n  test(`base64url should accept ${str}`, () => {\n    expect(z.string().base64url().safeParse(str).success).toBe(true);\n  });\n}\n\nconst invalidBase64URLStrings = [\n  \"w7/Dv8O+w74K\", // Has + and / characters (is base64)\n  \"12345\", // Invalid length (not a multiple of 4 characters when adding allowed number of padding characters)\n  \"12345===\", // Not padded correctly\n  \"!UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // Invalid character '!'\n  \"?QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // Invalid character '?'\n  \".MTIzND2Nzg5MC4=\", // Invalid character '.'\n];\n\nfor (const str of invalidBase64URLStrings) {\n  test(`base64url should reject ${str}`, () => {\n    expect(z.string().base64url().safeParse(str).success).toBe(false);\n  });\n}\n\nfunction makeJwt(header: object, payload: object) {\n  const headerBase64 = Buffer.from(JSON.stringify(header)).toString(\"base64url\");\n  const payloadBase64 = Buffer.from(JSON.stringify(payload)).toString(\"base64url\");\n  const signature = \"signature\"; // Placeholder for the signature\n  return `${headerBase64}.${payloadBase64}.${signature}`;\n}\n\ntest(\"jwt validations\", () => {\n  const jwt = z.string().jwt();\n  const jwtWithAlg = z.string().jwt({ alg: \"HS256\" });\n\n  expect(() => jwt.parse(\"invalid\")).toThrow();\n  expect(() => jwt.parse(\"invalid.invalid\")).toThrow();\n  expect(() => jwt.parse(\"invalid.invalid.invalid\")).toThrow();\n\n  // Valid JWTs\n  const d1 = makeJwt({ typ: \"JWT\", alg: \"HS256\" }, {});\n  expect(() => jwt.parse(d1)).not.toThrow();\n  expect(() => jwtWithAlg.parse(d1)).not.toThrow();\n\n  // Invalid header\n  const d2 = makeJwt({}, {});\n  expect(() => jwt.parse(d2)).toThrow();\n\n  // Wrong algorithm\n  const d3 = makeJwt({ typ: \"JWT\", alg: \"RS256\" }, {});\n  expect(() => jwtWithAlg.parse(d3)).toThrow();\n\n  // missing typ is fine\n  const d4 = makeJwt({ alg: \"HS256\" }, {});\n  jwt.parse(d4);\n\n  // type isn't JWT\n  const d5 = makeJwt({ typ: \"SUP\", alg: \"HS256\" }, { foo: \"bar\" });\n  expect(() => jwt.parse(d5)).toThrow();\n\n  // Custom error message\n  const customMsg = \"Invalid JWT token\";\n  const jwtWithMsg = z.string().jwt({ message: customMsg });\n  try {\n    jwtWithMsg.parse(\"invalid\");\n  } catch (error) {\n    expect((error as z.ZodError).issues[0].message).toBe(customMsg);\n  }\n});\n\ntest(\"url validations\", () => {\n  const url = z.string().url();\n  url.parse(\"http://google.com\");\n  url.parse(\"https://google.com/asdf?asdf=ljk3lk4&asdf=234#asdf\");\n  expect(() => url.parse(\"asdf\")).toThrow();\n  expect(() => url.parse(\"https:/\")).toThrow();\n  expect(() => url.parse(\"asdfj@lkjsdf.com\")).toThrow();\n});\n\ntest(\"url error overrides\", () => {\n  try {\n    z.string().url().parse(\"https\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Invalid url\");\n  }\n  try {\n    z.string().url(\"badurl\").parse(\"https\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"badurl\");\n  }\n  try {\n    z.string().url({ message: \"badurl\" }).parse(\"https\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"badurl\");\n  }\n});\n\ntest(\"emoji validations\", () => {\n  const emoji = z.string().emoji();\n\n  emoji.parse(\"👋👋👋👋\");\n  emoji.parse(\"🍺👩‍🚀🫡\");\n  emoji.parse(\"💚💙💜💛❤️\");\n  emoji.parse(\"🐛🗝🐏🍡🎦🚢🏨💫🎌☘🗡😹🔒🎬➡️🍹🗂🚨⚜🕑〽️🚦🌊🍴💍🍌💰😳🌺🍃\");\n  emoji.parse(\"🇹🇷🤽🏿‍♂️\");\n  emoji.parse(\n    \"😀😁😂🤣😃😄😅😆😉😊😋😎😍😘🥰😗😙😚☺️☺🙂🤗🤩🤔🤨😐😑😶🙄😏😣😥😮🤐😯😪😫😴😌😛😜😝🤤😒😓😔😕🙃🤑😲☹️☹🙁😖😞😟😤😢😭😦😧😨😩🤯😬😰😱🥵🥶😳🤪😵😡😠🤬😷🤒🤕🤢🤮🤧😇🤠🥳🥴🥺🤥🤫🤭🧐🤓😈👿🤡👹👺💀☠️☠👻👽👾🤖💩😺😸😹😻😼😽🙀😿😾🙈🙉🙊🏻🏼🏽🏾🏿👶👶🏻👶🏼👶🏽👶🏾👶🏿🧒🧒🏻🧒🏼🧒🏽🧒🏾🧒🏿👦👦🏻👦🏼👦🏽👦🏾👦🏿👧👧🏻👧🏼👧🏽👧🏾👧🏿🧑🧑🏻🧑🏼🧑🏽🧑🏾🧑🏿👨👨🏻👨🏼👨🏽👨🏾👨🏿👩👩🏻👩🏼👩🏽👩🏾👩🏿🧓🧓🏻🧓🏼🧓🏽🧓🏾🧓🏿👴👴🏻👴🏼👴🏽👴🏾👴🏿👵👵🏻👵🏼👵🏽👵🏾👵🏿👨‍⚕️👨‍⚕👨🏻‍⚕️👨🏻‍⚕👨🏼‍⚕️👨🏼‍⚕👨🏽‍⚕️👨🏽‍⚕👨🏾‍⚕️👨🏾‍⚕👨🏿‍⚕️👨🏿‍⚕👩‍⚕️👩‍⚕👩🏻‍⚕️👩🏻‍⚕👩🏼‍⚕️👩🏼‍⚕👩🏽‍⚕️👩🏽‍⚕👩🏾‍⚕️👩🏾‍⚕👩🏿‍⚕️👩🏿‍⚕👨‍🎓👨🏻‍🎓👨🏼‍🎓👨🏽‍🎓👨🏾‍🎓👨🏿‍🎓👩‍🎓👩🏻‍🎓👩🏼‍🎓👩🏽‍🎓👩🏾‍🎓👩🏿‍🎓👨‍🏫👨🏻‍🏫👨🏼‍🏫👨🏽‍🏫👨🏾‍🏫👨🏿‍🏫👩‍🏫👩🏻‍🏫👩🏼‍🏫👩🏽‍🏫👩🏾‍🏫👩🏿‍🏫👨‍⚖️👨‍⚖👨🏻‍⚖️👨🏻‍⚖👨🏼‍⚖️👨🏼‍⚖👨🏽‍⚖️👨🏽‍⚖👨🏾‍⚖️👨🏾‍⚖👨🏿‍⚖️👨🏿‍⚖👩‍⚖️👩‍⚖👩🏻‍⚖️👩🏻‍⚖👩🏼‍⚖️👩🏼‍⚖👩🏽‍⚖️👩🏽‍⚖👩🏾‍⚖️👩🏾‍⚖👩🏿‍⚖️👩🏿‍⚖👨‍🌾👨🏻‍🌾👨🏼‍🌾👨🏽‍🌾👨🏾‍🌾👨🏿‍🌾👩‍🌾👩🏻‍🌾👩🏼‍🌾👩🏽‍🌾👩🏾‍🌾👩🏿‍🌾👨‍🍳👨🏻‍🍳👨🏼‍🍳👨🏽‍🍳👨🏾‍🍳👨🏿‍🍳👩‍🍳👩🏻‍🍳👩🏼‍🍳👩🏽‍🍳👩🏾‍🍳👩🏿‍🍳👨‍🔧👨🏻‍🔧👨🏼‍🔧👨🏽‍🔧👨🏾‍🔧👨🏿‍🔧👩‍🔧👩🏻‍🔧👩🏼‍🔧👩🏽‍🔧👩🏾‍🔧👩🏿‍🔧👨‍🏭👨🏻‍🏭👨🏼‍🏭👨🏽‍🏭👨🏾‍🏭👨🏿‍🏭👩‍🏭👩🏻‍🏭👩🏼‍🏭👩🏽‍🏭👩🏾‍🏭👩🏿‍🏭👨‍💼👨🏻‍💼👨🏼‍💼👨🏽‍💼👨🏾‍💼👨🏿‍💼👩‍💼👩🏻‍💼👩🏼‍💼👩🏽‍💼👩🏾‍💼👩🏿‍💼👨‍🔬👨🏻‍🔬👨🏼‍🔬👨🏽‍🔬👨🏾‍🔬👨🏿‍🔬👩‍🔬👩🏻‍🔬👩🏼‍🔬👩🏽‍🔬👩🏾‍🔬👩🏿‍🔬👨‍💻👨🏻‍💻👨🏼‍💻👨🏽‍💻👨🏾‍💻👨🏿‍💻👩‍💻👩🏻‍💻👩🏼‍💻👩🏽‍💻👩🏾‍💻👩🏿‍💻👨‍🎤👨🏻‍🎤👨🏼‍🎤👨🏽‍🎤👨🏾‍🎤👨🏿‍🎤👩‍🎤👩🏻‍🎤👩🏼‍🎤👩🏽‍🎤👩🏾‍🎤👩🏿‍🎤👨‍🎨👨🏻‍🎨👨🏼‍🎨👨🏽‍🎨👨🏾‍🎨👨🏿‍🎨👩‍🎨👩🏻‍🎨👩🏼‍🎨👩🏽‍🎨👩🏾‍🎨👩🏿‍🎨👨‍✈️👨‍✈👨🏻‍✈️👨🏻‍✈👨🏼‍✈️👨🏼‍✈👨🏽‍✈️👨🏽‍✈👨🏾‍✈️👨🏾‍✈👨🏿‍✈️👨🏿‍✈👩‍✈️👩‍✈👩🏻‍✈️👩🏻‍✈👩🏼‍✈️👩🏼‍✈👩🏽‍✈️👩🏽‍✈👩🏾‍✈️👩🏾‍✈👩🏿‍✈️👩🏿‍✈👨‍🚀👨🏻‍🚀👨🏼‍🚀👨🏽‍🚀👨🏾‍🚀👨🏿‍🚀👩‍🚀👩🏻‍🚀👩🏼‍🚀👩🏽‍🚀👩🏾‍🚀👩🏿‍🚀👨‍🚒👨🏻‍🚒👨🏼‍🚒👨🏽‍🚒👨🏾‍🚒👨🏿‍🚒👩‍🚒👩🏻‍🚒👩🏼‍🚒👩🏽‍🚒👩🏾‍🚒👩🏿‍🚒👮👮🏻👮🏼👮🏽👮🏾👮🏿👮‍♂️👮‍♂👮🏻‍♂️👮🏻‍♂👮🏼‍♂️👮🏼‍♂👮🏽‍♂️👮🏽‍♂👮🏾‍♂️👮🏾‍♂👮🏿‍♂️👮🏿‍♂👮‍♀️👮‍♀👮🏻‍♀️👮🏻‍♀👮🏼‍♀️👮🏼‍♀👮🏽‍♀️👮🏽‍♀👮🏾‍♀️👮🏾‍♀👮🏿‍♀️👮🏿‍♀🕵️🕵🕵🏻🕵🏼🕵🏽🕵🏾🕵🏿🕵️‍♂️🕵‍♂️🕵️‍♂🕵‍♂🕵🏻‍♂️🕵🏻‍♂🕵🏼‍♂️🕵🏼‍♂🕵🏽‍♂️🕵🏽‍♂🕵🏾‍♂️🕵🏾‍♂🕵🏿‍♂️🕵🏿‍♂🕵️‍♀️🕵‍♀️🕵️‍♀🕵‍♀🕵🏻‍♀️🕵🏻‍♀🕵🏼‍♀️🕵🏼‍♀🕵🏽‍♀️🕵🏽‍♀🕵🏾‍♀️🕵🏾‍♀🕵🏿‍♀️🕵🏿‍♀💂💂🏻💂🏼💂🏽💂🏾💂🏿💂‍♂️💂‍♂💂🏻‍♂️💂🏻‍♂💂🏼‍♂️💂🏼‍♂💂🏽‍♂️💂🏽‍♂💂🏾‍♂️💂🏾‍♂💂🏿‍♂️💂🏿‍♂💂‍♀️💂‍♀💂🏻‍♀️💂🏻‍♀💂🏼‍♀️💂🏼‍♀💂🏽‍♀️💂🏽‍♀💂🏾‍♀️💂🏾‍♀💂🏿‍♀️💂🏿‍♀👷👷🏻👷🏼👷🏽👷🏾👷🏿👷‍♂️👷‍♂👷🏻‍♂️👷🏻‍♂👷🏼‍♂️👷🏼‍♂👷🏽‍♂️👷🏽‍♂👷🏾‍♂️👷🏾‍♂👷🏿‍♂️👷🏿‍♂👷‍♀️👷‍♀👷🏻‍♀️👷🏻‍♀👷🏼‍♀️👷🏼‍♀👷🏽‍♀️👷🏽‍♀👷🏾‍♀️👷🏾‍♀👷🏿‍♀️👷🏿‍♀🤴🤴🏻🤴🏼🤴🏽🤴🏾🤴🏿👸👸🏻👸🏼👸🏽👸🏾👸🏿👳👳🏻👳🏼👳🏽👳🏾👳🏿👳‍♂️👳‍♂👳🏻‍♂️👳🏻‍♂👳🏼‍♂️👳🏼‍♂👳🏽‍♂️👳🏽‍♂👳🏾‍♂️👳🏾‍♂👳🏿‍♂️👳🏿‍♂👳‍♀️👳‍♀👳🏻‍♀️👳🏻‍♀👳🏼‍♀️👳🏼‍♀👳🏽‍♀️👳🏽‍♀👳🏾‍♀️👳🏾‍♀👳🏿‍♀️👳🏿‍♀👲👲🏻👲🏼👲🏽👲🏾👲🏿🧕🧕🏻🧕🏼🧕🏽🧕🏾🧕🏿🧔🧔🏻🧔🏼🧔🏽🧔🏾🧔🏿👱👱🏻👱🏼👱🏽👱🏾👱🏿👱‍♂️👱‍♂👱🏻‍♂️👱🏻‍♂👱🏼‍♂️👱🏼‍♂👱🏽‍♂️👱🏽‍♂👱🏾‍♂️👱🏾‍♂👱🏿‍♂️👱🏿‍♂👱‍♀️👱‍♀👱🏻‍♀️👱🏻‍♀👱🏼‍♀️👱🏼‍♀👱🏽‍♀️👱🏽‍♀👱🏾‍♀️👱🏾‍♀👱🏿‍♀️👱🏿‍♀👨‍🦰👨🏻‍🦰👨🏼‍🦰👨🏽‍🦰👨🏾‍🦰👨🏿‍🦰👩‍🦰👩🏻‍🦰👩🏼‍🦰👩🏽‍🦰👩🏾‍🦰👩🏿‍🦰👨‍🦱👨🏻‍🦱👨🏼‍🦱👨🏽‍🦱👨🏾‍🦱👨🏿‍🦱👩‍🦱👩🏻‍🦱👩🏼‍🦱👩🏽‍🦱👩🏾‍🦱👩🏿‍🦱👨‍🦲👨🏻‍🦲👨🏼‍🦲👨🏽‍🦲👨🏾‍🦲👨🏿‍🦲👩‍🦲👩🏻‍🦲👩🏼‍🦲👩🏽‍🦲👩🏾‍🦲👩🏿‍🦲👨‍🦳👨🏻‍🦳👨🏼‍🦳👨🏽‍🦳👨🏾‍🦳👨🏿‍🦳👩‍🦳👩🏻‍🦳👩🏼‍🦳👩🏽‍🦳👩🏾‍🦳👩🏿‍🦳🤵🤵🏻🤵🏼🤵🏽🤵🏾🤵🏿👰👰🏻👰🏼👰🏽👰🏾👰🏿🤰🤰🏻🤰🏼🤰🏽🤰🏾🤰🏿🤱🤱🏻🤱🏼🤱🏽🤱🏾🤱🏿👼👼🏻👼🏼👼🏽👼🏾👼🏿🎅🎅🏻🎅🏼🎅🏽🎅🏾🎅🏿🤶🤶🏻🤶🏼🤶🏽🤶🏾🤶🏿🦸🦸🏻🦸🏼🦸🏽🦸🏾🦸🏿🦸‍♀️🦸‍♀🦸🏻‍♀️🦸🏻‍♀🦸🏼‍♀️🦸🏼‍♀🦸🏽‍♀️🦸🏽‍♀🦸🏾‍♀️🦸🏾‍♀🦸🏿‍♀️🦸🏿‍♀🦸‍♂️🦸‍♂🦸🏻‍♂️🦸🏻‍♂🦸🏼‍♂️🦸🏼‍♂🦸🏽‍♂️🦸🏽‍♂🦸🏾‍♂️🦸🏾‍♂🦸🏿‍♂️🦸🏿‍♂🦹🦹🏻🦹🏼🦹🏽🦹🏾🦹🏿🦹‍♀️🦹‍♀🦹🏻‍♀️🦹🏻‍♀🦹🏼‍♀️🦹🏼‍♀🦹🏽‍♀️🦹🏽‍♀🦹🏾‍♀️🦹🏾‍♀🦹🏿‍♀️🦹🏿‍♀🦹‍♂️🦹‍♂🦹🏻‍♂️🦹🏻‍♂🦹🏼‍♂️🦹🏼‍♂🦹🏽‍♂️🦹🏽‍♂🦹🏾‍♂️🦹🏾‍♂🦹🏿‍♂️🦹🏿‍♂🧙🧙🏻🧙🏼🧙🏽🧙🏾🧙🏿🧙‍♀️🧙‍♀🧙🏻‍♀️🧙🏻‍♀🧙🏼‍♀️🧙🏼‍♀🧙🏽‍♀️🧙🏽‍♀🧙🏾‍♀️🧙🏾‍♀🧙🏿‍♀️🧙🏿‍♀🧙‍♂️🧙‍♂🧙🏻‍♂️🧙🏻‍♂🧙🏼‍♂️🧙🏼‍♂🧙🏽‍♂️🧙🏽‍♂🧙🏾‍♂️🧙🏾‍♂🧙🏿‍♂️🧙🏿‍♂🧚🧚🏻🧚🏼🧚🏽🧚🏾🧚🏿🧚‍♀️🧚‍♀🧚🏻‍♀️🧚🏻‍♀🧚🏼‍♀️🧚🏼‍♀🧚🏽‍♀️🧚🏽‍♀🧚🏾‍♀️🧚🏾‍♀🧚🏿‍♀️🧚🏿‍♀🧚‍♂️🧚‍♂🧚🏻‍♂️🧚🏻‍♂🧚🏼‍♂️🧚🏼‍♂🧚🏽‍♂️🧚🏽‍♂🧚🏾‍♂️🧚🏾‍♂🧚🏿‍♂️🧚🏿‍♂🧛🧛🏻🧛🏼🧛🏽🧛🏾🧛🏿🧛‍♀️🧛‍♀🧛🏻‍♀️🧛🏻‍♀🧛🏼‍♀️🧛🏼‍♀🧛🏽‍♀️🧛🏽‍♀🧛🏾‍♀️🧛🏾‍♀🧛🏿‍♀️🧛🏿‍♀🧛‍♂️🧛‍♂🧛🏻‍♂️🧛🏻‍♂🧛🏼‍♂️🧛🏼‍♂🧛🏽‍♂️🧛🏽‍♂🧛🏾‍♂️🧛🏾‍♂🧛🏿‍♂️🧛🏿‍♂🧜🧜🏻🧜🏼🧜🏽🧜🏾🧜🏿🧜‍♀️🧜‍♀🧜🏻‍♀️🧜🏻‍♀🧜🏼‍♀️🧜🏼‍♀🧜🏽‍♀️🧜🏽‍♀🧜🏾‍♀️🧜🏾‍♀🧜🏿‍♀️🧜🏿‍♀🧜‍♂️🧜‍♂🧜🏻‍♂️🧜🏻‍♂🧜🏼‍♂️🧜🏼‍♂🧜🏽‍♂️🧜🏽‍♂🧜🏾‍♂️🧜🏾‍♂🧜🏿‍♂️🧜🏿‍♂🧝🧝🏻🧝🏼🧝🏽🧝🏾🧝🏿🧝‍♀️🧝‍♀🧝🏻‍♀️🧝🏻‍♀🧝🏼‍♀️🧝🏼‍♀🧝🏽‍♀️🧝🏽‍♀🧝🏾‍♀️🧝🏾‍♀🧝🏿‍♀️🧝🏿‍♀🧝‍♂️🧝‍♂🧝🏻‍♂️🧝🏻‍♂🧝🏼‍♂️🧝🏼‍♂🧝🏽‍♂️🧝🏽‍♂🧝🏾‍♂️🧝🏾‍♂🧝🏿‍♂️🧝🏿‍♂🧞🧞‍♀️🧞‍♀🧞‍♂️🧞‍♂🧟🧟‍♀️🧟‍♀🧟‍♂️🧟‍♂🙍🙍🏻🙍🏼🙍🏽🙍🏾🙍🏿🙍‍♂️🙍‍♂🙍🏻‍♂️🙍🏻‍♂🙍🏼‍♂️🙍🏼‍♂🙍🏽‍♂️🙍🏽‍♂🙍🏾‍♂️🙍🏾‍♂🙍🏿‍♂️🙍🏿‍♂🙍‍♀️🙍‍♀🙍🏻‍♀️🙍🏻‍♀🙍🏼‍♀️🙍🏼‍♀🙍🏽‍♀️🙍🏽‍♀🙍🏾‍♀️🙍🏾‍♀🙍🏿‍♀️🙍🏿‍♀🙎🙎🏻🙎🏼🙎🏽🙎🏾🙎🏿🙎‍♂️🙎‍♂🙎🏻‍♂️🙎🏻‍♂🙎🏼‍♂️🙎🏼‍♂🙎🏽‍♂️🙎🏽‍♂🙎🏾‍♂️🙎🏾‍♂🙎🏿‍♂️🙎🏿‍♂🙎‍♀️🙎‍♀🙎🏻‍♀️🙎🏻‍♀🙎🏼‍♀️🙎🏼‍♀🙎🏽‍♀️🙎🏽‍♀🙎🏾‍♀️🙎🏾‍♀🙎🏿‍♀️🙎🏿‍♀🙅🙅🏻🙅🏼🙅🏽🙅🏾🙅🏿🙅‍♂️🙅‍♂🙅🏻‍♂️🙅🏻‍♂🙅🏼‍♂️🙅🏼‍♂🙅🏽‍♂️🙅🏽‍♂🙅🏾‍♂️🙅🏾‍♂🙅🏿‍♂️🙅🏿‍♂🙅‍♀️🙅‍♀🙅🏻‍♀️🙅🏻‍♀🙅🏼‍♀️🙅🏼‍♀🙅🏽‍♀️🙅🏽‍♀🙅🏾‍♀️🙅🏾‍♀🙅🏿‍♀️🙅🏿‍♀🙆🙆🏻🙆🏼🙆🏽🙆🏾🙆🏿🙆‍♂️🙆‍♂🙆🏻‍♂️🙆🏻‍♂🙆🏼‍♂️🙆🏼‍♂🙆🏽‍♂️🙆🏽‍♂🙆🏾‍♂️🙆🏾‍♂🙆🏿‍♂️🙆🏿‍♂🙆‍♀️🙆‍♀🙆🏻‍♀️🙆🏻‍♀🙆🏼‍♀️🙆🏼‍♀🙆🏽‍♀️🙆🏽‍♀🙆🏾‍♀️🙆🏾‍♀🙆🏿‍♀️🙆🏿‍♀💁💁🏻💁🏼💁🏽💁🏾💁🏿💁‍♂️💁‍♂💁🏻‍♂️💁🏻‍♂💁🏼‍♂️💁🏼‍♂💁🏽‍♂️💁🏽‍♂💁🏾‍♂️💁🏾‍♂💁🏿‍♂️💁🏿‍♂💁‍♀️💁‍♀💁🏻‍♀️💁🏻‍♀💁🏼‍♀️💁🏼‍♀💁🏽‍♀️💁🏽‍♀💁🏾‍♀️💁🏾‍♀💁🏿‍♀️💁🏿‍♀🙋🙋🏻🙋🏼🙋🏽🙋🏾🙋🏿🙋‍♂️🙋‍♂🙋🏻‍♂️🙋🏻‍♂🙋🏼‍♂️🙋🏼‍♂🙋🏽‍♂️🙋🏽‍♂🙋🏾‍♂️🙋🏾‍♂🙋🏿‍♂️🙋🏿‍♂🙋‍♀️🙋‍♀🙋🏻‍♀️🙋🏻‍♀🙋🏼‍♀️🙋🏼‍♀🙋🏽‍♀️🙋🏽‍♀🙋🏾‍♀️🙋🏾‍♀🙋🏿‍♀️🙋🏿‍♀🙇🙇🏻🙇🏼🙇🏽🙇🏾🙇🏿🙇‍♂️🙇‍♂🙇🏻‍♂️🙇🏻‍♂🙇🏼‍♂️🙇🏼‍♂🙇🏽‍♂️🙇🏽‍♂🙇🏾‍♂️🙇🏾‍♂🙇🏿‍♂️🙇🏿‍♂🙇‍♀️🙇‍♀🙇🏻‍♀️🙇🏻‍♀🙇🏼‍♀️🙇🏼‍♀🙇🏽‍♀️🙇🏽‍♀🙇🏾‍♀️🙇🏾‍♀🙇🏿‍♀️🙇🏿‍♀🤦🤦🏻🤦🏼🤦🏽🤦🏾🤦🏿🤦‍♂️🤦‍♂🤦🏻‍♂️🤦🏻‍♂🤦🏼‍♂️🤦🏼‍♂🤦🏽‍♂️🤦🏽‍♂🤦🏾‍♂️🤦🏾‍♂🤦🏿‍♂️🤦🏿‍♂🤦‍♀️🤦‍♀🤦🏻‍♀️🤦🏻‍♀🤦🏼‍♀️🤦🏼‍♀🤦🏽‍♀️🤦🏽‍♀🤦🏾‍♀️🤦🏾‍♀🤦🏿‍♀️🤦🏿‍♀🤷🤷🏻🤷🏼🤷🏽🤷🏾🤷🏿🤷‍♂️🤷‍♂🤷🏻‍♂️🤷🏻‍♂🤷🏼‍♂️🤷🏼‍♂🤷🏽‍♂️🤷🏽‍♂🤷🏾‍♂️🤷🏾‍♂🤷🏿‍♂️🤷🏿‍♂🤷‍♀️🤷‍♀🤷🏻‍♀️🤷🏻‍♀🤷🏼‍♀️🤷🏼‍♀🤷🏽‍♀️🤷🏽‍♀🤷🏾‍♀️🤷🏾‍♀🤷🏿‍♀️🤷🏿‍♀💆💆🏻💆🏼💆🏽💆🏾💆🏿💆‍♂️💆‍♂💆🏻‍♂️💆🏻‍♂💆🏼‍♂️💆🏼‍♂💆🏽‍♂️💆🏽‍♂💆🏾‍♂️💆🏾‍♂💆🏿‍♂️💆🏿‍♂💆‍♀️💆‍♀💆🏻‍♀️💆🏻‍♀💆🏼‍♀️💆🏼‍♀💆🏽‍♀️💆🏽‍♀💆🏾‍♀️💆🏾‍♀💆🏿‍♀️💆🏿‍♀💇💇🏻💇🏼💇🏽💇🏾💇🏿💇‍♂️💇‍♂💇🏻‍♂️💇🏻‍♂💇🏼‍♂️💇🏼‍♂💇🏽‍♂️💇🏽‍♂💇🏾‍♂️💇🏾‍♂💇🏿‍♂️💇🏿‍♂💇‍♀️💇‍♀💇🏻‍♀️💇🏻‍♀💇🏼‍♀️💇🏼‍♀💇🏽‍♀️💇🏽‍♀💇🏾‍♀️💇🏾‍♀💇🏿‍♀️💇🏿‍♀🚶🚶🏻🚶🏼🚶🏽🚶🏾🚶🏿🚶‍♂️🚶‍♂🚶🏻‍♂️🚶🏻‍♂🚶🏼‍♂️🚶🏼‍♂🚶🏽‍♂️🚶🏽‍♂🚶🏾‍♂️🚶🏾‍♂🚶🏿‍♂️🚶🏿‍♂🚶‍♀️🚶‍♀🚶🏻‍♀️🚶🏻‍♀🚶🏼‍♀️🚶🏼‍♀🚶🏽‍♀️🚶🏽‍♀🚶🏾‍♀️🚶🏾‍♀🚶🏿‍♀️🚶🏿‍♀🏃🏃🏻🏃🏼🏃🏽🏃🏾🏃🏿🏃‍♂️🏃‍♂🏃🏻‍♂️🏃🏻‍♂🏃🏼‍♂️🏃🏼‍♂🏃🏽‍♂️🏃🏽‍♂🏃🏾‍♂️🏃🏾‍♂🏃🏿‍♂️🏃🏿‍♂🏃‍♀️🏃‍♀🏃🏻‍♀️🏃🏻‍♀🏃🏼‍♀️🏃🏼‍♀🏃🏽‍♀️🏃🏽‍♀🏃🏾‍♀️🏃🏾‍♀🏃🏿‍♀️🏃🏿‍♀💃💃🏻💃🏼💃🏽💃🏾💃🏿🕺🕺🏻🕺🏼🕺🏽🕺🏾🕺🏿👯👯‍♂️👯‍♂👯‍♀️👯‍♀🧖🧖🏻🧖🏼🧖🏽🧖🏾🧖🏿🧖‍♀️🧖‍♀🧖🏻‍♀️🧖🏻‍♀🧖🏼‍♀️🧖🏼‍♀🧖🏽‍♀️🧖🏽‍♀🧖🏾‍♀️🧖🏾‍♀🧖🏿‍♀️🧖🏿‍♀🧖‍♂️🧖‍♂🧖🏻‍♂️🧖🏻‍♂🧖🏼‍♂️🧖🏼‍♂🧖🏽‍♂️🧖🏽‍♂🧖🏾‍♂️🧖🏾‍♂🧖🏿‍♂️🧖🏿‍♂🧗🧗🏻🧗🏼🧗🏽🧗🏾🧗🏿🧗‍♀️🧗‍♀🧗🏻‍♀️🧗🏻‍♀🧗🏼‍♀️🧗🏼‍♀🧗🏽‍♀️🧗🏽‍♀🧗🏾‍♀️🧗🏾‍♀🧗🏿‍♀️🧗🏿‍♀🧗‍♂️🧗‍♂🧗🏻‍♂️🧗🏻‍♂🧗🏼‍♂️🧗🏼‍♂🧗🏽‍♂️🧗🏽‍♂🧗🏾‍♂️🧗🏾‍♂🧗🏿‍♂️🧗🏿‍♂🧘🧘🏻🧘🏼🧘🏽🧘🏾🧘🏿🧘‍♀️🧘‍♀🧘🏻‍♀️🧘🏻‍♀🧘🏼‍♀️🧘🏼‍♀🧘🏽‍♀️🧘🏽‍♀🧘🏾‍♀️🧘🏾‍♀🧘🏿‍♀️🧘🏿‍♀🧘‍♂️🧘‍♂🧘🏻‍♂️🧘🏻‍♂🧘🏼‍♂️🧘🏼‍♂🧘🏽‍♂️🧘🏽‍♂🧘🏾‍♂️🧘🏾‍♂🧘🏿‍♂️🧘🏿‍♂🛀🛀🏻🛀🏼🛀🏽🛀🏾🛀🏿🛌🛌🏻🛌🏼🛌🏽🛌🏾🛌🏿🕴️🕴🕴🏻🕴🏼🕴🏽🕴🏾🕴🏿🗣️🗣👤👥🤺🏇🏇🏻🏇🏼🏇🏽🏇🏾🏇🏿⛷️⛷🏂🏂🏻🏂🏼🏂🏽🏂🏾🏂🏿🏌️🏌🏌🏻🏌🏼🏌🏽🏌🏾🏌🏿🏌️‍♂️🏌‍♂️🏌️‍♂🏌‍♂🏌🏻‍♂️🏌🏻‍♂🏌🏼‍♂️🏌🏼‍♂🏌🏽‍♂️🏌🏽‍♂🏌🏾‍♂️🏌🏾‍♂🏌🏿‍♂️🏌🏿‍♂🏌️‍♀️🏌‍♀️🏌️‍♀🏌‍♀🏌🏻‍♀️🏌🏻‍♀🏌🏼‍♀️🏌🏼‍♀🏌🏽‍♀️🏌🏽‍♀🏌🏾‍♀️🏌🏾‍♀🏌🏿‍♀️🏌🏿‍♀🏄🏄🏻🏄🏼🏄🏽🏄🏾🏄🏿🏄‍♂️🏄‍♂🏄🏻‍♂️🏄🏻‍♂🏄🏼‍♂️🏄🏼‍♂🏄🏽‍♂️🏄🏽‍♂🏄🏾‍♂️🏄🏾‍♂🏄🏿‍♂️🏄🏿‍♂🏄‍♀️🏄‍♀🏄🏻‍♀️🏄🏻‍♀🏄🏼‍♀️🏄🏼‍♀🏄🏽‍♀️🏄🏽‍♀🏄🏾‍♀️🏄🏾‍♀🏄🏿‍♀️🏄🏿‍♀🚣🚣🏻🚣🏼🚣🏽🚣🏾🚣🏿🚣‍♂️🚣‍♂🚣🏻‍♂️🚣🏻‍♂🚣🏼‍♂️🚣🏼‍♂🚣🏽‍♂️🚣🏽‍♂🚣🏾‍♂️🚣🏾‍♂🚣🏿‍♂️🚣🏿‍♂🚣‍♀️🚣‍♀🚣🏻‍♀️🚣🏻‍♀🚣🏼‍♀️🚣🏼‍♀🚣🏽‍♀️🚣🏽‍♀🚣🏾‍♀️🚣🏾‍♀🚣🏿‍♀️🚣🏿‍♀🏊🏊🏻🏊🏼🏊🏽🏊🏾🏊🏿🏊‍♂️🏊‍♂🏊🏻‍♂️🏊🏻‍♂🏊🏼‍♂️🏊🏼‍♂🏊🏽‍♂️🏊🏽‍♂🏊🏾‍♂️🏊🏾‍♂🏊🏿‍♂️🏊🏿‍♂🏊‍♀️🏊‍♀🏊🏻‍♀️🏊🏻‍♀🏊🏼‍♀️🏊🏼‍♀🏊🏽‍♀️🏊🏽‍♀🏊🏾‍♀️🏊🏾‍♀🏊🏿‍♀️🏊🏿‍♀⛹️⛹⛹🏻⛹🏼⛹🏽⛹🏾⛹🏿⛹️‍♂️⛹‍♂️⛹️‍♂⛹‍♂⛹🏻‍♂️⛹🏻‍♂⛹🏼‍♂️⛹🏼‍♂⛹🏽‍♂️⛹🏽‍♂⛹🏾‍♂️⛹🏾‍♂⛹🏿‍♂️⛹🏿‍♂⛹️‍♀️⛹‍♀️⛹️‍♀⛹‍♀⛹🏻‍♀️⛹🏻‍♀⛹🏼‍♀️⛹🏼‍♀⛹🏽‍♀️⛹🏽‍♀⛹🏾‍♀️⛹🏾‍♀⛹🏿‍♀️⛹🏿‍♀🏋️🏋🏋🏻🏋🏼🏋🏽🏋🏾🏋🏿🏋️‍♂️🏋‍♂️🏋️‍♂🏋‍♂🏋🏻‍♂️🏋🏻‍♂🏋🏼‍♂️🏋🏼‍♂🏋🏽‍♂️🏋🏽‍♂🏋🏾‍♂️🏋🏾‍♂🏋🏿‍♂️🏋🏿‍♂🏋️‍♀️🏋‍♀️🏋️‍♀🏋‍♀🏋🏻‍♀️🏋🏻‍♀🏋🏼‍♀️🏋🏼‍♀🏋🏽‍♀️🏋🏽‍♀🏋🏾‍♀️🏋🏾‍♀🏋🏿‍♀️🏋🏿‍♀🚴🚴🏻🚴🏼🚴🏽🚴🏾🚴🏿🚴‍♂️🚴‍♂🚴🏻‍♂️🚴🏻‍♂🚴🏼‍♂️🚴🏼‍♂🚴🏽‍♂️🚴🏽‍♂🚴🏾‍♂️🚴🏾‍♂🚴🏿‍♂️🚴🏿‍♂🚴‍♀️🚴‍♀🚴🏻‍♀️🚴🏻‍♀🚴🏼‍♀️🚴🏼‍♀🚴🏽‍♀️🚴🏽‍♀🚴🏾‍♀️🚴🏾‍♀🚴🏿‍♀️🚴🏿‍♀🚵🚵🏻🚵🏼🚵🏽🚵🏾🚵🏿🚵‍♂️🚵‍♂🚵🏻‍♂️🚵🏻‍♂🚵🏼‍♂️🚵🏼‍♂🚵🏽‍♂️🚵🏽‍♂🚵🏾‍♂️🚵🏾‍♂🚵🏿‍♂️🚵🏿‍♂🚵‍♀️🚵‍♀🚵🏻‍♀️🚵🏻‍♀🚵🏼‍♀️🚵🏼‍♀🚵🏽‍♀️🚵🏽‍♀🚵🏾‍♀️🚵🏾‍♀🚵🏿‍♀️🚵🏿‍♀🏎️🏎🏍️🏍🤸🤸🏻🤸🏼🤸🏽🤸🏾🤸🏿🤸‍♂️🤸‍♂🤸🏻‍♂️🤸🏻‍♂🤸🏼‍♂️🤸🏼‍♂🤸🏽‍♂️🤸🏽‍♂🤸🏾‍♂️🤸🏾‍♂🤸🏿‍♂️🤸🏿‍♂🤸‍♀️🤸‍♀🤸🏻‍♀️🤸🏻‍♀🤸🏼‍♀️🤸🏼‍♀🤸🏽‍♀️🤸🏽‍♀🤸🏾‍♀️🤸🏾‍♀🤸🏿‍♀️🤸🏿‍♀🤼🤼‍♂️🤼‍♂🤼‍♀️🤼‍♀🤽🤽🏻🤽🏼🤽🏽🤽🏾🤽🏿🤽‍♂️🤽‍♂🤽🏻‍♂️🤽🏻‍♂🤽🏼‍♂️🤽🏼‍♂🤽🏽‍♂️🤽🏽‍♂🤽🏾‍♂️🤽🏾‍♂🤽🏿‍♂️🤽🏿‍♂🤽‍♀️🤽‍♀🤽🏻‍♀️🤽🏻‍♀🤽🏼‍♀️🤽🏼‍♀🤽🏽‍♀️🤽🏽‍♀🤽🏾‍♀️🤽🏾‍♀🤽🏿‍♀️🤽🏿‍♀🤾🤾🏻🤾🏼🤾🏽🤾🏾🤾🏿🤾‍♂️🤾‍♂🤾🏻‍♂️🤾🏻‍♂🤾🏼‍♂️🤾🏼‍♂🤾🏽‍♂️🤾🏽‍♂🤾🏾‍♂️🤾🏾‍♂🤾🏿‍♂️🤾🏿‍♂🤾‍♀️🤾‍♀🤾🏻‍♀️🤾🏻‍♀🤾🏼‍♀️🤾🏼‍♀🤾🏽‍♀️🤾🏽‍♀🤾🏾‍♀️🤾🏾‍♀🤾🏿‍♀️🤾🏿‍♀🤹🤹🏻🤹🏼🤹🏽🤹🏾🤹🏿🤹‍♂️🤹‍♂🤹🏻‍♂️🤹🏻‍♂🤹🏼‍♂️🤹🏼‍♂🤹🏽‍♂️🤹🏽‍♂🤹🏾‍♂️🤹🏾‍♂🤹🏿‍♂️🤹🏿‍♂🤹‍♀️🤹‍♀🤹🏻‍♀️🤹🏻‍♀🤹🏼‍♀️🤹🏼‍♀🤹🏽‍♀️🤹🏽‍♀🤹🏾‍♀️🤹🏾‍♀🤹🏿‍♀️🤹🏿‍♀👫👬👭💏👩‍❤️‍💋‍👨👩‍❤‍💋‍👨👨‍❤️‍💋‍👨👨‍❤‍💋‍👨👩‍❤️‍💋‍👩👩‍❤‍💋‍👩💑👩‍❤️‍👨👩‍❤‍👨👨‍❤️‍👨👨‍❤‍👨👩‍❤️‍👩👩‍❤‍👩👪👨‍👩‍👦👨‍👩‍👧👨‍👩‍👧‍👦👨‍👩‍👦‍👦👨‍👩‍👧‍👧👨‍👨‍👦👨‍👨‍👧👨‍👨‍👧‍👦👨‍👨‍👦‍👦👨‍👨‍👧‍👧👩‍👩‍👦👩‍👩‍👧👩‍👩‍👧‍👦👩‍👩‍👦‍👦👩‍👩‍👧‍👧👨‍👦👨‍👦‍👦👨‍👧👨‍👧‍👦👨‍👧‍👧👩‍👦👩‍👦‍👦👩‍👧👩‍👧‍👦👩‍👧‍👧🤳🤳🏻🤳🏼🤳🏽🤳🏾🤳🏿💪💪🏻💪🏼💪🏽💪🏾💪🏿🦵🦵🏻🦵🏼🦵🏽🦵🏾🦵🏿🦶🦶🏻🦶🏼🦶🏽🦶🏾🦶🏿👈👈🏻👈🏼👈🏽👈🏾👈🏿👉👉🏻👉🏼👉🏽👉🏾👉🏿☝️☝☝🏻☝🏼☝🏽☝🏾☝🏿👆👆🏻👆🏼👆🏽👆🏾👆🏿🖕🖕🏻🖕🏼🖕🏽🖕🏾🖕🏿👇👇🏻👇🏼👇🏽👇🏾👇🏿✌️✌✌🏻✌🏼✌🏽✌🏾✌🏿🤞🤞🏻🤞🏼🤞🏽🤞🏾🤞🏿🖖🖖🏻🖖🏼🖖🏽🖖🏾🖖🏿🤘🤘🏻🤘🏼🤘🏽🤘🏾🤘🏿🤙🤙🏻🤙🏼🤙🏽🤙🏾🤙🏿🖐️🖐🖐🏻🖐🏼🖐🏽🖐🏾🖐🏿✋✋🏻✋🏼✋🏽✋🏾✋🏿👌👌🏻👌🏼👌🏽👌🏾👌🏿👍👍🏻👍🏼👍🏽👍🏾👍🏿👎👎🏻👎🏼👎🏽👎🏾👎🏿✊✊🏻✊🏼✊🏽✊🏾✊🏿👊👊🏻👊🏼👊🏽👊🏾👊🏿🤛🤛🏻🤛🏼🤛🏽🤛🏾🤛🏿🤜🤜🏻🤜🏼🤜🏽🤜🏾🤜🏿🤚🤚🏻🤚🏼🤚🏽🤚🏾🤚🏿👋👋🏻👋🏼👋🏽👋🏾👋🏿🤟🤟🏻🤟🏼🤟🏽🤟🏾🤟🏿✍️✍✍🏻✍🏼✍🏽✍🏾✍🏿👏👏🏻👏🏼👏🏽👏🏾👏🏿👐👐🏻👐🏼👐🏽👐🏾👐🏿🙌🙌🏻🙌🏼🙌🏽🙌🏾🙌🏿🤲🤲🏻🤲🏼🤲🏽🤲🏾🤲🏿🙏🙏🏻🙏🏼🙏🏽🙏🏾🙏🏿🤝💅💅🏻💅🏼💅🏽💅🏾💅🏿👂👂🏻👂🏼👂🏽👂🏾👂🏿👃👃🏻👃🏼👃🏽👃🏾👃🏿🦰🦱🦲🦳👣👀👁️👁👁️‍🗨️👁‍🗨️👁️‍🗨👁‍🗨🧠🦴🦷👅👄💋💘❤️❤💓💔💕💖💗💙💚💛🧡💜🖤💝💞💟❣️❣💌💤💢💣💥💦💨💫💬🗨️🗨🗯️🗯💭🕳️🕳👓🕶️🕶🥽🥼👔👕👖🧣🧤🧥🧦👗👘👙👚👛👜👝🛍️🛍🎒👞👟🥾🥿👠👡👢👑👒🎩🎓🧢⛑️⛑📿💄💍💎🐵🐒🦍🐶🐕🐩🐺🦊🦝🐱🐈🦁🐯🐅🐆🐴🐎🦄🦓🦌🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🦙🦒🐘🦏🦛🐭🐁🐀🐹🐰🐇🐿️🐿🦔🦇🐻🐨🐼🦘🦡🐾🦃🐔🐓🐣🐤🐥🐦🐧🕊️🕊🦅🦆🦢🦉🦚🦜🐸🐊🐢🦎🐍🐲🐉🦕🦖🐳🐋🐬🐟🐠🐡🦈🐙🐚🦀🦞🦐🦑🐌🦋🐛🐜🐝🐞🦗🕷️🕷🕸️🕸🦂🦟🦠💐🌸💮🏵️🏵🌹🥀🌺🌻🌼🌷🌱🌲🌳🌴🌵🌾🌿☘️☘🍀🍁🍂🍃🍇🍈🍉🍊🍋🍌🍍🥭🍎🍏🍐🍑🍒🍓🥝🍅🥥🥑🍆🥔🥕🌽🌶️🌶🥒🥬🥦🍄🥜🌰🍞🥐🥖🥨🥯🥞🧀🍖🍗🥩🥓🍔🍟🍕🌭🥪🌮🌯🥙🥚🍳🥘🍲🥣🥗🍿🧂🥫🍱🍘🍙🍚🍛🍜🍝🍠🍢🍣🍤🍥🥮🍡🥟🥠🥡🍦🍧🍨🍩🍪🎂🍰🧁🥧🍫🍬🍭🍮🍯🍼🥛☕🍵🍶🍾🍷🍸🍹🍺🍻🥂🥃🥤🥢🍽️🍽🍴🥄🔪🏺🌍🌎🌏🌐🗺️🗺🗾🧭🏔️🏔⛰️⛰🌋🗻🏕️🏕🏖️🏖🏜️🏜🏝️🏝🏞️🏞🏟️🏟🏛️🏛🏗️🏗🧱🏘️🏘🏚️🏚🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪🕌🕍⛩️⛩🕋⛲⛺🌁🌃🏙️🏙🌄🌅🌆🌇🌉♨️♨🌌🎠🎡🎢💈🎪🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🚚🚛🚜🚲🛴🛹🛵🚏🛣️🛣🛤️🛤🛢️🛢⛽🚨🚥🚦🛑🚧⚓⛵🛶🚤🛳️🛳⛴️⛴🛥️🛥🚢✈️✈🛩️🛩🛫🛬💺🚁🚟🚠🚡🛰️🛰🚀🛸🛎️🛎🧳⌛⏳⌚⏰⏱️⏱⏲️⏲🕰️🕰🕛🕧🕐🕜🕑🕝🕒🕞🕓🕟🕔🕠🕕🕡🕖🕢🕗🕣🕘🕤🕙🕥🕚🕦🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌡️🌡☀️☀🌝🌞⭐🌟🌠☁️☁⛅⛈️⛈🌤️🌤🌥️🌥🌦️🌦🌧️🌧🌨️🌨🌩️🌩🌪️🌪🌫️🌫🌬️🌬🌀🌈🌂☂️☂☔⛱️⛱⚡❄️❄☃️☃⛄☄️☄🔥💧🌊🎃🎄🎆🎇🧨✨🎈🎉🎊🎋🎍🎎🎏🎐🎑🧧🎀🎁🎗️🎗🎟️🎟🎫🎖️🎖🏆🏅🥇🥈🥉⚽⚾🥎🏀🏐🏈🏉🎾🥏🎳🏏🏑🏒🥍🏓🏸🥊🥋🥅⛳⛸️⛸🎣🎽🎿🛷🥌🎯🎱🔮🧿🎮🕹️🕹🎰🎲🧩🧸♠️♠♥️♥♦️♦♣️♣♟️♟🃏🀄🎴🎭🖼️🖼🎨🧵🧶🔇🔈🔉🔊📢📣📯🔔🔕🎼🎵🎶🎙️🎙🎚️🎚🎛️🎛🎤🎧📻🎷🎸🎹🎺🎻🥁📱📲☎️☎📞📟📠🔋🔌💻🖥️🖥🖨️🖨⌨️⌨🖱️🖱🖲️🖲💽💾💿📀🧮🎥🎞️🎞📽️📽🎬📺📷📸📹📼🔍🔎🕯️🕯💡🔦🏮📔📕📖📗📘📙📚📓📒📃📜📄📰🗞️🗞📑🔖🏷️🏷💰💴💵💶💷💸💳🧾💹💱💲✉️✉📧📨📩📤📥📦📫📪📬📭📮🗳️🗳✏️✏✒️✒🖋️🖋🖊️🖊🖌️🖌🖍️🖍📝💼📁📂🗂️🗂📅📆🗒️🗒🗓️🗓📇📈📉📊📋📌📍📎🖇️🖇📏📐✂️✂🗃️🗃🗄️🗄🗑️🗑🔒🔓🔏🔐🔑🗝️🗝🔨⛏️⛏⚒️⚒🛠️🛠🗡️🗡⚔️⚔🔫🏹🛡️🛡🔧🔩⚙️⚙🗜️🗜⚖️⚖🔗⛓️⛓🧰🧲⚗️⚗🧪🧫🧬🔬🔭📡💉💊🚪🛏️🛏🛋️🛋🚽🚿🛁🧴🧷🧹🧺🧻🧼🧽🧯🛒🚬⚰️⚰⚱️⚱🗿🏧🚮🚰♿🚹🚺🚻🚼🚾🛂🛃🛄🛅⚠️⚠🚸⛔🚫🚳🚭🚯🚱🚷📵🔞☢️☢☣️☣⬆️⬆↗️↗➡️➡↘️↘⬇️⬇↙️↙⬅️⬅↖️↖↕️↕↔️↔↩️↩↪️↪⤴️⤴⤵️⤵🔃🔄🔙🔚🔛🔜🔝🛐⚛️⚛🕉️🕉✡️✡☸️☸☯️☯✝️✝☦️☦☪️☪☮️☮🕎🔯♈♉♊♋♌♍♎♏♐♑♒♓⛎🔀🔁🔂▶️▶⏩⏭️⏭⏯️⏯◀️◀⏪⏮️⏮🔼⏫🔽⏬⏸️⏸⏹️⏹⏺️⏺⏏️⏏🎦🔅🔆📶📳📴♀️♀♂️♂⚕️⚕♾️♾♻️♻⚜️⚜🔱📛🔰⭕✅☑️☑✔️✔✖️✖❌❎➕➖➗➰➿〽️〽✳️✳✴️✴❇️❇‼️‼⁉️⁉❓❔❕❗〰️〰©️©®️®™️™#️⃣#⃣*️⃣*⃣0️⃣0⃣1️⃣1⃣2️⃣2⃣3️⃣3⃣4️⃣4⃣5️⃣5⃣6️⃣6⃣7️⃣7⃣8️⃣8⃣9️⃣9⃣🔟💯🔠🔡🔢🔣🔤🅰️🅰🆎🅱️🅱🆑🆒🆓ℹ️ℹ🆔Ⓜ️Ⓜ🆕🆖🅾️🅾🆗🅿️🅿🆘🆙🆚🈁🈂️🈂🈷️🈷🈶🈯🉐🈹🈚🈲🉑🈸🈴🈳㊗️㊗㊙️㊙🈺🈵▪️▪▫️▫◻️◻◼️◼◽◾⬛⬜🔶🔷🔸🔹🔺🔻💠🔘🔲🔳⚪⚫🔴🔵🏁🚩🎌🏴🏳️🏳🏳️‍🌈🏳‍🌈🏴‍☠️🏴‍☠🇦🇨🇦🇩🇦🇪🇦🇫🇦🇬🇦🇮🇦🇱🇦🇲🇦🇴🇦🇶🇦🇷🇦🇸🇦🇹🇦🇺🇦🇼🇦🇽🇦🇿🇧🇦🇧🇧🇧🇩🇧🇪🇧🇫🇧🇬🇧🇭🇧🇮🇧🇯🇧🇱🇧🇲🇧🇳🇧🇴🇧🇶🇧🇷🇧🇸🇧🇹🇧🇻🇧🇼🇧🇾🇧🇿🇨🇦🇨🇨🇨🇩🇨🇫🇨🇬🇨🇭🇨🇮🇨🇰🇨🇱🇨🇲🇨🇳🇨🇴🇨🇵🇨🇷🇨🇺🇨🇻🇨🇼🇨🇽🇨🇾🇨🇿🇩🇪🇩🇬🇩🇯🇩🇰🇩🇲🇩🇴🇩🇿🇪🇦🇪🇨🇪🇪🇪🇬🇪🇭🇪🇷🇪🇸🇪🇹🇪🇺🇫🇮🇫🇯🇫🇰🇫🇲🇫🇴🇫🇷🇬🇦🇬🇧🇬🇩🇬🇪🇬🇫🇬🇬🇬🇭🇬🇮🇬🇱🇬🇲🇬🇳🇬🇵🇬🇶🇬🇷🇬🇸🇬🇹🇬🇺🇬🇼🇬🇾🇭🇰🇭🇲🇭🇳🇭🇷🇭🇹🇭🇺🇮🇨🇮🇩🇮🇪🇮🇱🇮🇲🇮🇳🇮🇴🇮🇶🇮🇷🇮🇸🇮🇹🇯🇪🇯🇲🇯🇴🇯🇵🇰🇪🇰🇬🇰🇭🇰🇮🇰🇲🇰🇳🇰🇵🇰🇷🇰🇼🇰🇾🇰🇿🇱🇦🇱🇧🇱🇨🇱🇮🇱🇰🇱🇷🇱🇸🇱🇹🇱🇺🇱🇻🇱🇾🇲🇦🇲🇨🇲🇩🇲🇪🇲🇫🇲🇬🇲🇭🇲🇰🇲🇱🇲🇲🇲🇳🇲🇴🇲🇵🇲🇶🇲🇷🇲🇸🇲🇹🇲🇺🇲🇻🇲🇼🇲🇽🇲🇾🇲🇿🇳🇦🇳🇨🇳🇪🇳🇫🇳🇬🇳🇮🇳🇱🇳🇴🇳🇵🇳🇷🇳🇺🇳🇿🇴🇲🇵🇦🇵🇪🇵🇫🇵🇬🇵🇭🇵🇰🇵🇱🇵🇲🇵🇳🇵🇷🇵🇸🇵🇹🇵🇼🇵🇾🇶🇦🇷🇪🇷🇴🇷🇸🇷🇺🇷🇼🇸🇦🇸🇧🇸🇨🇸🇩🇸🇪🇸🇬🇸🇭🇸🇮🇸🇯🇸🇰🇸🇱🇸🇲🇸🇳🇸🇴🇸🇷🇸🇸🇸🇹🇸🇻🇸🇽🇸🇾🇸🇿🇹🇦🇹🇨🇹🇩🇹🇫🇹🇬🇹🇭🇹🇯🇹🇰🇹🇱🇹🇲🇹🇳🇹🇴🇹🇷🇹🇹🇹🇻🇹🇼🇹🇿🇺🇦🇺🇬🇺🇲🇺🇳🇺🇸🇺🇾🇺🇿🇻🇦🇻🇨🇻🇪🇻🇬🇻🇮🇻🇳🇻🇺🇼🇫🇼🇸🇽🇰🇾🇪🇾🇹🇿🇦🇿🇲🇿🇼🏴󠁧󠁢󠁥󠁮󠁧󠁿🏴󠁧󠁢󠁳󠁣󠁴󠁿🏴󠁧󠁢󠁷󠁬󠁳󠁿\"\n  );\n  expect(() => emoji.parse(\":-)\")).toThrow();\n  expect(() => emoji.parse(\"😀 is an emoji\")).toThrow();\n  expect(() => emoji.parse(\"😀stuff\")).toThrow();\n  expect(() => emoji.parse(\"stuff😀\")).toThrow();\n});\n\ntest(\"uuid\", () => {\n  const uuid = z.string().uuid(\"custom error\");\n  uuid.parse(\"9491d710-3185-4e06-bea0-6a2f275345e0\");\n  uuid.parse(\"d89e7b01-7598-ed11-9d7a-0022489382fd\"); // new sequential id\n  uuid.parse(\"00000000-0000-0000-0000-000000000000\");\n  uuid.parse(\"b3ce60f8-e8b9-40f5-1150-172ede56ff74\"); // Variant 0 - RFC 4122: Reserved, NCS backward compatibility\n  uuid.parse(\"92e76bf9-28b3-4730-cd7f-cb6bc51f8c09\"); // Variant 2 - RFC 4122: Reserved, Microsoft Corporation backward compatibility\n  const result = uuid.safeParse(\"9491d710-3185-4e06-bea0-6a2f275345e0X\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"custom error\");\n  }\n});\n\ntest(\"bad uuid\", () => {\n  const uuid = z.string().uuid(\"custom error\");\n  uuid.parse(\"9491d710-3185-4e06-bea0-6a2f275345e0\");\n  const result = uuid.safeParse(\"invalid uuid\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"custom error\");\n  }\n});\n\ntest(\"nanoid\", () => {\n  const nanoid = z.string().nanoid(\"custom error\");\n  nanoid.parse(\"lfNZluvAxMkf7Q8C5H-QS\");\n  nanoid.parse(\"mIU_4PJWikaU8fMbmkouz\");\n  nanoid.parse(\"Hb9ZUtUa2JDm_dD-47EGv\");\n  nanoid.parse(\"5Noocgv_8vQ9oPijj4ioQ\");\n  const result = nanoid.safeParse(\"Xq90uDyhddC53KsoASYJGX\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"custom error\");\n  }\n});\n\ntest(\"bad nanoid\", () => {\n  const nanoid = z.string().nanoid(\"custom error\");\n  nanoid.parse(\"ySh_984wpDUu7IQRrLXAp\");\n  const result = nanoid.safeParse(\"invalid nanoid\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"custom error\");\n  }\n});\n\ntest(\"cuid\", () => {\n  const cuid = z.string().cuid();\n  cuid.parse(\"ckopqwooh000001la8mbi2im9\");\n  const result = cuid.safeParse(\"cifjhdsfhsd-invalid-cuid\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"Invalid cuid\");\n  }\n});\n\ntest(\"cuid2\", () => {\n  const cuid2 = z.string().cuid2();\n  const validStrings = [\n    \"a\", // short string\n    \"tz4a98xxat96iws9zmbrgj3a\", // normal string\n    \"kf5vz6ssxe4zjcb409rjgo747tc5qjazgptvotk6\", // longer than require(\"@paralleldrive/cuid2\").bigLength\n  ];\n  for (const s of validStrings) {\n    cuid2.parse(s);\n  }\n\n  const invalidStrings = [\n    \"\", // empty string\n    \"tz4a98xxat96iws9zMbrgj3a\", // include uppercase\n    \"tz4a98xxat96iws-zmbrgj3a\", // involve symbols\n  ];\n  const results = invalidStrings.map((s) => cuid2.safeParse(s));\n  expect(results.every((r) => !r.success)).toEqual(true);\n  if (!results[0].success) {\n    expect(results[0].error.issues[0].message).toEqual(\"Invalid cuid2\");\n  }\n});\n\ntest(\"ulid\", () => {\n  const ulid = z.string().ulid();\n  ulid.parse(\"01ARZ3NDEKTSV4RRFFQ69G5FAV\");\n  const result = ulid.safeParse(\"invalidulid\");\n  expect(result.success).toEqual(false);\n  const tooLong = \"01ARZ3NDEKTSV4RRFFQ69G5FAVA\";\n  expect(ulid.safeParse(tooLong).success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"Invalid ulid\");\n  }\n  const caseInsensitive = ulid.safeParse(\"01arZ3nDeKTsV4RRffQ69G5FAV\");\n  expect(caseInsensitive.success).toEqual(true);\n});\n\ntest(\"regex\", () => {\n  z.string()\n    .regex(/^moo+$/)\n    .parse(\"mooooo\");\n  expect(() => z.string().uuid().parse(\"purr\")).toThrow();\n});\n\ntest(\"regexp error message\", () => {\n  const result = z\n    .string()\n    .regex(/^moo+$/)\n    .safeParse(\"boooo\");\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"Invalid\");\n  } else {\n    throw new Error(\"validation should have failed\");\n  }\n\n  expect(() => z.string().uuid().parse(\"purr\")).toThrow();\n});\n\ntest(\"regex lastIndex reset\", () => {\n  const schema = z.string().regex(/^\\d+$/g);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n});\n\ntest(\"checks getters\", () => {\n  expect(z.string().email().isEmail).toEqual(true);\n  expect(z.string().email().isURL).toEqual(false);\n  expect(z.string().email().isCUID).toEqual(false);\n  expect(z.string().email().isCUID2).toEqual(false);\n  expect(z.string().email().isUUID).toEqual(false);\n  expect(z.string().email().isNANOID).toEqual(false);\n  expect(z.string().email().isIP).toEqual(false);\n  expect(z.string().email().isCIDR).toEqual(false);\n  expect(z.string().email().isULID).toEqual(false);\n\n  expect(z.string().url().isEmail).toEqual(false);\n  expect(z.string().url().isURL).toEqual(true);\n  expect(z.string().url().isCUID).toEqual(false);\n  expect(z.string().url().isCUID2).toEqual(false);\n  expect(z.string().url().isUUID).toEqual(false);\n  expect(z.string().url().isNANOID).toEqual(false);\n  expect(z.string().url().isIP).toEqual(false);\n  expect(z.string().url().isCIDR).toEqual(false);\n  expect(z.string().url().isULID).toEqual(false);\n\n  expect(z.string().cuid().isEmail).toEqual(false);\n  expect(z.string().cuid().isURL).toEqual(false);\n  expect(z.string().cuid().isCUID).toEqual(true);\n  expect(z.string().cuid().isCUID2).toEqual(false);\n  expect(z.string().cuid().isUUID).toEqual(false);\n  expect(z.string().cuid().isNANOID).toEqual(false);\n  expect(z.string().cuid().isIP).toEqual(false);\n  expect(z.string().cuid().isCIDR).toEqual(false);\n  expect(z.string().cuid().isULID).toEqual(false);\n\n  expect(z.string().cuid2().isEmail).toEqual(false);\n  expect(z.string().cuid2().isURL).toEqual(false);\n  expect(z.string().cuid2().isCUID).toEqual(false);\n  expect(z.string().cuid2().isCUID2).toEqual(true);\n  expect(z.string().cuid2().isUUID).toEqual(false);\n  expect(z.string().cuid2().isNANOID).toEqual(false);\n  expect(z.string().cuid2().isIP).toEqual(false);\n  expect(z.string().cuid2().isCIDR).toEqual(false);\n  expect(z.string().cuid2().isULID).toEqual(false);\n\n  expect(z.string().uuid().isEmail).toEqual(false);\n  expect(z.string().uuid().isURL).toEqual(false);\n  expect(z.string().uuid().isCUID).toEqual(false);\n  expect(z.string().uuid().isCUID2).toEqual(false);\n  expect(z.string().uuid().isUUID).toEqual(true);\n  expect(z.string().uuid().isNANOID).toEqual(false);\n  expect(z.string().uuid().isIP).toEqual(false);\n  expect(z.string().uuid().isCIDR).toEqual(false);\n  expect(z.string().uuid().isULID).toEqual(false);\n\n  expect(z.string().nanoid().isEmail).toEqual(false);\n  expect(z.string().nanoid().isURL).toEqual(false);\n  expect(z.string().nanoid().isCUID).toEqual(false);\n  expect(z.string().nanoid().isCUID2).toEqual(false);\n  expect(z.string().nanoid().isUUID).toEqual(false);\n  expect(z.string().nanoid().isNANOID).toEqual(true);\n  expect(z.string().nanoid().isIP).toEqual(false);\n  expect(z.string().nanoid().isCIDR).toEqual(false);\n  expect(z.string().nanoid().isULID).toEqual(false);\n\n  expect(z.string().ip().isEmail).toEqual(false);\n  expect(z.string().ip().isURL).toEqual(false);\n  expect(z.string().ip().isCUID).toEqual(false);\n  expect(z.string().ip().isCUID2).toEqual(false);\n  expect(z.string().ip().isUUID).toEqual(false);\n  expect(z.string().ip().isNANOID).toEqual(false);\n  expect(z.string().ip().isIP).toEqual(true);\n  expect(z.string().ip().isCIDR).toEqual(false);\n  expect(z.string().ip().isULID).toEqual(false);\n\n  expect(z.string().cidr().isEmail).toEqual(false);\n  expect(z.string().cidr().isURL).toEqual(false);\n  expect(z.string().cidr().isCUID).toEqual(false);\n  expect(z.string().cidr().isCUID2).toEqual(false);\n  expect(z.string().cidr().isUUID).toEqual(false);\n  expect(z.string().cidr().isNANOID).toEqual(false);\n  expect(z.string().cidr().isIP).toEqual(false);\n  expect(z.string().cidr().isCIDR).toEqual(true);\n  expect(z.string().cidr().isULID).toEqual(false);\n\n  expect(z.string().ulid().isEmail).toEqual(false);\n  expect(z.string().ulid().isURL).toEqual(false);\n  expect(z.string().ulid().isCUID).toEqual(false);\n  expect(z.string().ulid().isCUID2).toEqual(false);\n  expect(z.string().ulid().isUUID).toEqual(false);\n  expect(z.string().ulid().isNANOID).toEqual(false);\n  expect(z.string().ulid().isIP).toEqual(false);\n  expect(z.string().ulid().isCIDR).toEqual(false);\n  expect(z.string().ulid().isULID).toEqual(true);\n});\n\ntest(\"min max getters\", () => {\n  expect(z.string().min(5).minLength).toEqual(5);\n  expect(z.string().min(5).min(10).minLength).toEqual(10);\n  expect(z.string().minLength).toEqual(null);\n\n  expect(z.string().max(5).maxLength).toEqual(5);\n  expect(z.string().max(5).max(1).maxLength).toEqual(1);\n  expect(z.string().maxLength).toEqual(null);\n});\n\ntest(\"trim\", () => {\n  expect(z.string().trim().min(2).parse(\" 12 \")).toEqual(\"12\");\n\n  // ordering of methods is respected\n  expect(z.string().min(2).trim().parse(\" 1 \")).toEqual(\"1\");\n  expect(() => z.string().trim().min(2).parse(\" 1 \")).toThrow();\n});\n\ntest(\"lowerCase\", () => {\n  expect(z.string().toLowerCase().parse(\"ASDF\")).toEqual(\"asdf\");\n  expect(z.string().toUpperCase().parse(\"asdf\")).toEqual(\"ASDF\");\n});\n\ntest(\"datetime\", () => {\n  const a = z.string().datetime({});\n  expect(a.isDatetime).toEqual(true);\n\n  const b = z.string().datetime({ offset: true });\n  expect(b.isDatetime).toEqual(true);\n\n  const c = z.string().datetime({ precision: 3 });\n  expect(c.isDatetime).toEqual(true);\n\n  const d = z.string().datetime({ offset: true, precision: 0 });\n  expect(d.isDatetime).toEqual(true);\n\n  const { isDatetime } = z.string().datetime();\n  expect(isDatetime).toEqual(true);\n});\n\ntest(\"datetime parsing\", () => {\n  const datetime = z.string().datetime();\n  datetime.parse(\"1970-01-01T00:00:00.000Z\");\n  datetime.parse(\"2022-10-13T09:52:31.816Z\");\n  datetime.parse(\"2022-10-13T09:52:31.8162314Z\");\n  datetime.parse(\"1970-01-01T00:00:00Z\");\n  datetime.parse(\"2022-10-13T09:52:31Z\");\n  datetime.parse(\"2022-10-13T09:52Z\");\n  expect(() => datetime.parse(\"\")).toThrow();\n  expect(() => datetime.parse(\"foo\")).toThrow();\n  expect(() => datetime.parse(\"2020-10-14\")).toThrow();\n  expect(() => datetime.parse(\"T18:45:12.123\")).toThrow();\n  expect(() => datetime.parse(\"2020-10-14T17:42:29+00:00\")).toThrow();\n  expect(() => datetime.parse(\"2020-10-14T17:42.123+00:00\")).toThrow();\n\n  const datetimeNoMs = z.string().datetime({ precision: 0 });\n  datetimeNoMs.parse(\"1970-01-01T00:00:00Z\");\n  datetimeNoMs.parse(\"2022-10-13T09:52:31Z\");\n  datetimeNoMs.parse(\"2022-10-13T09:52Z\");\n  expect(() => datetimeNoMs.parse(\"tuna\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"1970-01-01T00:00:00.000Z\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"1970-01-01T00:00:00.Z\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"2022-10-13T09:52:31.816Z\")).toThrow();\n\n  const datetime3Ms = z.string().datetime({ precision: 3 });\n  datetime3Ms.parse(\"1970-01-01T00:00:00.000Z\");\n  datetime3Ms.parse(\"2022-10-13T09:52:31.123Z\");\n  expect(() => datetime3Ms.parse(\"tuna\")).toThrow();\n  expect(() => datetime3Ms.parse(\"1970-01-01T00:00:00.1Z\")).toThrow();\n  expect(() => datetime3Ms.parse(\"1970-01-01T00:00:00.12Z\")).toThrow();\n  expect(() => datetime3Ms.parse(\"2022-10-13T09:52:31Z\")).toThrow();\n  expect(() => datetime3Ms.parse(\"2022-10-13T09:52Z\")).toThrow();\n\n  const datetimeOffset = z.string().datetime({ offset: true });\n  datetimeOffset.parse(\"1970-01-01T00:00:00.000Z\");\n  datetimeOffset.parse(\"2022-10-13T09:52:31.816234134Z\");\n  datetimeOffset.parse(\"1970-01-01T00:00:00Z\");\n  datetimeOffset.parse(\"2022-10-13T09:52:31.4Z\");\n  datetimeOffset.parse(\"2020-10-14T17:42:29+00:00\");\n  datetimeOffset.parse(\"2020-10-14T17:42:29+03:15\");\n  datetimeOffset.parse(\"2020-10-14T17:42:29+0315\");\n  datetimeOffset.parse(\"2020-10-14T17:42+0315\");\n  expect(() => datetimeOffset.parse(\"2020-10-14T17:42:29+03\"));\n  expect(() => datetimeOffset.parse(\"tuna\")).toThrow();\n  expect(() => datetimeOffset.parse(\"2022-10-13T09:52:31.Z\")).toThrow();\n\n  const datetimeOffsetNoMs = z.string().datetime({ offset: true, precision: 0 });\n  datetimeOffsetNoMs.parse(\"1970-01-01T00:00:00Z\");\n  datetimeOffsetNoMs.parse(\"2022-10-13T09:52:31Z\");\n  datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29+00:00\");\n  datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29+0000\");\n  datetimeOffsetNoMs.parse(\"2020-10-14T17:42+0000\");\n  expect(() => datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29+00\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"tuna\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"1970-01-01T00:00:00.000Z\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"1970-01-01T00:00:00.Z\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"2022-10-13T09:52:31.816Z\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29.124+00:00\")).toThrow();\n\n  const datetimeOffset4Ms = z.string().datetime({ offset: true, precision: 4 });\n  datetimeOffset4Ms.parse(\"1970-01-01T00:00:00.1234Z\");\n  datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.1234+00:00\");\n  datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.1234+0000\");\n  expect(() => datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.1234+00\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"tuna\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"1970-01-01T00:00:00.123Z\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.124+00:00\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"2020-10-14T17:42+00:00\")).toThrow();\n});\n\ntest(\"date\", () => {\n  const a = z.string().date();\n  expect(a.isDate).toEqual(true);\n});\n\ntest(\"date parsing\", () => {\n  const date = z.string().date();\n  date.parse(\"1970-01-01\");\n  date.parse(\"2022-01-31\");\n  date.parse(\"2022-03-31\");\n  date.parse(\"2022-04-30\");\n  date.parse(\"2022-05-31\");\n  date.parse(\"2022-06-30\");\n  date.parse(\"2022-07-31\");\n  date.parse(\"2022-08-31\");\n  date.parse(\"2022-09-30\");\n  date.parse(\"2022-10-31\");\n  date.parse(\"2022-11-30\");\n  date.parse(\"2022-12-31\");\n\n  date.parse(\"2000-02-29\");\n  date.parse(\"2400-02-29\");\n  expect(() => date.parse(\"2022-02-29\")).toThrow();\n  expect(() => date.parse(\"2100-02-29\")).toThrow();\n  expect(() => date.parse(\"2200-02-29\")).toThrow();\n  expect(() => date.parse(\"2300-02-29\")).toThrow();\n  expect(() => date.parse(\"2500-02-29\")).toThrow();\n\n  expect(() => date.parse(\"\")).toThrow();\n  expect(() => date.parse(\"foo\")).toThrow();\n  expect(() => date.parse(\"200-01-01\")).toThrow();\n  expect(() => date.parse(\"20000-01-01\")).toThrow();\n  expect(() => date.parse(\"2000-0-01\")).toThrow();\n  expect(() => date.parse(\"2000-011-01\")).toThrow();\n  expect(() => date.parse(\"2000-01-0\")).toThrow();\n  expect(() => date.parse(\"2000-01-011\")).toThrow();\n  expect(() => date.parse(\"2000/01/01\")).toThrow();\n  expect(() => date.parse(\"01-01-2022\")).toThrow();\n  expect(() => date.parse(\"01/01/2022\")).toThrow();\n  expect(() => date.parse(\"2000-01-01 00:00:00Z\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29+00:00\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29Z\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29.123Z\")).toThrow();\n\n  expect(() => date.parse(\"2000-00-12\")).toThrow();\n  expect(() => date.parse(\"2000-12-00\")).toThrow();\n  expect(() => date.parse(\"2000-01-32\")).toThrow();\n  expect(() => date.parse(\"2000-13-01\")).toThrow();\n  expect(() => date.parse(\"2000-21-01\")).toThrow();\n\n  expect(() => date.parse(\"2000-02-30\")).toThrow();\n  expect(() => date.parse(\"2000-02-31\")).toThrow();\n  expect(() => date.parse(\"2000-04-31\")).toThrow();\n  expect(() => date.parse(\"2000-06-31\")).toThrow();\n  expect(() => date.parse(\"2000-09-31\")).toThrow();\n  expect(() => date.parse(\"2000-11-31\")).toThrow();\n});\n\ntest(\"time\", () => {\n  const a = z.string().time();\n  expect(a.isTime).toEqual(true);\n});\n\ntest(\"time parsing\", () => {\n  const time = z.string().time();\n  time.parse(\"00:00:00\");\n  time.parse(\"23:00:00\");\n  time.parse(\"00:59:00\");\n  time.parse(\"00:00:59\");\n  time.parse(\"23:59:59\");\n  time.parse(\"09:52:31\");\n  time.parse(\"23:59:59.9999999\");\n  time.parse(\"23:59\");\n  expect(() => time.parse(\"\")).toThrow();\n  expect(() => time.parse(\"foo\")).toThrow();\n  expect(() => time.parse(\"00:00:00Z\")).toThrow();\n  expect(() => time.parse(\"0:00:00\")).toThrow();\n  expect(() => time.parse(\"00:0:00\")).toThrow();\n  expect(() => time.parse(\"00:00:0\")).toThrow();\n  expect(() => time.parse(\"00:00:00.000+00:00\")).toThrow();\n\n  expect(() => time.parse(\"24:00:00\")).toThrow();\n  expect(() => time.parse(\"00:60:00\")).toThrow();\n  expect(() => time.parse(\"00:00:60\")).toThrow();\n  expect(() => time.parse(\"24:60:60\")).toThrow();\n  expect(() => time.parse(\"24:60\")).toThrow();\n\n  const time2 = z.string().time({ precision: 2 });\n  time2.parse(\"00:00:00.00\");\n  time2.parse(\"09:52:31.12\");\n  time2.parse(\"23:59:59.99\");\n  expect(() => time2.parse(\"\")).toThrow();\n  expect(() => time2.parse(\"foo\")).toThrow();\n  expect(() => time2.parse(\"00:00:00\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.00Z\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.0\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.000\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.00+00:00\")).toThrow();\n  expect(() => time2.parse(\"23:59\")).toThrow();\n\n  // const time3 = z.string().time({ offset: true });\n  // time3.parse(\"00:00:00Z\");\n  // time3.parse(\"09:52:31Z\");\n  // time3.parse(\"00:00:00+00:00\");\n  // time3.parse(\"00:00:00+0000\");\n  // time3.parse(\"00:00:00.000Z\");\n  // time3.parse(\"00:00:00.000+00:00\");\n  // time3.parse(\"00:00:00.000+0000\");\n  // expect(() => time3.parse(\"\")).toThrow();\n  // expect(() => time3.parse(\"foo\")).toThrow();\n  // expect(() => time3.parse(\"00:00:00\")).toThrow();\n  // expect(() => time3.parse(\"00:00:00.000\")).toThrow();\n\n  // const time4 = z.string().time({ offset: true, precision: 0 });\n  // time4.parse(\"00:00:00Z\");\n  // time4.parse(\"09:52:31Z\");\n  // time4.parse(\"00:00:00+00:00\");\n  // time4.parse(\"00:00:00+0000\");\n  // expect(() => time4.parse(\"\")).toThrow();\n  // expect(() => time4.parse(\"foo\")).toThrow();\n  // expect(() => time4.parse(\"00:00:00.0\")).toThrow();\n  // expect(() => time4.parse(\"00:00:00.000\")).toThrow();\n  // expect(() => time4.parse(\"00:00:00.000+00:00\")).toThrow();\n});\n\ntest(\"duration\", () => {\n  const duration = z.string().duration();\n  expect(duration.isDuration).toEqual(true);\n\n  const validDurations = [\n    \"P3Y6M4DT12H30M5S\",\n    \"P2Y9M3DT12H31M8.001S\",\n    \"+P3Y6M4DT12H30M5S\",\n    \"-PT0.001S\",\n    \"+PT0.001S\",\n    \"PT0,001S\",\n    \"PT12H30M5S\",\n    \"-P2M1D\",\n    \"P-2M-1D\",\n    \"-P5DT10H\",\n    \"P-5DT-10H\",\n    \"P1Y\",\n    \"P2MT30M\",\n    \"PT6H\",\n    \"P5W\",\n    \"P0.5Y\",\n    \"P0,5Y\",\n    \"P42YT7.004M\",\n  ];\n\n  const invalidDurations = [\"foo bar\", \"\", \" \", \"P\", \"T1H\", \"P0.5Y1D\", \"P0,5Y6M\", \"P1YT\"];\n\n  for (const val of validDurations) {\n    const result = duration.safeParse(val);\n    if (!result.success) {\n      throw Error(`Valid duration could not be parsed: ${val}`);\n    }\n  }\n\n  for (const val of invalidDurations) {\n    const result = duration.safeParse(val);\n\n    if (result.success) {\n      throw Error(`Invalid duration was successful parsed: ${val}`);\n    }\n\n    expect(result.error.issues[0].message).toEqual(\"Invalid duration\");\n  }\n});\n\ntest(\"IP validation\", () => {\n  const ip = z.string().ip();\n  expect(ip.safeParse(\"122.122.122.122\").success).toBe(true);\n\n  const ipv4 = z.string().ip({ version: \"v4\" });\n  expect(() => ipv4.parse(\"6097:adfa:6f0b:220d:db08:5021:6191:7990\")).toThrow();\n\n  const ipv6 = z.string().ip({ version: \"v6\" });\n  expect(() => ipv6.parse(\"254.164.77.1\")).toThrow();\n\n  const validIPs = [\n    \"1e5e:e6c8:daac:514b:114b:e360:d8c0:682c\",\n    \"9d4:c956:420f:5788:4339:9b3b:2418:75c3\",\n    \"474f:4c83::4e40:a47:ff95:0cda\",\n    \"d329:0:25b4:db47:a9d1:0:4926:0000\",\n    \"e48:10fb:1499:3e28:e4b6:dea5:4692:912c\",\n    \"114.71.82.94\",\n    \"0.0.0.0\",\n    \"37.85.236.115\",\n    \"2001:4888:50:ff00:500:d::\",\n    \"2001:4888:50:ff00:0500:000d:000:0000\",\n    \"2001:4888:50:ff00:0500:000d:0000:0000\",\n  ];\n\n  const invalidIPs = [\n    \"d329:1be4:25b4:db47:a9d1:dc71:4926:992c:14af\",\n    \"d5e7:7214:2b78::3906:85e6:53cc:709:32ba\",\n    \"8f69::c757:395e:976e::3441\",\n    \"54cb::473f:d516:0.255.256.22\",\n    \"54cb::473f:d516:192.168.1\",\n    \"256.0.4.4\",\n    \"-1.0.555.4\",\n    \"0.0.0.0.0\",\n    \"1.1.1\",\n  ];\n  // no parameters check IPv4 or IPv6\n  const ipSchema = z.string().ip();\n  expect(validIPs.every((ip) => ipSchema.safeParse(ip).success)).toBe(true);\n  expect(invalidIPs.every((ip) => ipSchema.safeParse(ip).success === false)).toBe(true);\n});\n\ntest(\"CIDR validation\", () => {\n  const ipv4Cidr = z.string().cidr({ version: \"v4\" });\n  expect(() => ipv4Cidr.parse(\"2001:0db8:85a3::8a2e:0370:7334/64\")).toThrow();\n\n  const ipv6Cidr = z.string().cidr({ version: \"v6\" });\n  expect(() => ipv6Cidr.parse(\"192.168.0.1/24\")).toThrow();\n\n  const validCidrs = [\n    \"192.168.0.0/24\",\n    \"10.0.0.0/8\",\n    \"203.0.113.0/24\",\n    \"192.0.2.0/24\",\n    \"127.0.0.0/8\",\n    \"172.16.0.0/12\",\n    \"192.168.1.0/24\",\n    \"fc00::/7\",\n    \"fd00::/8\",\n    \"2001:db8::/32\",\n    \"2607:f0d0:1002:51::4/64\",\n    \"2001:0db8:85a3:0000:0000:8a2e:0370:7334/128\",\n    \"2001:0db8:1234:0000::/64\",\n  ];\n\n  const invalidCidrs = [\n    \"192.168.1.1/33\",\n    \"10.0.0.1/-1\",\n    \"192.168.1.1/24/24\",\n    \"192.168.1.0/abc\",\n    \"2001:db8::1/129\",\n    \"2001:db8::1/-1\",\n    \"2001:db8::1/64/64\",\n    \"2001:db8::1/abc\",\n  ];\n\n  // no parameters check IPv4 or IPv6\n  const cidrSchema = z.string().cidr();\n  expect(validCidrs.every((ip) => cidrSchema.safeParse(ip).success)).toBe(true);\n  expect(invalidCidrs.every((ip) => cidrSchema.safeParse(ip).success === false)).toBe(true);\n});\n",
    "symbols": [
      {
        "name": "makeJwt",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v3/tests/string.test.ts",
        "startLine": 250,
        "endLine": 255
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/transformer.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\n\nconst stringToNumber = z.string().transform((arg) => Number.parseFloat(arg));\n// const numberToString = z\n//   .transformer(z.number())\n//   .transform((n) => String(n));\nconst asyncNumberToString = z.number().transform(async (n) => String(n));\n\ntest(\"transform ctx.addIssue with parse\", () => {\n  const strs = [\"foo\", \"bar\"];\n\n  expect(() => {\n    z.string()\n      .transform((data, ctx) => {\n        const i = strs.indexOf(data);\n        if (i === -1) {\n          ctx.addIssue({\n            code: \"custom\",\n            message: `${data} is not one of our allowed strings`,\n          });\n        }\n        return data.length;\n      })\n      .parse(\"asdf\");\n  }).toThrow(\n    JSON.stringify(\n      [\n        {\n          code: \"custom\",\n          message: \"asdf is not one of our allowed strings\",\n          path: [],\n        },\n      ],\n      null,\n      2\n    )\n  );\n});\n\ntest(\"transform ctx.addIssue with parseAsync\", async () => {\n  const strs = [\"foo\", \"bar\"];\n\n  const result = await z\n    .string()\n    .transform(async (data, ctx) => {\n      const i = strs.indexOf(data);\n      if (i === -1) {\n        ctx.addIssue({\n          code: \"custom\",\n          message: `${data} is not one of our allowed strings`,\n        });\n      }\n      return data.length;\n    })\n    .safeParseAsync(\"asdf\");\n\n  expect(JSON.parse(JSON.stringify(result))).toEqual({\n    success: false,\n    error: {\n      issues: [\n        {\n          code: \"custom\",\n          message: \"asdf is not one of our allowed strings\",\n          path: [],\n        },\n      ],\n      name: \"ZodError\",\n    },\n  });\n});\n\ntest(\"z.NEVER in transform\", () => {\n  const foo = z\n    .number()\n    .optional()\n    .transform((val, ctx) => {\n      if (!val) {\n        ctx.addIssue({ code: z.ZodIssueCode.custom, message: \"bad\" });\n        return z.NEVER;\n      }\n      return val;\n    });\n  type foo = z.infer<typeof foo>;\n  util.assertEqual<foo, number>(true);\n  const arg = foo.safeParse(undefined);\n  if (!arg.success) {\n    expect(arg.error.issues[0].message).toEqual(\"bad\");\n  }\n});\n\ntest(\"basic transformations\", () => {\n  const r1 = z\n    .string()\n    .transform((data) => data.length)\n    .parse(\"asdf\");\n  expect(r1).toEqual(4);\n});\n\ntest(\"coercion\", () => {\n  const numToString = z.number().transform((n) => String(n));\n  const data = z\n    .object({\n      id: numToString,\n    })\n    .parse({ id: 5 });\n\n  expect(data).toEqual({ id: \"5\" });\n});\n\ntest(\"async coercion\", async () => {\n  const numToString = z.number().transform(async (n) => String(n));\n  const data = await z\n    .object({\n      id: numToString,\n    })\n    .parseAsync({ id: 5 });\n\n  expect(data).toEqual({ id: \"5\" });\n});\n\ntest(\"sync coercion async error\", async () => {\n  expect(() =>\n    z\n      .object({\n        id: asyncNumberToString,\n      })\n      .parse({ id: 5 })\n  ).toThrow();\n  // expect(data).toEqual({ id: '5' });\n});\n\ntest(\"default\", () => {\n  const data = z.string().default(\"asdf\").parse(undefined); // => \"asdf\"\n  expect(data).toEqual(\"asdf\");\n});\n\ntest(\"dynamic default\", () => {\n  const data = z\n    .string()\n    .default(() => \"string\")\n    .parse(undefined); // => \"asdf\"\n  expect(data).toEqual(\"string\");\n});\n\ntest(\"default when property is null or undefined\", () => {\n  const data = z\n    .object({\n      foo: z.boolean().nullable().default(true),\n      bar: z.boolean().default(true),\n    })\n    .parse({ foo: null });\n\n  expect(data).toEqual({ foo: null, bar: true });\n});\n\ntest(\"default with falsy values\", () => {\n  const schema = z.object({\n    emptyStr: z.string().default(\"def\"),\n    zero: z.number().default(5),\n    falseBoolean: z.boolean().default(true),\n  });\n  const input = { emptyStr: \"\", zero: 0, falseBoolean: true };\n  const output = schema.parse(input);\n  // defaults are not supposed to be used\n  expect(output).toEqual(input);\n});\n\ntest(\"object typing\", () => {\n  const t1 = z.object({\n    stringToNumber,\n  });\n\n  type t1 = z.input<typeof t1>;\n  type t2 = z.output<typeof t1>;\n\n  util.assertEqual<t1, { stringToNumber: string }>(true);\n  util.assertEqual<t2, { stringToNumber: number }>(true);\n});\n\ntest(\"transform method overloads\", () => {\n  const t1 = z.string().transform((val) => val.toUpperCase());\n  expect(t1.parse(\"asdf\")).toEqual(\"ASDF\");\n\n  const t2 = z.string().transform((val) => val.length);\n  expect(t2.parse(\"asdf\")).toEqual(4);\n});\n\ntest(\"multiple transformers\", () => {\n  const doubler = stringToNumber.transform((val) => {\n    return val * 2;\n  });\n  expect(doubler.parse(\"5\")).toEqual(10);\n});\n\ntest(\"short circuit on dirty\", () => {\n  const schema = z\n    .string()\n    .refine(() => false)\n    .transform((val) => val.toUpperCase());\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);\n  }\n\n  const result2 = schema.safeParse(1234);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);\n  }\n});\n\ntest(\"async short circuit on dirty\", async () => {\n  const schema = z\n    .string()\n    .refine(() => false)\n    .transform((val) => val.toUpperCase());\n  const result = await schema.spa(\"asdf\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);\n  }\n\n  const result2 = await schema.spa(1234);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/tuple.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { ZodError } from \"../ZodError.js\";\nimport { util } from \"../helpers/util.js\";\n\nconst testTuple = z.tuple([z.string(), z.object({ name: z.literal(\"Rudy\") }), z.array(z.literal(\"blue\"))]);\nconst testData = [\"asdf\", { name: \"Rudy\" }, [\"blue\"]];\nconst badData = [123, { name: \"Rudy2\" }, [\"blue\", \"red\"]];\n\ntest(\"tuple inference\", () => {\n  const args1 = z.tuple([z.string()]);\n  const returns1 = z.number();\n  const func1 = z.function(args1, returns1);\n  type func1 = z.TypeOf<typeof func1>;\n  util.assertEqual<func1, (k: string) => number>(true);\n});\n\ntest(\"successful validation\", () => {\n  const val = testTuple.parse(testData);\n  expect(val).toEqual([\"asdf\", { name: \"Rudy\" }, [\"blue\"]]);\n});\n\ntest(\"successful async validation\", async () => {\n  const val = await testTuple.parseAsync(testData);\n  return expect(val).toEqual(testData);\n});\n\ntest(\"failed validation\", () => {\n  const checker = () => {\n    testTuple.parse([123, { name: \"Rudy2\" }, [\"blue\", \"red\"]] as any);\n  };\n  try {\n    checker();\n  } catch (err) {\n    if (err instanceof ZodError) {\n      expect(err.issues.length).toEqual(3);\n    }\n  }\n});\n\ntest(\"failed async validation\", async () => {\n  const res = await testTuple.safeParse(badData);\n  expect(res.success).toEqual(false);\n  if (!res.success) {\n    expect(res.error.issues.length).toEqual(3);\n  }\n  // try {\n  //   checker();\n  // } catch (err) {\n  //   if (err instanceof ZodError) {\n  //     expect(err.issues.length).toEqual(3);\n  //   }\n  // }\n});\n\ntest(\"tuple with transformers\", () => {\n  const stringToNumber = z.string().transform((val) => val.length);\n  const val = z.tuple([stringToNumber]);\n\n  type t1 = z.input<typeof val>;\n  util.assertEqual<t1, [string]>(true);\n  type t2 = z.output<typeof val>;\n  util.assertEqual<t2, [number]>(true);\n  expect(val.parse([\"1234\"])).toEqual([4]);\n});\n\ntest(\"tuple with rest schema\", () => {\n  const myTuple = z.tuple([z.string(), z.number()]).rest(z.boolean());\n  expect(myTuple.parse([\"asdf\", 1234, true, false, true])).toEqual([\"asdf\", 1234, true, false, true]);\n\n  expect(myTuple.parse([\"asdf\", 1234])).toEqual([\"asdf\", 1234]);\n\n  expect(() => myTuple.parse([\"asdf\", 1234, \"asdf\"])).toThrow();\n  type t1 = z.output<typeof myTuple>;\n\n  util.assertEqual<t1, [string, number, ...boolean[]]>(true);\n});\n\ntest(\"parse should fail given sparse array as tuple\", () => {\n  expect(() => testTuple.parse(new Array(3))).toThrow();\n});\n\n// test('tuple with optional elements', () => {\n//   const result = z\n//     .tuple([z.string(), z.number().optional()])\n//     .safeParse(['asdf']);\n//   expect(result).toEqual(['asdf']);\n// });\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/unions.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"function parsing\", () => {\n  const schema = z.union([z.string().refine(() => false), z.number().refine(() => false)]);\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n});\n\ntest(\"union 2\", () => {\n  const result = z.union([z.number(), z.string().refine(() => false)]).safeParse(\"a\");\n  expect(result.success).toEqual(false);\n});\n\ntest(\"return valid over invalid\", () => {\n  const schema = z.union([\n    z.object({\n      email: z.string().email(),\n    }),\n    z.string(),\n  ]);\n  expect(schema.parse(\"asdf\")).toEqual(\"asdf\");\n  expect(schema.parse({ email: \"asdlkjf@lkajsdf.com\" })).toEqual({\n    email: \"asdlkjf@lkajsdf.com\",\n  });\n});\n\ntest(\"return dirty result over aborted\", () => {\n  const result = z.union([z.number(), z.string().refine(() => false)]).safeParse(\"a\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues).toEqual([\n      {\n        code: \"custom\",\n        message: \"Invalid input\",\n        path: [],\n      },\n    ]);\n  }\n});\n\ntest(\"options getter\", async () => {\n  const union = z.union([z.string(), z.number()]);\n  union.options[0].parse(\"asdf\");\n  union.options[1].parse(1234);\n  await union.options[0].parseAsync(\"asdf\");\n  await union.options[1].parseAsync(1234);\n});\n\ntest(\"readonly union\", async () => {\n  const options = [z.string(), z.number()] as const;\n  const union = z.union(options);\n  union.parse(\"asdf\");\n  union.parse(12);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/validations.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\n\ntest(\"array min\", async () => {\n  try {\n    await z.array(z.string()).min(4).parseAsync([]);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Array must contain at least 4 element(s)\");\n  }\n});\n\ntest(\"array max\", async () => {\n  try {\n    await z.array(z.string()).max(2).parseAsync([\"asdf\", \"asdf\", \"asdf\"]);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Array must contain at most 2 element(s)\");\n  }\n});\n\ntest(\"array length\", async () => {\n  try {\n    await z.array(z.string()).length(2).parseAsync([\"asdf\", \"asdf\", \"asdf\"]);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Array must contain exactly 2 element(s)\");\n  }\n\n  try {\n    await z.array(z.string()).length(2).parseAsync([\"asdf\"]);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Array must contain exactly 2 element(s)\");\n  }\n});\n\ntest(\"string length\", async () => {\n  try {\n    await z.string().length(4).parseAsync(\"asd\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"String must contain exactly 4 character(s)\");\n  }\n\n  try {\n    await z.string().length(4).parseAsync(\"asdaa\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"String must contain exactly 4 character(s)\");\n  }\n});\n\ntest(\"string min\", async () => {\n  try {\n    await z.string().min(4).parseAsync(\"asd\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"String must contain at least 4 character(s)\");\n  }\n});\n\ntest(\"string max\", async () => {\n  try {\n    await z.string().max(4).parseAsync(\"aasdfsdfsd\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"String must contain at most 4 character(s)\");\n  }\n});\n\ntest(\"number min\", async () => {\n  try {\n    await z.number().gte(3).parseAsync(2);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Number must be greater than or equal to 3\");\n  }\n});\n\ntest(\"number max\", async () => {\n  try {\n    await z.number().lte(3).parseAsync(4);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Number must be less than or equal to 3\");\n  }\n});\n\ntest(\"number nonnegative\", async () => {\n  try {\n    await z.number().nonnegative().parseAsync(-1);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Number must be greater than or equal to 0\");\n  }\n});\n\ntest(\"number nonpositive\", async () => {\n  try {\n    await z.number().nonpositive().parseAsync(1);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Number must be less than or equal to 0\");\n  }\n});\n\ntest(\"number negative\", async () => {\n  try {\n    await z.number().negative().parseAsync(1);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Number must be less than 0\");\n  }\n});\n\ntest(\"number positive\", async () => {\n  try {\n    await z.number().positive().parseAsync(-1);\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Number must be greater than 0\");\n  }\n});\n\ntest(\"instantiation\", () => {\n  z.string().min(5);\n  z.string().max(5);\n  z.string().length(5);\n  z.string().email();\n  z.string().url();\n  z.string().uuid();\n  z.string().min(5, { message: \"Must be 5 or more characters long\" });\n  z.string().max(5, { message: \"Must be 5 or fewer characters long\" });\n  z.string().length(5, { message: \"Must be exactly 5 characters long\" });\n  z.string().email({ message: \"Invalid email address.\" });\n  z.string().url({ message: \"Invalid url\" });\n  z.string().uuid({ message: \"Invalid UUID\" });\n});\n\ntest(\"int\", async () => {\n  const int = z.number().int();\n  int.parse(4);\n  expect(() => int.parse(3.5)).toThrow();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v3/tests/void.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v3\";\nimport { util } from \"../helpers/util.js\";\ntest(\"void\", () => {\n  const v = z.void();\n  v.parse(undefined);\n\n  expect(() => v.parse(null)).toThrow();\n  expect(() => v.parse(\"\")).toThrow();\n\n  type v = z.infer<typeof v>;\n  util.assertEqual<v, void>(true);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/checks.ts",
    "content": "export {\n  _lt as lt,\n  _lte as lte,\n  _gt as gt,\n  _gte as gte,\n  _positive as positive,\n  _negative as negative,\n  _nonpositive as nonpositive,\n  _nonnegative as nonnegative,\n  _multipleOf as multipleOf,\n  _maxSize as maxSize,\n  _minSize as minSize,\n  _size as size,\n  _maxLength as maxLength,\n  _minLength as minLength,\n  _length as length,\n  _regex as regex,\n  _lowercase as lowercase,\n  _uppercase as uppercase,\n  _includes as includes,\n  _startsWith as startsWith,\n  _endsWith as endsWith,\n  _property as property,\n  _mime as mime,\n  _overwrite as overwrite,\n  _normalize as normalize,\n  _trim as trim,\n  _toLowerCase as toLowerCase,\n  _toUpperCase as toUpperCase,\n} from \"../core/index.js\";\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts",
    "content": "import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\n\nexport interface ZodCoercedString<T = unknown> extends schemas._ZodString<core.$ZodStringInternals<T>> {}\nexport function string<T = unknown>(params?: string | core.$ZodStringParams): ZodCoercedString<T> {\n  return core._coercedString(schemas.ZodString, params) as any;\n}\n\nexport interface ZodCoercedNumber<T = unknown> extends schemas._ZodNumber<core.$ZodNumberInternals<T>> {}\nexport function number<T = unknown>(params?: string | core.$ZodNumberParams): ZodCoercedNumber<T> {\n  return core._coercedNumber(schemas.ZodNumber, params) as ZodCoercedNumber<T>;\n}\n\nexport interface ZodCoercedBoolean<T = unknown> extends schemas._ZodBoolean<core.$ZodBooleanInternals<T>> {}\nexport function boolean<T = unknown>(params?: string | core.$ZodBooleanParams): ZodCoercedBoolean<T> {\n  return core._coercedBoolean(schemas.ZodBoolean, params) as ZodCoercedBoolean<T>;\n}\n\nexport interface ZodCoercedBigInt<T = unknown> extends schemas._ZodBigInt<core.$ZodBigIntInternals<T>> {}\nexport function bigint<T = unknown>(params?: string | core.$ZodBigIntParams): ZodCoercedBigInt<T> {\n  return core._coercedBigint(schemas.ZodBigInt, params) as ZodCoercedBigInt<T>;\n}\n\nexport interface ZodCoercedDate<T = unknown> extends schemas._ZodDate<core.$ZodDateInternals<T>> {}\nexport function date<T = unknown>(params?: string | core.$ZodDateParams): ZodCoercedDate<T> {\n  return core._coercedDate(schemas.ZodDate, params) as ZodCoercedDate<T>;\n}\n",
    "symbols": [
      {
        "name": "string",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts",
        "startLine": 5,
        "endLine": 7
      },
      {
        "name": "number",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts",
        "startLine": 10,
        "endLine": 12
      },
      {
        "name": "boolean",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts",
        "startLine": 15,
        "endLine": 17
      },
      {
        "name": "bigint",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts",
        "startLine": 20,
        "endLine": 22
      },
      {
        "name": "date",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/coerce.ts",
        "startLine": 25,
        "endLine": 27
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/compat.ts",
    "content": "// Zod 3 compat layer\n\nimport * as core from \"../core/index.js\";\nimport type { ZodType } from \"./schemas.js\";\n\nexport type {\n  /** @deprecated Use `z.output<T>` instead. */\n  output as TypeOf,\n  /** @deprecated Use `z.output<T>` instead. */\n  output as Infer,\n  /** @deprecated Use `z.core.$$ZodFirstPartyTypes` instead */\n  $ZodTypes as ZodFirstPartySchemaTypes,\n} from \"../core/index.js\";\n\n/** @deprecated Use the raw string literal codes instead, e.g. \"invalid_type\". */\nexport const ZodIssueCode = {\n  invalid_type: \"invalid_type\",\n  too_big: \"too_big\",\n  too_small: \"too_small\",\n  invalid_format: \"invalid_format\",\n  not_multiple_of: \"not_multiple_of\",\n  unrecognized_keys: \"unrecognized_keys\",\n  invalid_union: \"invalid_union\",\n  invalid_key: \"invalid_key\",\n  invalid_element: \"invalid_element\",\n  invalid_value: \"invalid_value\",\n  custom: \"custom\",\n} as const;\n\n/** @deprecated Use `z.$ZodFlattenedError` */\nexport type inferFlattenedErrors<T extends core.$ZodType, U = string> = core.$ZodFlattenedError<core.output<T>, U>;\n\n/** @deprecated Use `z.$ZodFormattedError` */\nexport type inferFormattedError<T extends core.$ZodType<any, any>, U = string> = core.$ZodFormattedError<\n  core.output<T>,\n  U\n>;\n\n/** Use `z.$brand` instead */\nexport type BRAND<T extends string | number | symbol = string | number | symbol> = {\n  [core.$brand]: { [k in T]: true };\n};\nexport { $brand, config } from \"../core/index.js\";\n\n/** @deprecated Use `z.config(params)` instead. */\nexport function setErrorMap(map: core.$ZodErrorMap): void {\n  core.config({\n    customError: map,\n  });\n}\n\n/** @deprecated Use `z.config()` instead. */\nexport function getErrorMap(): core.$ZodErrorMap<core.$ZodIssue> | undefined {\n  return core.config().customError;\n}\n\nexport type {\n  /** @deprecated Use z.ZodType (without generics) instead. */\n  ZodType as ZodTypeAny,\n  /** @deprecated Use `z.ZodType` */\n  ZodType as ZodSchema,\n  /** @deprecated Use `z.ZodType` */\n  ZodType as Schema,\n};\n\nexport type ZodRawShape = core.$ZodShape;\n",
    "symbols": [
      {
        "name": "setErrorMap",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/compat.ts",
        "startLine": 46,
        "endLine": 50
      },
      {
        "name": "getErrorMap",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/compat.ts",
        "startLine": 53,
        "endLine": 55
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/errors.ts",
    "content": "import * as core from \"../core/index.js\";\nimport { $ZodError } from \"../core/index.js\";\n\n/** @deprecated Use `z.core.$ZodIssue` from `@zod/core` instead, especially if you are building a library on top of Zod. */\nexport type ZodIssue = core.$ZodIssue;\n\n/** An Error-like class used to store Zod validation issues.  */\nexport interface ZodError<T = unknown> extends $ZodError<T> {\n  /** @deprecated Use the `z.treeifyError(err)` function instead. */\n  format(): core.$ZodFormattedError<T>;\n  format<U>(mapper: (issue: core.$ZodIssue) => U): core.$ZodFormattedError<T, U>;\n  /** @deprecated Use the `z.treeifyError(err)` function instead. */\n  flatten(): core.$ZodFlattenedError<T>;\n  flatten<U>(mapper: (issue: core.$ZodIssue) => U): core.$ZodFlattenedError<T, U>;\n  /** @deprecated Push directly to `.issues` instead. */\n  addIssue(issue: core.$ZodIssue): void;\n  /** @deprecated Push directly to `.issues` instead. */\n  addIssues(issues: core.$ZodIssue[]): void;\n\n  /** @deprecated Check `err.issues.length === 0` instead. */\n  isEmpty: boolean;\n}\n\nconst initializer = (inst: ZodError, issues: core.$ZodIssue[]) => {\n  $ZodError.init(inst, issues);\n  inst.name = \"ZodError\";\n  Object.defineProperties(inst, {\n    format: {\n      value: (mapper: any) => core.formatError(inst, mapper),\n      // enumerable: false,\n    },\n    flatten: {\n      value: (mapper: any) => core.flattenError(inst, mapper),\n      // enumerable: false,\n    },\n    addIssue: {\n      value: (issue: any) => inst.issues.push(issue),\n      // enumerable: false,\n    },\n    addIssues: {\n      value: (issues: any) => inst.issues.push(...issues),\n      // enumerable: false,\n    },\n    isEmpty: {\n      get() {\n        return inst.issues.length === 0;\n      },\n      // enumerable: false,\n    },\n  });\n  // Object.defineProperty(inst, \"isEmpty\", {\n  //   get() {\n  //     return inst.issues.length === 0;\n  //   },\n  // });\n};\nexport const ZodError: core.$constructor<ZodError> = core.$constructor(\"ZodError\", initializer);\nexport const ZodRealError: core.$constructor<ZodError> = core.$constructor(\"ZodError\", initializer, {\n  Parent: Error,\n});\n\nexport type {\n  /** @deprecated Use `z.core.$ZodFlattenedError` instead. */\n  $ZodFlattenedError as ZodFlattenedError,\n  /** @deprecated Use `z.core.$ZodFormattedError` instead. */\n  $ZodFormattedError as ZodFormattedError,\n  /** @deprecated Use `z.core.$ZodErrorMap` instead. */\n  $ZodErrorMap as ZodErrorMap,\n} from \"../core/index.js\";\n\n/** @deprecated Use `z.core.$ZodRawIssue` instead. */\nexport type IssueData = core.$ZodRawIssue;\n\n// /** @deprecated Use `z.core.$ZodErrorMapCtx` instead. */\n// export type ErrorMapCtx = core.$ZodErrorMapCtx;\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/external.ts",
    "content": "export * as core from \"../core/index.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\nexport * from \"./errors.js\";\nexport * from \"./parse.js\";\nexport * from \"./compat.js\";\n\n// zod-specified\nimport { config } from \"../core/index.js\";\nimport en from \"../locales/en.js\";\nconfig(en());\n\nexport type { infer, output, input } from \"../core/index.js\";\nexport {\n  globalRegistry,\n  type GlobalMeta,\n  registry,\n  config,\n  function,\n  $output,\n  $input,\n  $brand,\n  clone,\n  regexes,\n  treeifyError,\n  prettifyError,\n  formatError,\n  flattenError,\n  toJSONSchema,\n  TimePrecision,\n  NEVER,\n} from \"../core/index.js\";\n\nexport * as locales from \"../locales/index.js\";\n\n// iso\n// must be exported from top-level\n// https://github.com/colinhacks/zod/issues/4491\nexport { ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration } from \"./iso.js\";\nexport * as iso from \"./iso.js\";\n\n// coerce\nexport type {\n  ZodCoercedString,\n  ZodCoercedNumber,\n  ZodCoercedBigInt,\n  ZodCoercedBoolean,\n  ZodCoercedDate,\n} from \"./coerce.js\";\nexport * as coerce from \"./coerce.js\";\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/index.ts",
    "content": "import * as z from \"./external.js\";\n\nexport { z };\nexport * from \"./external.js\";\nexport default z;\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/iso.ts",
    "content": "import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\n\n//////////////////////////////////////////////\n//////////////////////////////////////////////\n//////////                          //////////\n//////////      ZodISODateTime      //////////\n//////////                          //////////\n//////////////////////////////////////////////\n//////////////////////////////////////////////\n\nexport interface ZodISODateTime extends schemas.ZodStringFormat {\n  _zod: core.$ZodISODateTimeInternals;\n}\nexport const ZodISODateTime: core.$constructor<ZodISODateTime> = /*@__PURE__*/ core.$constructor(\n  \"ZodISODateTime\",\n  (inst, def) => {\n    core.$ZodISODateTime.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n  }\n);\n\nexport function datetime(params?: string | core.$ZodISODateTimeParams): ZodISODateTime {\n  return core._isoDateTime(ZodISODateTime, params);\n}\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      ZodISODate      //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n\nexport interface ZodISODate extends schemas.ZodStringFormat {\n  _zod: core.$ZodISODateInternals;\n}\nexport const ZodISODate: core.$constructor<ZodISODate> = /*@__PURE__*/ core.$constructor(\"ZodISODate\", (inst, def) => {\n  core.$ZodISODate.init(inst, def);\n  schemas.ZodStringFormat.init(inst, def);\n});\n\nexport function date(params?: string | core.$ZodISODateParams): ZodISODate {\n  return core._isoDate(ZodISODate, params);\n}\n\n// ZodISOTime\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      ZodISOTime      //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n\nexport interface ZodISOTime extends schemas.ZodStringFormat {\n  _zod: core.$ZodISOTimeInternals;\n}\nexport const ZodISOTime: core.$constructor<ZodISOTime> = /*@__PURE__*/ core.$constructor(\"ZodISOTime\", (inst, def) => {\n  core.$ZodISOTime.init(inst, def);\n  schemas.ZodStringFormat.init(inst, def);\n});\n\nexport function time(params?: string | core.$ZodISOTimeParams): ZodISOTime {\n  return core._isoTime(ZodISOTime, params);\n}\n\n//////////////////////////////////////////////\n//////////////////////////////////////////////\n//////////                          //////////\n//////////      ZodISODuration      //////////\n//////////                          //////////\n//////////////////////////////////////////////\n//////////////////////////////////////////////\n\nexport interface ZodISODuration extends schemas.ZodStringFormat {\n  _zod: core.$ZodISODurationInternals;\n}\nexport const ZodISODuration: core.$constructor<ZodISODuration> = /*@__PURE__*/ core.$constructor(\n  \"ZodISODuration\",\n  (inst, def) => {\n    core.$ZodISODuration.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n  }\n);\n\nexport function duration(params?: string | core.$ZodISODurationParams): ZodISODuration {\n  return core._isoDuration(ZodISODuration, params);\n}\n",
    "symbols": [
      {
        "name": "datetime",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/iso.ts",
        "startLine": 23,
        "endLine": 25
      },
      {
        "name": "date",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/iso.ts",
        "startLine": 43,
        "endLine": 45
      },
      {
        "name": "time",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/iso.ts",
        "startLine": 65,
        "endLine": 67
      },
      {
        "name": "duration",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/iso.ts",
        "startLine": 88,
        "endLine": 90
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/parse.ts",
    "content": "import * as core from \"../core/index.js\";\nimport { type ZodError, ZodRealError } from \"./errors.js\";\n\nexport type ZodSafeParseResult<T> = ZodSafeParseSuccess<T> | ZodSafeParseError<T>;\nexport type ZodSafeParseSuccess<T> = { success: true; data: T; error?: never };\nexport type ZodSafeParseError<T> = { success: false; data?: never; error: ZodError<T> };\n\nexport const parse: <T extends core.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: core.ParseContext<core.$ZodIssue>,\n  _params?: { callee?: core.util.AnyFunc; Err?: core.$ZodErrorClass }\n) => core.output<T> = /* @__PURE__ */ core._parse(ZodRealError) as any;\n\nexport const parseAsync: <T extends core.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: core.ParseContext<core.$ZodIssue>,\n  _params?: { callee?: core.util.AnyFunc; Err?: core.$ZodErrorClass }\n) => Promise<core.output<T>> = /* @__PURE__ */ core._parseAsync(ZodRealError) as any;\n\nexport const safeParse: <T extends core.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: core.ParseContext<core.$ZodIssue>\n  // _params?: { callee?: core.util.AnyFunc; Err?: core.$ZodErrorClass }\n) => ZodSafeParseResult<core.output<T>> = /* @__PURE__ */ core._safeParse(ZodRealError) as any;\n\nexport const safeParseAsync: <T extends core.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: core.ParseContext<core.$ZodIssue>\n) => Promise<ZodSafeParseResult<core.output<T>>> = /* @__PURE__ */ core._safeParseAsync(ZodRealError) as any;\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
    "content": "import * as core from \"../core/index.js\";\nimport { util } from \"../core/index.js\";\n\nimport * as checks from \"./checks.js\";\nimport * as iso from \"./iso.js\";\nimport * as parse from \"./parse.js\";\n\n///////////////////////////////////////////\n///////////////////////////////////////////\n////////////                   ////////////\n////////////      ZodType      ////////////\n////////////                   ////////////\n///////////////////////////////////////////\n///////////////////////////////////////////\n\nexport interface RefinementCtx<T = unknown> extends core.ParsePayload<T> {\n  addIssue(arg: string | core.$ZodRawIssue | Partial<core.$ZodIssueCustom>): void;\n}\n\nexport interface ZodType<\n  out Output = unknown,\n  out Input = unknown,\n  out Internals extends core.$ZodTypeInternals<Output, Input> = core.$ZodTypeInternals<Output, Input>,\n> extends core.$ZodType<Output, Input, Internals> {\n  def: Internals[\"def\"];\n  type: Internals[\"def\"][\"type\"];\n\n  /** @deprecated Use `.def` instead. */\n  _def: Internals[\"def\"];\n  /** @deprecated Use `z.output<typeof schema>` instead. */\n  _output: Internals[\"output\"];\n  /** @deprecated Use `z.input<typeof schema>` instead. */\n  _input: Internals[\"input\"];\n\n  // base methods\n  check(...checks: (core.CheckFn<core.output<this>> | core.$ZodCheck<core.output<this>>)[]): this;\n  clone(def?: Internals[\"def\"], params?: { parent: boolean }): this;\n  register<R extends core.$ZodRegistry>(\n    registry: R,\n    ...meta: this extends R[\"_schema\"]\n      ? undefined extends R[\"_meta\"]\n        ? [core.$replace<R[\"_meta\"], this>?]\n        : [core.$replace<R[\"_meta\"], this>]\n      : [\"Incompatible schema\"]\n  ): this;\n\n  brand<T extends PropertyKey = PropertyKey>(value?: T): PropertyKey extends T ? this : core.$ZodBranded<this, T>;\n\n  // parsing\n  parse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): core.output<this>;\n  safeParse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): parse.ZodSafeParseResult<core.output<this>>;\n  parseAsync(data: unknown, params?: core.ParseContext<core.$ZodIssue>): Promise<core.output<this>>;\n  safeParseAsync(\n    data: unknown,\n    params?: core.ParseContext<core.$ZodIssue>\n  ): Promise<parse.ZodSafeParseResult<core.output<this>>>;\n  spa: (\n    data: unknown,\n    params?: core.ParseContext<core.$ZodIssue>\n  ) => Promise<parse.ZodSafeParseResult<core.output<this>>>;\n\n  // refinements\n  refine(check: (arg: core.output<this>) => unknown | Promise<unknown>, params?: string | core.$ZodCustomParams): this;\n  /** @deprecated Use `.check()` instead. */\n  superRefine(\n    refinement: (arg: core.output<this>, ctx: RefinementCtx<core.output<this>>) => void | Promise<void>\n  ): this;\n  overwrite(fn: (x: core.output<this>) => core.output<this>): this;\n\n  // wrappers\n  optional(): ZodOptional<this>;\n  nonoptional(params?: string | core.$ZodNonOptionalParams): ZodNonOptional<this>;\n  nullable(): ZodNullable<this>;\n  nullish(): ZodOptional<ZodNullable<this>>;\n  default(def: core.output<this>): ZodDefault<this>;\n  default(def: () => util.NoUndefined<core.output<this>>): ZodDefault<this>;\n  prefault(def: () => core.input<this>): ZodPrefault<this>;\n  prefault(def: core.input<this>): ZodPrefault<this>;\n  array(): ZodArray<this>;\n  or<T extends core.SomeType>(option: T): ZodUnion<[this, T]>;\n  and<T extends core.SomeType>(incoming: T): ZodIntersection<this, T>;\n  transform<NewOut>(\n    transform: (arg: core.output<this>, ctx: RefinementCtx<core.output<this>>) => NewOut | Promise<NewOut>\n  ): ZodPipe<this, ZodTransform<Awaited<NewOut>, core.output<this>>>;\n  catch(def: core.output<this>): ZodCatch<this>;\n  catch(def: (ctx: core.$ZodCatchCtx) => core.output<this>): ZodCatch<this>;\n  pipe<T extends core.$ZodType<any, core.output<this>>>(\n    target: T | core.$ZodType<any, core.output<this>>\n  ): ZodPipe<this, T>;\n  readonly(): ZodReadonly<this>;\n\n  /** Returns a new instance that has been registered in `z.globalRegistry` with the specified description */\n  describe(description: string): this;\n  description?: string;\n  /** Returns the metadata associated with this instance in `z.globalRegistry` */\n  meta(): core.$replace<core.GlobalMeta, this> | undefined;\n  /** Returns a new instance that has been registered in `z.globalRegistry` with the specified metadata */\n  meta(data: core.$replace<core.GlobalMeta, this>): this;\n\n  // helpers\n  /** @deprecated Try safe-parsing `undefined` (this is what `isOptional` does internally):\n   *\n   * ```ts\n   * const schema = z.string().optional();\n   * const isOptional = schema.safeParse(undefined).success; // true\n   * ```\n   */\n  isOptional(): boolean;\n  /**\n   * @deprecated Try safe-parsing `null` (this is what `isNullable` does internally):\n   *\n   * ```ts\n   * const schema = z.string().nullable();\n   * const isNullable = schema.safeParse(null).success; // true\n   * ```\n   */\n  isNullable(): boolean;\n}\n\nexport interface _ZodType<out Internals extends core.$ZodTypeInternals = core.$ZodTypeInternals>\n  extends ZodType<any, any, Internals> {}\n\nexport const ZodType: core.$constructor<ZodType> = /*@__PURE__*/ core.$constructor(\"ZodType\", (inst, def) => {\n  core.$ZodType.init(inst, def);\n  inst.def = def;\n  Object.defineProperty(inst, \"_def\", { value: def });\n\n  // base methods\n  inst.check = (...checks) => {\n    return inst.clone(\n      {\n        ...def,\n        checks: [\n          ...(def.checks ?? []),\n          ...checks.map((ch) =>\n            typeof ch === \"function\" ? { _zod: { check: ch, def: { check: \"custom\" }, onattach: [] } } : ch\n          ),\n        ],\n      }\n      // { parent: true }\n    );\n  };\n  inst.clone = (def, params) => core.clone(inst, def, params);\n  inst.brand = () => inst as any;\n  inst.register = ((reg: any, meta: any) => {\n    reg.add(inst, meta);\n    return inst;\n  }) as any;\n\n  // parsing\n  inst.parse = (data, params) => parse.parse(inst, data, params, { callee: inst.parse });\n  inst.safeParse = (data, params) => parse.safeParse(inst, data, params);\n  inst.parseAsync = async (data, params) => parse.parseAsync(inst, data, params, { callee: inst.parseAsync });\n  inst.safeParseAsync = async (data, params) => parse.safeParseAsync(inst, data, params);\n  inst.spa = inst.safeParseAsync;\n\n  // refinements\n  inst.refine = (check, params) => inst.check(refine(check, params));\n  inst.superRefine = (refinement) => inst.check(superRefine(refinement));\n  inst.overwrite = (fn) => inst.check(checks.overwrite(fn));\n\n  // wrappers\n  inst.optional = () => optional(inst);\n  inst.nullable = () => nullable(inst);\n  inst.nullish = () => optional(nullable(inst));\n  inst.nonoptional = (params) => nonoptional(inst, params);\n  inst.array = () => array(inst);\n  inst.or = (arg) => union([inst, arg]);\n  inst.and = (arg) => intersection(inst, arg);\n  inst.transform = (tx) => pipe(inst, transform(tx as any)) as never;\n  inst.default = (def) => _default(inst, def);\n  inst.prefault = (def) => prefault(inst, def);\n  // inst.coalesce = (def, params) => coalesce(inst, def, params);\n  inst.catch = (params) => _catch(inst, params);\n  inst.pipe = (target) => pipe(inst, target);\n  inst.readonly = () => readonly(inst);\n\n  // meta\n  inst.describe = (description) => {\n    const cl = inst.clone();\n    core.globalRegistry.add(cl, { description });\n    return cl;\n  };\n  Object.defineProperty(inst, \"description\", {\n    get() {\n      return core.globalRegistry.get(inst)?.description;\n    },\n    configurable: true,\n  });\n  inst.meta = (...args: any) => {\n    if (args.length === 0) {\n      return core.globalRegistry.get(inst);\n    }\n    const cl = inst.clone();\n    core.globalRegistry.add(cl, args[0]);\n    return cl as any;\n  };\n\n  // helpers\n  inst.isOptional = () => inst.safeParse(undefined).success;\n  inst.isNullable = () => inst.safeParse(null).success;\n  return inst;\n});\n\n// ZodString\nexport interface _ZodString<T extends core.$ZodStringInternals<unknown> = core.$ZodStringInternals<unknown>>\n  extends _ZodType<T> {\n  format: string | null;\n  minLength: number | null;\n  maxLength: number | null;\n\n  // miscellaneous checks\n  regex(regex: RegExp, params?: string | core.$ZodCheckRegexParams): this;\n  includes(value: string, params?: core.$ZodCheckIncludesParams): this;\n  startsWith(value: string, params?: string | core.$ZodCheckStartsWithParams): this;\n  endsWith(value: string, params?: string | core.$ZodCheckEndsWithParams): this;\n  min(minLength: number, params?: string | core.$ZodCheckMinLengthParams): this;\n  max(maxLength: number, params?: string | core.$ZodCheckMaxLengthParams): this;\n  length(len: number, params?: string | core.$ZodCheckLengthEqualsParams): this;\n  nonempty(params?: string | core.$ZodCheckMinLengthParams): this;\n  lowercase(params?: string | core.$ZodCheckLowerCaseParams): this;\n  uppercase(params?: string | core.$ZodCheckUpperCaseParams): this;\n\n  // transforms\n  trim(): this;\n  normalize(form?: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\" | (string & {})): this;\n  toLowerCase(): this;\n  toUpperCase(): this;\n}\n\n/** @internal */\nexport const _ZodString: core.$constructor<_ZodString> = /*@__PURE__*/ core.$constructor(\"_ZodString\", (inst, def) => {\n  core.$ZodString.init(inst, def);\n  ZodType.init(inst, def);\n\n  const bag = inst._zod.bag;\n  inst.format = bag.format ?? null;\n  inst.minLength = bag.minimum ?? null;\n  inst.maxLength = bag.maximum ?? null;\n\n  // validations\n  inst.regex = (...args) => inst.check(checks.regex(...args));\n  inst.includes = (...args) => inst.check(checks.includes(...args));\n  inst.startsWith = (...args) => inst.check(checks.startsWith(...args));\n  inst.endsWith = (...args) => inst.check(checks.endsWith(...args));\n  inst.min = (...args) => inst.check(checks.minLength(...args));\n  inst.max = (...args) => inst.check(checks.maxLength(...args));\n  inst.length = (...args) => inst.check(checks.length(...args));\n  inst.nonempty = (...args) => inst.check(checks.minLength(1, ...args));\n  inst.lowercase = (params) => inst.check(checks.lowercase(params));\n  inst.uppercase = (params) => inst.check(checks.uppercase(params));\n\n  // transforms\n  inst.trim = () => inst.check(checks.trim());\n  inst.normalize = (...args) => inst.check(checks.normalize(...args));\n  inst.toLowerCase = () => inst.check(checks.toLowerCase());\n  inst.toUpperCase = () => inst.check(checks.toUpperCase());\n});\n\nexport interface ZodString extends _ZodString<core.$ZodStringInternals<string>> {\n  // string format checks\n\n  /** @deprecated Use `z.email()` instead. */\n  email(params?: string | core.$ZodCheckEmailParams): this;\n  /** @deprecated Use `z.url()` instead. */\n  url(params?: string | core.$ZodCheckURLParams): this;\n  /** @deprecated Use `z.jwt()` instead. */\n  jwt(params?: string | core.$ZodCheckJWTParams): this;\n  /** @deprecated Use `z.emoji()` instead. */\n  emoji(params?: string | core.$ZodCheckEmojiParams): this;\n  /** @deprecated Use `z.guid()` instead. */\n  guid(params?: string | core.$ZodCheckGUIDParams): this;\n  /** @deprecated Use `z.uuid()` instead. */\n  uuid(params?: string | core.$ZodCheckUUIDParams): this;\n  /** @deprecated Use `z.uuid()` instead. */\n  uuidv4(params?: string | core.$ZodCheckUUIDParams): this;\n  /** @deprecated Use `z.uuid()` instead. */\n  uuidv6(params?: string | core.$ZodCheckUUIDParams): this;\n  /** @deprecated Use `z.uuid()` instead. */\n  uuidv7(params?: string | core.$ZodCheckUUIDParams): this;\n  /** @deprecated Use `z.nanoid()` instead. */\n  nanoid(params?: string | core.$ZodCheckNanoIDParams): this;\n  /** @deprecated Use `z.guid()` instead. */\n  guid(params?: string | core.$ZodCheckGUIDParams): this;\n  /** @deprecated Use `z.cuid()` instead. */\n  cuid(params?: string | core.$ZodCheckCUIDParams): this;\n  /** @deprecated Use `z.cuid2()` instead. */\n  cuid2(params?: string | core.$ZodCheckCUID2Params): this;\n  /** @deprecated Use `z.ulid()` instead. */\n  ulid(params?: string | core.$ZodCheckULIDParams): this;\n  /** @deprecated Use `z.base64()` instead. */\n  base64(params?: string | core.$ZodCheckBase64Params): this;\n  /** @deprecated Use `z.base64url()` instead. */\n  base64url(params?: string | core.$ZodCheckBase64URLParams): this;\n  // /** @deprecated Use `z.jsonString()` instead. */\n  // jsonString(params?: string | core.$ZodCheckJSONStringParams): this;\n  /** @deprecated Use `z.xid()` instead. */\n  xid(params?: string | core.$ZodCheckXIDParams): this;\n  /** @deprecated Use `z.ksuid()` instead. */\n  ksuid(params?: string | core.$ZodCheckKSUIDParams): this;\n  // /** @deprecated Use `z.ipv4()` or `z.ipv6()` instead. */\n  // ip(params?: string | (core.$ZodCheckIPv4Params & { version?: \"v4\" | \"v6\" })): ZodUnion<[this, this]>;\n  /** @deprecated Use `z.ipv4()` instead. */\n  ipv4(params?: string | core.$ZodCheckIPv4Params): this;\n  /** @deprecated Use `z.ipv6()` instead. */\n  ipv6(params?: string | core.$ZodCheckIPv6Params): this;\n  /** @deprecated Use `z.cidrv4()` instead. */\n  cidrv4(params?: string | core.$ZodCheckCIDRv4Params): this;\n  /** @deprecated Use `z.cidrv6()` instead. */\n  cidrv6(params?: string | core.$ZodCheckCIDRv6Params): this;\n  /** @deprecated Use `z.e164()` instead. */\n  e164(params?: string | core.$ZodCheckE164Params): this;\n\n  // ISO 8601 checks\n  /** @deprecated Use `z.iso.datetime()` instead. */\n  datetime(params?: string | core.$ZodCheckISODateTimeParams): this;\n  /** @deprecated Use `z.iso.date()` instead. */\n  date(params?: string | core.$ZodCheckISODateParams): this;\n  /** @deprecated Use `z.iso.time()` instead. */\n  time(\n    params?:\n      | string\n      // | {\n      //     message?: string | undefined;\n      //     precision?: number | null;\n      //   }\n      | core.$ZodCheckISOTimeParams\n  ): this;\n  /** @deprecated Use `z.iso.duration()` instead. */\n  duration(params?: string | core.$ZodCheckISODurationParams): this;\n}\n\nexport const ZodString: core.$constructor<ZodString> = /*@__PURE__*/ core.$constructor(\"ZodString\", (inst, def) => {\n  core.$ZodString.init(inst, def);\n  _ZodString.init(inst, def);\n\n  inst.email = (params) => inst.check(core._email(ZodEmail, params));\n  inst.url = (params) => inst.check(core._url(ZodURL, params));\n  inst.jwt = (params) => inst.check(core._jwt(ZodJWT, params));\n  inst.emoji = (params) => inst.check(core._emoji(ZodEmoji, params));\n  inst.guid = (params) => inst.check(core._guid(ZodGUID, params));\n  inst.uuid = (params) => inst.check(core._uuid(ZodUUID, params));\n  inst.uuidv4 = (params) => inst.check(core._uuidv4(ZodUUID, params));\n  inst.uuidv6 = (params) => inst.check(core._uuidv6(ZodUUID, params));\n  inst.uuidv7 = (params) => inst.check(core._uuidv7(ZodUUID, params));\n  inst.nanoid = (params) => inst.check(core._nanoid(ZodNanoID, params));\n  inst.guid = (params) => inst.check(core._guid(ZodGUID, params));\n  inst.cuid = (params) => inst.check(core._cuid(ZodCUID, params));\n  inst.cuid2 = (params) => inst.check(core._cuid2(ZodCUID2, params));\n  inst.ulid = (params) => inst.check(core._ulid(ZodULID, params));\n  inst.base64 = (params) => inst.check(core._base64(ZodBase64, params));\n  inst.base64url = (params) => inst.check(core._base64url(ZodBase64URL, params));\n  inst.xid = (params) => inst.check(core._xid(ZodXID, params));\n  inst.ksuid = (params) => inst.check(core._ksuid(ZodKSUID, params));\n  inst.ipv4 = (params) => inst.check(core._ipv4(ZodIPv4, params));\n  inst.ipv6 = (params) => inst.check(core._ipv6(ZodIPv6, params));\n  inst.cidrv4 = (params) => inst.check(core._cidrv4(ZodCIDRv4, params));\n  inst.cidrv6 = (params) => inst.check(core._cidrv6(ZodCIDRv6, params));\n  inst.e164 = (params) => inst.check(core._e164(ZodE164, params));\n\n  // iso\n  inst.datetime = (params) => inst.check(iso.datetime(params as any));\n  inst.date = (params) => inst.check(iso.date(params as any));\n  inst.time = (params) => inst.check(iso.time(params as any));\n  inst.duration = (params) => inst.check(iso.duration(params as any));\n});\n\nexport function string(params?: string | core.$ZodStringParams): ZodString;\nexport function string<T extends string>(params?: string | core.$ZodStringParams): core.$ZodType<T, T>;\nexport function string(params?: string | core.$ZodStringParams): ZodString {\n  return core._string(ZodString, params) as any;\n}\n\n// ZodStringFormat\nexport interface ZodStringFormat<Format extends string = string>\n  extends _ZodString<core.$ZodStringFormatInternals<Format>> {}\nexport const ZodStringFormat: core.$constructor<ZodStringFormat> = /*@__PURE__*/ core.$constructor(\n  \"ZodStringFormat\",\n  (inst, def) => {\n    core.$ZodStringFormat.init(inst, def);\n    _ZodString.init(inst, def);\n  }\n);\n\n// ZodEmail\nexport interface ZodEmail extends ZodStringFormat<\"email\"> {\n  _zod: core.$ZodEmailInternals;\n}\nexport const ZodEmail: core.$constructor<ZodEmail> = /*@__PURE__*/ core.$constructor(\"ZodEmail\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodEmail.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function email(params?: string | core.$ZodEmailParams): ZodEmail {\n  return core._email(ZodEmail, params);\n}\n\n// ZodGUID\nexport interface ZodGUID extends ZodStringFormat<\"guid\"> {\n  _zod: core.$ZodGUIDInternals;\n}\nexport const ZodGUID: core.$constructor<ZodGUID> = /*@__PURE__*/ core.$constructor(\"ZodGUID\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodGUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function guid(params?: string | core.$ZodGUIDParams): ZodGUID {\n  return core._guid(ZodGUID, params);\n}\n\n// ZodUUID\nexport interface ZodUUID extends ZodStringFormat<\"uuid\"> {\n  _zod: core.$ZodUUIDInternals;\n}\nexport const ZodUUID: core.$constructor<ZodUUID> = /*@__PURE__*/ core.$constructor(\"ZodUUID\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodUUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function uuid(params?: string | core.$ZodUUIDParams): ZodUUID {\n  return core._uuid(ZodUUID, params);\n}\n\nexport function uuidv4(params?: string | core.$ZodUUIDv4Params): ZodUUID {\n  return core._uuidv4(ZodUUID, params);\n}\n\n// ZodUUIDv6\n\nexport function uuidv6(params?: string | core.$ZodUUIDv6Params): ZodUUID {\n  return core._uuidv6(ZodUUID, params);\n}\n\n// ZodUUIDv7\n\nexport function uuidv7(params?: string | core.$ZodUUIDv7Params): ZodUUID {\n  return core._uuidv7(ZodUUID, params);\n}\n\n// ZodURL\nexport interface ZodURL extends ZodStringFormat<\"url\"> {\n  _zod: core.$ZodURLInternals;\n}\nexport const ZodURL: core.$constructor<ZodURL> = /*@__PURE__*/ core.$constructor(\"ZodURL\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodURL.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function url(params?: string | core.$ZodURLParams): ZodURL {\n  return core._url(ZodURL, params);\n}\n\n// ZodEmoji\nexport interface ZodEmoji extends ZodStringFormat<\"emoji\"> {\n  _zod: core.$ZodEmojiInternals;\n}\nexport const ZodEmoji: core.$constructor<ZodEmoji> = /*@__PURE__*/ core.$constructor(\"ZodEmoji\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodEmoji.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function emoji(params?: string | core.$ZodEmojiParams): ZodEmoji {\n  return core._emoji(ZodEmoji, params);\n}\n\n// ZodNanoID\nexport interface ZodNanoID extends ZodStringFormat<\"nanoid\"> {\n  _zod: core.$ZodNanoIDInternals;\n}\nexport const ZodNanoID: core.$constructor<ZodNanoID> = /*@__PURE__*/ core.$constructor(\"ZodNanoID\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodNanoID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function nanoid(params?: string | core.$ZodNanoIDParams): ZodNanoID {\n  return core._nanoid(ZodNanoID, params);\n}\n\n// ZodCUID\nexport interface ZodCUID extends ZodStringFormat<\"cuid\"> {\n  _zod: core.$ZodCUIDInternals;\n}\nexport const ZodCUID: core.$constructor<ZodCUID> = /*@__PURE__*/ core.$constructor(\"ZodCUID\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodCUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function cuid(params?: string | core.$ZodCUIDParams): ZodCUID {\n  return core._cuid(ZodCUID, params);\n}\n\n// ZodCUID2\nexport interface ZodCUID2 extends ZodStringFormat<\"cuid2\"> {\n  _zod: core.$ZodCUID2Internals;\n}\nexport const ZodCUID2: core.$constructor<ZodCUID2> = /*@__PURE__*/ core.$constructor(\"ZodCUID2\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodCUID2.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function cuid2(params?: string | core.$ZodCUID2Params): ZodCUID2 {\n  return core._cuid2(ZodCUID2, params);\n}\n\n// ZodULID\nexport interface ZodULID extends ZodStringFormat<\"ulid\"> {\n  _zod: core.$ZodULIDInternals;\n}\nexport const ZodULID: core.$constructor<ZodULID> = /*@__PURE__*/ core.$constructor(\"ZodULID\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodULID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function ulid(params?: string | core.$ZodULIDParams): ZodULID {\n  return core._ulid(ZodULID, params);\n}\n\n// ZodXID\nexport interface ZodXID extends ZodStringFormat<\"xid\"> {\n  _zod: core.$ZodXIDInternals;\n}\nexport const ZodXID: core.$constructor<ZodXID> = /*@__PURE__*/ core.$constructor(\"ZodXID\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodXID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function xid(params?: string | core.$ZodXIDParams): ZodXID {\n  return core._xid(ZodXID, params);\n}\n\n// ZodKSUID\nexport interface ZodKSUID extends ZodStringFormat<\"ksuid\"> {\n  _zod: core.$ZodKSUIDInternals;\n}\nexport const ZodKSUID: core.$constructor<ZodKSUID> = /*@__PURE__*/ core.$constructor(\"ZodKSUID\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodKSUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function ksuid(params?: string | core.$ZodKSUIDParams): ZodKSUID {\n  return core._ksuid(ZodKSUID, params);\n}\n\n// ZodIP\n// export interface ZodIP extends ZodStringFormat<\"ip\"> {\n//   _zod: core.$ZodIPInternals;\n// }\n// export const ZodIP: core.$constructor<ZodIP> = /*@__PURE__*/ core.$constructor(\"ZodIP\", (inst, def) => {\n//   // ZodStringFormat.init(inst, def);\n//   core.$ZodIP.init(inst, def);\n//   ZodStringFormat.init(inst, def);\n// });\n\n// export function ip(params?: string | core.$ZodIPParams): ZodIP {\n//   return core._ip(ZodIP, params);\n// }\n\n// ZodIPv4\nexport interface ZodIPv4 extends ZodStringFormat<\"ipv4\"> {\n  _zod: core.$ZodIPv4Internals;\n}\nexport const ZodIPv4: core.$constructor<ZodIPv4> = /*@__PURE__*/ core.$constructor(\"ZodIPv4\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodIPv4.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function ipv4(params?: string | core.$ZodIPv4Params): ZodIPv4 {\n  return core._ipv4(ZodIPv4, params);\n}\n\n// ZodIPv6\nexport interface ZodIPv6 extends ZodStringFormat<\"ipv6\"> {\n  _zod: core.$ZodIPv6Internals;\n}\nexport const ZodIPv6: core.$constructor<ZodIPv6> = /*@__PURE__*/ core.$constructor(\"ZodIPv6\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodIPv6.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nexport function ipv6(params?: string | core.$ZodIPv6Params): ZodIPv6 {\n  return core._ipv6(ZodIPv6, params);\n}\n\n// ZodCIDRv4\nexport interface ZodCIDRv4 extends ZodStringFormat<\"cidrv4\"> {\n  _zod: core.$ZodCIDRv4Internals;\n}\nexport const ZodCIDRv4: core.$constructor<ZodCIDRv4> = /*@__PURE__*/ core.$constructor(\"ZodCIDRv4\", (inst, def) => {\n  core.$ZodCIDRv4.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function cidrv4(params?: string | core.$ZodCIDRv4Params): ZodCIDRv4 {\n  return core._cidrv4(ZodCIDRv4, params);\n}\n\n// ZodCIDRv6\nexport interface ZodCIDRv6 extends ZodStringFormat<\"cidrv6\"> {\n  _zod: core.$ZodCIDRv6Internals;\n}\nexport const ZodCIDRv6: core.$constructor<ZodCIDRv6> = /*@__PURE__*/ core.$constructor(\"ZodCIDRv6\", (inst, def) => {\n  core.$ZodCIDRv6.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function cidrv6(params?: string | core.$ZodCIDRv6Params): ZodCIDRv6 {\n  return core._cidrv6(ZodCIDRv6, params);\n}\n\n// ZodBase64\nexport interface ZodBase64 extends ZodStringFormat<\"base64\"> {\n  _zod: core.$ZodBase64Internals;\n}\nexport const ZodBase64: core.$constructor<ZodBase64> = /*@__PURE__*/ core.$constructor(\"ZodBase64\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodBase64.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nexport function base64(params?: string | core.$ZodBase64Params): ZodBase64 {\n  return core._base64(ZodBase64, params);\n}\n\n// ZodBase64URL\nexport interface ZodBase64URL extends ZodStringFormat<\"base64url\"> {\n  _zod: core.$ZodBase64URLInternals;\n}\nexport const ZodBase64URL: core.$constructor<ZodBase64URL> = /*@__PURE__*/ core.$constructor(\n  \"ZodBase64URL\",\n  (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodBase64URL.init(inst, def);\n    ZodStringFormat.init(inst, def);\n  }\n);\nexport function base64url(params?: string | core.$ZodBase64URLParams): ZodBase64URL {\n  return core._base64url(ZodBase64URL, params);\n}\n\n// ZodE164\nexport interface ZodE164 extends ZodStringFormat<\"e164\"> {\n  _zod: core.$ZodE164Internals;\n}\nexport const ZodE164: core.$constructor<ZodE164> = /*@__PURE__*/ core.$constructor(\"ZodE164\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodE164.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function e164(params?: string | core.$ZodE164Params): ZodE164 {\n  return core._e164(ZodE164, params);\n}\n\n// ZodJWT\nexport interface ZodJWT extends ZodStringFormat<\"jwt\"> {\n  _zod: core.$ZodJWTInternals;\n}\nexport const ZodJWT: core.$constructor<ZodJWT> = /*@__PURE__*/ core.$constructor(\"ZodJWT\", (inst, def) => {\n  // ZodStringFormat.init(inst, def);\n  core.$ZodJWT.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\n\nexport function jwt(params?: string | core.$ZodJWTParams): ZodJWT {\n  return core._jwt(ZodJWT, params);\n}\n\n// ZodCustomStringFormat\nexport interface ZodCustomStringFormat<Format extends string = string>\n  extends ZodStringFormat<Format>,\n    core.$ZodCustomStringFormat<Format> {\n  _zod: core.$ZodCustomStringFormatInternals<Format>;\n}\nexport const ZodCustomStringFormat: core.$constructor<ZodCustomStringFormat> = /*@__PURE__*/ core.$constructor(\n  \"ZodCustomStringFormat\",\n  (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodCustomStringFormat.init(inst, def);\n    ZodStringFormat.init(inst, def);\n  }\n);\nexport function stringFormat<Format extends string>(\n  format: Format,\n  fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp,\n  _params: string | core.$ZodStringFormatParams = {}\n): ZodCustomStringFormat<Format> {\n  return core._stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params) as any;\n}\n\n// ZodNumber\nexport interface _ZodNumber<Internals extends core.$ZodNumberInternals = core.$ZodNumberInternals>\n  extends _ZodType<Internals> {\n  gt(value: number, params?: string | core.$ZodCheckGreaterThanParams): this;\n  /** Identical to .min() */\n  gte(value: number, params?: string | core.$ZodCheckGreaterThanParams): this;\n  min(value: number, params?: string | core.$ZodCheckGreaterThanParams): this;\n  lt(value: number, params?: string | core.$ZodCheckLessThanParams): this;\n  /** Identical to .max() */\n  lte(value: number, params?: string | core.$ZodCheckLessThanParams): this;\n  max(value: number, params?: string | core.$ZodCheckLessThanParams): this;\n  /** Consider `z.int()` instead. This API is considered *legacy*; it will never be removed but a better alternative exists. */\n  int(params?: string | core.$ZodCheckNumberFormatParams): this;\n  /** @deprecated This is now identical to `.int()`. Only numbers in the safe integer range are accepted. */\n  safe(params?: string | core.$ZodCheckNumberFormatParams): this;\n  positive(params?: string | core.$ZodCheckGreaterThanParams): this;\n  nonnegative(params?: string | core.$ZodCheckGreaterThanParams): this;\n  negative(params?: string | core.$ZodCheckLessThanParams): this;\n  nonpositive(params?: string | core.$ZodCheckLessThanParams): this;\n  multipleOf(value: number, params?: string | core.$ZodCheckMultipleOfParams): this;\n  /** @deprecated Use `.multipleOf()` instead. */\n  step(value: number, params?: string | core.$ZodCheckMultipleOfParams): this;\n\n  /** @deprecated In v4 and later, z.number() does not allow infinite values by default. This is a no-op. */\n  finite(params?: unknown): this;\n\n  minValue: number | null;\n  maxValue: number | null;\n  /** @deprecated Check the `format` property instead.  */\n  isInt: boolean;\n  /** @deprecated Number schemas no longer accept infinite values, so this always returns `true`. */\n  isFinite: boolean;\n  format: string | null;\n}\n\nexport interface ZodNumber extends _ZodNumber<core.$ZodNumberInternals<number>> {}\n\nexport const ZodNumber: core.$constructor<ZodNumber> = /*@__PURE__*/ core.$constructor(\"ZodNumber\", (inst, def) => {\n  core.$ZodNumber.init(inst, def);\n  ZodType.init(inst, def);\n\n  inst.gt = (value, params) => inst.check(checks.gt(value, params));\n  inst.gte = (value, params) => inst.check(checks.gte(value, params));\n  inst.min = (value, params) => inst.check(checks.gte(value, params));\n  inst.lt = (value, params) => inst.check(checks.lt(value, params));\n  inst.lte = (value, params) => inst.check(checks.lte(value, params));\n  inst.max = (value, params) => inst.check(checks.lte(value, params));\n  inst.int = (params) => inst.check(int(params));\n  inst.safe = (params) => inst.check(int(params));\n  inst.positive = (params) => inst.check(checks.gt(0, params));\n  inst.nonnegative = (params) => inst.check(checks.gte(0, params));\n  inst.negative = (params) => inst.check(checks.lt(0, params));\n  inst.nonpositive = (params) => inst.check(checks.lte(0, params));\n  inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));\n  inst.step = (value, params) => inst.check(checks.multipleOf(value, params));\n\n  // inst.finite = (params) => inst.check(core.finite(params));\n  inst.finite = () => inst;\n\n  const bag = inst._zod.bag;\n  inst.minValue =\n    Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;\n  inst.maxValue =\n    Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;\n  inst.isInt = (bag.format ?? \"\").includes(\"int\") || Number.isSafeInteger(bag.multipleOf ?? 0.5);\n  inst.isFinite = true;\n  inst.format = bag.format ?? null;\n});\n\nexport function number(params?: string | core.$ZodNumberParams): ZodNumber {\n  return core._number(ZodNumber, params) as any;\n}\n\n// ZodNumberFormat\nexport interface ZodNumberFormat extends ZodNumber {\n  _zod: core.$ZodNumberFormatInternals;\n}\nexport const ZodNumberFormat: core.$constructor<ZodNumberFormat> = /*@__PURE__*/ core.$constructor(\n  \"ZodNumberFormat\",\n  (inst, def) => {\n    core.$ZodNumberFormat.init(inst, def);\n    ZodNumber.init(inst, def);\n  }\n);\n\n// int\nexport interface ZodInt extends ZodNumberFormat {}\nexport function int(params?: string | core.$ZodCheckNumberFormatParams): ZodInt {\n  return core._int(ZodNumberFormat, params);\n}\n\n// float32\nexport interface ZodFloat32 extends ZodNumberFormat {}\nexport function float32(params?: string | core.$ZodCheckNumberFormatParams): ZodFloat32 {\n  return core._float32(ZodNumberFormat, params);\n}\n\n// float64\nexport interface ZodFloat64 extends ZodNumberFormat {}\nexport function float64(params?: string | core.$ZodCheckNumberFormatParams): ZodFloat64 {\n  return core._float64(ZodNumberFormat, params);\n}\n\n// int32\nexport interface ZodInt32 extends ZodNumberFormat {}\nexport function int32(params?: string | core.$ZodCheckNumberFormatParams): ZodInt32 {\n  return core._int32(ZodNumberFormat, params);\n}\n\n// uint32\nexport interface ZodUInt32 extends ZodNumberFormat {}\nexport function uint32(params?: string | core.$ZodCheckNumberFormatParams): ZodUInt32 {\n  return core._uint32(ZodNumberFormat, params);\n}\n\n// boolean\nexport interface _ZodBoolean<T extends core.$ZodBooleanInternals = core.$ZodBooleanInternals> extends _ZodType<T> {}\nexport interface ZodBoolean extends _ZodBoolean<core.$ZodBooleanInternals<boolean>> {}\nexport const ZodBoolean: core.$constructor<ZodBoolean> = /*@__PURE__*/ core.$constructor(\"ZodBoolean\", (inst, def) => {\n  core.$ZodBoolean.init(inst, def);\n  ZodType.init(inst, def);\n});\n\nexport function boolean(params?: string | core.$ZodBooleanParams): ZodBoolean {\n  return core._boolean(ZodBoolean, params) as any;\n}\n\n// bigint\nexport interface _ZodBigInt<T extends core.$ZodBigIntInternals = core.$ZodBigIntInternals> extends _ZodType<T> {\n  gte(value: bigint, params?: string | core.$ZodCheckGreaterThanParams): this;\n  /** Alias of `.gte()` */\n  min(value: bigint, params?: string | core.$ZodCheckGreaterThanParams): this;\n  gt(value: bigint, params?: string | core.$ZodCheckGreaterThanParams): this;\n  /** Alias of `.lte()` */\n  lte(value: bigint, params?: string | core.$ZodCheckLessThanParams): this;\n  max(value: bigint, params?: string | core.$ZodCheckLessThanParams): this;\n  lt(value: bigint, params?: string | core.$ZodCheckLessThanParams): this;\n  positive(params?: string | core.$ZodCheckGreaterThanParams): this;\n  negative(params?: string | core.$ZodCheckLessThanParams): this;\n  nonpositive(params?: string | core.$ZodCheckLessThanParams): this;\n  nonnegative(params?: string | core.$ZodCheckGreaterThanParams): this;\n  multipleOf(value: bigint, params?: string | core.$ZodCheckMultipleOfParams): this;\n\n  minValue: bigint | null;\n  maxValue: bigint | null;\n  format: string | null;\n}\n\nexport interface ZodBigInt extends _ZodBigInt<core.$ZodBigIntInternals<bigint>> {}\nexport const ZodBigInt: core.$constructor<ZodBigInt> = /*@__PURE__*/ core.$constructor(\"ZodBigInt\", (inst, def) => {\n  core.$ZodBigInt.init(inst, def);\n  ZodType.init(inst, def);\n\n  inst.gte = (value, params) => inst.check(checks.gte(value, params));\n  inst.min = (value, params) => inst.check(checks.gte(value, params));\n  inst.gt = (value, params) => inst.check(checks.gt(value, params));\n  inst.gte = (value, params) => inst.check(checks.gte(value, params));\n  inst.min = (value, params) => inst.check(checks.gte(value, params));\n  inst.lt = (value, params) => inst.check(checks.lt(value, params));\n  inst.lte = (value, params) => inst.check(checks.lte(value, params));\n  inst.max = (value, params) => inst.check(checks.lte(value, params));\n  inst.positive = (params) => inst.check(checks.gt(BigInt(0), params));\n  inst.negative = (params) => inst.check(checks.lt(BigInt(0), params));\n  inst.nonpositive = (params) => inst.check(checks.lte(BigInt(0), params));\n  inst.nonnegative = (params) => inst.check(checks.gte(BigInt(0), params));\n  inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));\n\n  const bag = inst._zod.bag;\n  inst.minValue = bag.minimum ?? null;\n  inst.maxValue = bag.maximum ?? null;\n  inst.format = bag.format ?? null;\n});\n\nexport function bigint(params?: string | core.$ZodBigIntParams): ZodBigInt {\n  return core._bigint(ZodBigInt, params) as any;\n}\n// bigint formats\n\n// ZodBigIntFormat\nexport interface ZodBigIntFormat extends ZodBigInt {\n  _zod: core.$ZodBigIntFormatInternals;\n}\nexport const ZodBigIntFormat: core.$constructor<ZodBigIntFormat> = /*@__PURE__*/ core.$constructor(\n  \"ZodBigIntFormat\",\n  (inst, def) => {\n    core.$ZodBigIntFormat.init(inst, def);\n    ZodBigInt.init(inst, def);\n  }\n);\n\n// int64\nexport function int64(params?: string | core.$ZodBigIntFormatParams): ZodBigIntFormat {\n  return core._int64(ZodBigIntFormat, params);\n}\n\n// uint64\nexport function uint64(params?: string | core.$ZodBigIntFormatParams): ZodBigIntFormat {\n  return core._uint64(ZodBigIntFormat, params);\n}\n\n// symbol\nexport interface ZodSymbol extends _ZodType<core.$ZodSymbolInternals> {}\nexport const ZodSymbol: core.$constructor<ZodSymbol> = /*@__PURE__*/ core.$constructor(\"ZodSymbol\", (inst, def) => {\n  core.$ZodSymbol.init(inst, def);\n  ZodType.init(inst, def);\n});\n\nexport function symbol(params?: string | core.$ZodSymbolParams): ZodSymbol {\n  return core._symbol(ZodSymbol, params);\n}\n\n// ZodUndefined\nexport interface ZodUndefined extends _ZodType<core.$ZodUndefinedInternals> {}\nexport const ZodUndefined: core.$constructor<ZodUndefined> = /*@__PURE__*/ core.$constructor(\n  \"ZodUndefined\",\n  (inst, def) => {\n    core.$ZodUndefined.init(inst, def);\n    ZodType.init(inst, def);\n  }\n);\n\nfunction _undefined(params?: string | core.$ZodUndefinedParams): ZodUndefined {\n  return core._undefined(ZodUndefined, params);\n}\nexport { _undefined as undefined };\n\n// ZodNull\nexport interface ZodNull extends _ZodType<core.$ZodNullInternals> {}\nexport const ZodNull: core.$constructor<ZodNull> = /*@__PURE__*/ core.$constructor(\"ZodNull\", (inst, def) => {\n  core.$ZodNull.init(inst, def);\n  ZodType.init(inst, def);\n});\n\nfunction _null(params?: string | core.$ZodNullParams): ZodNull {\n  return core._null(ZodNull, params);\n}\nexport { _null as null };\n\n// ZodAny\nexport interface ZodAny extends _ZodType<core.$ZodAnyInternals> {}\nexport const ZodAny: core.$constructor<ZodAny> = /*@__PURE__*/ core.$constructor(\"ZodAny\", (inst, def) => {\n  core.$ZodAny.init(inst, def);\n  ZodType.init(inst, def);\n});\n\nexport function any(): ZodAny {\n  return core._any(ZodAny);\n}\n\n// ZodUnknown\nexport interface ZodUnknown extends _ZodType<core.$ZodUnknownInternals> {}\nexport const ZodUnknown: core.$constructor<ZodUnknown> = /*@__PURE__*/ core.$constructor(\"ZodUnknown\", (inst, def) => {\n  core.$ZodUnknown.init(inst, def);\n  ZodType.init(inst, def);\n});\n\nexport function unknown(): ZodUnknown {\n  return core._unknown(ZodUnknown);\n}\n\n// ZodNever\nexport interface ZodNever extends _ZodType<core.$ZodNeverInternals> {}\nexport const ZodNever: core.$constructor<ZodNever> = /*@__PURE__*/ core.$constructor(\"ZodNever\", (inst, def) => {\n  core.$ZodNever.init(inst, def);\n  ZodType.init(inst, def);\n});\n\nexport function never(params?: string | core.$ZodNeverParams): ZodNever {\n  return core._never(ZodNever, params);\n}\n\n// ZodVoid\nexport interface ZodVoid extends _ZodType<core.$ZodVoidInternals> {}\nexport const ZodVoid: core.$constructor<ZodVoid> = /*@__PURE__*/ core.$constructor(\"ZodVoid\", (inst, def) => {\n  core.$ZodVoid.init(inst, def);\n  ZodType.init(inst, def);\n});\n\nfunction _void(params?: string | core.$ZodVoidParams): ZodVoid {\n  return core._void(ZodVoid, params);\n}\nexport { _void as void };\n\n// ZodDate\nexport interface _ZodDate<T extends core.$ZodDateInternals = core.$ZodDateInternals> extends _ZodType<T> {\n  min(value: number | Date, params?: string | core.$ZodCheckGreaterThanParams): this;\n  max(value: number | Date, params?: string | core.$ZodCheckLessThanParams): this;\n\n  /** @deprecated Not recommended. */\n  minDate: Date | null;\n  /** @deprecated Not recommended. */\n  maxDate: Date | null;\n}\n\nexport interface ZodDate extends _ZodDate<core.$ZodDateInternals<Date>> {}\nexport const ZodDate: core.$constructor<ZodDate> = /*@__PURE__*/ core.$constructor(\"ZodDate\", (inst, def) => {\n  core.$ZodDate.init(inst, def);\n  ZodType.init(inst, def);\n\n  inst.min = (value, params) => inst.check(checks.gte(value, params));\n  inst.max = (value, params) => inst.check(checks.lte(value, params));\n\n  const c = inst._zod.bag;\n  inst.minDate = c.minimum ? new Date(c.minimum) : null;\n  inst.maxDate = c.maximum ? new Date(c.maximum) : null;\n});\n\nexport function date(params?: string | core.$ZodDateParams): ZodDate {\n  return core._date(ZodDate, params);\n}\n\n// ZodArray\nexport interface ZodArray<T extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodArrayInternals<T>>,\n    core.$ZodArray<T> {\n  element: T;\n  min(minLength: number, params?: string | core.$ZodCheckMinLengthParams): this;\n  nonempty(params?: string | core.$ZodCheckMinLengthParams): this;\n  max(maxLength: number, params?: string | core.$ZodCheckMaxLengthParams): this;\n  length(len: number, params?: string | core.$ZodCheckLengthEqualsParams): this;\n\n  unwrap(): T;\n}\nexport const ZodArray: core.$constructor<ZodArray> = /*@__PURE__*/ core.$constructor(\"ZodArray\", (inst, def) => {\n  core.$ZodArray.init(inst, def);\n  ZodType.init(inst, def);\n\n  inst.element = def.element as any;\n  inst.min = (minLength, params) => inst.check(checks.minLength(minLength, params));\n  inst.nonempty = (params) => inst.check(checks.minLength(1, params));\n  inst.max = (maxLength, params) => inst.check(checks.maxLength(maxLength, params));\n  inst.length = (len, params) => inst.check(checks.length(len, params));\n\n  inst.unwrap = () => inst.element;\n});\n\nexport function array<T extends core.SomeType>(element: T, params?: string | core.$ZodArrayParams): ZodArray<T> {\n  return core._array(ZodArray, element as any, params) as any;\n}\n\n// .keyof\nexport function keyof<T extends ZodObject>(schema: T): ZodLiteral<Exclude<keyof T[\"_zod\"][\"output\"], symbol>> {\n  const shape = schema._zod.def.shape;\n  return literal(Object.keys(shape)) as any;\n}\n\n// ZodObject\n\nexport interface ZodObject<\n  /** @ts-ignore Cast variance */\n  out Shape extends core.$ZodShape = core.$ZodLooseShape,\n  out Config extends core.$ZodObjectConfig = core.$strip,\n> extends _ZodType<core.$ZodObjectInternals<Shape, Config>>,\n    core.$ZodObject<Shape, Config> {\n  shape: Shape;\n\n  keyof(): ZodEnum<util.ToEnum<keyof Shape & string>>;\n  /** Define a schema to validate all unrecognized keys. This overrides the existing strict/loose behavior. */\n  catchall<T extends core.SomeType>(schema: T): ZodObject<Shape, core.$catchall<T>>;\n\n  /** @deprecated Use `z.looseObject()` or `.loose()` instead. */\n  passthrough(): ZodObject<Shape, core.$loose>;\n  /** Consider `z.looseObject(A.shape)` instead */\n  loose(): ZodObject<Shape, core.$loose>;\n\n  /** Consider `z.strictObject(A.shape)` instead */\n  strict(): ZodObject<Shape, core.$strict>;\n\n  /** This is the default behavior. This method call is likely unnecessary. */\n  strip(): ZodObject<Shape, core.$strip>;\n\n  extend<U extends core.$ZodLooseShape & Partial<Record<keyof Shape, core.SomeType>>>(\n    shape: U\n  ): ZodObject<util.Extend<Shape, U>, Config>;\n\n  /**\n   * @deprecated Use spread syntax and the `.shape` property to combine two object schemas:\n   *\n   * ```ts\n   * const A = z.object({ a: z.string() });\n   * const B = z.object({ b: z.number() });\n   *\n   * const C = z.object({\n   *    ...A.shape,\n   *    ...B.shape\n   * });\n   * ```\n   */\n  merge<U extends ZodObject>(other: U): ZodObject<util.Extend<Shape, U[\"shape\"]>, U[\"_zod\"][\"config\"]>;\n\n  pick<M extends util.Mask<keyof Shape>>(\n    mask: M\n  ): ZodObject<util.Flatten<Pick<Shape, Extract<keyof Shape, keyof M>>>, Config>;\n\n  omit<M extends util.Mask<keyof Shape>>(\n    mask: M\n  ): ZodObject<util.Flatten<Omit<Shape, Extract<keyof Shape, keyof M>>>, Config>;\n\n  partial(): ZodObject<\n    {\n      [k in keyof Shape]: ZodOptional<Shape[k]>;\n    },\n    Config\n  >;\n  partial<M extends util.Mask<keyof Shape>>(\n    mask: M\n  ): ZodObject<\n    {\n      [k in keyof Shape]: k extends keyof M\n        ? // Shape[k] extends OptionalInSchema\n          //   ? Shape[k]\n          //   :\n          ZodOptional<Shape[k]>\n        : Shape[k];\n    },\n    Config\n  >;\n\n  // required\n  required(): ZodObject<\n    {\n      [k in keyof Shape]: ZodNonOptional<Shape[k]>;\n    },\n    Config\n  >;\n  required<M extends util.Mask<keyof Shape>>(\n    mask: M\n  ): ZodObject<\n    {\n      [k in keyof Shape]: k extends keyof M ? ZodNonOptional<Shape[k]> : Shape[k];\n    },\n    Config\n  >;\n}\n\nexport const ZodObject: core.$constructor<ZodObject> = /*@__PURE__*/ core.$constructor(\"ZodObject\", (inst, def) => {\n  core.$ZodObject.init(inst, def);\n  ZodType.init(inst, def);\n\n  util.defineLazy(inst, \"shape\", () => def.shape);\n  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape)) as any;\n  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall: catchall as any as core.$ZodType }) as any;\n  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  // inst.nonstrict = () => inst.clone({ ...inst._zod.def, catchall: api.unknown() });\n  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });\n  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });\n\n  inst.extend = (incoming: any) => {\n    return util.extend(inst, incoming);\n  };\n  inst.merge = (other) => util.merge(inst, other);\n  inst.pick = (mask) => util.pick(inst, mask);\n  inst.omit = (mask) => util.omit(inst, mask);\n  inst.partial = (...args: any[]) => util.partial(ZodOptional, inst, args[0] as object);\n  inst.required = (...args: any[]) => util.required(ZodNonOptional, inst, args[0] as object);\n});\n\nexport function object<T extends core.$ZodLooseShape = Partial<Record<never, core.SomeType>>>(\n  shape?: T,\n  params?: string | core.$ZodObjectParams\n): ZodObject<util.Writeable<T>, core.$strip> {\n  const def: core.$ZodObjectDef = {\n    type: \"object\",\n    get shape() {\n      util.assignProp(this, \"shape\", { ...shape });\n      return this.shape;\n    },\n    ...util.normalizeParams(params),\n  };\n  return new ZodObject(def) as any;\n}\n\n// strictObject\n\nexport function strictObject<T extends core.$ZodLooseShape>(\n  shape: T,\n  params?: string | core.$ZodObjectParams\n): ZodObject<T, core.$strict> {\n  return new ZodObject({\n    type: \"object\",\n    get shape() {\n      util.assignProp(this, \"shape\", { ...shape });\n      return this.shape;\n    },\n    catchall: never(),\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// looseObject\n\nexport function looseObject<T extends core.$ZodLooseShape>(\n  shape: T,\n  params?: string | core.$ZodObjectParams\n): ZodObject<T, core.$loose> {\n  return new ZodObject({\n    type: \"object\",\n    get shape() {\n      util.assignProp(this, \"shape\", { ...shape });\n      return this.shape;\n    },\n    catchall: unknown(),\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodUnion\nexport interface ZodUnion<T extends readonly core.SomeType[] = readonly core.$ZodType[]>\n  extends _ZodType<core.$ZodUnionInternals<T>>,\n    core.$ZodUnion<T> {\n  options: T;\n}\nexport const ZodUnion: core.$constructor<ZodUnion> = /*@__PURE__*/ core.$constructor(\"ZodUnion\", (inst, def) => {\n  core.$ZodUnion.init(inst, def);\n  ZodType.init(inst, def);\n  inst.options = def.options;\n});\n\nexport function union<const T extends readonly core.SomeType[]>(\n  options: T,\n  params?: string | core.$ZodUnionParams\n): ZodUnion<T> {\n  return new ZodUnion({\n    type: \"union\",\n    options: options as any as core.$ZodType[],\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodDiscriminatedUnion\nexport interface ZodDiscriminatedUnion<Options extends readonly core.SomeType[] = readonly core.$ZodType[]>\n  extends ZodUnion<Options>,\n    core.$ZodDiscriminatedUnion<Options> {\n  _zod: core.$ZodDiscriminatedUnionInternals<Options>;\n}\nexport const ZodDiscriminatedUnion: core.$constructor<ZodDiscriminatedUnion> = /*@__PURE__*/ core.$constructor(\n  \"ZodDiscriminatedUnion\",\n  (inst, def) => {\n    ZodUnion.init(inst, def);\n    core.$ZodDiscriminatedUnion.init(inst, def);\n  }\n);\n\nexport function discriminatedUnion<\n  Types extends readonly [core.$ZodTypeDiscriminable, ...core.$ZodTypeDiscriminable[]],\n>(\n  discriminator: string,\n  options: Types,\n  params?: string | core.$ZodDiscriminatedUnionParams\n): ZodDiscriminatedUnion<Types> {\n  // const [options, params] = args;\n  return new ZodDiscriminatedUnion({\n    type: \"union\",\n    options,\n    discriminator,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodIntersection\nexport interface ZodIntersection<A extends core.SomeType = core.$ZodType, B extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodIntersectionInternals<A, B>>,\n    core.$ZodIntersection<A, B> {}\nexport const ZodIntersection: core.$constructor<ZodIntersection> = /*@__PURE__*/ core.$constructor(\n  \"ZodIntersection\",\n  (inst, def) => {\n    core.$ZodIntersection.init(inst, def);\n    ZodType.init(inst, def);\n  }\n);\n\nexport function intersection<T extends core.SomeType, U extends core.SomeType>(\n  left: T,\n  right: U\n): ZodIntersection<T, U> {\n  return new ZodIntersection({\n    type: \"intersection\",\n    left: left as any as core.$ZodType,\n    right: right as any as core.$ZodType,\n  }) as any;\n}\n\n// ZodTuple\nexport interface ZodTuple<\n  T extends util.TupleItems = readonly core.$ZodType[],\n  Rest extends core.SomeType | null = core.$ZodType | null,\n> extends _ZodType<core.$ZodTupleInternals<T, Rest>>,\n    core.$ZodTuple<T, Rest> {\n  rest<Rest extends core.SomeType = core.$ZodType>(rest: Rest): ZodTuple<T, Rest>;\n}\nexport const ZodTuple: core.$constructor<ZodTuple> = /*@__PURE__*/ core.$constructor(\"ZodTuple\", (inst, def) => {\n  core.$ZodTuple.init(inst, def);\n  ZodType.init(inst, def);\n  inst.rest = (rest) =>\n    inst.clone({\n      ...inst._zod.def,\n      rest: rest as any as core.$ZodType,\n    }) as any;\n});\n\nexport function tuple<T extends readonly [core.SomeType, ...core.SomeType[]]>(\n  items: T,\n  params?: string | core.$ZodTupleParams\n): ZodTuple<T, null>;\nexport function tuple<T extends readonly [core.SomeType, ...core.SomeType[]], Rest extends core.SomeType>(\n  items: T,\n  rest: Rest,\n  params?: string | core.$ZodTupleParams\n): ZodTuple<T, Rest>;\nexport function tuple(items: [], params?: string | core.$ZodTupleParams): ZodTuple<[], null>;\nexport function tuple(\n  items: core.SomeType[],\n  _paramsOrRest?: string | core.$ZodTupleParams | core.SomeType,\n  _params?: string | core.$ZodTupleParams\n) {\n  const hasRest = _paramsOrRest instanceof core.$ZodType;\n  const params = hasRest ? _params : _paramsOrRest;\n  const rest = hasRest ? _paramsOrRest : null;\n  return new ZodTuple({\n    type: \"tuple\",\n    items: items as any as core.$ZodType[],\n    rest,\n    ...util.normalizeParams(params),\n  });\n}\n\n// ZodRecord\nexport interface ZodRecord<\n  Key extends core.$ZodRecordKey = core.$ZodRecordKey,\n  Value extends core.SomeType = core.$ZodType,\n> extends _ZodType<core.$ZodRecordInternals<Key, Value>>,\n    core.$ZodRecord<Key, Value> {\n  keyType: Key;\n  valueType: Value;\n}\nexport const ZodRecord: core.$constructor<ZodRecord> = /*@__PURE__*/ core.$constructor(\"ZodRecord\", (inst, def) => {\n  core.$ZodRecord.init(inst, def);\n  ZodType.init(inst, def);\n\n  inst.keyType = def.keyType;\n  inst.valueType = def.valueType;\n});\n\nexport function record<Key extends core.$ZodRecordKey, Value extends core.SomeType>(\n  keyType: Key,\n  valueType: Value,\n  params?: string | core.$ZodRecordParams\n): ZodRecord<Key, Value> {\n  return new ZodRecord({\n    type: \"record\",\n    keyType,\n    valueType: valueType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n// type alksjf = core.output<core.$ZodRecordKey>;\nexport function partialRecord<Key extends core.$ZodRecordKey, Value extends core.SomeType>(\n  keyType: Key,\n  valueType: Value,\n  params?: string | core.$ZodRecordParams\n): ZodRecord<Key & core.$partial, Value> {\n  return new ZodRecord({\n    type: \"record\",\n    keyType: union([keyType, never()]),\n    valueType: valueType as any,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodMap\nexport interface ZodMap<Key extends core.SomeType = core.$ZodType, Value extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodMapInternals<Key, Value>>,\n    core.$ZodMap<Key, Value> {\n  keyType: Key;\n  valueType: Value;\n}\nexport const ZodMap: core.$constructor<ZodMap> = /*@__PURE__*/ core.$constructor(\"ZodMap\", (inst, def) => {\n  core.$ZodMap.init(inst, def);\n  ZodType.init(inst, def);\n  inst.keyType = def.keyType;\n  inst.valueType = def.valueType;\n});\n\nexport function map<Key extends core.SomeType, Value extends core.SomeType>(\n  keyType: Key,\n  valueType: Value,\n  params?: string | core.$ZodMapParams\n): ZodMap<Key, Value> {\n  return new ZodMap({\n    type: \"map\",\n    keyType: keyType as any as core.$ZodType,\n    valueType: valueType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodSet\nexport interface ZodSet<T extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodSetInternals<T>>,\n    core.$ZodSet<T> {\n  min(minSize: number, params?: string | core.$ZodCheckMinSizeParams): this;\n  /** */\n  nonempty(params?: string | core.$ZodCheckMinSizeParams): this;\n  max(maxSize: number, params?: string | core.$ZodCheckMaxSizeParams): this;\n  size(size: number, params?: string | core.$ZodCheckSizeEqualsParams): this;\n}\nexport const ZodSet: core.$constructor<ZodSet> = /*@__PURE__*/ core.$constructor(\"ZodSet\", (inst, def) => {\n  core.$ZodSet.init(inst, def);\n  ZodType.init(inst, def);\n\n  inst.min = (...args) => inst.check(core._minSize(...args));\n  inst.nonempty = (params) => inst.check(core._minSize(1, params));\n  inst.max = (...args) => inst.check(core._maxSize(...args));\n  inst.size = (...args) => inst.check(core._size(...args));\n});\n\nexport function set<Value extends core.SomeType>(\n  valueType: Value,\n  params?: string | core.$ZodSetParams\n): ZodSet<Value> {\n  return new ZodSet({\n    type: \"set\",\n    valueType: valueType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodEnum\nexport interface ZodEnum<\n  /** @ts-ignore Cast variance */\n  out T extends util.EnumLike = util.EnumLike,\n> extends _ZodType<core.$ZodEnumInternals<T>>,\n    core.$ZodEnum<T> {\n  enum: T;\n  options: Array<T[keyof T]>;\n\n  extract<const U extends readonly (keyof T)[]>(\n    values: U,\n    params?: string | core.$ZodEnumParams\n  ): ZodEnum<util.Flatten<Pick<T, U[number]>>>;\n  exclude<const U extends readonly (keyof T)[]>(\n    values: U,\n    params?: string | core.$ZodEnumParams\n  ): ZodEnum<util.Flatten<Omit<T, U[number]>>>;\n}\nexport const ZodEnum: core.$constructor<ZodEnum> = /*@__PURE__*/ core.$constructor(\"ZodEnum\", (inst, def) => {\n  core.$ZodEnum.init(inst, def);\n  ZodType.init(inst, def);\n\n  inst.enum = def.entries;\n  inst.options = Object.values(def.entries);\n\n  const keys = new Set(Object.keys(def.entries));\n\n  inst.extract = (values, params) => {\n    const newEntries: Record<string, any> = {};\n    for (const value of values) {\n      if (keys.has(value)) {\n        newEntries[value] = def.entries[value];\n      } else throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...util.normalizeParams(params),\n      entries: newEntries,\n    }) as any;\n  };\n\n  inst.exclude = (values, params) => {\n    const newEntries: Record<string, any> = { ...def.entries };\n    for (const value of values) {\n      if (keys.has(value)) {\n        delete newEntries[value];\n      } else throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...util.normalizeParams(params),\n      entries: newEntries,\n    }) as any;\n  };\n});\n\nfunction _enum<const T extends readonly string[]>(\n  values: T,\n  params?: string | core.$ZodEnumParams\n): ZodEnum<util.ToEnum<T[number]>>;\nfunction _enum<const T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodEnum<T>;\nfunction _enum(values: any, params?: string | core.$ZodEnumParams) {\n  const entries: any = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n\n  return new ZodEnum({\n    type: \"enum\",\n    entries,\n    ...util.normalizeParams(params),\n  }) as any;\n}\nexport { _enum as enum };\n\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport function nativeEnum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodEnum<T> {\n  return new ZodEnum({\n    type: \"enum\",\n    entries,\n    ...util.normalizeParams(params),\n  }) as any as ZodEnum<T>;\n}\n\n// ZodLiteral\nexport interface ZodLiteral<T extends util.Literal = util.Literal>\n  extends _ZodType<core.$ZodLiteralInternals<T>>,\n    core.$ZodLiteral<T> {\n  values: Set<T>;\n  /** @legacy Use `.values` instead. Accessing this property will throw an error if the literal accepts multiple values. */\n  value: T;\n}\nexport const ZodLiteral: core.$constructor<ZodLiteral> = /*@__PURE__*/ core.$constructor(\"ZodLiteral\", (inst, def) => {\n  core.$ZodLiteral.init(inst, def);\n  ZodType.init(inst, def);\n  inst.values = new Set(def.values);\n  Object.defineProperty(inst, \"value\", {\n    get() {\n      if (def.values.length > 1) {\n        throw new Error(\"This schema contains multiple valid literal values. Use `.values` instead.\");\n      }\n      return def.values[0];\n    },\n  });\n});\n\nexport function literal<const T extends ReadonlyArray<util.Literal>>(\n  value: T,\n  params?: string | core.$ZodLiteralParams\n): ZodLiteral<T[number]>;\nexport function literal<const T extends util.Literal>(\n  value: T,\n  params?: string | core.$ZodLiteralParams\n): ZodLiteral<T>;\nexport function literal(value: any, params: any) {\n  return new ZodLiteral({\n    type: \"literal\",\n    values: Array.isArray(value) ? value : [value],\n    ...util.normalizeParams(params),\n  });\n}\n\n// ZodFile\nexport interface ZodFile extends _ZodType<core.$ZodFileInternals>, core.$ZodFile {\n  min(size: number, params?: string | core.$ZodCheckMinSizeParams): this;\n  max(size: number, params?: string | core.$ZodCheckMaxSizeParams): this;\n  mime(types: util.MimeTypes | Array<util.MimeTypes>, params?: string | core.$ZodCheckMimeTypeParams): this;\n}\nexport const ZodFile: core.$constructor<ZodFile> = /*@__PURE__*/ core.$constructor(\"ZodFile\", (inst, def) => {\n  core.$ZodFile.init(inst, def);\n  ZodType.init(inst, def);\n\n  inst.min = (size, params) => inst.check(core._minSize(size, params));\n  inst.max = (size, params) => inst.check(core._maxSize(size, params));\n  inst.mime = (types, params) => inst.check(core._mime(Array.isArray(types) ? types : [types], params));\n});\n\nexport function file(params?: string | core.$ZodFileParams): ZodFile {\n  return core._file(ZodFile, params) as any;\n}\n\n// ZodTransform\nexport interface ZodTransform<O = unknown, I = unknown>\n  extends _ZodType<core.$ZodTransformInternals<O, I>>,\n    core.$ZodTransform<O, I> {}\nexport const ZodTransform: core.$constructor<ZodTransform> = /*@__PURE__*/ core.$constructor(\n  \"ZodTransform\",\n  (inst, def) => {\n    core.$ZodTransform.init(inst, def);\n    ZodType.init(inst, def);\n\n    inst._zod.parse = (payload, _ctx) => {\n      (payload as RefinementCtx).addIssue = (issue) => {\n        if (typeof issue === \"string\") {\n          payload.issues.push(util.issue(issue, payload.value, def));\n        } else {\n          // for Zod 3 backwards compatibility\n          const _issue = issue as any;\n\n          if (_issue.fatal) _issue.continue = false;\n          _issue.code ??= \"custom\";\n          _issue.input ??= payload.value;\n          _issue.inst ??= inst;\n          _issue.continue ??= true;\n          payload.issues.push(util.issue(_issue));\n        }\n      };\n\n      const output = def.transform(payload.value, payload);\n      if (output instanceof Promise) {\n        return output.then((output) => {\n          payload.value = output;\n          return payload;\n        });\n      }\n      payload.value = output;\n      return payload;\n    };\n  }\n);\n\nexport function transform<I = unknown, O = I>(\n  fn: (input: I, ctx: core.ParsePayload) => O\n): ZodTransform<Awaited<O>, I> {\n  return new ZodTransform({\n    type: \"transform\",\n    transform: fn as any,\n  }) as any;\n}\n\n// ZodOptional\nexport interface ZodOptional<T extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodOptionalInternals<T>>,\n    core.$ZodOptional<T> {\n  unwrap(): T;\n}\nexport const ZodOptional: core.$constructor<ZodOptional> = /*@__PURE__*/ core.$constructor(\n  \"ZodOptional\",\n  (inst, def) => {\n    core.$ZodOptional.init(inst, def);\n    ZodType.init(inst, def);\n\n    inst.unwrap = () => inst._zod.def.innerType;\n  }\n);\n\nexport function optional<T extends core.SomeType>(innerType: T): ZodOptional<T> {\n  return new ZodOptional({\n    type: \"optional\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}\n\n// ZodNullable\nexport interface ZodNullable<T extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodNullableInternals<T>>,\n    core.$ZodNullable<T> {\n  unwrap(): T;\n}\nexport const ZodNullable: core.$constructor<ZodNullable> = /*@__PURE__*/ core.$constructor(\n  \"ZodNullable\",\n  (inst, def) => {\n    core.$ZodNullable.init(inst, def);\n    ZodType.init(inst, def);\n\n    inst.unwrap = () => inst._zod.def.innerType;\n  }\n);\n\nexport function nullable<T extends core.SomeType>(innerType: T): ZodNullable<T> {\n  return new ZodNullable({\n    type: \"nullable\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}\n\n// nullish\nexport function nullish<T extends core.SomeType>(innerType: T): ZodOptional<ZodNullable<T>> {\n  return optional(nullable(innerType));\n}\n\n// ZodDefault\nexport interface ZodDefault<T extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodDefaultInternals<T>>,\n    core.$ZodDefault<T> {\n  unwrap(): T;\n  /** @deprecated Use `.unwrap()` instead. */\n  removeDefault(): T;\n}\nexport const ZodDefault: core.$constructor<ZodDefault> = /*@__PURE__*/ core.$constructor(\"ZodDefault\", (inst, def) => {\n  core.$ZodDefault.init(inst, def);\n  ZodType.init(inst, def);\n\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeDefault = inst.unwrap;\n});\n\nexport function _default<T extends core.SomeType>(\n  innerType: T,\n  defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)\n): ZodDefault<T> {\n  return new ZodDefault({\n    type: \"default\",\n    innerType: innerType as any as core.$ZodType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? (defaultValue as Function)() : defaultValue;\n    },\n  }) as any;\n}\n\n// ZodPrefault\nexport interface ZodPrefault<T extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodPrefaultInternals<T>>,\n    core.$ZodPrefault<T> {\n  unwrap(): T;\n}\nexport const ZodPrefault: core.$constructor<ZodPrefault> = /*@__PURE__*/ core.$constructor(\n  \"ZodPrefault\",\n  (inst, def) => {\n    core.$ZodPrefault.init(inst, def);\n    ZodType.init(inst, def);\n    inst.unwrap = () => inst._zod.def.innerType;\n  }\n);\n\nexport function prefault<T extends core.SomeType>(\n  innerType: T,\n  defaultValue: core.input<T> | (() => core.input<T>)\n): ZodPrefault<T> {\n  return new ZodPrefault({\n    type: \"prefault\",\n    innerType: innerType as any as core.$ZodType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? (defaultValue as Function)() : defaultValue;\n    },\n  }) as any;\n}\n\n// ZodNonOptional\nexport interface ZodNonOptional<T extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodNonOptionalInternals<T>>,\n    core.$ZodNonOptional<T> {\n  unwrap(): T;\n}\nexport const ZodNonOptional: core.$constructor<ZodNonOptional> = /*@__PURE__*/ core.$constructor(\n  \"ZodNonOptional\",\n  (inst, def) => {\n    core.$ZodNonOptional.init(inst, def);\n    ZodType.init(inst, def);\n\n    inst.unwrap = () => inst._zod.def.innerType;\n  }\n);\n\nexport function nonoptional<T extends core.SomeType>(\n  innerType: T,\n  params?: string | core.$ZodNonOptionalParams\n): ZodNonOptional<T> {\n  return new ZodNonOptional({\n    type: \"nonoptional\",\n    innerType: innerType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodSuccess\nexport interface ZodSuccess<T extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodSuccessInternals<T>>,\n    core.$ZodSuccess<T> {\n  unwrap(): T;\n}\nexport const ZodSuccess: core.$constructor<ZodSuccess> = /*@__PURE__*/ core.$constructor(\"ZodSuccess\", (inst, def) => {\n  core.$ZodSuccess.init(inst, def);\n  ZodType.init(inst, def);\n\n  inst.unwrap = () => inst._zod.def.innerType;\n});\n\nexport function success<T extends core.SomeType>(innerType: T): ZodSuccess<T> {\n  return new ZodSuccess({\n    type: \"success\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}\n\n// ZodCatch\nexport interface ZodCatch<T extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodCatchInternals<T>>,\n    core.$ZodCatch<T> {\n  unwrap(): T;\n  /** @deprecated Use `.unwrap()` instead. */\n  removeCatch(): T;\n}\nexport const ZodCatch: core.$constructor<ZodCatch> = /*@__PURE__*/ core.$constructor(\"ZodCatch\", (inst, def) => {\n  core.$ZodCatch.init(inst, def);\n  ZodType.init(inst, def);\n\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeCatch = inst.unwrap;\n});\n\nfunction _catch<T extends core.SomeType>(\n  innerType: T,\n  catchValue: core.output<T> | ((ctx: core.$ZodCatchCtx) => core.output<T>)\n): ZodCatch<T> {\n  return new ZodCatch({\n    type: \"catch\",\n    innerType: innerType as any as core.$ZodType,\n    catchValue: (typeof catchValue === \"function\" ? catchValue : () => catchValue) as (\n      ctx: core.$ZodCatchCtx\n    ) => core.output<T>,\n  }) as any;\n}\nexport { _catch as catch };\n\n// ZodNaN\nexport interface ZodNaN extends _ZodType<core.$ZodNaNInternals>, core.$ZodNaN {}\nexport const ZodNaN: core.$constructor<ZodNaN> = /*@__PURE__*/ core.$constructor(\"ZodNaN\", (inst, def) => {\n  core.$ZodNaN.init(inst, def);\n  ZodType.init(inst, def);\n});\n\nexport function nan(params?: string | core.$ZodNaNParams): ZodNaN {\n  return core._nan(ZodNaN, params);\n}\n\n// ZodPipe\nexport interface ZodPipe<A extends core.SomeType = core.$ZodType, B extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodPipeInternals<A, B>>,\n    core.$ZodPipe<A, B> {\n  in: A;\n  out: B;\n}\nexport const ZodPipe: core.$constructor<ZodPipe> = /*@__PURE__*/ core.$constructor(\"ZodPipe\", (inst, def) => {\n  core.$ZodPipe.init(inst, def);\n  ZodType.init(inst, def);\n\n  inst.in = def.in;\n  inst.out = def.out;\n});\n\nexport function pipe<\n  const A extends core.SomeType,\n  B extends core.$ZodType<unknown, core.output<A>> = core.$ZodType<unknown, core.output<A>>,\n>(in_: A, out: B | core.$ZodType<unknown, core.output<A>>): ZodPipe<A, B>;\nexport function pipe(in_: core.SomeType, out: core.SomeType) {\n  return new ZodPipe({\n    type: \"pipe\",\n    in: in_ as unknown as core.$ZodType,\n    out: out as unknown as core.$ZodType,\n    // ...util.normalizeParams(params),\n  });\n}\n\n// ZodReadonly\nexport interface ZodReadonly<T extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodReadonlyInternals<T>>,\n    core.$ZodReadonly<T> {}\nexport const ZodReadonly: core.$constructor<ZodReadonly> = /*@__PURE__*/ core.$constructor(\n  \"ZodReadonly\",\n  (inst, def) => {\n    core.$ZodReadonly.init(inst, def);\n    ZodType.init(inst, def);\n  }\n);\n\nexport function readonly<T extends core.SomeType>(innerType: T): ZodReadonly<T> {\n  return new ZodReadonly({\n    type: \"readonly\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}\n\n// ZodTemplateLiteral\nexport interface ZodTemplateLiteral<Template extends string = string>\n  extends _ZodType<core.$ZodTemplateLiteralInternals<Template>>,\n    core.$ZodTemplateLiteral<Template> {}\nexport const ZodTemplateLiteral: core.$constructor<ZodTemplateLiteral> = /*@__PURE__*/ core.$constructor(\n  \"ZodTemplateLiteral\",\n  (inst, def) => {\n    core.$ZodTemplateLiteral.init(inst, def);\n    ZodType.init(inst, def);\n  }\n);\n\nexport function templateLiteral<const Parts extends core.$ZodTemplateLiteralPart[]>(\n  parts: Parts,\n  params?: string | core.$ZodTemplateLiteralParams\n): ZodTemplateLiteral<core.$PartsToTemplateLiteral<Parts>> {\n  return new ZodTemplateLiteral({\n    type: \"template_literal\",\n    parts,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodLazy\nexport interface ZodLazy<T extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodLazyInternals<T>>,\n    core.$ZodLazy<T> {\n  unwrap(): T;\n}\nexport const ZodLazy: core.$constructor<ZodLazy> = /*@__PURE__*/ core.$constructor(\"ZodLazy\", (inst, def) => {\n  core.$ZodLazy.init(inst, def);\n  ZodType.init(inst, def);\n\n  inst.unwrap = () => inst._zod.def.getter();\n});\n\nexport function lazy<T extends core.SomeType>(getter: () => T): ZodLazy<T> {\n  return new ZodLazy({\n    type: \"lazy\",\n    getter: getter as any,\n  }) as any;\n}\n\n// ZodPromise\nexport interface ZodPromise<T extends core.SomeType = core.$ZodType>\n  extends _ZodType<core.$ZodPromiseInternals<T>>,\n    core.$ZodPromise<T> {\n  unwrap(): T;\n}\nexport const ZodPromise: core.$constructor<ZodPromise> = /*@__PURE__*/ core.$constructor(\"ZodPromise\", (inst, def) => {\n  core.$ZodPromise.init(inst, def);\n  ZodType.init(inst, def);\n\n  inst.unwrap = () => inst._zod.def.innerType;\n});\n\nexport function promise<T extends core.SomeType>(innerType: T): ZodPromise<T> {\n  return new ZodPromise({\n    type: \"promise\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}\n\n// ZodCustom\nexport interface ZodCustom<O = unknown, I = unknown>\n  extends _ZodType<core.$ZodCustomInternals<O, I>>,\n    core.$ZodCustom<O, I> {}\nexport const ZodCustom: core.$constructor<ZodCustom> = /*@__PURE__*/ core.$constructor(\"ZodCustom\", (inst, def) => {\n  core.$ZodCustom.init(inst, def);\n  ZodType.init(inst, def);\n});\n\n// custom checks\nexport function check<O = unknown>(fn: core.CheckFn<O>): core.$ZodCheck<O> {\n  const ch = new core.$ZodCheck({\n    check: \"custom\",\n    // ...util.normalizeParams(params),\n  });\n\n  ch._zod.check = fn;\n  return ch;\n}\n\nexport function custom<O>(\n  fn?: (data: unknown) => unknown,\n  _params?: string | core.$ZodCustomParams | undefined\n): ZodCustom<O, O> {\n  return core._custom(ZodCustom, fn ?? (() => true), _params) as any;\n}\n\nexport function refine<T>(\n  fn: (arg: NoInfer<T>) => util.MaybeAsync<unknown>,\n  _params: string | core.$ZodCustomParams = {}\n): core.$ZodCheck<T> {\n  return core._refine(ZodCustom, fn, _params);\n}\n\n// superRefine\nexport function superRefine<T>(fn: (arg: T, payload: RefinementCtx<T>) => void | Promise<void>): core.$ZodCheck<T> {\n  const ch = check<T>((payload) => {\n    (payload as RefinementCtx).addIssue = (issue) => {\n      if (typeof issue === \"string\") {\n        payload.issues.push(util.issue(issue, payload.value, ch._zod.def));\n      } else {\n        // for Zod 3 backwards compatibility\n        const _issue: any = issue;\n        if (_issue.fatal) _issue.continue = false;\n        _issue.code ??= \"custom\";\n        _issue.input ??= payload.value;\n        _issue.inst ??= ch;\n        _issue.continue ??= !ch._zod.def.abort;\n        payload.issues.push(util.issue(_issue));\n      }\n    };\n\n    return fn(payload.value, payload as RefinementCtx<T>);\n  });\n  return ch;\n}\n\ntype ZodInstanceOfParams = core.Params<\n  ZodCustom,\n  core.$ZodIssueCustom,\n  \"type\" | \"check\" | \"checks\" | \"fn\" | \"abort\" | \"error\" | \"params\" | \"path\"\n>;\nfunction _instanceof<T extends typeof util.Class>(\n  cls: T,\n  params: ZodInstanceOfParams = {\n    error: `Input not instance of ${cls.name}`,\n  }\n): ZodCustom<InstanceType<T>, InstanceType<T>> {\n  const inst = new ZodCustom({\n    type: \"custom\",\n    check: \"custom\",\n    fn: (data) => data instanceof cls,\n    abort: true,\n    ...(util.normalizeParams(params) as any),\n  });\n  inst._zod.bag.Class = cls;\n  return inst as any;\n}\nexport { _instanceof as instanceof };\n\n// stringbool\nexport const stringbool: (\n  _params?: string | core.$ZodStringBoolParams\n) => ZodPipe<ZodPipe<ZodString, ZodTransform<boolean, string>>, ZodBoolean> = (...args) =>\n  core._stringbool(\n    {\n      Pipe: ZodPipe,\n      Boolean: ZodBoolean,\n      String: ZodString,\n      Transform: ZodTransform,\n    },\n    ...args\n  ) as any;\n\n// json\ntype _ZodJSONSchema = ZodUnion<\n  [ZodString, ZodNumber, ZodBoolean, ZodNull, ZodArray<ZodJSONSchema>, ZodRecord<ZodString, ZodJSONSchema>]\n>;\ntype _ZodJSONSchemaInternals = _ZodJSONSchema[\"_zod\"];\n\nexport interface ZodJSONSchemaInternals extends _ZodJSONSchemaInternals {\n  output: util.JSONType;\n  input: util.JSONType;\n}\nexport interface ZodJSONSchema extends _ZodJSONSchema {\n  _zod: ZodJSONSchemaInternals;\n}\n\nexport function json(params?: string | core.$ZodCustomParams): ZodJSONSchema {\n  const jsonSchema: any = lazy(() => {\n    return union([string(params), number(), boolean(), _null(), array(jsonSchema), record(string(), jsonSchema)]);\n  });\n\n  return jsonSchema;\n}\n\n// preprocess\n\n// /** @deprecated Use `z.pipe()` and `z.transform()` instead. */\nexport function preprocess<A, U extends core.SomeType, B = unknown>(\n  fn: (arg: B, ctx: RefinementCtx) => A,\n  schema: U\n): ZodPipe<ZodTransform<A, B>, U> {\n  return pipe(transform(fn as any), schema as any) as any;\n}\n",
    "symbols": [
      {
        "name": "string",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 368,
        "endLine": 368
      },
      {
        "name": "string",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 369,
        "endLine": 369
      },
      {
        "name": "string",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 370,
        "endLine": 372
      },
      {
        "name": "email",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 395,
        "endLine": 397
      },
      {
        "name": "guid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 409,
        "endLine": 411
      },
      {
        "name": "uuid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 423,
        "endLine": 425
      },
      {
        "name": "uuidv4",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 427,
        "endLine": 429
      },
      {
        "name": "uuidv6",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 433,
        "endLine": 435
      },
      {
        "name": "uuidv7",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 439,
        "endLine": 441
      },
      {
        "name": "url",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 453,
        "endLine": 455
      },
      {
        "name": "emoji",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 467,
        "endLine": 469
      },
      {
        "name": "nanoid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 481,
        "endLine": 483
      },
      {
        "name": "cuid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 495,
        "endLine": 497
      },
      {
        "name": "cuid2",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 509,
        "endLine": 511
      },
      {
        "name": "ulid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 523,
        "endLine": 525
      },
      {
        "name": "xid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 537,
        "endLine": 539
      },
      {
        "name": "ksuid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 551,
        "endLine": 553
      },
      {
        "name": "ipv4",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 579,
        "endLine": 581
      },
      {
        "name": "ipv6",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 592,
        "endLine": 594
      },
      {
        "name": "cidrv4",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 605,
        "endLine": 607
      },
      {
        "name": "cidrv6",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 618,
        "endLine": 620
      },
      {
        "name": "base64",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 631,
        "endLine": 633
      },
      {
        "name": "base64url",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 647,
        "endLine": 649
      },
      {
        "name": "e164",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 661,
        "endLine": 663
      },
      {
        "name": "jwt",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 675,
        "endLine": 677
      },
      {
        "name": "stringFormat",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 693,
        "endLine": 699
      },
      {
        "name": "number",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 770,
        "endLine": 772
      },
      {
        "name": "int",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 788,
        "endLine": 790
      },
      {
        "name": "float32",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 794,
        "endLine": 796
      },
      {
        "name": "float64",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 800,
        "endLine": 802
      },
      {
        "name": "int32",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 806,
        "endLine": 808
      },
      {
        "name": "uint32",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 812,
        "endLine": 814
      },
      {
        "name": "boolean",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 824,
        "endLine": 826
      },
      {
        "name": "bigint",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 874,
        "endLine": 876
      },
      {
        "name": "int64",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 892,
        "endLine": 894
      },
      {
        "name": "uint64",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 897,
        "endLine": 899
      },
      {
        "name": "symbol",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 908,
        "endLine": 910
      },
      {
        "name": "_undefined",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 922,
        "endLine": 924
      },
      {
        "name": "_null",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 934,
        "endLine": 936
      },
      {
        "name": "any",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 946,
        "endLine": 948
      },
      {
        "name": "unknown",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 957,
        "endLine": 959
      },
      {
        "name": "never",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 968,
        "endLine": 970
      },
      {
        "name": "_void",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 979,
        "endLine": 981
      },
      {
        "name": "date",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1008,
        "endLine": 1010
      },
      {
        "name": "array",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1037,
        "endLine": 1039
      },
      {
        "name": "keyof",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1042,
        "endLine": 1045
      },
      {
        "name": "object",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1159,
        "endLine": 1172
      },
      {
        "name": "strictObject",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1176,
        "endLine": 1189
      },
      {
        "name": "looseObject",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1193,
        "endLine": 1206
      },
      {
        "name": "union",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1220,
        "endLine": 1229
      },
      {
        "name": "discriminatedUnion",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1245,
        "endLine": 1259
      },
      {
        "name": "intersection",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1273,
        "endLine": 1282
      },
      {
        "name": "tuple",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1302,
        "endLine": 1305
      },
      {
        "name": "tuple",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1306,
        "endLine": 1310
      },
      {
        "name": "tuple",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1311,
        "endLine": 1311
      },
      {
        "name": "tuple",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1312,
        "endLine": 1326
      },
      {
        "name": "record",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1345,
        "endLine": 1356
      },
      {
        "name": "partialRecord",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1358,
        "endLine": 1369
      },
      {
        "name": "map",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1385,
        "endLine": 1396
      },
      {
        "name": "set",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1418,
        "endLine": 1427
      },
      {
        "name": "_enum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1487,
        "endLine": 1490
      },
      {
        "name": "_enum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1491,
        "endLine": 1491
      },
      {
        "name": "_enum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1492,
        "endLine": 1500
      },
      {
        "name": "nativeEnum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1510,
        "endLine": 1516
      },
      {
        "name": "literal",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1540,
        "endLine": 1543
      },
      {
        "name": "literal",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1544,
        "endLine": 1547
      },
      {
        "name": "literal",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1548,
        "endLine": 1554
      },
      {
        "name": "file",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1571,
        "endLine": 1573
      },
      {
        "name": "transform",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1615,
        "endLine": 1622
      },
      {
        "name": "optional",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1640,
        "endLine": 1645
      },
      {
        "name": "nullable",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1663,
        "endLine": 1668
      },
      {
        "name": "nullish",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1671,
        "endLine": 1673
      },
      {
        "name": "_default",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1691,
        "endLine": 1702
      },
      {
        "name": "prefault",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1719,
        "endLine": 1730
      },
      {
        "name": "nonoptional",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1748,
        "endLine": 1757
      },
      {
        "name": "success",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1772,
        "endLine": 1777
      },
      {
        "name": "_catch",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1795,
        "endLine": 1806
      },
      {
        "name": "nan",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1816,
        "endLine": 1818
      },
      {
        "name": "pipe",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1835,
        "endLine": 1838
      },
      {
        "name": "pipe",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1839,
        "endLine": 1846
      },
      {
        "name": "readonly",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1860,
        "endLine": 1865
      },
      {
        "name": "templateLiteral",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1879,
        "endLine": 1888
      },
      {
        "name": "lazy",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1903,
        "endLine": 1908
      },
      {
        "name": "promise",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1923,
        "endLine": 1928
      },
      {
        "name": "check",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1940,
        "endLine": 1948
      },
      {
        "name": "custom",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1950,
        "endLine": 1955
      },
      {
        "name": "refine",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1957,
        "endLine": 1962
      },
      {
        "name": "superRefine",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1965,
        "endLine": 1985
      },
      {
        "name": "_instanceof",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 1992,
        "endLine": 2007
      },
      {
        "name": "json",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 2038,
        "endLine": 2044
      },
      {
        "name": "preprocess",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/schemas.ts",
        "startLine": 2049,
        "endLine": 2054
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
    "content": "import * as checks from \"./checks.js\";\nimport type * as core from \"./core.js\";\nimport type * as errors from \"./errors.js\";\nimport * as schemas from \"./schemas.js\";\nimport * as util from \"./util.js\";\n\nexport type Params<\n  T extends schemas.$ZodType | checks.$ZodCheck,\n  IssueTypes extends errors.$ZodIssueBase,\n  OmitKeys extends keyof T[\"_zod\"][\"def\"] = never,\n> = util.Flatten<\n  Partial<\n    util.EmptyToNever<\n      Omit<T[\"_zod\"][\"def\"], OmitKeys> &\n        ([IssueTypes] extends [never]\n          ? {} // unknown\n          : {\n              error?: string | errors.$ZodErrorMap<IssueTypes> | undefined;\n              /** @deprecated This parameter is deprecated. Use `error` instead. */\n              message?: string | undefined; // supported in Zod 3\n            })\n    >\n  >\n>;\n\nexport type TypeParams<\n  T extends schemas.$ZodType = schemas.$ZodType & { _isst: never },\n  AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"checks\" | \"error\"> = never,\n> = Params<T, NonNullable<T[\"_zod\"][\"isst\"]>, \"type\" | \"checks\" | \"error\" | AlsoOmit>;\n\n// strips types that are not exposed in the public factory\n// incl. `error`, `check`\nexport type CheckParams<\n  T extends checks.$ZodCheck = checks.$ZodCheck, // & { _issc: never },\n  AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"check\" | \"error\"> = never,\n> = Params<T, NonNullable<T[\"_zod\"][\"issc\"]>, \"check\" | \"error\" | AlsoOmit>;\n\n// strips types that are not exposed in the public factory\n// incl. `type`, `checks`, `error`, `check`, `format`\nexport type StringFormatParams<\n  T extends schemas.$ZodStringFormat = schemas.$ZodStringFormat,\n  AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\"> = never,\n> = Params<\n  T,\n  NonNullable<T[\"_zod\"][\"isst\"] | T[\"_zod\"][\"issc\"]>,\n  \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\" | AlsoOmit\n>;\n\nexport type CheckStringFormatParams<\n  T extends schemas.$ZodStringFormat = schemas.$ZodStringFormat,\n  AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\"> = never,\n> = Params<T, NonNullable<T[\"_zod\"][\"issc\"]>, \"type\" | \"coerce\" | \"checks\" | \"error\" | \"check\" | \"format\" | AlsoOmit>;\n\nexport type CheckTypeParams<\n  T extends schemas.$ZodType & checks.$ZodCheck = schemas.$ZodType & checks.$ZodCheck,\n  AlsoOmit extends Exclude<keyof T[\"_zod\"][\"def\"], \"type\" | \"checks\" | \"error\" | \"check\"> = never,\n> = Params<T, NonNullable<T[\"_zod\"][\"isst\"] | T[\"_zod\"][\"issc\"]>, \"type\" | \"checks\" | \"error\" | \"check\" | AlsoOmit>;\n\n// String\nexport type $ZodStringParams = TypeParams<schemas.$ZodString<string>, \"coerce\">;\nexport function _string<T extends schemas.$ZodString>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodStringParams\n): T {\n  return new Class({\n    type: \"string\",\n    ...util.normalizeParams(params),\n  });\n}\n\nexport function _coercedString<T extends schemas.$ZodString>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodStringParams\n): T {\n  return new Class({\n    type: \"string\",\n    coerce: true,\n    ...util.normalizeParams(params),\n  });\n}\n\nexport type $ZodStringFormatParams = CheckTypeParams<schemas.$ZodStringFormat, \"format\" | \"coerce\">;\nexport type $ZodCheckStringFormatParams = CheckParams<checks.$ZodCheckStringFormat, \"format\">;\n// custom format\n\n// Email\nexport type $ZodEmailParams = StringFormatParams<schemas.$ZodEmail>;\nexport type $ZodCheckEmailParams = CheckStringFormatParams<schemas.$ZodEmail>;\nexport function _email<T extends schemas.$ZodEmail>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodEmailParams | $ZodCheckEmailParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"email\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// GUID\nexport type $ZodGUIDParams = StringFormatParams<schemas.$ZodGUID, \"pattern\">;\nexport type $ZodCheckGUIDParams = CheckStringFormatParams<schemas.$ZodGUID, \"pattern\">;\nexport function _guid<T extends schemas.$ZodGUID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodGUIDParams | $ZodCheckGUIDParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"guid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// UUID\nexport type $ZodUUIDParams = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDParams = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport function _uuid<T extends schemas.$ZodUUID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodUUIDParams | $ZodCheckUUIDParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// UUIDv4\nexport type $ZodUUIDv4Params = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDv4Params = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport function _uuidv4<T extends schemas.$ZodUUID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodUUIDv4Params | $ZodCheckUUIDv4Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    version: \"v4\",\n    ...util.normalizeParams(params),\n  });\n}\n\n// UUIDv6\nexport type $ZodUUIDv6Params = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDv6Params = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport function _uuidv6<T extends schemas.$ZodUUID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodUUIDv6Params | $ZodCheckUUIDv6Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    version: \"v6\",\n    ...util.normalizeParams(params),\n  });\n}\n\n// UUIDv7\nexport type $ZodUUIDv7Params = StringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport type $ZodCheckUUIDv7Params = CheckStringFormatParams<schemas.$ZodUUID, \"pattern\">;\nexport function _uuidv7<T extends schemas.$ZodUUID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodUUIDv7Params | $ZodCheckUUIDv7Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    version: \"v7\",\n    ...util.normalizeParams(params),\n  });\n}\n\n// URL\nexport type $ZodURLParams = StringFormatParams<schemas.$ZodURL>;\nexport type $ZodCheckURLParams = CheckStringFormatParams<schemas.$ZodURL>;\nexport function _url<T extends schemas.$ZodURL>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodURLParams | $ZodCheckURLParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"url\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// Emoji\nexport type $ZodEmojiParams = StringFormatParams<schemas.$ZodEmoji>;\nexport type $ZodCheckEmojiParams = CheckStringFormatParams<schemas.$ZodEmoji>;\nexport function _emoji<T extends schemas.$ZodEmoji>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodEmojiParams | $ZodCheckEmojiParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"emoji\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// NanoID\nexport type $ZodNanoIDParams = StringFormatParams<schemas.$ZodNanoID>;\nexport type $ZodCheckNanoIDParams = CheckStringFormatParams<schemas.$ZodNanoID>;\nexport function _nanoid<T extends schemas.$ZodNanoID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodNanoIDParams | $ZodCheckNanoIDParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"nanoid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// CUID\nexport type $ZodCUIDParams = StringFormatParams<schemas.$ZodCUID>;\nexport type $ZodCheckCUIDParams = CheckStringFormatParams<schemas.$ZodCUID>;\nexport function _cuid<T extends schemas.$ZodCUID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCUIDParams | $ZodCheckCUIDParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"cuid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// CUID2\nexport type $ZodCUID2Params = StringFormatParams<schemas.$ZodCUID2>;\nexport type $ZodCheckCUID2Params = CheckStringFormatParams<schemas.$ZodCUID2>;\nexport function _cuid2<T extends schemas.$ZodCUID2>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCUID2Params | $ZodCheckCUID2Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"cuid2\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// ULID\nexport type $ZodULIDParams = StringFormatParams<schemas.$ZodULID>;\nexport type $ZodCheckULIDParams = CheckStringFormatParams<schemas.$ZodULID>;\nexport function _ulid<T extends schemas.$ZodULID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodULIDParams | $ZodCheckULIDParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"ulid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// XID\nexport type $ZodXIDParams = StringFormatParams<schemas.$ZodXID>;\nexport type $ZodCheckXIDParams = CheckStringFormatParams<schemas.$ZodXID>;\nexport function _xid<T extends schemas.$ZodXID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodXIDParams | $ZodCheckXIDParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"xid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// KSUID\nexport type $ZodKSUIDParams = StringFormatParams<schemas.$ZodKSUID>;\nexport type $ZodCheckKSUIDParams = CheckStringFormatParams<schemas.$ZodKSUID>;\nexport function _ksuid<T extends schemas.$ZodKSUID>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodKSUIDParams | $ZodCheckKSUIDParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"ksuid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// IP\n// export type $ZodIPParams = StringFormatParams<schemas.$ZodIP, \"pattern\">;\n// export type $ZodCheckIPParams = CheckStringFormatParams<schemas.$ZodIP, \"pattern\">;\n// export function _ip<T extends schemas.$ZodIP>(\n//   Class: util.SchemaClass<T>,\n//   params?: string | $ZodIPParams | $ZodCheckIPParams\n// ): T {\n//   return new Class({\n//     type: \"string\",\n//     format: \"ip\",\n//     check: \"string_format\",\n//     abort: false,\n//     ...util.normalizeParams(params),\n//   });\n// }\n\n// IPv4\nexport type $ZodIPv4Params = StringFormatParams<schemas.$ZodIPv4, \"pattern\">;\nexport type $ZodCheckIPv4Params = CheckStringFormatParams<schemas.$ZodIPv4, \"pattern\">;\nexport function _ipv4<T extends schemas.$ZodIPv4>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodIPv4Params | $ZodCheckIPv4Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"ipv4\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// IPv6\nexport type $ZodIPv6Params = StringFormatParams<schemas.$ZodIPv6, \"pattern\">;\nexport type $ZodCheckIPv6Params = CheckStringFormatParams<schemas.$ZodIPv6, \"pattern\">;\nexport function _ipv6<T extends schemas.$ZodIPv6>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodIPv6Params | $ZodCheckIPv6Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"ipv6\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// CIDRv4\nexport type $ZodCIDRv4Params = StringFormatParams<schemas.$ZodCIDRv4, \"pattern\">;\nexport type $ZodCheckCIDRv4Params = CheckStringFormatParams<schemas.$ZodCIDRv4, \"pattern\">;\nexport function _cidrv4<T extends schemas.$ZodCIDRv4>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCIDRv4Params | $ZodCheckCIDRv4Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"cidrv4\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// CIDRv6\nexport type $ZodCIDRv6Params = StringFormatParams<schemas.$ZodCIDRv6, \"pattern\">;\nexport type $ZodCheckCIDRv6Params = CheckStringFormatParams<schemas.$ZodCIDRv6, \"pattern\">;\nexport function _cidrv6<T extends schemas.$ZodCIDRv6>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCIDRv6Params | $ZodCheckCIDRv6Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"cidrv6\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// Base64\nexport type $ZodBase64Params = StringFormatParams<schemas.$ZodBase64, \"pattern\">;\nexport type $ZodCheckBase64Params = CheckStringFormatParams<schemas.$ZodBase64, \"pattern\">;\nexport function _base64<T extends schemas.$ZodBase64>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBase64Params | $ZodCheckBase64Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"base64\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// base64url\nexport type $ZodBase64URLParams = StringFormatParams<schemas.$ZodBase64URL, \"pattern\">;\nexport type $ZodCheckBase64URLParams = CheckStringFormatParams<schemas.$ZodBase64URL, \"pattern\">;\nexport function _base64url<T extends schemas.$ZodBase64URL>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBase64URLParams | $ZodCheckBase64URLParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"base64url\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// E164\nexport type $ZodE164Params = StringFormatParams<schemas.$ZodE164>;\nexport type $ZodCheckE164Params = CheckStringFormatParams<schemas.$ZodE164>;\nexport function _e164<T extends schemas.$ZodE164>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodE164Params | $ZodCheckE164Params\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"e164\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\n// JWT\nexport type $ZodJWTParams = StringFormatParams<schemas.$ZodJWT, \"pattern\">;\nexport type $ZodCheckJWTParams = CheckStringFormatParams<schemas.$ZodJWT, \"pattern\">;\nexport function _jwt<T extends schemas.$ZodJWT>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodJWTParams | $ZodCheckJWTParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"jwt\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params),\n  });\n}\n\nexport const TimePrecision = {\n  Any: null,\n  Minute: -1,\n  Second: 0,\n  Millisecond: 3,\n  Microsecond: 6,\n} as const;\n// ISODateTime\nexport type $ZodISODateTimeParams = StringFormatParams<schemas.$ZodISODateTime, \"pattern\">;\nexport type $ZodCheckISODateTimeParams = CheckStringFormatParams<schemas.$ZodISODateTime, \"pattern\">;\nexport function _isoDateTime<T extends schemas.$ZodISODateTime>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodISODateTimeParams | $ZodCheckISODateTimeParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"datetime\",\n    check: \"string_format\",\n    offset: false,\n    local: false,\n    precision: null,\n    ...util.normalizeParams(params),\n  });\n}\n\n// ISODate\nexport type $ZodISODateParams = StringFormatParams<schemas.$ZodISODate, \"pattern\">;\nexport type $ZodCheckISODateParams = CheckStringFormatParams<schemas.$ZodISODate, \"pattern\">;\nexport function _isoDate<T extends schemas.$ZodISODate>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodISODateParams | $ZodCheckISODateParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"date\",\n    check: \"string_format\",\n    ...util.normalizeParams(params),\n  });\n}\n\n// ISOTime\nexport type $ZodISOTimeParams = StringFormatParams<schemas.$ZodISOTime, \"pattern\">;\nexport type $ZodCheckISOTimeParams = CheckStringFormatParams<schemas.$ZodISOTime, \"pattern\">;\nexport function _isoTime<T extends schemas.$ZodISOTime>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodISOTimeParams | $ZodCheckISOTimeParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"time\",\n    check: \"string_format\",\n    precision: null,\n    ...util.normalizeParams(params),\n  });\n}\n\n// ISODuration\nexport type $ZodISODurationParams = StringFormatParams<schemas.$ZodISODuration>;\nexport type $ZodCheckISODurationParams = CheckStringFormatParams<schemas.$ZodISODuration>;\nexport function _isoDuration<T extends schemas.$ZodISODuration>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodISODurationParams | $ZodCheckISODurationParams\n): T {\n  return new Class({\n    type: \"string\",\n    format: \"duration\",\n    check: \"string_format\",\n    ...util.normalizeParams(params),\n  });\n}\n\n// Number\nexport type $ZodNumberParams = TypeParams<schemas.$ZodNumber<number>, \"coerce\">;\nexport type $ZodNumberFormatParams = CheckTypeParams<schemas.$ZodNumberFormat, \"format\" | \"coerce\">;\nexport type $ZodCheckNumberFormatParams = CheckParams<checks.$ZodCheckNumberFormat, \"format\">;\nexport function _number<T extends schemas.$ZodNumber>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodNumberParams\n): T {\n  return new Class({\n    type: \"number\",\n    checks: [],\n    ...util.normalizeParams(params),\n  });\n}\n\nexport function _coercedNumber<T extends schemas.$ZodNumber>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodNumberParams\n): T {\n  return new Class({\n    type: \"number\",\n    coerce: true,\n    checks: [],\n    ...util.normalizeParams(params),\n  });\n}\n\nexport function _int<T extends schemas.$ZodNumberFormat>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCheckNumberFormatParams\n): T {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"safeint\",\n    ...util.normalizeParams(params),\n  });\n}\nexport function _float32<T extends schemas.$ZodNumberFormat>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCheckNumberFormatParams\n): T {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"float32\",\n    ...util.normalizeParams(params),\n  });\n}\nexport function _float64<T extends schemas.$ZodNumberFormat>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCheckNumberFormatParams\n): T {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"float64\",\n    ...util.normalizeParams(params),\n  });\n}\nexport function _int32<T extends schemas.$ZodNumberFormat>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCheckNumberFormatParams\n): T {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"int32\",\n    ...util.normalizeParams(params),\n  });\n}\nexport function _uint32<T extends schemas.$ZodNumberFormat>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodCheckNumberFormatParams\n): T {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"uint32\",\n    ...util.normalizeParams(params),\n  });\n}\n\n// Boolean\nexport type $ZodBooleanParams = TypeParams<schemas.$ZodBoolean<boolean>, \"coerce\">;\nexport function _boolean<T extends schemas.$ZodBoolean>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBooleanParams\n): T {\n  return new Class({\n    type: \"boolean\",\n    ...util.normalizeParams(params),\n  });\n}\nexport function _coercedBoolean<T extends schemas.$ZodBoolean>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBooleanParams\n): T {\n  return new Class({\n    type: \"boolean\",\n    coerce: true,\n    ...util.normalizeParams(params),\n  });\n}\n\n// BigInt\nexport type $ZodBigIntParams = TypeParams<schemas.$ZodBigInt<bigint>>;\nexport type $ZodBigIntFormatParams = CheckTypeParams<schemas.$ZodBigIntFormat, \"format\" | \"coerce\">;\nexport type $ZodCheckBigIntFormatParams = CheckParams<checks.$ZodCheckBigIntFormat, \"format\">;\nexport function _bigint<T extends schemas.$ZodBigInt>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBigIntParams\n): T {\n  return new Class({\n    type: \"bigint\",\n    ...util.normalizeParams(params),\n  });\n}\nexport function _coercedBigint<T extends schemas.$ZodBigInt>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBigIntParams\n): T {\n  return new Class({\n    type: \"bigint\",\n    coerce: true,\n    ...util.normalizeParams(params),\n  });\n}\n\nexport function _int64<T extends schemas.$ZodBigIntFormat>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBigIntFormatParams\n): T {\n  return new Class({\n    type: \"bigint\",\n    check: \"bigint_format\",\n    abort: false,\n    format: \"int64\",\n    ...util.normalizeParams(params),\n  });\n}\nexport function _uint64<T extends schemas.$ZodBigIntFormat>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodBigIntFormatParams\n): T {\n  return new Class({\n    type: \"bigint\",\n    check: \"bigint_format\",\n    abort: false,\n    format: \"uint64\",\n    ...util.normalizeParams(params),\n  });\n}\n\n// Symbol\nexport type $ZodSymbolParams = TypeParams<schemas.$ZodSymbol>;\nexport function _symbol<T extends schemas.$ZodSymbol>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodSymbolParams\n): T {\n  return new Class({\n    type: \"symbol\",\n    ...util.normalizeParams(params),\n  });\n}\n\n// Undefined\nexport type $ZodUndefinedParams = TypeParams<schemas.$ZodUndefined>;\nexport function _undefined<T extends schemas.$ZodUndefined>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodUndefinedParams\n): T {\n  return new Class({\n    type: \"undefined\",\n    ...util.normalizeParams(params),\n  });\n}\n\n// Null\nexport type $ZodNullParams = TypeParams<schemas.$ZodNull>;\nexport function _null<T extends schemas.$ZodNull>(Class: util.SchemaClass<T>, params?: string | $ZodNullParams): T {\n  return new Class({\n    type: \"null\",\n    ...util.normalizeParams(params),\n  });\n}\n\n// Any\nexport type $ZodAnyParams = TypeParams<schemas.$ZodAny>;\nexport function _any<T extends schemas.$ZodAny>(Class: util.SchemaClass<T>): T {\n  return new Class({\n    type: \"any\",\n  });\n}\n\n// Unknown\nexport type $ZodUnknownParams = TypeParams<schemas.$ZodUnknown>;\nexport function _unknown<T extends schemas.$ZodUnknown>(Class: util.SchemaClass<T>): T {\n  return new Class({\n    type: \"unknown\",\n  });\n}\n\n// Never\nexport type $ZodNeverParams = TypeParams<schemas.$ZodNever>;\nexport function _never<T extends schemas.$ZodNever>(Class: util.SchemaClass<T>, params?: string | $ZodNeverParams): T {\n  return new Class({\n    type: \"never\",\n    ...util.normalizeParams(params),\n  });\n}\n\n// Void\nexport type $ZodVoidParams = TypeParams<schemas.$ZodVoid>;\nexport function _void<T extends schemas.$ZodVoid>(Class: util.SchemaClass<T>, params?: string | $ZodVoidParams): T {\n  return new Class({\n    type: \"void\",\n    ...util.normalizeParams(params),\n  });\n}\n\n// Date\nexport type $ZodDateParams = TypeParams<schemas.$ZodDate, \"coerce\">;\nexport function _date<T extends schemas.$ZodDate>(Class: util.SchemaClass<T>, params?: string | $ZodDateParams): T {\n  return new Class({\n    type: \"date\",\n    ...util.normalizeParams(params),\n  });\n}\nexport function _coercedDate<T extends schemas.$ZodDate>(\n  Class: util.SchemaClass<T>,\n  params?: string | $ZodDateParams\n): T {\n  return new Class({\n    type: \"date\",\n    coerce: true,\n    ...util.normalizeParams(params),\n  });\n}\n\n// NaN\nexport type $ZodNaNParams = TypeParams<schemas.$ZodNaN>;\nexport function _nan<T extends schemas.$ZodNaN>(Class: util.SchemaClass<T>, params?: string | $ZodNaNParams): T {\n  return new Class({\n    type: \"nan\",\n    ...util.normalizeParams(params),\n  });\n}\n\n// export type $ZodCheckParams = CheckParams<checks.$ZodCheck, \"abort\">;\n\nexport type $ZodCheckLessThanParams = CheckParams<checks.$ZodCheckLessThan, \"inclusive\" | \"value\">;\nexport function _lt(\n  value: util.Numeric,\n  params?: string | $ZodCheckLessThanParams\n): checks.$ZodCheckLessThan<util.Numeric> {\n  return new checks.$ZodCheckLessThan({\n    check: \"less_than\",\n    ...util.normalizeParams(params),\n    value,\n    inclusive: false,\n  });\n}\n\nexport function _lte(\n  value: util.Numeric,\n  params?: string | $ZodCheckLessThanParams\n): checks.$ZodCheckLessThan<util.Numeric> {\n  return new checks.$ZodCheckLessThan({\n    check: \"less_than\",\n\n    ...util.normalizeParams(params),\n    value,\n    inclusive: true,\n  });\n}\nexport {\n  /** @deprecated Use `z.lte()` instead. */\n  _lte as _max,\n};\n\n// ZodCheckGreaterThan\nexport type $ZodCheckGreaterThanParams = CheckParams<checks.$ZodCheckGreaterThan, \"inclusive\" | \"value\">;\nexport function _gt(value: util.Numeric, params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {\n  return new checks.$ZodCheckGreaterThan({\n    check: \"greater_than\",\n\n    ...util.normalizeParams(params),\n    value,\n    inclusive: false,\n  });\n}\n\nexport function _gte(value: util.Numeric, params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {\n  return new checks.$ZodCheckGreaterThan({\n    check: \"greater_than\",\n    ...util.normalizeParams(params),\n    value,\n    inclusive: true,\n  });\n}\n\nexport {\n  /** @deprecated Use `z.gte()` instead. */\n  _gte as _min,\n};\n\nexport function _positive(params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {\n  return _gt(0, params);\n}\n\n// negative\nexport function _negative(params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan {\n  return _lt(0, params);\n}\n\n// nonpositive\nexport function _nonpositive(params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan {\n  return _lte(0, params);\n}\n\n// nonnegative\nexport function _nonnegative(params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {\n  return _gte(0, params);\n}\n\nexport type $ZodCheckMultipleOfParams = CheckParams<checks.$ZodCheckMultipleOf, \"value\">;\nexport function _multipleOf(\n  value: number | bigint,\n  params?: string | $ZodCheckMultipleOfParams\n): checks.$ZodCheckMultipleOf {\n  return new checks.$ZodCheckMultipleOf({\n    check: \"multiple_of\",\n    ...util.normalizeParams(params),\n    value,\n  });\n}\n\nexport type $ZodCheckMaxSizeParams = CheckParams<checks.$ZodCheckMaxSize, \"maximum\">;\nexport function _maxSize(\n  maximum: number,\n  params?: string | $ZodCheckMaxSizeParams\n): checks.$ZodCheckMaxSize<util.HasSize> {\n  return new checks.$ZodCheckMaxSize({\n    check: \"max_size\",\n    ...util.normalizeParams(params),\n    maximum,\n  });\n}\n\nexport type $ZodCheckMinSizeParams = CheckParams<checks.$ZodCheckMinSize, \"minimum\">;\nexport function _minSize(\n  minimum: number,\n  params?: string | $ZodCheckMinSizeParams\n): checks.$ZodCheckMinSize<util.HasSize> {\n  return new checks.$ZodCheckMinSize({\n    check: \"min_size\",\n    ...util.normalizeParams(params),\n    minimum,\n  });\n}\n\nexport type $ZodCheckSizeEqualsParams = CheckParams<checks.$ZodCheckSizeEquals, \"size\">;\nexport function _size(\n  size: number,\n  params?: string | $ZodCheckSizeEqualsParams\n): checks.$ZodCheckSizeEquals<util.HasSize> {\n  return new checks.$ZodCheckSizeEquals({\n    check: \"size_equals\",\n    ...util.normalizeParams(params),\n    size,\n  });\n}\n\nexport type $ZodCheckMaxLengthParams = CheckParams<checks.$ZodCheckMaxLength, \"maximum\">;\nexport function _maxLength(\n  maximum: number,\n  params?: string | $ZodCheckMaxLengthParams\n): checks.$ZodCheckMaxLength<util.HasLength> {\n  const ch = new checks.$ZodCheckMaxLength({\n    check: \"max_length\",\n    ...util.normalizeParams(params),\n    maximum,\n  });\n  return ch;\n}\n\nexport type $ZodCheckMinLengthParams = CheckParams<checks.$ZodCheckMinLength, \"minimum\">;\nexport function _minLength(\n  minimum: number,\n  params?: string | $ZodCheckMinLengthParams\n): checks.$ZodCheckMinLength<util.HasLength> {\n  return new checks.$ZodCheckMinLength({\n    check: \"min_length\",\n    ...util.normalizeParams(params),\n    minimum,\n  });\n}\n\nexport type $ZodCheckLengthEqualsParams = CheckParams<checks.$ZodCheckLengthEquals, \"length\">;\nexport function _length(\n  length: number,\n  params?: string | $ZodCheckLengthEqualsParams\n): checks.$ZodCheckLengthEquals<util.HasLength> {\n  return new checks.$ZodCheckLengthEquals({\n    check: \"length_equals\",\n    ...util.normalizeParams(params),\n    length,\n  });\n}\n\nexport type $ZodCheckRegexParams = CheckParams<checks.$ZodCheckRegex, \"format\" | \"pattern\">;\nexport function _regex(pattern: RegExp, params?: string | $ZodCheckRegexParams): checks.$ZodCheckRegex {\n  return new checks.$ZodCheckRegex({\n    check: \"string_format\",\n    format: \"regex\",\n    ...util.normalizeParams(params),\n    pattern,\n  });\n}\n\nexport type $ZodCheckLowerCaseParams = CheckParams<checks.$ZodCheckLowerCase, \"format\">;\nexport function _lowercase(params?: string | $ZodCheckLowerCaseParams): checks.$ZodCheckLowerCase {\n  return new checks.$ZodCheckLowerCase({\n    check: \"string_format\",\n    format: \"lowercase\",\n    ...util.normalizeParams(params),\n  });\n}\n\nexport type $ZodCheckUpperCaseParams = CheckParams<checks.$ZodCheckUpperCase, \"format\">;\n\nexport function _uppercase(params?: string | $ZodCheckUpperCaseParams): checks.$ZodCheckUpperCase {\n  return new checks.$ZodCheckUpperCase({\n    check: \"string_format\",\n    format: \"uppercase\",\n    ...util.normalizeParams(params),\n  });\n}\n\nexport type $ZodCheckIncludesParams = CheckParams<checks.$ZodCheckIncludes, \"includes\" | \"format\" | \"pattern\">;\nexport function _includes(includes: string, params?: string | $ZodCheckIncludesParams): checks.$ZodCheckIncludes {\n  return new checks.$ZodCheckIncludes({\n    check: \"string_format\",\n    format: \"includes\",\n    ...util.normalizeParams(params),\n    includes,\n  });\n}\nexport type $ZodCheckStartsWithParams = CheckParams<checks.$ZodCheckStartsWith, \"prefix\" | \"format\" | \"pattern\">;\nexport function _startsWith(prefix: string, params?: string | $ZodCheckStartsWithParams): checks.$ZodCheckStartsWith {\n  return new checks.$ZodCheckStartsWith({\n    check: \"string_format\",\n    format: \"starts_with\",\n    ...util.normalizeParams(params),\n    prefix,\n  });\n}\n\nexport type $ZodCheckEndsWithParams = CheckParams<checks.$ZodCheckEndsWith, \"suffix\" | \"format\" | \"pattern\">;\n\nexport function _endsWith(suffix: string, params?: string | $ZodCheckEndsWithParams): checks.$ZodCheckEndsWith {\n  return new checks.$ZodCheckEndsWith({\n    check: \"string_format\",\n    format: \"ends_with\",\n    ...util.normalizeParams(params),\n    suffix,\n  });\n}\n\nexport type $ZodCheckPropertyParams = CheckParams<checks.$ZodCheckProperty, \"property\" | \"schema\">;\nexport function _property<K extends string, T extends schemas.$ZodType>(\n  property: K,\n  schema: T,\n  params?: string | $ZodCheckPropertyParams\n): checks.$ZodCheckProperty<{ [k in K]: core.output<T> }> {\n  return new checks.$ZodCheckProperty({\n    check: \"property\",\n    property,\n    schema,\n    ...util.normalizeParams(params),\n  });\n}\n\nexport type $ZodCheckMimeTypeParams = CheckParams<checks.$ZodCheckMimeType, \"mime\">;\nexport function _mime(types: util.MimeTypes[], params?: string | $ZodCheckMimeTypeParams): checks.$ZodCheckMimeType {\n  return new checks.$ZodCheckMimeType({\n    check: \"mime_type\",\n    mime: types,\n    ...util.normalizeParams(params),\n  });\n}\n\nexport function _overwrite<T>(tx: (input: T) => T): checks.$ZodCheckOverwrite<T> {\n  return new checks.$ZodCheckOverwrite({\n    check: \"overwrite\",\n    tx,\n  }) as checks.$ZodCheckOverwrite<T>;\n}\n// normalize\nexport function _normalize(form?: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\" | (string & {})): checks.$ZodCheckOverwrite<string> {\n  return _overwrite((input) => input.normalize(form));\n}\n\n// trim\nexport function _trim(): checks.$ZodCheckOverwrite<string> {\n  return _overwrite((input) => input.trim());\n}\n// toLowerCase\nexport function _toLowerCase(): checks.$ZodCheckOverwrite<string> {\n  return _overwrite((input) => input.toLowerCase());\n}\n// toUpperCase\nexport function _toUpperCase(): checks.$ZodCheckOverwrite<string> {\n  return _overwrite((input) => input.toUpperCase());\n}\n\n///////  collections   ///////\n\n// Array\nexport type $ZodArrayParams = TypeParams<schemas.$ZodArray, \"element\">;\nexport function _array<T extends schemas.$ZodType>(\n  Class: util.SchemaClass<schemas.$ZodArray>,\n  element: T,\n  params?: string | $ZodArrayParams\n): schemas.$ZodArray<T> {\n  return new Class({\n    type: \"array\",\n    element,\n    // get element() {\n    //   return element;\n    // },\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\nexport type $ZodObjectParams = TypeParams<schemas.$ZodObject, \"shape\" | \"catchall\">;\n\n// ZodUnion\nexport type $ZodUnionParams = TypeParams<schemas.$ZodUnion, \"options\">;\nexport function _union<const T extends readonly schemas.$ZodObject[]>(\n  Class: util.SchemaClass<schemas.$ZodUnion>,\n  options: T,\n  params?: string | $ZodUnionParams\n): schemas.$ZodUnion<T> {\n  return new Class({\n    type: \"union\",\n    options,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodDiscriminatedUnion\nexport interface $ZodTypeDiscriminableInternals extends schemas.$ZodTypeInternals {\n  propValues: util.PropValues;\n}\n\nexport interface $ZodTypeDiscriminable extends schemas.$ZodType {\n  _zod: $ZodTypeDiscriminableInternals;\n}\nexport type $ZodDiscriminatedUnionParams = TypeParams<schemas.$ZodDiscriminatedUnion, \"options\" | \"discriminator\">;\nexport function _discriminatedUnion<Types extends [$ZodTypeDiscriminable, ...$ZodTypeDiscriminable[]]>(\n  Class: util.SchemaClass<schemas.$ZodDiscriminatedUnion>,\n  discriminator: string,\n  options: Types,\n  params?: string | $ZodDiscriminatedUnionParams\n): schemas.$ZodDiscriminatedUnion<Types> {\n  return new Class({\n    type: \"union\",\n    options,\n    discriminator,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodIntersection\nexport type $ZodIntersectionParams = TypeParams<schemas.$ZodIntersection, \"left\" | \"right\">;\nexport function _intersection<T extends schemas.$ZodObject, U extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodIntersection>,\n  left: T,\n  right: U\n): schemas.$ZodIntersection<T, U> {\n  return new Class({\n    type: \"intersection\",\n    left,\n    right,\n  }) as any;\n}\n\n// ZodTuple\nexport type $ZodTupleParams = TypeParams<schemas.$ZodTuple, \"items\" | \"rest\">;\nexport function _tuple<T extends readonly [schemas.$ZodType, ...schemas.$ZodType[]]>(\n  Class: util.SchemaClass<schemas.$ZodTuple>,\n  items: T,\n  params?: string | $ZodTupleParams\n): schemas.$ZodTuple<T, null>;\nexport function _tuple<T extends readonly [schemas.$ZodType, ...schemas.$ZodType[]], Rest extends schemas.$ZodType>(\n  Class: util.SchemaClass<schemas.$ZodTuple>,\n  items: T,\n  rest: Rest,\n  params?: string | $ZodTupleParams\n): schemas.$ZodTuple<T, Rest>;\n// export function _tuple(\n//   Class: util.SchemaClass<schemas.$ZodTuple>,\n//   items: [],\n//   params?: string | $ZodTupleParams\n// ): schemas.$ZodTuple<[], null>;\nexport function _tuple(\n  Class: util.SchemaClass<schemas.$ZodTuple>,\n  items: schemas.$ZodType[],\n  _paramsOrRest?: string | $ZodTupleParams | schemas.$ZodType,\n  _params?: string | $ZodTupleParams\n) {\n  const hasRest = _paramsOrRest instanceof schemas.$ZodType;\n  const params = hasRest ? _params : _paramsOrRest;\n  const rest = hasRest ? _paramsOrRest : null;\n  return new Class({\n    type: \"tuple\",\n    items,\n    rest,\n    ...util.normalizeParams(params),\n  });\n}\n\n// ZodRecord\nexport type $ZodRecordParams = TypeParams<schemas.$ZodRecord, \"keyType\" | \"valueType\">;\nexport function _record<Key extends schemas.$ZodRecordKey, Value extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodRecord>,\n  keyType: Key,\n  valueType: Value,\n  params?: string | $ZodRecordParams\n): schemas.$ZodRecord<Key, Value> {\n  return new Class({\n    type: \"record\",\n    keyType,\n    valueType,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodMap\nexport type $ZodMapParams = TypeParams<schemas.$ZodMap, \"keyType\" | \"valueType\">;\nexport function _map<Key extends schemas.$ZodObject, Value extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodMap>,\n  keyType: Key,\n  valueType: Value,\n  params?: string | $ZodMapParams\n): schemas.$ZodMap<Key, Value> {\n  return new Class({\n    type: \"map\",\n    keyType,\n    valueType,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodSet\nexport type $ZodSetParams = TypeParams<schemas.$ZodSet, \"valueType\">;\nexport function _set<Value extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodSet>,\n  valueType: Value,\n  params?: string | $ZodSetParams\n): schemas.$ZodSet<Value> {\n  return new Class({\n    type: \"set\",\n    valueType,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodEnum\nexport type $ZodEnumParams = TypeParams<schemas.$ZodEnum, \"entries\">;\nexport function _enum<const T extends string[]>(\n  Class: util.SchemaClass<schemas.$ZodEnum>,\n  values: T,\n  params?: string | $ZodEnumParams\n): schemas.$ZodEnum<util.ToEnum<T[number]>>;\nexport function _enum<T extends util.EnumLike>(\n  Class: util.SchemaClass<schemas.$ZodEnum>,\n  entries: T,\n  params?: string | $ZodEnumParams\n): schemas.$ZodEnum<T>;\nexport function _enum(Class: util.SchemaClass<schemas.$ZodEnum>, values: any, params?: string | $ZodEnumParams) {\n  const entries: any = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n  // if (Array.isArray(values)) {\n  //   for (const value of values) {\n  //     entries[value] = value;\n  //   }\n  // } else {\n  //   Object.assign(entries, values);\n  // }\n  // const entries: util.EnumLike = {};\n  // for (const val of values) {\n  //   entries[val] = val;\n  // }\n\n  return new Class({\n    type: \"enum\",\n    entries,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport function _nativeEnum<T extends util.EnumLike>(\n  Class: util.SchemaClass<schemas.$ZodEnum>,\n  entries: T,\n  params?: string | $ZodEnumParams\n): schemas.$ZodEnum<T> {\n  return new Class({\n    type: \"enum\",\n    entries,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodLiteral\nexport type $ZodLiteralParams = TypeParams<schemas.$ZodLiteral, \"values\">;\nexport function _literal<const T extends Array<util.Literal>>(\n  Class: util.SchemaClass<schemas.$ZodLiteral>,\n  value: T,\n  params?: string | $ZodLiteralParams\n): schemas.$ZodLiteral<T[number]>;\nexport function _literal<const T extends util.Literal>(\n  Class: util.SchemaClass<schemas.$ZodLiteral>,\n  value: T,\n  params?: string | $ZodLiteralParams\n): schemas.$ZodLiteral<T>;\nexport function _literal(Class: util.SchemaClass<schemas.$ZodLiteral>, value: any, params: any) {\n  return new Class({\n    type: \"literal\",\n    values: Array.isArray(value) ? value : [value],\n    ...util.normalizeParams(params),\n  });\n}\n\n// ZodFile\nexport type $ZodFileParams = TypeParams<schemas.$ZodFile>;\nexport function _file(Class: util.SchemaClass<schemas.$ZodFile>, params?: string | $ZodFileParams): schemas.$ZodFile {\n  return new Class({\n    type: \"file\",\n    ...util.normalizeParams(params),\n  });\n}\n\n// ZodTransform\nexport type $ZodTransformParams = TypeParams<schemas.$ZodTransform, \"transform\">;\nexport function _transform<I = unknown, O = I>(\n  Class: util.SchemaClass<schemas.$ZodTransform>,\n  fn: (input: I, ctx?: schemas.ParsePayload) => O\n): schemas.$ZodTransform<Awaited<O>, I> {\n  return new Class({\n    type: \"transform\",\n    transform: fn as any,\n  }) as any;\n}\n\n// ZodOptional\nexport type $ZodOptionalParams = TypeParams<schemas.$ZodOptional, \"innerType\">;\nexport function _optional<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodOptional>,\n  innerType: T\n): schemas.$ZodOptional<T> {\n  return new Class({\n    type: \"optional\",\n    innerType,\n  }) as any;\n}\n\n// ZodNullable\nexport type $ZodNullableParams = TypeParams<schemas.$ZodNullable, \"innerType\">;\nexport function _nullable<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodNullable>,\n  innerType: T\n): schemas.$ZodNullable<T> {\n  return new Class({\n    type: \"nullable\",\n    innerType,\n  }) as any;\n}\n\n// ZodDefault\nexport type $ZodDefaultParams = TypeParams<schemas.$ZodDefault, \"innerType\" | \"defaultValue\">;\nexport function _default<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodDefault>,\n  innerType: T,\n  defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)\n): schemas.$ZodDefault<T> {\n  return new Class({\n    type: \"default\",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? (defaultValue as Function)() : defaultValue;\n    },\n  }) as any;\n}\n\n// ZodNonOptional\nexport type $ZodNonOptionalParams = TypeParams<schemas.$ZodNonOptional, \"innerType\">;\nexport function _nonoptional<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodNonOptional>,\n  innerType: T,\n  params?: string | $ZodNonOptionalParams\n): schemas.$ZodNonOptional<T> {\n  return new Class({\n    type: \"nonoptional\",\n    innerType,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodSuccess\nexport type $ZodSuccessParams = TypeParams<schemas.$ZodSuccess, \"innerType\">;\nexport function _success<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodSuccess>,\n  innerType: T\n): schemas.$ZodSuccess<T> {\n  return new Class({\n    type: \"success\",\n    innerType,\n  }) as any;\n}\n\n// ZodCatch\nexport type $ZodCatchParams = TypeParams<schemas.$ZodCatch, \"innerType\" | \"catchValue\">;\nexport function _catch<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodCatch>,\n  innerType: T,\n  catchValue: core.output<T> | ((ctx: schemas.$ZodCatchCtx) => core.output<T>)\n): schemas.$ZodCatch<T> {\n  return new Class({\n    type: \"catch\",\n    innerType,\n    catchValue: (typeof catchValue === \"function\" ? catchValue : () => catchValue) as any,\n  }) as any;\n}\n\n// ZodPipe\nexport type $ZodPipeParams = TypeParams<schemas.$ZodPipe, \"in\" | \"out\">;\nexport function _pipe<\n  const A extends schemas.$ZodType,\n  B extends schemas.$ZodType<unknown, core.output<A>> = schemas.$ZodType<unknown, core.output<A>>,\n>(\n  Class: util.SchemaClass<schemas.$ZodPipe>,\n  in_: A,\n  out: B | schemas.$ZodType<unknown, core.output<A>>\n): schemas.$ZodPipe<A, B> {\n  return new Class({\n    type: \"pipe\",\n    in: in_,\n    out,\n  }) as any;\n}\n\n// ZodReadonly\nexport type $ZodReadonlyParams = TypeParams<schemas.$ZodReadonly, \"innerType\">;\nexport function _readonly<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodReadonly>,\n  innerType: T\n): schemas.$ZodReadonly<T> {\n  return new Class({\n    type: \"readonly\",\n    innerType,\n  }) as any;\n}\n\n// ZodTemplateLiteral\nexport type $ZodTemplateLiteralParams = TypeParams<schemas.$ZodTemplateLiteral, \"parts\">;\nexport function _templateLiteral<const Parts extends schemas.$ZodTemplateLiteralPart[]>(\n  Class: util.SchemaClass<schemas.$ZodTemplateLiteral>,\n  parts: Parts,\n  params?: string | $ZodTemplateLiteralParams\n): schemas.$ZodTemplateLiteral<schemas.$PartsToTemplateLiteral<Parts>> {\n  return new Class({\n    type: \"template_literal\",\n    parts,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodLazy\nexport type $ZodLazyParams = TypeParams<schemas.$ZodLazy, \"getter\">;\nexport function _lazy<T extends schemas.$ZodType>(\n  Class: util.SchemaClass<schemas.$ZodLazy>,\n  getter: () => T\n): schemas.$ZodLazy<T> {\n  return new Class({\n    type: \"lazy\",\n    getter,\n  }) as any;\n}\n\n// ZodPromise\nexport type $ZodPromiseParams = TypeParams<schemas.$ZodPromise, \"innerType\">;\nexport function _promise<T extends schemas.$ZodObject>(\n  Class: util.SchemaClass<schemas.$ZodPromise>,\n  innerType: T\n): schemas.$ZodPromise<T> {\n  return new Class({\n    type: \"promise\",\n    innerType,\n  }) as any;\n}\n\n// ZodCustom\nexport type $ZodCustomParams = CheckTypeParams<schemas.$ZodCustom, \"fn\">;\nexport function _custom<O = unknown, I = O>(\n  Class: util.SchemaClass<schemas.$ZodCustom>,\n  fn: (data: O) => unknown,\n  _params: string | $ZodCustomParams | undefined\n): schemas.$ZodCustom<O, I> {\n  const norm = util.normalizeParams(_params);\n  norm.abort ??= true; // default to abort:false\n  const schema = new Class({\n    type: \"custom\",\n    check: \"custom\",\n    fn: fn as any,\n    ...norm,\n  });\n\n  return schema as any;\n}\n\n// export function _refine<T>(\n//   Class: util.SchemaClass<schemas.$ZodCustom>,\n//   fn: (arg: NoInfer<T>) => util.MaybeAsync<unknown>,\n//   _params: string | $ZodCustomParams = {}\n// ): checks.$ZodCheck<T> {\n//   return _custom(Class, fn, _params);\n// }\n// same as _custom but defaults to abort:false\nexport function _refine<O = unknown, I = O>(\n  Class: util.SchemaClass<schemas.$ZodCustom>,\n  fn: (data: O) => unknown,\n  _params: string | $ZodCustomParams | undefined\n): schemas.$ZodCustom<O, I> {\n  const schema = new Class({\n    type: \"custom\",\n    check: \"custom\",\n    fn: fn as any,\n    ...util.normalizeParams(_params),\n  });\n\n  return schema as any;\n}\n\n// export type $ZodCustomParams = CheckTypeParams<schemas.$ZodCustom, \"fn\">\n\n/////////    STRINGBOOL   /////////\n\n// stringbool\nexport interface $ZodStringBoolParams extends TypeParams {\n  truthy?: string[];\n  falsy?: string[];\n  /**\n   * Options: `\"sensitive\"`, `\"insensitive\"`\n   *\n   * @default `\"insensitive\"`\n   */\n  case?: \"sensitive\" | \"insensitive\" | undefined;\n}\n\nexport function _stringbool(\n  Classes: {\n    Pipe?: typeof schemas.$ZodPipe;\n    Boolean?: typeof schemas.$ZodBoolean;\n    Transform?: typeof schemas.$ZodTransform;\n    String?: typeof schemas.$ZodString;\n  },\n  _params?: string | $ZodStringBoolParams\n): schemas.$ZodPipe<\n  schemas.$ZodPipe<schemas.$ZodString, schemas.$ZodTransform<boolean, string>>,\n  schemas.$ZodBoolean<boolean>\n> {\n  const params = util.normalizeParams(_params);\n\n  let truthyArray = params.truthy ?? [\"true\", \"1\", \"yes\", \"on\", \"y\", \"enabled\"];\n  let falsyArray = params.falsy ?? [\"false\", \"0\", \"no\", \"off\", \"n\", \"disabled\"];\n  if (params.case !== \"sensitive\") {\n    truthyArray = truthyArray.map((v) => (typeof v === \"string\" ? v.toLowerCase() : v));\n    falsyArray = falsyArray.map((v) => (typeof v === \"string\" ? v.toLowerCase() : v));\n  }\n\n  const truthySet = new Set(truthyArray);\n  const falsySet = new Set(falsyArray);\n\n  const _Pipe = Classes.Pipe ?? schemas.$ZodPipe;\n  const _Boolean = Classes.Boolean ?? schemas.$ZodBoolean;\n  const _String = Classes.String ?? schemas.$ZodString;\n  const _Transform = Classes.Transform ?? schemas.$ZodTransform;\n\n  const tx = new _Transform({\n    type: \"transform\",\n    transform: (input, payload: schemas.ParsePayload<unknown>) => {\n      let data: string = input as string;\n      if (params.case !== \"sensitive\") data = data.toLowerCase();\n      if (truthySet.has(data)) {\n        return true;\n      } else if (falsySet.has(data)) {\n        return false;\n      } else {\n        payload.issues.push({\n          code: \"invalid_value\",\n          expected: \"stringbool\",\n          values: [...truthySet, ...falsySet],\n          input: payload.value,\n          inst: tx,\n        });\n        return {} as never;\n      }\n    },\n    error: params.error,\n  });\n  // params.error;\n\n  const innerPipe = new _Pipe({\n    type: \"pipe\",\n    in: new _String({ type: \"string\", error: params.error }),\n    out: tx,\n    error: params.error,\n  });\n\n  const outerPipe = new _Pipe({\n    type: \"pipe\",\n    in: innerPipe,\n    out: new _Boolean({\n      type: \"boolean\",\n      error: params.error,\n    }),\n    error: params.error,\n  });\n  return outerPipe as any;\n}\n\nexport function _stringFormat<Format extends string>(\n  Class: typeof schemas.$ZodCustomStringFormat,\n  format: Format,\n  fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp,\n  _params: string | $ZodStringFormatParams = {}\n): schemas.$ZodCustomStringFormat<Format> {\n  const params = util.normalizeParams(_params);\n  const def: schemas.$ZodCustomStringFormatDef = {\n    ...util.normalizeParams(_params),\n    check: \"string_format\",\n    type: \"string\",\n    format,\n    fn: typeof fnOrRegex === \"function\" ? fnOrRegex : (val) => fnOrRegex.test(val),\n    ...params,\n  };\n  if (fnOrRegex instanceof RegExp) {\n    def.pattern = fnOrRegex;\n  }\n\n  const inst = new Class(def);\n  return inst as any;\n}\n",
    "symbols": [
      {
        "name": "_string",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 61,
        "endLine": 69
      },
      {
        "name": "_coercedString",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 71,
        "endLine": 80
      },
      {
        "name": "_email",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 89,
        "endLine": 100
      },
      {
        "name": "_guid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 105,
        "endLine": 116
      },
      {
        "name": "_uuid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 121,
        "endLine": 132
      },
      {
        "name": "_uuidv4",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 137,
        "endLine": 149
      },
      {
        "name": "_uuidv6",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 154,
        "endLine": 166
      },
      {
        "name": "_uuidv7",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 171,
        "endLine": 183
      },
      {
        "name": "_url",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 188,
        "endLine": 199
      },
      {
        "name": "_emoji",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 204,
        "endLine": 215
      },
      {
        "name": "_nanoid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 220,
        "endLine": 231
      },
      {
        "name": "_cuid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 236,
        "endLine": 247
      },
      {
        "name": "_cuid2",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 252,
        "endLine": 263
      },
      {
        "name": "_ulid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 268,
        "endLine": 279
      },
      {
        "name": "_xid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 284,
        "endLine": 295
      },
      {
        "name": "_ksuid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 300,
        "endLine": 311
      },
      {
        "name": "_ipv4",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 332,
        "endLine": 343
      },
      {
        "name": "_ipv6",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 348,
        "endLine": 359
      },
      {
        "name": "_cidrv4",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 364,
        "endLine": 375
      },
      {
        "name": "_cidrv6",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 380,
        "endLine": 391
      },
      {
        "name": "_base64",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 396,
        "endLine": 407
      },
      {
        "name": "_base64url",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 412,
        "endLine": 423
      },
      {
        "name": "_e164",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 428,
        "endLine": 439
      },
      {
        "name": "_jwt",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 444,
        "endLine": 455
      },
      {
        "name": "_isoDateTime",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 467,
        "endLine": 480
      },
      {
        "name": "_isoDate",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 485,
        "endLine": 495
      },
      {
        "name": "_isoTime",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 500,
        "endLine": 511
      },
      {
        "name": "_isoDuration",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 516,
        "endLine": 526
      },
      {
        "name": "_number",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 532,
        "endLine": 541
      },
      {
        "name": "_coercedNumber",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 543,
        "endLine": 553
      },
      {
        "name": "_int",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 555,
        "endLine": 566
      },
      {
        "name": "_float32",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 567,
        "endLine": 578
      },
      {
        "name": "_float64",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 579,
        "endLine": 590
      },
      {
        "name": "_int32",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 591,
        "endLine": 602
      },
      {
        "name": "_uint32",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 603,
        "endLine": 614
      },
      {
        "name": "_boolean",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 618,
        "endLine": 626
      },
      {
        "name": "_coercedBoolean",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 627,
        "endLine": 636
      },
      {
        "name": "_bigint",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 642,
        "endLine": 650
      },
      {
        "name": "_coercedBigint",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 651,
        "endLine": 660
      },
      {
        "name": "_int64",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 662,
        "endLine": 673
      },
      {
        "name": "_uint64",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 674,
        "endLine": 685
      },
      {
        "name": "_symbol",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 689,
        "endLine": 697
      },
      {
        "name": "_undefined",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 701,
        "endLine": 709
      },
      {
        "name": "_null",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 713,
        "endLine": 718
      },
      {
        "name": "_any",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 722,
        "endLine": 726
      },
      {
        "name": "_unknown",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 730,
        "endLine": 734
      },
      {
        "name": "_never",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 738,
        "endLine": 743
      },
      {
        "name": "_void",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 747,
        "endLine": 752
      },
      {
        "name": "_date",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 756,
        "endLine": 761
      },
      {
        "name": "_coercedDate",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 762,
        "endLine": 771
      },
      {
        "name": "_nan",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 775,
        "endLine": 780
      },
      {
        "name": "_lt",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 785,
        "endLine": 795
      },
      {
        "name": "_lte",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 797,
        "endLine": 808
      },
      {
        "name": "_gt",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 816,
        "endLine": 824
      },
      {
        "name": "_gte",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 826,
        "endLine": 833
      },
      {
        "name": "_positive",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 840,
        "endLine": 842
      },
      {
        "name": "_negative",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 845,
        "endLine": 847
      },
      {
        "name": "_nonpositive",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 850,
        "endLine": 852
      },
      {
        "name": "_nonnegative",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 855,
        "endLine": 857
      },
      {
        "name": "_multipleOf",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 860,
        "endLine": 869
      },
      {
        "name": "_maxSize",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 872,
        "endLine": 881
      },
      {
        "name": "_minSize",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 884,
        "endLine": 893
      },
      {
        "name": "_size",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 896,
        "endLine": 905
      },
      {
        "name": "_maxLength",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 908,
        "endLine": 918
      },
      {
        "name": "_minLength",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 921,
        "endLine": 930
      },
      {
        "name": "_length",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 933,
        "endLine": 942
      },
      {
        "name": "_regex",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 945,
        "endLine": 952
      },
      {
        "name": "_lowercase",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 955,
        "endLine": 961
      },
      {
        "name": "_uppercase",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 965,
        "endLine": 971
      },
      {
        "name": "_includes",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 974,
        "endLine": 981
      },
      {
        "name": "_startsWith",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 983,
        "endLine": 990
      },
      {
        "name": "_endsWith",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 994,
        "endLine": 1001
      },
      {
        "name": "_property",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1004,
        "endLine": 1015
      },
      {
        "name": "_mime",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1018,
        "endLine": 1024
      },
      {
        "name": "_overwrite",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1026,
        "endLine": 1031
      },
      {
        "name": "_normalize",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1033,
        "endLine": 1035
      },
      {
        "name": "_trim",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1038,
        "endLine": 1040
      },
      {
        "name": "_toLowerCase",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1042,
        "endLine": 1044
      },
      {
        "name": "_toUpperCase",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1046,
        "endLine": 1048
      },
      {
        "name": "_array",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1054,
        "endLine": 1067
      },
      {
        "name": "_union",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1073,
        "endLine": 1083
      },
      {
        "name": "_discriminatedUnion",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1094,
        "endLine": 1106
      },
      {
        "name": "_intersection",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1110,
        "endLine": 1120
      },
      {
        "name": "_tuple",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1124,
        "endLine": 1128
      },
      {
        "name": "_tuple",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1129,
        "endLine": 1134
      },
      {
        "name": "_tuple",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1140,
        "endLine": 1155
      },
      {
        "name": "_record",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1159,
        "endLine": 1171
      },
      {
        "name": "_map",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1175,
        "endLine": 1187
      },
      {
        "name": "_set",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1191,
        "endLine": 1201
      },
      {
        "name": "_enum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1205,
        "endLine": 1209
      },
      {
        "name": "_enum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1210,
        "endLine": 1214
      },
      {
        "name": "_enum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1215,
        "endLine": 1234
      },
      {
        "name": "_nativeEnum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1243,
        "endLine": 1253
      },
      {
        "name": "_literal",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1257,
        "endLine": 1261
      },
      {
        "name": "_literal",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1262,
        "endLine": 1266
      },
      {
        "name": "_literal",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1267,
        "endLine": 1273
      },
      {
        "name": "_file",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1277,
        "endLine": 1282
      },
      {
        "name": "_transform",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1286,
        "endLine": 1294
      },
      {
        "name": "_optional",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1298,
        "endLine": 1306
      },
      {
        "name": "_nullable",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1310,
        "endLine": 1318
      },
      {
        "name": "_default",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1322,
        "endLine": 1334
      },
      {
        "name": "_nonoptional",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1338,
        "endLine": 1348
      },
      {
        "name": "_success",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1352,
        "endLine": 1360
      },
      {
        "name": "_catch",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1364,
        "endLine": 1374
      },
      {
        "name": "_pipe",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1378,
        "endLine": 1391
      },
      {
        "name": "_readonly",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1395,
        "endLine": 1403
      },
      {
        "name": "_templateLiteral",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1407,
        "endLine": 1417
      },
      {
        "name": "_lazy",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1421,
        "endLine": 1429
      },
      {
        "name": "_promise",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1433,
        "endLine": 1441
      },
      {
        "name": "_custom",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1445,
        "endLine": 1460
      },
      {
        "name": "_refine",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1470,
        "endLine": 1483
      },
      {
        "name": "_stringbool",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1501,
        "endLine": 1571
      },
      {
        "name": "_stringFormat",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/api.ts",
        "startLine": 1573,
        "endLine": 1594
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/checks.ts",
    "content": "// import { $ZodType } from \"./schemas.js\";\n\nimport * as core from \"./core.js\";\nimport type * as errors from \"./errors.js\";\nimport * as regexes from \"./regexes.js\";\nimport type * as schemas from \"./schemas.js\";\nimport * as util from \"./util.js\";\n\n//////////////////////////////   CHECKS   ///////////////////////////////////////\n\nexport interface $ZodCheckDef {\n  check: string;\n  error?: errors.$ZodErrorMap<never> | undefined;\n  /** If true, no later checks will be executed if this check fails. Default `false`. */\n  abort?: boolean | undefined;\n  /** If provided, this check will only be executed if the function returns `true`. Defaults to `payload => z.util.isAborted(payload)`. */\n  when?: ((payload: schemas.ParsePayload) => boolean) | undefined;\n}\n\nexport interface $ZodCheckInternals<T> {\n  def: $ZodCheckDef;\n  /** The set of issues this check might throw. */\n  issc?: errors.$ZodIssueBase;\n  check(payload: schemas.ParsePayload<T>): util.MaybeAsync<void>;\n  onattach: ((schema: schemas.$ZodType) => void)[];\n}\n\nexport interface $ZodCheck<in T = never> {\n  _zod: $ZodCheckInternals<T>;\n}\n\nexport const $ZodCheck: core.$constructor<$ZodCheck<any>> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheck\",\n  (inst, def) => {\n    inst._zod ??= {} as any;\n    inst._zod.def = def;\n    inst._zod.onattach ??= [];\n  }\n);\n\n///////////////////////////////////////\n/////      $ZodCheckLessThan      /////\n///////////////////////////////////////\nexport interface $ZodCheckLessThanDef extends $ZodCheckDef {\n  check: \"less_than\";\n  value: util.Numeric;\n  inclusive: boolean;\n}\n\nexport interface $ZodCheckLessThanInternals<T extends util.Numeric = util.Numeric> extends $ZodCheckInternals<T> {\n  def: $ZodCheckLessThanDef;\n  issc: errors.$ZodIssueTooBig<T>;\n}\n\nconst numericOriginMap = {\n  number: \"number\",\n  bigint: \"bigint\",\n  object: \"date\",\n} as const;\nexport interface $ZodCheckLessThan<T extends util.Numeric = util.Numeric> extends $ZodCheck<T> {\n  _zod: $ZodCheckLessThanInternals<T>;\n}\n\nexport const $ZodCheckLessThan: core.$constructor<$ZodCheckLessThan> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckLessThan\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const origin = numericOriginMap[typeof def.value as \"number\" | \"bigint\" | \"object\"];\n\n    inst._zod.onattach.push((inst) => {\n      const bag = inst._zod.bag;\n      const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;\n      if (def.value < curr) {\n        if (def.inclusive) bag.maximum = def.value;\n        else bag.exclusiveMaximum = def.value;\n      }\n    });\n\n    inst._zod.check = (payload) => {\n      if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {\n        return;\n      }\n\n      payload.issues.push({\n        origin,\n        code: \"too_big\",\n        maximum: def.value as number,\n        input: payload.value,\n        inclusive: def.inclusive,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n/////////////////////////////////////\n/////    $ZodCheckGreaterThan    /////\n/////////////////////////////////////\nexport interface $ZodCheckGreaterThanDef extends $ZodCheckDef {\n  check: \"greater_than\";\n  value: util.Numeric;\n  inclusive: boolean;\n}\n\nexport interface $ZodCheckGreaterThanInternals<T extends util.Numeric = util.Numeric> extends $ZodCheckInternals<T> {\n  def: $ZodCheckGreaterThanDef;\n  issc: errors.$ZodIssueTooSmall<T>;\n}\n\nexport interface $ZodCheckGreaterThan<T extends util.Numeric = util.Numeric> extends $ZodCheck<T> {\n  _zod: $ZodCheckGreaterThanInternals<T>;\n}\n\nexport const $ZodCheckGreaterThan: core.$constructor<$ZodCheckGreaterThan> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckGreaterThan\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const origin = numericOriginMap[typeof def.value as \"number\" | \"bigint\" | \"object\"];\n\n    inst._zod.onattach.push((inst) => {\n      const bag = inst._zod.bag;\n      const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;\n      if (def.value > curr) {\n        if (def.inclusive) bag.minimum = def.value;\n        else bag.exclusiveMinimum = def.value;\n      }\n    });\n\n    inst._zod.check = (payload) => {\n      if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {\n        return;\n      }\n\n      payload.issues.push({\n        origin,\n        code: \"too_small\",\n        minimum: def.value as number,\n        input: payload.value,\n        inclusive: def.inclusive,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n/////////////////////////////////////\n/////    $ZodCheckMultipleOf    /////\n/////////////////////////////////////\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\n\nexport interface $ZodCheckMultipleOfDef<T extends number | bigint = number | bigint> extends $ZodCheckDef {\n  check: \"multiple_of\";\n  value: T;\n}\n\nexport interface $ZodCheckMultipleOfInternals<T extends number | bigint = number | bigint>\n  extends $ZodCheckInternals<T> {\n  def: $ZodCheckMultipleOfDef<T>;\n  issc: errors.$ZodIssueNotMultipleOf;\n}\n\nexport interface $ZodCheckMultipleOf<T extends number | bigint = number | bigint> extends $ZodCheck<T> {\n  _zod: $ZodCheckMultipleOfInternals<T>;\n}\n\nexport const $ZodCheckMultipleOf: core.$constructor<$ZodCheckMultipleOf<number | bigint>> =\n  /*@__PURE__*/ core.$constructor(\"$ZodCheckMultipleOf\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n\n    inst._zod.onattach.push((inst) => {\n      inst._zod.bag.multipleOf ??= def.value;\n    });\n\n    inst._zod.check = (payload) => {\n      if (typeof payload.value !== typeof def.value)\n        throw new Error(\"Cannot mix number and bigint in multiple_of check.\");\n      const isMultiple =\n        typeof payload.value === \"bigint\"\n          ? payload.value % (def.value as bigint) === BigInt(0)\n          : util.floatSafeRemainder(payload.value, def.value as number) === 0;\n\n      if (isMultiple) return;\n      payload.issues.push({\n        origin: typeof payload.value as \"number\",\n        code: \"not_multiple_of\",\n        divisor: def.value as number,\n        input: payload.value,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  });\n\n/////////////////////////////////////\n/////    $ZodCheckFinite    /////\n/////////////////////////////////////\n// interface $ZodCheckFiniteDef extends $ZodCheckDef {\n//   check: \"finite\";\n// }\n\n// export interface $ZodCheckFinite extends $ZodCheckInternals<number> {\n//   _def: $ZodCheckFiniteDef;\n//   _issc:\n//     | errors.$ZodIssueTooBig<\"number\", number>\n//     | errors.$ZodIssueTooSmall<\"number\", number>;\n// }\n\n// export const $ZodCheckFinite: core.$constructor<$ZodCheckFinite> =\n//   core.$constructor(\"$ZodCheckFinite\", (inst, def) => {\n//     $ZodCheck.init(inst, def);\n\n//     inst._zod.onattach = (inst) => {\n//       inst[\"_bag\"].finite = true;\n//     };\n\n//     inst._zod.check = (payload) => {\n//       if (Number.isFinite(payload.value)) return;\n//       payload.issues.push({\n//         origin: \"number\",\n//         ...(payload.value === Number.POSITIVE_INFINITY\n//           ? {\n//               code: \"too_big\",\n//               maximum: Number.POSITIVE_INFINITY,\n//             }\n//           : {\n//               code: \"too_small\",\n//               minimum: Number.NEGATIVE_INFINITY,\n//             }),\n//         // code: payload.value === Number.POSITIVE_INFINITY ? \"too_big\" : \"too_big\",\n//         // maximum: Number.POSITIVE_INFINITY,\n//         inclusive: false,\n//         input: payload.value,\n//         inst,\n//       });\n//     };\n//   });\n\n///////////////////////////////////////\n/////    $ZodCheckNumberFormat    /////\n///////////////////////////////////////\n\nexport type $ZodNumberFormats = \"int32\" | \"uint32\" | \"float32\" | \"float64\" | \"safeint\";\n\nexport interface $ZodCheckNumberFormatDef extends $ZodCheckDef {\n  check: \"number_format\";\n  format: $ZodNumberFormats;\n  // abort?: boolean;\n}\n\nexport interface $ZodCheckNumberFormatInternals extends $ZodCheckInternals<number> {\n  def: $ZodCheckNumberFormatDef;\n  issc: errors.$ZodIssueInvalidType | errors.$ZodIssueTooBig<\"number\"> | errors.$ZodIssueTooSmall<\"number\">;\n  // bag: util.LoosePartial<{\n  //   minimum?: number | undefined;\n  // }>;\n}\n\nexport interface $ZodCheckNumberFormat extends $ZodCheck<number> {\n  _zod: $ZodCheckNumberFormatInternals;\n}\n\nexport const $ZodCheckNumberFormat: core.$constructor<$ZodCheckNumberFormat> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckNumberFormat\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def); // no format checks\n    def.format = def.format || \"float64\";\n\n    const isInt = def.format?.includes(\"int\");\n    const origin = isInt ? \"int\" : \"number\";\n    const [minimum, maximum] = util.NUMBER_FORMAT_RANGES[def.format];\n\n    inst._zod.onattach.push((inst) => {\n      const bag = inst._zod.bag;\n      bag.format = def.format;\n      bag.minimum = minimum;\n      bag.maximum = maximum;\n      if (isInt) bag.pattern = regexes.integer;\n    });\n\n    inst._zod.check = (payload) => {\n      const input = payload.value;\n\n      if (isInt) {\n        if (!Number.isInteger(input)) {\n          // invalid_format issue\n          // payload.issues.push({\n          //   expected: def.format,\n          //   format: def.format,\n          //   code: \"invalid_format\",\n          //   input,\n          //   inst,\n          // });\n          // invalid_type issue\n          payload.issues.push({\n            expected: origin,\n            format: def.format,\n            code: \"invalid_type\",\n            input,\n            inst,\n          });\n\n          return;\n\n          // not_multiple_of issue\n          // payload.issues.push({\n          //   code: \"not_multiple_of\",\n          //   origin: \"number\",\n          //   input,\n          //   inst,\n          //   divisor: 1,\n          // });\n        }\n        if (!Number.isSafeInteger(input)) {\n          if (input > 0) {\n            // too_big\n            payload.issues.push({\n              input,\n              code: \"too_big\",\n              maximum: Number.MAX_SAFE_INTEGER,\n              note: \"Integers must be within the safe integer range.\",\n              inst,\n              origin,\n              continue: !def.abort,\n            });\n          } else {\n            // too_small\n            payload.issues.push({\n              input,\n              code: \"too_small\",\n              minimum: Number.MIN_SAFE_INTEGER,\n              note: \"Integers must be within the safe integer range.\",\n              inst,\n              origin,\n              continue: !def.abort,\n            });\n          }\n\n          return;\n        }\n      }\n\n      if (input < minimum) {\n        payload.issues.push({\n          origin: \"number\",\n          input,\n          code: \"too_small\",\n          minimum,\n          inclusive: true,\n          inst,\n          continue: !def.abort,\n        });\n      }\n\n      if (input > maximum) {\n        payload.issues.push({\n          origin: \"number\",\n          input,\n          code: \"too_big\",\n          maximum,\n          inst,\n        } as any);\n      }\n    };\n  }\n);\n\n/////////////////////////////////////\n/////    $ZodCheckBigIntFormat    /////\n/////////////////////////////////////\n\nexport type $ZodBigIntFormats = \"int64\" | \"uint64\";\n\nexport interface $ZodCheckBigIntFormatDef extends $ZodCheckDef {\n  check: \"bigint_format\";\n  format: $ZodBigIntFormats | undefined;\n}\n\nexport interface $ZodCheckBigIntFormatInternals extends $ZodCheckInternals<bigint> {\n  def: $ZodCheckBigIntFormatDef;\n  issc: errors.$ZodIssueTooBig<\"bigint\"> | errors.$ZodIssueTooSmall<\"bigint\">;\n}\n\nexport interface $ZodCheckBigIntFormat extends $ZodCheck<bigint> {\n  _zod: $ZodCheckBigIntFormatInternals;\n}\n\nexport const $ZodCheckBigIntFormat: core.$constructor<$ZodCheckBigIntFormat> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckBigIntFormat\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def); // no format checks\n\n    const [minimum, maximum] = util.BIGINT_FORMAT_RANGES[def.format!];\n\n    inst._zod.onattach.push((inst) => {\n      const bag = inst._zod.bag;\n      bag.format = def.format;\n      bag.minimum = minimum;\n      bag.maximum = maximum;\n    });\n\n    inst._zod.check = (payload) => {\n      const input = payload.value;\n\n      if (input < minimum) {\n        payload.issues.push({\n          origin: \"bigint\",\n          input,\n          code: \"too_small\",\n          minimum: minimum as any,\n          inclusive: true,\n          inst,\n          continue: !def.abort,\n        });\n      }\n\n      if (input > maximum) {\n        payload.issues.push({\n          origin: \"bigint\",\n          input,\n          code: \"too_big\",\n          maximum,\n          inst,\n        } as any);\n      }\n    };\n  }\n);\n\n//////////////////////////////////\n/////    $ZodCheckMaxSize    /////\n//////////////////////////////////\nexport interface $ZodCheckMaxSizeDef extends $ZodCheckDef {\n  check: \"max_size\";\n  maximum: number;\n}\n\nexport interface $ZodCheckMaxSizeInternals<T extends util.HasSize = util.HasSize> extends $ZodCheckInternals<T> {\n  def: $ZodCheckMaxSizeDef;\n  issc: errors.$ZodIssueTooBig<T>;\n}\n\nexport interface $ZodCheckMaxSize<T extends util.HasSize = util.HasSize> extends $ZodCheck<T> {\n  _zod: $ZodCheckMaxSizeInternals<T>;\n}\n\nexport const $ZodCheckMaxSize: core.$constructor<$ZodCheckMaxSize> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckMaxSize\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n\n    inst._zod.def.when ??= (payload) => {\n      const val = payload.value;\n      return !util.nullish(val) && (val as any).size !== undefined;\n    };\n\n    inst._zod.onattach.push((inst) => {\n      const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY) as number;\n      if (def.maximum < curr) inst._zod.bag.maximum = def.maximum;\n    });\n\n    inst._zod.check = (payload) => {\n      const input = payload.value;\n      const size = input.size;\n\n      if (size <= def.maximum) return;\n      payload.issues.push({\n        origin: util.getSizableOrigin(input),\n        code: \"too_big\",\n        maximum: def.maximum,\n        input,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n//////////////////////////////////\n/////    $ZodCheckMinSize    /////\n//////////////////////////////////\nexport interface $ZodCheckMinSizeDef extends $ZodCheckDef {\n  check: \"min_size\";\n  minimum: number;\n}\n\nexport interface $ZodCheckMinSizeInternals<T extends util.HasSize = util.HasSize> extends $ZodCheckInternals<T> {\n  def: $ZodCheckMinSizeDef;\n  issc: errors.$ZodIssueTooSmall<T>;\n}\n\nexport interface $ZodCheckMinSize<T extends util.HasSize = util.HasSize> extends $ZodCheck<T> {\n  _zod: $ZodCheckMinSizeInternals<T>;\n}\n\nexport const $ZodCheckMinSize: core.$constructor<$ZodCheckMinSize> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckMinSize\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n\n    inst._zod.def.when ??= (payload) => {\n      const val = payload.value;\n      return !util.nullish(val) && (val as any).size !== undefined;\n    };\n\n    inst._zod.onattach.push((inst) => {\n      const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY) as number;\n      if (def.minimum > curr) inst._zod.bag.minimum = def.minimum;\n    });\n\n    inst._zod.check = (payload) => {\n      const input = payload.value;\n      const size = input.size;\n\n      if (size >= def.minimum) return;\n      payload.issues.push({\n        origin: util.getSizableOrigin(input),\n        code: \"too_small\",\n        minimum: def.minimum,\n        input,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n/////////////////////////////////////\n/////    $ZodCheckSizeEquals    /////\n/////////////////////////////////////\nexport interface $ZodCheckSizeEqualsDef extends $ZodCheckDef {\n  check: \"size_equals\";\n  size: number;\n}\n\nexport interface $ZodCheckSizeEqualsInternals<T extends util.HasSize = util.HasSize> extends $ZodCheckInternals<T> {\n  def: $ZodCheckSizeEqualsDef;\n  issc: errors.$ZodIssueTooBig<T> | errors.$ZodIssueTooSmall<T>;\n}\n\nexport interface $ZodCheckSizeEquals<T extends util.HasSize = util.HasSize> extends $ZodCheck<T> {\n  _zod: $ZodCheckSizeEqualsInternals<T>;\n}\n\nexport const $ZodCheckSizeEquals: core.$constructor<$ZodCheckSizeEquals> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckSizeEquals\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n\n    inst._zod.def.when ??= (payload) => {\n      const val = payload.value;\n      return !util.nullish(val) && (val as any).size !== undefined;\n    };\n\n    inst._zod.onattach.push((inst) => {\n      const bag = inst._zod.bag;\n      bag.minimum = def.size;\n      bag.maximum = def.size;\n      bag.size = def.size;\n    });\n\n    inst._zod.check = (payload) => {\n      const input = payload.value;\n      const size = input.size;\n      if (size === def.size) return;\n\n      const tooBig = size > def.size;\n      payload.issues.push({\n        origin: util.getSizableOrigin(input),\n        ...(tooBig ? { code: \"too_big\", maximum: def.size } : { code: \"too_small\", minimum: def.size }),\n        inclusive: true,\n        exact: true,\n        input: payload.value,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n//////////////////////////////////\n/////    $ZodCheckMaxLength    /////\n//////////////////////////////////\n\nexport interface $ZodCheckMaxLengthDef extends $ZodCheckDef {\n  check: \"max_length\";\n  maximum: number;\n}\n\nexport interface $ZodCheckMaxLengthInternals<T extends util.HasLength = util.HasLength> extends $ZodCheckInternals<T> {\n  def: $ZodCheckMaxLengthDef;\n  issc: errors.$ZodIssueTooBig<T>;\n}\n\nexport interface $ZodCheckMaxLength<T extends util.HasLength = util.HasLength> extends $ZodCheck<T> {\n  _zod: $ZodCheckMaxLengthInternals<T>;\n}\n\nexport const $ZodCheckMaxLength: core.$constructor<$ZodCheckMaxLength> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckMaxLength\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n\n    inst._zod.def.when ??= (payload) => {\n      const val = payload.value;\n      return !util.nullish(val) && (val as any).length !== undefined;\n    };\n\n    inst._zod.onattach.push((inst) => {\n      const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY) as number;\n      if (def.maximum < curr) inst._zod.bag.maximum = def.maximum;\n    });\n\n    inst._zod.check = (payload) => {\n      const input = payload.value;\n      const length = input.length;\n\n      if (length <= def.maximum) return;\n      const origin = util.getLengthableOrigin(input);\n      payload.issues.push({\n        origin,\n        code: \"too_big\",\n        maximum: def.maximum,\n        inclusive: true,\n        input,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n//////////////////////////////////\n/////    $ZodCheckMinLength    /////\n//////////////////////////////////\nexport interface $ZodCheckMinLengthDef extends $ZodCheckDef {\n  check: \"min_length\";\n  minimum: number;\n}\n\nexport interface $ZodCheckMinLengthInternals<T extends util.HasLength = util.HasLength> extends $ZodCheckInternals<T> {\n  def: $ZodCheckMinLengthDef;\n  issc: errors.$ZodIssueTooSmall<T>;\n}\n\nexport interface $ZodCheckMinLength<T extends util.HasLength = util.HasLength> extends $ZodCheck<T> {\n  _zod: $ZodCheckMinLengthInternals<T>;\n}\n\nexport const $ZodCheckMinLength: core.$constructor<$ZodCheckMinLength> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckMinLength\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n\n    inst._zod.def.when ??= (payload) => {\n      const val = payload.value;\n      return !util.nullish(val) && (val as any).length !== undefined;\n    };\n\n    inst._zod.onattach.push((inst) => {\n      const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY) as number;\n      if (def.minimum > curr) inst._zod.bag.minimum = def.minimum;\n    });\n\n    inst._zod.check = (payload) => {\n      const input = payload.value;\n      const length = input.length;\n\n      if (length >= def.minimum) return;\n      const origin = util.getLengthableOrigin(input);\n      payload.issues.push({\n        origin,\n        code: \"too_small\",\n        minimum: def.minimum,\n        inclusive: true,\n        input,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n/////////////////////////////////////\n/////    $ZodCheckLengthEquals    /////\n/////////////////////////////////////\nexport interface $ZodCheckLengthEqualsDef extends $ZodCheckDef {\n  check: \"length_equals\";\n  length: number;\n}\n\nexport interface $ZodCheckLengthEqualsInternals<T extends util.HasLength = util.HasLength>\n  extends $ZodCheckInternals<T> {\n  def: $ZodCheckLengthEqualsDef;\n  issc: errors.$ZodIssueTooBig<T> | errors.$ZodIssueTooSmall<T>;\n}\n\nexport interface $ZodCheckLengthEquals<T extends util.HasLength = util.HasLength> extends $ZodCheck<T> {\n  _zod: $ZodCheckLengthEqualsInternals<T>;\n}\n\nexport const $ZodCheckLengthEquals: core.$constructor<$ZodCheckLengthEquals> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckLengthEquals\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n\n    inst._zod.def.when ??= (payload) => {\n      const val = payload.value;\n      return !util.nullish(val) && (val as any).length !== undefined;\n    };\n\n    inst._zod.onattach.push((inst) => {\n      const bag = inst._zod.bag;\n      bag.minimum = def.length;\n      bag.maximum = def.length;\n      bag.length = def.length;\n    });\n\n    inst._zod.check = (payload) => {\n      const input = payload.value;\n      const length = input.length;\n      if (length === def.length) return;\n      const origin = util.getLengthableOrigin(input);\n      const tooBig = length > def.length;\n      payload.issues.push({\n        origin,\n        ...(tooBig ? { code: \"too_big\", maximum: def.length } : { code: \"too_small\", minimum: def.length }),\n        inclusive: true,\n        exact: true,\n        input: payload.value,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n/////////////////////////////////////////////\n/////    $ZodCheckStringFormatRegex    /////\n/////////////////////////////////////////////\nexport type $ZodStringFormats =\n  | \"email\"\n  | \"url\"\n  | \"emoji\"\n  | \"uuid\"\n  | \"guid\"\n  | \"nanoid\"\n  | \"cuid\"\n  | \"cuid2\"\n  | \"ulid\"\n  | \"xid\"\n  | \"ksuid\"\n  | \"datetime\"\n  | \"date\"\n  | \"time\"\n  | \"duration\"\n  | \"ipv4\"\n  | \"ipv6\"\n  | \"cidrv4\"\n  | \"cidrv6\"\n  | \"base64\"\n  | \"base64url\"\n  | \"json_string\"\n  | \"e164\"\n  | \"lowercase\"\n  | \"uppercase\"\n  | \"regex\"\n  | \"jwt\"\n  | \"starts_with\"\n  | \"ends_with\"\n  | \"includes\";\nexport interface $ZodCheckStringFormatDef<Format extends string = string> extends $ZodCheckDef {\n  check: \"string_format\";\n  format: Format;\n  pattern?: RegExp | undefined;\n}\n\nexport interface $ZodCheckStringFormatInternals extends $ZodCheckInternals<string> {\n  def: $ZodCheckStringFormatDef;\n  issc: errors.$ZodIssueInvalidStringFormat;\n}\n\nexport interface $ZodCheckStringFormat extends $ZodCheck<string> {\n  _zod: $ZodCheckStringFormatInternals;\n}\n\nexport const $ZodCheckStringFormat: core.$constructor<$ZodCheckStringFormat> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckStringFormat\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n\n    inst._zod.onattach.push((inst) => {\n      const bag = inst._zod.bag as schemas.$ZodStringInternals<unknown>[\"bag\"];\n      bag.format = def.format;\n      if (def.pattern) {\n        bag.patterns ??= new Set();\n        bag.patterns.add(def.pattern);\n      }\n    });\n\n    if (def.pattern)\n      inst._zod.check ??= (payload) => {\n        def.pattern!.lastIndex = 0;\n        if (def.pattern!.test(payload.value)) return;\n        payload.issues.push({\n          origin: \"string\",\n          code: \"invalid_format\",\n          format: def.format,\n          input: payload.value,\n          ...(def.pattern ? { pattern: def.pattern.toString() } : {}),\n          inst,\n          continue: !def.abort,\n        });\n      };\n    else inst._zod.check ??= () => {};\n  }\n);\n\n////////////////////////////////\n/////    $ZodCheckRegex    /////\n////////////////////////////////\nexport interface $ZodCheckRegexDef extends $ZodCheckStringFormatDef {\n  format: \"regex\";\n  pattern: RegExp;\n}\n\nexport interface $ZodCheckRegexInternals extends $ZodCheckInternals<string> {\n  def: $ZodCheckRegexDef;\n  issc: errors.$ZodIssueInvalidStringFormat;\n}\n\nexport interface $ZodCheckRegex extends $ZodCheck<string> {\n  _zod: $ZodCheckRegexInternals;\n}\n\nexport const $ZodCheckRegex: core.$constructor<$ZodCheckRegex> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckRegex\",\n  (inst, def) => {\n    $ZodCheckStringFormat.init(inst, def);\n\n    inst._zod.check = (payload) => {\n      def.pattern.lastIndex = 0;\n      if (def.pattern.test(payload.value)) return;\n      payload.issues.push({\n        origin: \"string\",\n        code: \"invalid_format\",\n        format: \"regex\",\n        input: payload.value,\n        pattern: def.pattern.toString(),\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n///////////////////////////////////\n/////    $ZodCheckJSONString    /////\n///////////////////////////////////\n// interface $ZodCheckJSONStringDef extends $ZodCheckStringFormatDef<\"json_string\"> {\n//   // check: \"string_format\";\n//   // format: \"json_string\";\n//   // error?: errors.$ZodErrorMap<errors.$ZodIssueInvalidStringFormat> | undefined;\n// }\n\n// export interface $ZodCheckJSONString extends $ZodCheckStringFormat {\n//   _def: $ZodCheckJSONStringDef;\n// }\n\n// export const $ZodCheckJSONString: core.$constructor<$ZodCheckJSONString> = /*@__PURE__*/ core.$constructor(\n//   \"$ZodCheckJSONString\",\n//   (inst, def) => {\n//     $ZodCheck.init(inst, def);\n\n//     inst._zod.check = (payload) => {\n//       try {\n//         JSON.parse(payload.value);\n//         return;\n//       } catch (_) {\n//         payload.issues.push({\n//           origin: \"string\",\n//           code: \"invalid_format\",\n//           format: def.format,\n//           input: payload.value,\n//           inst,\n//           continue: !def.abort,\n//         });\n//       }\n//     };\n//   }\n// );\n\n//////////////////////////////////////\n/////    $ZodCheckLowerCase    /////\n//////////////////////////////////////\nexport interface $ZodCheckLowerCaseDef extends $ZodCheckStringFormatDef<\"lowercase\"> {}\n\nexport interface $ZodCheckLowerCaseInternals extends $ZodCheckInternals<string> {\n  def: $ZodCheckLowerCaseDef;\n  issc: errors.$ZodIssueInvalidStringFormat;\n}\n\nexport interface $ZodCheckLowerCase extends $ZodCheck<string> {\n  _zod: $ZodCheckLowerCaseInternals;\n}\n\nexport const $ZodCheckLowerCase: core.$constructor<$ZodCheckLowerCase> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckLowerCase\",\n  (inst, def) => {\n    def.pattern ??= regexes.lowercase;\n    $ZodCheckStringFormat.init(inst, def);\n  }\n);\n\n//////////////////////////////////////\n/////    $ZodCheckUpperCase    /////\n//////////////////////////////////////\nexport interface $ZodCheckUpperCaseDef extends $ZodCheckStringFormatDef<\"uppercase\"> {}\n\nexport interface $ZodCheckUpperCaseInternals extends $ZodCheckInternals<string> {\n  def: $ZodCheckUpperCaseDef;\n  issc: errors.$ZodIssueInvalidStringFormat;\n}\n\nexport interface $ZodCheckUpperCase extends $ZodCheck<string> {\n  _zod: $ZodCheckUpperCaseInternals;\n}\n\nexport const $ZodCheckUpperCase: core.$constructor<$ZodCheckUpperCase> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckUpperCase\",\n  (inst, def) => {\n    def.pattern ??= regexes.uppercase;\n    $ZodCheckStringFormat.init(inst, def);\n  }\n);\n\n///////////////////////////////////\n/////    $ZodCheckIncludes    /////\n///////////////////////////////////\nexport interface $ZodCheckIncludesDef extends $ZodCheckStringFormatDef<\"includes\"> {\n  includes: string;\n  position?: number | undefined;\n}\n\nexport interface $ZodCheckIncludesInternals extends $ZodCheckInternals<string> {\n  def: $ZodCheckIncludesDef;\n  issc: errors.$ZodIssueInvalidStringFormat;\n}\n\nexport interface $ZodCheckIncludes extends $ZodCheck<string> {\n  _zod: $ZodCheckIncludesInternals;\n}\n\nexport const $ZodCheckIncludes: core.$constructor<$ZodCheckIncludes> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckIncludes\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n\n    const escapedRegex = util.escapeRegex(def.includes);\n    const pattern = new RegExp(typeof def.position === \"number\" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);\n    def.pattern = pattern;\n    inst._zod.onattach.push((inst) => {\n      const bag = inst._zod.bag as schemas.$ZodStringInternals<unknown>[\"bag\"];\n      bag.patterns ??= new Set();\n      bag.patterns.add(pattern);\n    });\n\n    inst._zod.check = (payload) => {\n      if (payload.value.includes(def.includes, def.position)) return;\n      payload.issues.push({\n        origin: \"string\",\n        code: \"invalid_format\",\n        format: \"includes\",\n        includes: def.includes,\n        input: payload.value,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n/////////////////////////////////////\n/////    $ZodCheckStartsWith    /////\n/////////////////////////////////////\nexport interface $ZodCheckStartsWithDef extends $ZodCheckStringFormatDef<\"starts_with\"> {\n  prefix: string;\n}\n\nexport interface $ZodCheckStartsWithInternals extends $ZodCheckInternals<string> {\n  def: $ZodCheckStartsWithDef;\n  issc: errors.$ZodIssueInvalidStringFormat;\n}\n\nexport interface $ZodCheckStartsWith extends $ZodCheck<string> {\n  _zod: $ZodCheckStartsWithInternals;\n}\n\nexport const $ZodCheckStartsWith: core.$constructor<$ZodCheckStartsWith> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckStartsWith\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n\n    const pattern = new RegExp(`^${util.escapeRegex(def.prefix)}.*`);\n    def.pattern ??= pattern;\n    inst._zod.onattach.push((inst) => {\n      const bag = inst._zod.bag as schemas.$ZodStringInternals<unknown>[\"bag\"];\n      bag.patterns ??= new Set();\n      bag.patterns.add(pattern);\n    });\n\n    inst._zod.check = (payload) => {\n      if (payload.value.startsWith(def.prefix)) return;\n      payload.issues.push({\n        origin: \"string\",\n        code: \"invalid_format\",\n        format: \"starts_with\",\n        prefix: def.prefix,\n        input: payload.value,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n//////////////////////////////////\n/////   $ZodCheckEndsWith    /////\n//////////////////////////////////\nexport interface $ZodCheckEndsWithDef extends $ZodCheckStringFormatDef<\"ends_with\"> {\n  suffix: string;\n}\n\nexport interface $ZodCheckEndsWithInternals extends $ZodCheckInternals<string> {\n  def: $ZodCheckEndsWithDef;\n  issc: errors.$ZodIssueInvalidStringFormat;\n}\n\nexport interface $ZodCheckEndsWith extends $ZodCheckInternals<string> {\n  _zod: $ZodCheckEndsWithInternals;\n}\n\nexport const $ZodCheckEndsWith: core.$constructor<$ZodCheckEndsWith> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckEndsWith\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n\n    const pattern = new RegExp(`.*${util.escapeRegex(def.suffix)}$`);\n    def.pattern ??= pattern;\n    inst._zod.onattach.push((inst) => {\n      const bag = inst._zod.bag as schemas.$ZodStringInternals<unknown>[\"bag\"];\n      bag.patterns ??= new Set();\n      bag.patterns.add(pattern);\n    });\n\n    inst._zod.check = (payload) => {\n      if (payload.value.endsWith(def.suffix)) return;\n      payload.issues.push({\n        origin: \"string\",\n        code: \"invalid_format\",\n        format: \"ends_with\",\n        suffix: def.suffix,\n        input: payload.value,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n///////////////////////////////////\n/////    $ZodCheckProperty    /////\n///////////////////////////////////\nfunction handleCheckPropertyResult(\n  result: schemas.ParsePayload<unknown>,\n  payload: schemas.ParsePayload<unknown>,\n  property: string\n) {\n  if (result.issues.length) {\n    payload.issues.push(...util.prefixIssues(property, result.issues));\n  }\n}\nexport interface $ZodCheckPropertyDef extends $ZodCheckDef {\n  check: \"property\";\n  property: string;\n  schema: schemas.$ZodType;\n}\n\nexport interface $ZodCheckPropertyInternals<T extends object = object> extends $ZodCheckInternals<T> {\n  def: $ZodCheckPropertyDef;\n  issc: errors.$ZodIssue;\n}\n\nexport interface $ZodCheckProperty<T extends object = object> extends $ZodCheck<T> {\n  _zod: $ZodCheckPropertyInternals<T>;\n}\n\nexport const $ZodCheckProperty: core.$constructor<$ZodCheckProperty> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckProperty\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n\n    inst._zod.check = (payload) => {\n      const result = def.schema._zod.run(\n        {\n          value: (payload.value as any)[def.property],\n          issues: [],\n        },\n        {}\n      );\n\n      if (result instanceof Promise) {\n        return result.then((result) => handleCheckPropertyResult(result, payload, def.property));\n      }\n\n      handleCheckPropertyResult(result, payload, def.property);\n      return;\n    };\n  }\n);\n\n///////////////////////////////////\n/////    $ZodCheckMimeType    /////\n///////////////////////////////////\nexport interface $ZodCheckMimeTypeDef extends $ZodCheckDef {\n  check: \"mime_type\";\n  mime: util.MimeTypes[];\n}\n\nexport interface $ZodCheckMimeTypeInternals<T extends File = File> extends $ZodCheckInternals<T> {\n  def: $ZodCheckMimeTypeDef;\n  issc: errors.$ZodIssueInvalidValue;\n}\n\nexport interface $ZodCheckMimeType<T extends File = File> extends $ZodCheck<T> {\n  _zod: $ZodCheckMimeTypeInternals<T>;\n}\n\nexport const $ZodCheckMimeType: core.$constructor<$ZodCheckMimeType> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckMimeType\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const mimeSet = new Set(def.mime);\n    inst._zod.onattach.push((inst) => {\n      inst._zod.bag.mime = def.mime;\n    });\n    inst._zod.check = (payload) => {\n      if (mimeSet.has(payload.value.type)) return;\n      payload.issues.push({\n        code: \"invalid_value\",\n        values: def.mime,\n        input: payload.value.type,\n        inst,\n      });\n    };\n  }\n);\n\n///////////////////////////////////\n/////    $ZodCheckFileName    /////\n///////////////////////////////////\n// interface $ZodCheckFileNameDef extends $ZodCheckDef {\n//   check: \"file_name\";\n//   fileName: string;\n//   error?: errors.$ZodErrorMap<errors.$ZodIssueInvalidType> | undefined;\n// }\n// export interface $ZodCheckFileName<T extends File = File>\n//   extends $ZodCheckInternals<T> {\n//   _def: $ZodCheckFileNameDef;\n// }\n\n// export const $ZodCheckFileName: core.$constructor<$ZodCheckFileName> =\n//   core.$constructor(\"$ZodCheckFileName\", (inst, def) => {\n//     $ZodCheck.init(inst, def);\n\n//     inst._zod.check = (payload) => {\n//       if (def.fileName === payload.value.name) return;\n//       payload.issues.push({\n//         origin: \"file\",\n//         code: \"invalid_value\",\n//         options: [def.fileName],\n//         input: payload.value,\n//         path: [\"name\"],\n//         inst,\n//       });\n//     };\n//   });\n\n///////////////////////////////////\n/////    $ZodCheckOverwrite    /////\n///////////////////////////////////\nexport interface $ZodCheckOverwriteDef<T = unknown> extends $ZodCheckDef {\n  check: \"overwrite\";\n  tx(value: T): T;\n}\n\nexport interface $ZodCheckOverwriteInternals<T = unknown> extends $ZodCheckInternals<T> {\n  def: $ZodCheckOverwriteDef<T>;\n  issc: never;\n}\n\nexport interface $ZodCheckOverwrite<T = unknown> extends $ZodCheck<T> {\n  _zod: $ZodCheckOverwriteInternals<T>;\n}\n\nexport const $ZodCheckOverwrite: core.$constructor<$ZodCheckOverwrite> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCheckOverwrite\",\n  (inst, def) => {\n    $ZodCheck.init(inst, def);\n\n    inst._zod.check = (payload) => {\n      payload.value = def.tx(payload.value);\n    };\n  }\n);\n\n// ///////////////////////////////\n// /////    $ZodCheckTrim    /////\n// ///////////////////////////////\n// export interface $ZodCheckTrimDef extends $ZodCheckDef {\n//   check: \"trim\";\n//   error?: errors.$ZodErrorMap<never> | undefined;\n// }\n// export interface $ZodCheckTrim extends $ZodCheckInternals<string> {\n//   _def: $ZodCheckTrimDef;\n// }\n\n// export const $ZodCheckTrim: core.$constructor<$ZodCheckTrim> =\n//   core.$constructor(\"$ZodCheckTrim\", (inst, def) => {\n//     $ZodCheck.init(inst, def);\n\n//     inst._zod.check = (payload) => {\n//       payload.value = payload.value.trim();\n//     };\n//   });\n\n// //////////////////////////////////////\n// /////    $ZodCheckNormalize    /////\n// //////////////////////////////////////\n// interface $ZodCheckNormalizeDef extends $ZodCheckDef {\n//   check: \"normalize\";\n//   error?: errors.$ZodErrorMap<never> | undefined;\n// }\n\n// export interface $ZodCheckNormalize extends $ZodCheckInternals<string> {\n//   _def: $ZodCheckNormalizeDef;\n// }\n\n// export const $ZodCheckNormalize: core.$constructor<$ZodCheckNormalize> =\n//   core.$constructor(\"$ZodCheckNormalize\", (inst, def) => {\n//     $ZodCheck.init(inst, def);\n\n//     inst._zod.check = (payload) => {\n//       payload.value = payload.value.normalize();\n//     };\n//   });\n\nexport type $ZodChecks =\n  | $ZodCheckLessThan\n  | $ZodCheckGreaterThan\n  | $ZodCheckMultipleOf\n  | $ZodCheckNumberFormat\n  | $ZodCheckBigIntFormat\n  | $ZodCheckMaxSize\n  | $ZodCheckMinSize\n  | $ZodCheckSizeEquals\n  | $ZodCheckMaxLength\n  | $ZodCheckMinLength\n  | $ZodCheckLengthEquals\n  | $ZodCheckStringFormat\n  | $ZodCheckProperty\n  | $ZodCheckMimeType\n  | $ZodCheckOverwrite;\n\nexport type $ZodStringFormatChecks =\n  | $ZodCheckRegex\n  | $ZodCheckLowerCase\n  | $ZodCheckUpperCase\n  | $ZodCheckIncludes\n  | $ZodCheckStartsWith\n  | $ZodCheckEndsWith\n  | schemas.$ZodStringFormatTypes; // union of string format schema types\n",
    "symbols": [
      {
        "name": "handleCheckPropertyResult",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/checks.ts",
        "startLine": 1075,
        "endLine": 1083
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/config.ts",
    "content": "import type * as errors from \"./errors.js\";\n\nexport interface $ZodConfig {\n  /** Custom error map. Overrides `config().localeError`. */\n  customError?: errors.$ZodErrorMap | undefined;\n  /** Localized error map. Lowest priority. */\n  localeError?: errors.$ZodErrorMap | undefined;\n}\n\nexport const globalConfig: $ZodConfig = {};\n\nexport function config(config?: Partial<$ZodConfig>): $ZodConfig {\n  if (config) Object.assign(globalConfig, config);\n  return globalConfig;\n}\n",
    "symbols": [
      {
        "name": "config",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/config.ts",
        "startLine": 12,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/core.ts",
    "content": "import type * as errors from \"./errors.js\";\nimport type * as schemas from \"./schemas.js\";\nimport type { Class } from \"./util.js\";\n//////////////////////////////   CONSTRUCTORS   ///////////////////////////////////////\n\ntype ZodTrait = { _zod: { def: any; [k: string]: any } };\nexport interface $constructor<T extends ZodTrait, D = T[\"_zod\"][\"def\"]> {\n  new (def: D): T;\n  init(inst: T, def: D): asserts inst is T;\n}\n\n/** A special constant with type `never` */\nexport const NEVER: never = Object.freeze({\n  status: \"aborted\",\n}) as never;\n\nexport /*@__NO_SIDE_EFFECTS__*/ function $constructor<T extends ZodTrait, D = T[\"_zod\"][\"def\"]>(\n  name: string,\n  initializer: (inst: T, def: D) => void,\n  params?: { Parent?: typeof Class }\n): $constructor<T, D> {\n  function init(inst: T, def: D) {\n    Object.defineProperty(inst, \"_zod\", {\n      value: inst._zod ?? {},\n      enumerable: false,\n    });\n\n    inst._zod.traits ??= new Set();\n\n    inst._zod.traits.add(name);\n    initializer(inst, def);\n    // support prototype modifications\n    for (const k in _.prototype) {\n      if (!(k in inst)) Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });\n    }\n    inst._zod.constr = _;\n    inst._zod.def = def;\n  }\n\n  // doesn't work if Parent has a constructor with arguments\n  const Parent = params?.Parent ?? Object;\n  class Definition extends Parent {}\n  Object.defineProperty(Definition, \"name\", { value: name });\n\n  function _(this: any, def: D) {\n    const inst = params?.Parent ? new Definition() : this;\n    init(inst, def);\n    inst._zod.deferred ??= [];\n    for (const fn of inst._zod.deferred) {\n      fn();\n    }\n    return inst;\n  }\n\n  Object.defineProperty(_, \"init\", { value: init });\n  Object.defineProperty(_, Symbol.hasInstance, {\n    value: (inst: any) => {\n      if (params?.Parent && inst instanceof params.Parent) return true;\n      return inst?._zod?.traits?.has(name);\n    },\n  });\n  Object.defineProperty(_, \"name\", { value: name });\n  return _ as any;\n}\n\n//////////////////////////////   UTILITIES   ///////////////////////////////////////\nexport const $brand: unique symbol = Symbol(\"zod_brand\");\nexport type $brand<T extends string | number | symbol = string | number | symbol> = {\n  [$brand]: { [k in T]: true };\n};\n\nexport type $ZodBranded<T extends schemas.SomeType, Brand extends string | number | symbol> = T &\n  Record<\"_zod\", Record<\"output\", output<T> & $brand<Brand>>>;\n\nexport class $ZodAsyncError extends Error {\n  constructor() {\n    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n  }\n}\n\n////////////////////////////  TYPE HELPERS  ///////////////////////////////////\n\n// export type input<T extends schemas.$ZodType> = T[\"_zod\"][\"input\"];\n// export type output<T extends schemas.$ZodType> = T[\"_zod\"][\"output\"];\n// export type input<T extends schemas.$ZodType> = T[\"_zod\"][\"input\"];\n// export type output<T extends schemas.$ZodType> = T[\"_zod\"][\"output\"];\nexport type input<T> = T extends { _zod: { input: any } } ? Required<T[\"_zod\"]>[\"input\"] : unknown;\nexport type output<T> = T extends { _zod: { output: any } } ? Required<T[\"_zod\"]>[\"output\"] : unknown;\n\n// Mk2\n// export type input<T> = T extends { _zod: { \"~input\": any } }\n//   ? T[\"_zod\"][\"~input\"]\n//   : T extends { _zod: { input: any } }\n//     ? T[\"_zod\"][\"input\"]\n//     : never;\n// export type output<T> = T extends { _zod: { \"~output\": any } }\n//   ? T[\"_zod\"][\"~output\"]\n//   : T extends { _zod: { output: any } }\n//     ? T[\"_zod\"][\"output\"]\n//     : never;\n// Mk 3\n// export type input<T extends schemas.$ZodType> = T[\"_zod\"][\"input\"];\n// export type output<T extends schemas.$ZodType> = T[\"_zod\"][\"output\"];\n// Mk 4\n// export type input<T extends schemas.$ZodType> = T[] extends { _zod: { \"~input\": any } }\n//   ? T[\"_zod\"][\"~input\"]\n//   : T extends { _zod: { input: any } }\n//     ? T[\"_zod\"][\"input\"]\n//     : never;\n// export type output<T extends schemas.$ZodType> = T extends { _zod: { \"~output\": any } }\n//   ? T[\"_zod\"][\"~output\"]\n//   : T extends { _zod: { output: any } }\n//     ? T[\"_zod\"][\"output\"]\n//     : never;\n\nexport type { output as infer };\n\n//////////////////////////////   CONFIG   ///////////////////////////////////////\n\nexport interface $ZodConfig {\n  /** Custom error map. Overrides `config().localeError`. */\n  customError?: errors.$ZodErrorMap | undefined;\n  /** Localized error map. Lowest priority. */\n  localeError?: errors.$ZodErrorMap | undefined;\n  /** Disable JIT schema compilation. Useful in environments that disallow `eval`. */\n  jitless?: boolean | undefined;\n}\n\nexport const globalConfig: $ZodConfig = {};\n\nexport function config(newConfig?: Partial<$ZodConfig>): $ZodConfig {\n  if (newConfig) Object.assign(globalConfig, newConfig);\n  return globalConfig;\n}\n",
    "symbols": [
      {
        "name": "$constructor",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/core.ts",
        "startLine": 17,
        "endLine": 64
      },
      {
        "name": "init",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/core.ts",
        "startLine": 22,
        "endLine": 38
      },
      {
        "name": "Definition",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/core.ts",
        "startLine": 42,
        "endLine": 42
      },
      {
        "name": "_",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/core.ts",
        "startLine": 45,
        "endLine": 53
      },
      {
        "name": "$ZodAsyncError",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/core.ts",
        "startLine": 75,
        "endLine": 79
      },
      {
        "name": "config",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/core.ts",
        "startLine": 131,
        "endLine": 134
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/doc.ts",
    "content": "type ModeWriter = (doc: Doc, modes: { execution: \"sync\" | \"async\" }) => void;\n\nexport class Doc {\n  args!: string[];\n  content: string[] = [];\n  indent = 0;\n\n  constructor(args: string[] = []) {\n    if (this) this.args = args;\n  }\n\n  indented(fn: (doc: Doc) => void) {\n    this.indent += 1;\n    fn(this);\n    this.indent -= 1;\n  }\n\n  write(fn: ModeWriter): void;\n  write(line: string): void;\n  write(arg: any) {\n    if (typeof arg === \"function\") {\n      (arg as ModeWriter)(this, { execution: \"sync\" });\n      (arg as ModeWriter)(this, { execution: \"async\" });\n      return;\n    }\n\n    const content = arg as string;\n    const lines = content.split(\"\\n\").filter((x) => x);\n    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));\n    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => \" \".repeat(this.indent * 2) + x);\n    for (const line of dedented) {\n      this.content.push(line);\n    }\n  }\n\n  compile() {\n    const F = Function;\n    const args = this?.args;\n    const content = this?.content ?? [``];\n    const lines = [...content.map((x) => `  ${x}`)];\n    // console.log(lines.join(\"\\n\"));\n    return new F(...args, lines.join(\"\\n\"));\n  }\n}\n",
    "symbols": [
      {
        "name": "Doc",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/doc.ts",
        "startLine": 3,
        "endLine": 44
      },
      {
        "name": "Doc.indented",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/doc.ts",
        "startLine": 12,
        "endLine": 16
      },
      {
        "name": "Doc.write",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/doc.ts",
        "startLine": 20,
        "endLine": 34
      },
      {
        "name": "Doc.compile",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/doc.ts",
        "startLine": 36,
        "endLine": 43
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
    "content": "import type { $ZodCheck, $ZodStringFormats } from \"./checks.js\";\nimport { $constructor } from \"./core.js\";\nimport type { $ZodType } from \"./schemas.js\";\nimport * as util from \"./util.js\";\n\n///////////////////////////\n////     base type     ////\n///////////////////////////\nexport interface $ZodIssueBase {\n  readonly code?: string;\n  readonly input?: unknown;\n  readonly path: PropertyKey[];\n  readonly message: string;\n  // [k: string]: unknown;\n}\n\n////////////////////////////////\n////     issue subtypes     ////\n////////////////////////////////\nexport interface $ZodIssueInvalidType<Input = unknown> extends $ZodIssueBase {\n  readonly code: \"invalid_type\";\n  readonly expected: $ZodType[\"_zod\"][\"def\"][\"type\"];\n  readonly input: Input;\n}\n\nexport interface $ZodIssueTooBig<Input = unknown> extends $ZodIssueBase {\n  readonly code: \"too_big\";\n  readonly origin: \"number\" | \"int\" | \"bigint\" | \"date\" | \"string\" | \"array\" | \"set\" | \"file\" | (string & {});\n  readonly maximum: number | bigint;\n  readonly inclusive?: boolean;\n  readonly exact?: boolean;\n  readonly input: Input;\n}\n\nexport interface $ZodIssueTooSmall<Input = unknown> extends $ZodIssueBase {\n  readonly code: \"too_small\";\n  readonly origin: \"number\" | \"int\" | \"bigint\" | \"date\" | \"string\" | \"array\" | \"set\" | \"file\" | (string & {});\n  readonly minimum: number | bigint;\n  /** True if the allowable range includes the minimum */\n  readonly inclusive?: boolean;\n  /** True if the allowed value is fixed (e.g.` z.length(5)`), not a range (`z.minLength(5)`) */\n  readonly exact?: boolean;\n  readonly input: Input;\n}\n\nexport interface $ZodIssueInvalidStringFormat extends $ZodIssueBase {\n  readonly code: \"invalid_format\";\n  readonly format: $ZodStringFormats | (string & {});\n  readonly pattern?: string;\n  readonly input: string;\n}\n\nexport interface $ZodIssueNotMultipleOf<Input extends number | bigint = number | bigint> extends $ZodIssueBase {\n  readonly code: \"not_multiple_of\";\n  readonly divisor: number;\n  readonly input: Input;\n}\n\nexport interface $ZodIssueUnrecognizedKeys extends $ZodIssueBase {\n  readonly code: \"unrecognized_keys\";\n  readonly keys: string[];\n  readonly input: Record<string, unknown>;\n}\n\nexport interface $ZodIssueInvalidUnion extends $ZodIssueBase {\n  readonly code: \"invalid_union\";\n  readonly errors: $ZodIssue[][];\n  readonly input: unknown;\n}\n\nexport interface $ZodIssueInvalidKey<Input = unknown> extends $ZodIssueBase {\n  readonly code: \"invalid_key\";\n  readonly origin: \"map\" | \"record\";\n  readonly issues: $ZodIssue[];\n  readonly input: Input;\n}\n\nexport interface $ZodIssueInvalidElement<Input = unknown> extends $ZodIssueBase {\n  readonly code: \"invalid_element\";\n  readonly origin: \"map\" | \"set\";\n  readonly key: unknown;\n  readonly issues: $ZodIssue[];\n  readonly input: Input;\n}\n\nexport interface $ZodIssueInvalidValue<Input = unknown> extends $ZodIssueBase {\n  readonly code: \"invalid_value\";\n  readonly values: util.Primitive[];\n  readonly input: Input;\n}\n\nexport interface $ZodIssueCustom extends $ZodIssueBase {\n  readonly code: \"custom\";\n  readonly params?: Record<string, any> | undefined;\n  readonly input: unknown;\n}\n\n////////////////////////////////////////////\n////     first-party string formats     ////\n////////////////////////////////////////////\n\nexport interface $ZodIssueStringCommonFormats extends $ZodIssueInvalidStringFormat {\n  format: Exclude<$ZodStringFormats, \"regex\" | \"jwt\" | \"starts_with\" | \"ends_with\" | \"includes\">;\n}\n\nexport interface $ZodIssueStringInvalidRegex extends $ZodIssueInvalidStringFormat {\n  format: \"regex\";\n  pattern: string;\n}\n\nexport interface $ZodIssueStringInvalidJWT extends $ZodIssueInvalidStringFormat {\n  format: \"jwt\";\n  algorithm?: string;\n}\n\nexport interface $ZodIssueStringStartsWith extends $ZodIssueInvalidStringFormat {\n  format: \"starts_with\";\n  prefix: string;\n}\n\nexport interface $ZodIssueStringEndsWith extends $ZodIssueInvalidStringFormat {\n  format: \"ends_with\";\n  suffix: string;\n}\n\nexport interface $ZodIssueStringIncludes extends $ZodIssueInvalidStringFormat {\n  format: \"includes\";\n  includes: string;\n}\n\nexport type $ZodStringFormatIssues =\n  | $ZodIssueStringCommonFormats\n  | $ZodIssueStringInvalidRegex\n  | $ZodIssueStringInvalidJWT\n  | $ZodIssueStringStartsWith\n  | $ZodIssueStringEndsWith\n  | $ZodIssueStringIncludes;\n\n////////////////////////\n////     utils     /////\n////////////////////////\n\nexport type $ZodIssue =\n  | $ZodIssueInvalidType\n  | $ZodIssueTooBig\n  | $ZodIssueTooSmall\n  | $ZodIssueInvalidStringFormat\n  | $ZodIssueNotMultipleOf\n  | $ZodIssueUnrecognizedKeys\n  | $ZodIssueInvalidUnion\n  | $ZodIssueInvalidKey\n  | $ZodIssueInvalidElement\n  | $ZodIssueInvalidValue\n  | $ZodIssueCustom;\n\nexport type $ZodIssueCode = $ZodIssue[\"code\"];\n\nexport type $ZodRawIssue<T extends $ZodIssueBase = $ZodIssue> = T extends any ? RawIssue<T> : never;\ntype RawIssue<T extends $ZodIssueBase> = util.Flatten<\n  util.MakePartial<T, \"message\" | \"path\"> & {\n    /** The input data */\n    readonly input?: unknown;\n    /** The schema or check that originated this issue. */\n    readonly inst?: $ZodType | $ZodCheck;\n    /** @deprecated Internal use only. If `true`, Zod will continue executing validation despite this issue. */\n    readonly continue?: boolean | undefined;\n  } & Record<string, any>\n>;\n\nexport interface $ZodErrorMap<T extends $ZodIssueBase = $ZodIssue> {\n  // biome-ignore lint:\n  (issue: $ZodRawIssue<T>): { message: string } | string | undefined | null;\n}\n\n////////////////////////    ERROR CLASS   ////////////////////////\n\n// const ZOD_ERROR: symbol = Symbol.for(\"{{zod.error}}\");\nexport interface $ZodError<T = unknown> extends Error {\n  type: T;\n  issues: $ZodIssue[];\n  _zod: {\n    output: T;\n    def: $ZodIssue[];\n  };\n  stack?: string;\n  name: string;\n}\n\nconst initializer = (inst: $ZodError, def: $ZodIssue[]): void => {\n  inst.name = \"$ZodError\";\n  Object.defineProperty(inst, \"_zod\", {\n    value: inst._zod,\n    enumerable: false,\n  });\n  Object.defineProperty(inst, \"issues\", {\n    value: def,\n    enumerable: false,\n  });\n  Object.defineProperty(inst, \"message\", {\n    get() {\n      return JSON.stringify(def, util.jsonStringifyReplacer, 2);\n    },\n    enumerable: true,\n    // configurable: false,\n  });\n  Object.defineProperty(inst, \"toString\", {\n    value: () => inst.message,\n    enumerable: false,\n  });\n};\n\nexport const $ZodError: $constructor<$ZodError> = $constructor(\"$ZodError\", initializer);\ninterface $ZodRealError<T = any> extends $ZodError<T> {}\nexport const $ZodRealError: $constructor<$ZodRealError> = $constructor(\"$ZodError\", initializer, { Parent: Error });\n\n///////////////////    ERROR UTILITIES   ////////////////////////\n\n// flatten\nexport type $ZodFlattenedError<T, U = string> = _FlattenedError<T, U>;\ntype _FlattenedError<T, U = string> = {\n  formErrors: U[];\n  fieldErrors: {\n    [P in keyof T]?: U[];\n  };\n};\n\nexport function flattenError<T>(error: $ZodError<T>): _FlattenedError<T>;\nexport function flattenError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): _FlattenedError<T, U>;\nexport function flattenError(error: $ZodError, mapper = (issue: $ZodIssue) => issue.message): any {\n  const fieldErrors: any = {};\n  const formErrors: any[] = [];\n  for (const sub of error.issues) {\n    if (sub.path.length > 0) {\n      fieldErrors[sub.path[0]!] = fieldErrors[sub.path[0]!] || [];\n      fieldErrors[sub.path[0]!].push(mapper(sub));\n    } else {\n      formErrors.push(mapper(sub));\n    }\n  }\n  return { formErrors, fieldErrors };\n}\n\ntype _ZodFormattedError<T, U = string> = T extends [any, ...any[]]\n  ? { [K in keyof T]?: $ZodFormattedError<T[K], U> }\n  : T extends any[]\n    ? { [k: number]: $ZodFormattedError<T[number], U> }\n    : T extends object\n      ? util.Flatten<{ [K in keyof T]?: $ZodFormattedError<T[K], U> }>\n      : any;\n\nexport type $ZodFormattedError<T, U = string> = {\n  _errors: U[];\n} & util.Flatten<_ZodFormattedError<T, U>>;\n\nexport function formatError<T>(error: $ZodError<T>): $ZodFormattedError<T>;\nexport function formatError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): $ZodFormattedError<T, U>;\nexport function formatError<T>(error: $ZodError, _mapper?: any) {\n  const mapper: (issue: $ZodIssue) => any =\n    _mapper ||\n    function (issue: $ZodIssue) {\n      return issue.message;\n    };\n  const fieldErrors: $ZodFormattedError<T> = { _errors: [] } as any;\n  const processError = (error: { issues: $ZodIssue[] }) => {\n    for (const issue of error.issues) {\n      if (issue.code === \"invalid_union\" && issue.errors.length) {\n        issue.errors.map((issues) => processError({ issues }));\n      } else if (issue.code === \"invalid_key\") {\n        processError({ issues: issue.issues });\n      } else if (issue.code === \"invalid_element\") {\n        processError({ issues: issue.issues });\n      } else if (issue.path.length === 0) {\n        (fieldErrors as any)._errors.push(mapper(issue));\n      } else {\n        let curr: any = fieldErrors;\n        let i = 0;\n        while (i < issue.path.length) {\n          const el = issue.path[i]!;\n          const terminal = i === issue.path.length - 1;\n\n          if (!terminal) {\n            curr[el] = curr[el] || { _errors: [] };\n          } else {\n            curr[el] = curr[el] || { _errors: [] };\n            curr[el]._errors.push(mapper(issue));\n          }\n\n          curr = curr[el];\n          i++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return fieldErrors;\n}\n\nexport type $ZodErrorTree<T, U = string> = T extends [any, ...any[]]\n  ? { errors: U[]; items?: { [K in keyof T]?: $ZodErrorTree<T[K], U> } }\n  : T extends any[]\n    ? { errors: U[]; items?: Array<$ZodErrorTree<T[number], U>> }\n    : T extends object\n      ? { errors: U[]; properties?: { [K in keyof T]?: $ZodErrorTree<T[K], U> } }\n      : { errors: U[] };\n\nexport function treeifyError<T>(error: $ZodError<T>): $ZodErrorTree<T>;\nexport function treeifyError<T, U>(error: $ZodError<T>, mapper?: (issue: $ZodIssue) => U): $ZodErrorTree<T, U>;\nexport function treeifyError<T>(error: $ZodError, _mapper?: any) {\n  const mapper: (issue: $ZodIssue) => any =\n    _mapper ||\n    function (issue: $ZodIssue) {\n      return issue.message;\n    };\n  const result: $ZodErrorTree<T> = { errors: [] } as any;\n  const processError = (error: { issues: $ZodIssue[] }, path: PropertyKey[] = []) => {\n    for (const issue of error.issues) {\n      if (issue.code === \"invalid_union\" && issue.errors.length) {\n        // regular union error\n        issue.errors.map((issues) => processError({ issues }, issue.path));\n      } else if (issue.code === \"invalid_key\") {\n        processError({ issues: issue.issues }, issue.path);\n      } else if (issue.code === \"invalid_element\") {\n        processError({ issues: issue.issues }, issue.path);\n      } else {\n        const fullpath = [...path, ...issue.path];\n        if (fullpath.length === 0) {\n          result.errors.push(mapper(issue));\n          continue;\n        }\n\n        let curr: any = result;\n        let i = 0;\n        while (i < fullpath.length) {\n          const el = fullpath[i]!;\n\n          const terminal = i === fullpath.length - 1;\n          if (typeof el === \"string\") {\n            curr.properties ??= {};\n            curr.properties[el] ??= { errors: [] };\n            curr = curr.properties[el];\n          } else {\n            curr.items ??= [];\n            curr.items[el] ??= { errors: [] };\n            curr = curr.items[el];\n          }\n\n          if (terminal) {\n            curr.errors.push(mapper(issue));\n          }\n\n          i++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return result;\n}\n\n/** Format a ZodError as a human-readable string in the following form.\n *\n * From\n *\n * ```ts\n * ZodError {\n *   issues: [\n *     {\n *       expected: 'string',\n *       code: 'invalid_type',\n *       path: [ 'username' ],\n *       message: 'Invalid input: expected string'\n *     },\n *     {\n *       expected: 'number',\n *       code: 'invalid_type',\n *       path: [ 'favoriteNumbers', 1 ],\n *       message: 'Invalid input: expected number'\n *     }\n *   ];\n * }\n * ```\n *\n * to\n *\n * ```\n * username\n *   ✖ Expected number, received string at \"username\n * favoriteNumbers[0]\n *   ✖ Invalid input: expected number\n * ```\n */\nexport function toDotPath(path: (string | number | symbol)[]): string {\n  const segs: string[] = [];\n  for (const seg of path) {\n    if (typeof seg === \"number\") segs.push(`[${seg}]`);\n    else if (typeof seg === \"symbol\") segs.push(`[${JSON.stringify(String(seg))}]`);\n    else if (/[^\\w$]/.test(seg)) segs.push(`[${JSON.stringify(seg)}]`);\n    else {\n      if (segs.length) segs.push(\".\");\n      segs.push(seg);\n    }\n  }\n\n  return segs.join(\"\");\n}\n\ninterface BaseError {\n  issues: $ZodIssueBase[];\n}\n\nexport function prettifyError(error: BaseError): string {\n  const lines: string[] = [];\n  // sort by path length\n  const issues = [...error.issues].sort((a, b) => a.path.length - b.path.length);\n\n  // Process each issue\n  for (const issue of issues) {\n    lines.push(`✖ ${issue.message}`);\n    if (issue.path?.length) lines.push(`  → at ${toDotPath(issue.path)}`);\n  }\n\n  // Convert Map to formatted string\n  return lines.join(\"\\n\");\n}\n",
    "symbols": [
      {
        "name": "flattenError",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
        "startLine": 227,
        "endLine": 227
      },
      {
        "name": "flattenError",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
        "startLine": 228,
        "endLine": 228
      },
      {
        "name": "flattenError",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
        "startLine": 229,
        "endLine": 241
      },
      {
        "name": "formatError",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
        "startLine": 255,
        "endLine": 255
      },
      {
        "name": "formatError",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
        "startLine": 256,
        "endLine": 256
      },
      {
        "name": "formatError",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
        "startLine": 257,
        "endLine": 296
      },
      {
        "name": "treeifyError",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
        "startLine": 306,
        "endLine": 306
      },
      {
        "name": "treeifyError",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
        "startLine": 307,
        "endLine": 307
      },
      {
        "name": "treeifyError",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
        "startLine": 308,
        "endLine": 358
      },
      {
        "name": "toDotPath",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
        "startLine": 392,
        "endLine": 405
      },
      {
        "name": "prettifyError",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/errors.ts",
        "startLine": 411,
        "endLine": 424
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
    "content": "import { _array, _tuple, _unknown } from \"./api.js\";\nimport type * as core from \"./core.js\";\nimport { parse, parseAsync } from \"./parse.js\";\nimport * as schemas from \"./schemas.js\";\nimport { $ZodTuple } from \"./schemas.js\";\nimport type * as util from \"./util.js\";\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////     $ZodFunction     //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\nexport interface $ZodFunctionDef<\n  In extends $ZodFunctionIn = $ZodFunctionIn,\n  Out extends $ZodFunctionOut = $ZodFunctionOut,\n> {\n  type: \"function\";\n  input: In;\n  output: Out;\n}\n\nexport type $ZodFunctionArgs = schemas.$ZodType<unknown[], unknown[]>;\nexport type $ZodFunctionIn = $ZodFunctionArgs;\nexport type $ZodFunctionOut = schemas.$ZodType;\n\nexport type $InferInnerFunctionType<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (\n  ...args: $ZodFunctionIn extends Args ? never[] : core.output<Args>\n) => core.input<Returns>;\n\nexport type $InferInnerFunctionTypeAsync<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (\n  ...args: $ZodFunctionIn extends Args ? never[] : core.output<Args>\n) => util.MaybeAsync<core.input<Returns>>;\n\nexport type $InferOuterFunctionType<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (\n  ...args: $ZodFunctionIn extends Args ? never[] : core.input<Args>\n) => core.output<Returns>;\n\nexport type $InferOuterFunctionTypeAsync<Args extends $ZodFunctionIn, Returns extends $ZodFunctionOut> = (\n  ...args: $ZodFunctionIn extends Args ? never[] : core.input<Args>\n) => util.MaybeAsync<core.output<Returns>>;\n\nexport class $ZodFunction<\n  Args extends $ZodFunctionIn = $ZodFunctionIn,\n  Returns extends $ZodFunctionOut = $ZodFunctionOut,\n> {\n  def: $ZodFunctionDef<Args, Returns>;\n\n  /** @deprecated */\n  _def!: $ZodFunctionDef<Args, Returns>;\n  _input!: $InferInnerFunctionType<Args, Returns>;\n  _output!: $InferOuterFunctionType<Args, Returns>;\n\n  constructor(def: $ZodFunctionDef<Args, Returns>) {\n    this._def = def;\n    this.def = def;\n  }\n\n  implement<F extends $InferInnerFunctionType<Args, Returns>>(\n    func: F\n  ): // allow for return type inference\n  (\n    ...args: Parameters<this[\"_output\"]>\n  ) => ReturnType<F> extends ReturnType<this[\"_output\"]> ? ReturnType<F> : ReturnType<this[\"_output\"]> {\n    if (typeof func !== \"function\") {\n      throw new Error(\"implement() must be called with a function\");\n    }\n    const impl = ((...args: any[]) => {\n      const parsedArgs = this._def.input ? parse(this._def.input, args, undefined, { callee: impl }) : args;\n      if (!Array.isArray(parsedArgs)) {\n        throw new Error(\"Invalid arguments schema: not an array or tuple schema.\");\n      }\n      const output = func(...(parsedArgs as any));\n      return this._def.output ? parse(this._def.output, output, undefined, { callee: impl }) : output;\n    }) as any;\n    return impl;\n  }\n\n  implementAsync<F extends $InferInnerFunctionTypeAsync<Args, Returns>>(\n    func: F\n  ): F extends $InferOuterFunctionTypeAsync<Args, Returns> ? F : $InferOuterFunctionTypeAsync<Args, Returns> {\n    if (typeof func !== \"function\") {\n      throw new Error(\"implement() must be called with a function\");\n    }\n\n    const impl = (async (...args: any[]) => {\n      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, undefined, { callee: impl }) : args;\n      if (!Array.isArray(parsedArgs)) {\n        throw new Error(\"Invalid arguments schema: not an array or tuple schema.\");\n      }\n      const output = await func(...(parsedArgs as any));\n      return this._def.output ? parseAsync(this._def.output, output, undefined, { callee: impl }) : output;\n    }) as any;\n    return impl;\n  }\n\n  input<const Items extends util.TupleItems, const Rest extends $ZodFunctionOut = $ZodFunctionOut>(\n    args: Items,\n    rest?: Rest\n  ): $ZodFunction<schemas.$ZodTuple<Items, Rest>, Returns>;\n  input<NewArgs extends $ZodFunctionIn>(args: NewArgs): $ZodFunction<NewArgs, Returns>;\n  input(...args: any[]): $ZodFunction<any, Returns> {\n    const F: any = this.constructor;\n    if (Array.isArray(args[0])) {\n      return new F({\n        type: \"function\",\n        input: new $ZodTuple({\n          type: \"tuple\",\n          items: args[0],\n          rest: args[1],\n        }),\n        output: this._def.output,\n      });\n    }\n\n    return new F({\n      type: \"function\",\n      input: args[0],\n      output: this._def.output,\n    });\n  }\n\n  output<NewReturns extends schemas.$ZodType>(output: NewReturns): $ZodFunction<Args, NewReturns> {\n    const F: any = this.constructor;\n    return new F({\n      type: \"function\",\n      input: this._def.input,\n      output,\n    });\n  }\n}\n\nexport interface $ZodFunctionParams<I extends $ZodFunctionIn, O extends schemas.$ZodType> {\n  input?: I;\n  output?: O;\n}\n\nfunction _function(): $ZodFunction;\nfunction _function<const In extends Array<schemas.$ZodType> = Array<schemas.$ZodType>>(params: {\n  input: In;\n}): $ZodFunction<$ZodTuple<In, null>, $ZodFunctionOut>;\nfunction _function<\n  const In extends Array<schemas.$ZodType> = Array<schemas.$ZodType>,\n  const Out extends $ZodFunctionOut = $ZodFunctionOut,\n>(params: {\n  input: In;\n  output: Out;\n}): $ZodFunction<$ZodTuple<In, null>, Out>;\nfunction _function<const In extends $ZodFunctionIn = $ZodFunctionIn>(params: {\n  input: In;\n}): $ZodFunction<In, $ZodFunctionOut>;\nfunction _function<const Out extends $ZodFunctionOut = $ZodFunctionOut>(params: {\n  output: Out;\n}): $ZodFunction<$ZodFunctionIn, Out>;\nfunction _function<\n  In extends $ZodFunctionIn = $ZodFunctionIn,\n  Out extends schemas.$ZodType = schemas.$ZodType,\n>(params?: {\n  input: In;\n  output: Out;\n}): $ZodFunction<In, Out>;\nfunction _function(params?: {\n  output?: schemas.$ZodType;\n  input?: $ZodFunctionArgs | Array<schemas.$ZodType>;\n}): any {\n  return new $ZodFunction({\n    type: \"function\",\n    input: Array.isArray(params?.input)\n      ? _tuple(schemas.$ZodTuple, params?.input as any)\n      : (params?.input ?? _array(schemas.$ZodArray, _unknown(schemas.$ZodUnknown))),\n    output: params?.output ?? _unknown(schemas.$ZodUnknown),\n  });\n}\n\nexport { _function as function };\n",
    "symbols": [
      {
        "name": "$ZodFunction",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
        "startLine": 44,
        "endLine": 132
      },
      {
        "name": "$ZodFunction.implement",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
        "startLine": 60,
        "endLine": 78
      },
      {
        "name": "$ZodFunction.implementAsync",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
        "startLine": 80,
        "endLine": 96
      },
      {
        "name": "$ZodFunction.input",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
        "startLine": 103,
        "endLine": 122
      },
      {
        "name": "$ZodFunction.output",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
        "startLine": 124,
        "endLine": 131
      },
      {
        "name": "_function",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
        "startLine": 139,
        "endLine": 139
      },
      {
        "name": "_function",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
        "startLine": 140,
        "endLine": 142
      },
      {
        "name": "_function",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
        "startLine": 143,
        "endLine": 149
      },
      {
        "name": "_function",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
        "startLine": 150,
        "endLine": 152
      },
      {
        "name": "_function",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
        "startLine": 153,
        "endLine": 155
      },
      {
        "name": "_function",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
        "startLine": 156,
        "endLine": 162
      },
      {
        "name": "_function",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/function.ts",
        "startLine": 163,
        "endLine": 174
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/index.ts",
    "content": "export * from \"./core.js\";\nexport * from \"./parse.js\";\nexport * from \"./errors.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\nexport * from \"./versions.js\";\nexport * as util from \"./util.js\";\nexport * as regexes from \"./regexes.js\";\nexport * as locales from \"../locales/index.js\";\nexport * from \"./registries.js\";\nexport * from \"./doc.js\";\nexport * from \"./function.js\";\nexport * from \"./api.js\";\nexport * from \"./to-json-schema.js\";\nexport * as JSONSchema from \"./json-schema.js\";\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/json-schema.ts",
    "content": "export type Schema =\n  | ObjectSchema\n  | ArraySchema\n  | StringSchema\n  | NumberSchema\n  | IntegerSchema\n  | BooleanSchema\n  | NullSchema;\n\n// export type JsonType = \"object\" | \"array\" | \"string\" | \"number\" | \"boolean\" | \"null\" | \"integer\";\n\n// export interface JSONSchema {\n//   type?: string ;\n//   $id?: string ;\n//   id?: string ;\n//   $schema?: string ;\n//   $ref?: string ;\n//   $anchor?: string ;\n//   $defs?: { [key: string]: JSONSchema } ;\n//   definitions?: { [key: string]: JSONSchema } ;\n//   $comment?: string ;\n//   title?: string ;\n//   description?: string ;\n//   default?: unknown ;\n//   examples?: unknown[] ;\n//   readOnly?: boolean ;\n//   writeOnly?: boolean ;\n//   deprecated?: boolean ;\n//   allOf?: JSONSchema[] ;\n//   anyOf?: JSONSchema[] ;\n//   oneOf?: JSONSchema[] ;\n//   not?: JSONSchema ;\n//   if?: JSONSchema ;\n//   then?: JSONSchema ;\n//   else?: JSONSchema ;\n//   enum?: Array<string | number | boolean | null> ;\n//   const?: string | number | boolean | null ;\n//   [k: string]: unknown;\n\n//   /** A special key used as an intermediate representation of extends-style relationships. Omitted as a $ref with additional properties. */\n//   // _ref?: JSONSchema;\n//   _prefault?: unknown ;\n// }\n\nexport type _JSONSchema = boolean | JSONSchema;\nexport type JSONSchema = {\n  [k: string]: unknown;\n  $schema?: \"https://json-schema.org/draft/2020-12/schema\" | \"http://json-schema.org/draft-07/schema#\";\n  $id?: string;\n  $anchor?: string;\n  $ref?: string;\n  $dynamicRef?: string;\n  $dynamicAnchor?: string;\n  $vocabulary?: Record<string, boolean>;\n  $comment?: string;\n  $defs?: Record<string, JSONSchema>;\n  type?: \"object\" | \"array\" | \"string\" | \"number\" | \"boolean\" | \"null\" | \"integer\";\n  additionalItems?: _JSONSchema;\n  unevaluatedItems?: _JSONSchema;\n  prefixItems?: _JSONSchema[];\n  items?: _JSONSchema | _JSONSchema[];\n  contains?: _JSONSchema;\n  additionalProperties?: _JSONSchema;\n  unevaluatedProperties?: _JSONSchema;\n  properties?: Record<string, _JSONSchema>;\n  patternProperties?: Record<string, _JSONSchema>;\n  dependentSchemas?: Record<string, _JSONSchema>;\n  propertyNames?: _JSONSchema;\n  if?: _JSONSchema;\n  then?: _JSONSchema;\n  else?: _JSONSchema;\n  allOf?: JSONSchema[];\n  anyOf?: JSONSchema[];\n  oneOf?: JSONSchema[];\n  not?: _JSONSchema;\n  multipleOf?: number;\n  maximum?: number;\n  exclusiveMaximum?: number;\n  minimum?: number;\n  exclusiveMinimum?: number;\n  maxLength?: number;\n  minLength?: number;\n  pattern?: string;\n  maxItems?: number;\n  minItems?: number;\n  uniqueItems?: boolean;\n  maxContains?: number;\n  minContains?: number;\n  maxProperties?: number;\n  minProperties?: number;\n  required?: string[];\n  dependentRequired?: Record<string, string[]>;\n  enum?: Array<string | number | boolean | null>;\n  const?: string | number | boolean | null;\n\n  // metadata\n  id?: string;\n  title?: string;\n  description?: string;\n  default?: unknown;\n  deprecated?: boolean;\n  readOnly?: boolean;\n  writeOnly?: boolean;\n  examples?: unknown[];\n  format?: string;\n  contentMediaType?: string;\n  contentEncoding?: string;\n  contentSchema?: JSONSchema;\n\n  // internal\n  _prefault?: unknown;\n};\n\n// for backwards compatibility\nexport type BaseSchema = JSONSchema;\n\nexport interface ObjectSchema extends JSONSchema {\n  type: \"object\";\n}\n\nexport interface ArraySchema extends JSONSchema {\n  type: \"array\";\n}\n\nexport interface StringSchema extends JSONSchema {\n  type: \"string\";\n}\n\nexport interface NumberSchema extends JSONSchema {\n  type: \"number\";\n}\n\nexport interface IntegerSchema extends JSONSchema {\n  type: \"integer\";\n}\n\nexport interface BooleanSchema extends JSONSchema {\n  type: \"boolean\";\n}\n\nexport interface NullSchema extends JSONSchema {\n  type: \"null\";\n}\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/parse.ts",
    "content": "import * as core from \"./core.js\";\nimport * as errors from \"./errors.js\";\nimport type * as schemas from \"./schemas.js\";\nimport * as util from \"./util.js\";\n\nexport type $ZodErrorClass = { new (issues: errors.$ZodIssue[]): errors.$ZodError };\n\n///////////        METHODS       ///////////\nexport type $Parse = <T extends schemas.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: schemas.ParseContext<errors.$ZodIssue>,\n  _params?: { callee?: util.AnyFunc; Err?: $ZodErrorClass }\n) => core.output<T>;\n\nexport const _parse: (_Err: $ZodErrorClass) => $Parse = (_Err) => (schema, value, _ctx, _params) => {\n  const ctx: schemas.ParseContextInternal = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new core.$ZodAsyncError();\n  }\n  if (result.issues.length) {\n    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));\n    util.captureStackTrace(e, _params?.callee);\n    throw e;\n  }\n  return result.value as core.output<typeof schema>;\n};\n\nexport const parse: $Parse = /* @__PURE__*/ _parse(errors.$ZodRealError);\n\nexport type $ParseAsync = <T extends schemas.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: schemas.ParseContext<errors.$ZodIssue>,\n  _params?: { callee?: util.AnyFunc; Err?: $ZodErrorClass }\n) => Promise<core.output<T>>;\n\nexport const _parseAsync: (_Err: $ZodErrorClass) => $ParseAsync = (_Err) => async (schema, value, _ctx, params) => {\n  const ctx: schemas.ParseContextInternal = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) result = await result;\n  if (result.issues.length) {\n    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));\n    util.captureStackTrace(e, params?.callee);\n    throw e;\n  }\n  return result.value as core.output<typeof schema>;\n};\n\nexport const parseAsync: $ParseAsync = /* @__PURE__*/ _parseAsync(errors.$ZodRealError);\n\nexport type $SafeParse = <T extends schemas.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: schemas.ParseContext<errors.$ZodIssue>\n) => util.SafeParseResult<core.output<T>>;\n\nexport const _safeParse: (_Err: $ZodErrorClass) => $SafeParse = (_Err) => (schema, value, _ctx) => {\n  const ctx: schemas.ParseContextInternal = _ctx ? { ..._ctx, async: false } : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new core.$ZodAsyncError();\n  }\n\n  return result.issues.length\n    ? {\n        success: false,\n        error: new (_Err ?? errors.$ZodError)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n      }\n    : ({ success: true, data: result.value } as any);\n};\nexport const safeParse: $SafeParse = /* @__PURE__*/ _safeParse(errors.$ZodRealError);\n\nexport type $SafeParseAsync = <T extends schemas.$ZodType>(\n  schema: T,\n  value: unknown,\n  _ctx?: schemas.ParseContext<errors.$ZodIssue>\n) => Promise<util.SafeParseResult<core.output<T>>>;\n\nexport const _safeParseAsync: (_Err: $ZodErrorClass) => $SafeParseAsync = (_Err) => async (schema, value, _ctx) => {\n  const ctx: schemas.ParseContextInternal = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) result = await result;\n\n  return result.issues.length\n    ? {\n        success: false,\n        error: new _Err(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n      }\n    : ({ success: true, data: result.value } as any);\n};\n\nexport const safeParseAsync: $SafeParseAsync = /* @__PURE__*/ _safeParseAsync(errors.$ZodRealError);\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/regexes.ts",
    "content": "export const cuid: RegExp = /^[cC][^\\s-]{8,}$/;\nexport const cuid2: RegExp = /^[0-9a-z]+$/;\nexport const ulid: RegExp = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;\nexport const xid: RegExp = /^[0-9a-vA-V]{20}$/;\nexport const ksuid: RegExp = /^[A-Za-z0-9]{27}$/;\nexport const nanoid: RegExp = /^[a-zA-Z0-9_-]{21}$/;\n\n/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */\nexport const duration: RegExp =\n  /^P(?:(\\d+W)|(?!.*W)(?=\\d|T\\d)(\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+([.,]\\d+)?S)?)?)$/;\n\n/** Implements ISO 8601-2 extensions like explicit +- prefixes, mixing weeks with other units, and fractional/negative components. */\nexport const extendedDuration: RegExp =\n  /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n\n/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */\nexport const guid: RegExp = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;\n\n/** Returns a regex for validating an RFC 4122 UUID.\n *\n * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */\nexport const uuid = (version?: number | undefined): RegExp => {\n  if (!version)\n    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;\n  return new RegExp(\n    `^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`\n  );\n};\nexport const uuid4: RegExp = /*@__PURE__*/ uuid(4);\nexport const uuid6: RegExp = /*@__PURE__*/ uuid(6);\nexport const uuid7: RegExp = /*@__PURE__*/ uuid(7);\n\n/** Practical email validation */\nexport const email: RegExp =\n  /^(?!\\.)(?!.*\\.\\.)([A-Za-z0-9_'+\\-\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\-]*\\.)+[A-Za-z]{2,}$/;\n\n/** Equivalent to the HTML5 input[type=email] validation implemented by browsers. Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email */\nexport const html5Email: RegExp =\n  /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n\n/** The classic emailregex.com regex for RFC 5322-compliant emails */\nexport const rfc5322Email =\n  /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n\n/** A loose regex that allows Unicode characters, enforces length limits, and that's about it. */\nexport const unicodeEmail = /^[^\\s@\"]{1,64}@[^\\s@]{1,255}$/u;\n\nexport const browserEmail: RegExp =\n  /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\n\nexport const _emoji = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nexport function emoji(): RegExp {\n  return new RegExp(_emoji, \"u\");\n}\n\nexport const ipv4: RegExp =\n  /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nexport const ipv6: RegExp =\n  /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;\n\nexport const cidrv4: RegExp =\n  /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/([0-9]|[1-2][0-9]|3[0-2])$/;\nexport const cidrv6: RegExp =\n  /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nexport const base64: RegExp = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;\nexport const base64url: RegExp = /^[A-Za-z0-9_-]*$/;\n\n// based on https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address\n// export const hostname: RegExp =\n//   /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)+([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\nexport const hostname: RegExp = /^([a-zA-Z0-9-]+\\.)*[a-zA-Z0-9-]+$/;\nexport const domain: RegExp = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$/;\n\n// https://blog.stevenlevithan.com/archives/validate-phone-number#r4-3 (regex sans spaces)\nexport const e164: RegExp = /^\\+(?:[0-9]){6,14}[0-9]$/;\n\n// const dateSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateSource = `(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))`;\nexport const date: RegExp = /*@__PURE__*/ new RegExp(`^${dateSource}$`);\n\nfunction timeSource(args: { precision?: number | null | undefined }) {\n  const hhmm = `(?:[01]\\\\d|2[0-3]):[0-5]\\\\d`;\n  const regex =\n    typeof args.precision === \"number\"\n      ? args.precision === -1\n        ? `${hhmm}`\n        : args.precision === 0\n          ? `${hhmm}:[0-5]\\\\d`\n          : `${hhmm}:[0-5]\\\\d\\\\.\\\\d{${args.precision}}`\n      : `${hhmm}(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?`;\n  return regex;\n}\nexport function time(args: {\n  precision?: number | null;\n  // local?: boolean;\n}): RegExp {\n  return new RegExp(`^${timeSource(args)}$`);\n}\n\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetime(args: {\n  precision?: number | null;\n  offset?: boolean;\n  local?: boolean;\n}): RegExp {\n  const time = timeSource({ precision: args.precision });\n  const opts = [\"Z\"];\n  if (args.local) opts.push(\"\");\n  if (args.offset) opts.push(`([+-]\\\\d{2}:\\\\d{2})`);\n  const timeRegex = `${time}(?:${opts.join(\"|\")})`;\n\n  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);\n}\n\nexport const string = (params?: { minimum?: number | undefined; maximum?: number | undefined }): RegExp => {\n  const regex = params ? `[\\\\s\\\\S]{${params?.minimum ?? 0},${params?.maximum ?? \"\"}}` : `[\\\\s\\\\S]*`;\n  return new RegExp(`^${regex}$`);\n};\n\nexport const bigint: RegExp = /^\\d+n?$/;\nexport const integer: RegExp = /^\\d+$/;\nexport const number: RegExp = /^-?\\d+(?:\\.\\d+)?/i;\nexport const boolean: RegExp = /true|false/i;\nconst _null: RegExp = /null/i;\nexport { _null as null };\nconst _undefined: RegExp = /undefined/i;\nexport { _undefined as undefined };\n\n// regex for string with no uppercase letters\nexport const lowercase: RegExp = /^[^A-Z]*$/;\n// regex for string with no lowercase letters\nexport const uppercase: RegExp = /^[^a-z]*$/;\n",
    "symbols": [
      {
        "name": "emoji",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/regexes.ts",
        "startLine": 53,
        "endLine": 55
      },
      {
        "name": "timeSource",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/regexes.ts",
        "startLine": 84,
        "endLine": 95
      },
      {
        "name": "time",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/regexes.ts",
        "startLine": 96,
        "endLine": 101
      },
      {
        "name": "datetime",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/regexes.ts",
        "startLine": 104,
        "endLine": 116
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
    "content": "import type * as core from \"./core.js\";\nimport type { $ZodType } from \"./schemas.js\";\n\nexport const $output: unique symbol = Symbol(\"ZodOutput\");\nexport type $output = typeof $output;\nexport const $input: unique symbol = Symbol(\"ZodInput\");\nexport type $input = typeof $input;\n\nexport type $replace<Meta, S extends $ZodType> = Meta extends $output\n  ? core.output<S>\n  : Meta extends $input\n    ? core.input<S>\n    : Meta extends (infer M)[]\n      ? $replace<M, S>[]\n      : Meta extends (...args: infer P) => infer R\n        ? (\n            ...args: {\n              [K in keyof P]: $replace<P[K], S>; // tuple\n            }\n          ) => $replace<R, S>\n        : // handle objects\n          Meta extends object\n          ? { [K in keyof Meta]: $replace<Meta[K], S> }\n          : Meta;\n\ntype MetadataType = Record<string, unknown> | undefined;\nexport class $ZodRegistry<Meta extends MetadataType = MetadataType, Schema extends $ZodType = $ZodType> {\n  _meta!: Meta;\n  _schema!: Schema;\n  _map: Map<Schema, $replace<Meta, Schema>> = new Map();\n  _idmap: Map<string, Schema> = new Map();\n\n  add<S extends Schema>(\n    schema: S,\n    ..._meta: undefined extends Meta ? [$replace<Meta, S>?] : [$replace<Meta, S>]\n  ): this {\n    const meta: any = _meta[0];\n    this._map.set(schema, meta!);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      if (this._idmap.has(meta.id!)) {\n        throw new Error(`ID ${meta.id} already exists in the registry`);\n      }\n      this._idmap.set(meta.id!, schema);\n    }\n    return this as any;\n  }\n\n  clear(): this {\n    this._map = new Map();\n    this._idmap = new Map();\n    return this;\n  }\n\n  remove(schema: Schema): this {\n    const meta: any = this._map.get(schema);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      this._idmap.delete(meta.id!);\n    }\n    this._map.delete(schema);\n    return this;\n  }\n\n  get<S extends Schema>(schema: S): $replace<Meta, S> | undefined {\n    // return this._map.get(schema) as any;\n\n    // inherit metadata\n    const p = schema._zod.parent as Schema;\n    if (p) {\n      const pm: any = { ...(this.get(p) ?? {}) };\n      delete pm.id; // do not inherit id\n      return { ...pm, ...this._map.get(schema) } as any;\n    }\n    return this._map.get(schema) as any;\n  }\n\n  has(schema: Schema): boolean {\n    return this._map.has(schema);\n  }\n}\n\nexport interface JSONSchemaMeta {\n  id?: string | undefined;\n  title?: string | undefined;\n  description?: string | undefined;\n  deprecated?: boolean | undefined;\n  [k: string]: unknown;\n}\n\nexport interface GlobalMeta extends JSONSchemaMeta {}\n\n// registries\nexport function registry<T extends MetadataType = MetadataType, S extends $ZodType = $ZodType>(): $ZodRegistry<T, S> {\n  return new $ZodRegistry<T, S>();\n}\n\nexport const globalRegistry: $ZodRegistry<GlobalMeta> = /*@__PURE__*/ registry<GlobalMeta>();\n",
    "symbols": [
      {
        "name": "$ZodRegistry",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
        "startLine": 27,
        "endLine": 79
      },
      {
        "name": "$ZodRegistry.add",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
        "startLine": 33,
        "endLine": 46
      },
      {
        "name": "$ZodRegistry.clear",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
        "startLine": 48,
        "endLine": 52
      },
      {
        "name": "$ZodRegistry.remove",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
        "startLine": 54,
        "endLine": 61
      },
      {
        "name": "$ZodRegistry.get",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
        "startLine": 63,
        "endLine": 74
      },
      {
        "name": "$ZodRegistry.has",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
        "startLine": 76,
        "endLine": 78
      },
      {
        "name": "registry",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/registries.ts",
        "startLine": 92,
        "endLine": 94
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
    "content": "import type { $ZodTypeDiscriminable } from \"./api.js\";\nimport * as checks from \"./checks.js\";\nimport * as core from \"./core.js\";\nimport { Doc } from \"./doc.js\";\nimport type * as errors from \"./errors.js\";\nimport { safeParse, safeParseAsync } from \"./parse.js\";\nimport * as regexes from \"./regexes.js\";\nimport type { StandardSchemaV1 } from \"./standard-schema.js\";\nimport * as util from \"./util.js\";\nimport { version } from \"./versions.js\";\n\n/////////////////////////////   PARSE   //////////////////////////////\n\nexport interface ParseContext<T extends errors.$ZodIssueBase = never> {\n  /** Customize error messages. */\n  readonly error?: errors.$ZodErrorMap<T>;\n  /** Include the `input` field in issue objects. Default `false`. */\n  readonly reportInput?: boolean;\n  /** Skip eval-based fast path. Default `false`. */\n  readonly jitless?: boolean;\n  /** Abort validation after the first error. Default `false`. */\n  // readonly abortEarly?: boolean;\n}\n\n/** @internal */\nexport interface ParseContextInternal<T extends errors.$ZodIssueBase = never> extends ParseContext<T> {\n  readonly async?: boolean | undefined;\n}\n\nexport interface ParsePayload<T = unknown> {\n  value: T;\n  issues: errors.$ZodRawIssue[];\n}\n\nexport type CheckFn<T> = (input: ParsePayload<T>) => util.MaybeAsync<void>;\n\n/////////////////////////////   SCHEMAS   //////////////////////////////\n\nexport interface $ZodTypeDef {\n  type:\n    | \"string\"\n    | \"number\"\n    | \"int\"\n    | \"boolean\"\n    | \"bigint\"\n    | \"symbol\"\n    | \"null\"\n    | \"undefined\"\n    | \"void\" // merge with undefined?\n    | \"never\"\n    | \"any\"\n    | \"unknown\"\n    | \"date\"\n    | \"object\"\n    | \"record\"\n    | \"file\"\n    | \"array\"\n    | \"tuple\"\n    | \"union\"\n    | \"intersection\"\n    | \"map\"\n    | \"set\"\n    | \"enum\"\n    | \"literal\"\n    | \"nullable\"\n    | \"optional\"\n    | \"nonoptional\"\n    | \"success\"\n    | \"transform\"\n    | \"default\"\n    | \"prefault\"\n    | \"catch\"\n    | \"nan\"\n    | \"pipe\"\n    | \"readonly\"\n    | \"template_literal\"\n    | \"promise\"\n    | \"lazy\"\n    | \"custom\";\n  error?: errors.$ZodErrorMap<never> | undefined;\n  checks?: checks.$ZodCheck<never>[];\n}\n\nexport interface _$ZodTypeInternals {\n  /** The `@zod/core` version of this schema */\n  version: typeof version;\n\n  /** Schema definition. */\n  def: $ZodTypeDef;\n  // types: Types;\n\n  /** @internal Randomly generated ID for this schema. */\n  // id: string;\n\n  /** @internal List of deferred initializers. */\n  deferred: util.AnyFunc[] | undefined;\n\n  /** @internal Parses input and runs all checks (refinements). */\n  run(payload: ParsePayload<any>, ctx: ParseContextInternal): util.MaybeAsync<ParsePayload>;\n\n  /** @internal Parses input, doesn't run checks. */\n  parse(payload: ParsePayload<any>, ctx: ParseContextInternal): util.MaybeAsync<ParsePayload>;\n\n  /** @internal  Stores identifiers for the set of traits implemented by this schema. */\n  traits: Set<string>;\n\n  /** @internal Indicates that a schema output type should be considered optional inside objects.\n   * @default Required\n   */\n\n  /** @internal */\n  optin?: \"optional\" | undefined;\n  /** @internal */\n  optout?: \"optional\" | undefined;\n\n  /** @internal The set of literal values that will pass validation. Must be an exhaustive set. Used to determine optionality in z.record().\n   *\n   * Defined on: enum, const, literal, null, undefined\n   * Passthrough: optional, nullable, branded, default, catch, pipe\n   * Todo: unions?\n   */\n  values?: util.PrimitiveSet | undefined;\n\n  /** @internal A set of literal discriminators used for the fast path in discriminated unions. */\n  propValues?: util.PropValues | undefined;\n\n  /** @internal This flag indicates that a schema validation can be represented with a regular expression. Used to determine allowable schemas in z.templateLiteral(). */\n  pattern: RegExp | undefined;\n\n  /** @internal The constructor function of this schema. */\n  constr: new (\n    def: any\n  ) => $ZodType;\n\n  /** @internal A catchall object for bag metadata related to this schema. Commonly modified by checks using `onattach`. */\n  bag: Record<string, unknown>;\n\n  /** @internal The set of issues this schema might throw during type checking. */\n  isst: errors.$ZodIssueBase;\n\n  /** An optional method used to override `toJSONSchema` logic. */\n  toJSONSchema?: () => unknown;\n\n  /** @internal The parent of this schema. Only set during certain clone operations. */\n  parent?: $ZodType | undefined;\n}\n/** @internal */\nexport interface $ZodTypeInternals<out O = unknown, out I = unknown> extends _$ZodTypeInternals {\n  /** @internal The inferred output type */\n  output: O; //extends { $out: infer O } ? O : Out;\n  /** @internal The inferred input type */\n  input: I; //extends { $in: infer I } ? I : In;\n}\n\nexport type $ZodStandardSchema<T> = StandardSchemaV1.Props<core.input<T>, core.output<T>>;\n\nexport type SomeType = { _zod: _$ZodTypeInternals };\n\nexport interface $ZodType<\n  O = unknown,\n  I = unknown,\n  Internals extends $ZodTypeInternals<O, I> = $ZodTypeInternals<O, I>,\n> {\n  _zod: Internals;\n  \"~standard\": $ZodStandardSchema<this>;\n}\nexport interface _$ZodType<T extends $ZodTypeInternals = $ZodTypeInternals>\n  extends $ZodType<T[\"output\"], T[\"input\"], T> {\n  // _zod: T;\n}\n\nexport const $ZodType: core.$constructor<$ZodType> = /*@__PURE__*/ core.$constructor(\"$ZodType\", (inst, def) => {\n  inst ??= {} as any;\n\n  inst._zod.def = def; // set _def property\n  inst._zod.bag = inst._zod.bag || {}; // initialize _bag object\n  inst._zod.version = version;\n\n  const checks = [...(inst._zod.def.checks ?? [])];\n\n  // if inst is itself a checks.$ZodCheck, run it as a check\n  if (inst._zod.traits.has(\"$ZodCheck\")) {\n    checks.unshift(inst as any);\n  }\n  //\n\n  for (const ch of checks) {\n    for (const fn of ch._zod.onattach) {\n      fn(inst);\n    }\n  }\n\n  if (checks.length === 0) {\n    // deferred initializer\n    // inst._zod.parse is not yet defined\n    inst._zod.deferred ??= [];\n    inst._zod.deferred?.push(() => {\n      inst._zod.run = inst._zod.parse;\n    });\n  } else {\n    const runChecks = (\n      payload: ParsePayload,\n      checks: checks.$ZodCheck<never>[],\n      ctx?: ParseContextInternal | undefined\n    ): util.MaybeAsync<ParsePayload> => {\n      let isAborted = util.aborted(payload);\n\n      let asyncResult!: Promise<unknown> | undefined;\n      for (const ch of checks) {\n        if (ch._zod.def.when) {\n          const shouldRun = ch._zod.def.when(payload);\n          if (!shouldRun) continue;\n        } else if (isAborted) {\n          continue;\n        }\n        const currLen = payload.issues.length;\n        const _ = ch._zod.check(payload as any) as any as ParsePayload;\n\n        if (_ instanceof Promise && ctx?.async === false) {\n          throw new core.$ZodAsyncError();\n        }\n        if (asyncResult || _ instanceof Promise) {\n          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n            await _;\n            const nextLen = payload.issues.length;\n            if (nextLen === currLen) return;\n            if (!isAborted) isAborted = util.aborted(payload, currLen);\n          });\n        } else {\n          const nextLen = payload.issues.length;\n          if (nextLen === currLen) continue;\n          if (!isAborted) isAborted = util.aborted(payload, currLen);\n        }\n      }\n\n      if (asyncResult) {\n        return asyncResult.then(() => {\n          return payload;\n        });\n      }\n      return payload;\n    };\n\n    inst._zod.run = (payload, ctx) => {\n      const result = inst._zod.parse(payload, ctx);\n\n      if (result instanceof Promise) {\n        if (ctx.async === false) throw new core.$ZodAsyncError();\n        return result.then((result) => runChecks(result, checks, ctx));\n      }\n\n      return runChecks(result, checks, ctx);\n    };\n  }\n\n  inst[\"~standard\"] = {\n    validate: (value: unknown) => {\n      try {\n        const r = safeParse(inst, value);\n        return r.success ? { value: r.data } : { issues: r.error?.issues };\n      } catch (_) {\n        return safeParseAsync(inst, value).then((r) => (r.success ? { value: r.data } : { issues: r.error?.issues }));\n      }\n    },\n    vendor: \"zod\",\n    version: 1 as const,\n  };\n});\n\nexport { clone } from \"./util.js\";\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      $ZodString      //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\nexport interface $ZodStringDef extends $ZodTypeDef {\n  type: \"string\";\n  coerce?: boolean;\n  checks?: checks.$ZodCheck<string>[];\n}\n\nexport interface $ZodStringInternals<Input> extends $ZodTypeInternals<string, Input> {\n  def: $ZodStringDef;\n  /** @deprecated Internal API, use with caution (not deprecated) */\n  pattern: RegExp;\n\n  /** @deprecated Internal API, use with caution (not deprecated) */\n  isst: errors.$ZodIssueInvalidType;\n  bag: util.LoosePartial<{\n    minimum: number;\n    maximum: number;\n    patterns: Set<RegExp>;\n    format: string;\n    contentEncoding: string;\n  }>;\n}\n\nexport interface $ZodString<Input = unknown> extends _$ZodType<$ZodStringInternals<Input>> {\n  // _zod: $ZodStringInternals<Input>;\n}\n\nexport const $ZodString: core.$constructor<$ZodString> = /*@__PURE__*/ core.$constructor(\"$ZodString\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = [...(inst?._zod.bag?.patterns ?? [])].pop() ?? regexes.string(inst._zod.bag);\n  inst._zod.parse = (payload, _) => {\n    if (def.coerce)\n      try {\n        payload.value = String(payload.value);\n      } catch (_) {}\n\n    if (typeof payload.value === \"string\") return payload;\n\n    payload.issues.push({\n      expected: \"string\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst,\n    });\n    return payload;\n  };\n});\n\n//////////////////////////////   ZodStringFormat   //////////////////////////////\n\nexport interface $ZodStringFormatDef<Format extends string = string>\n  extends $ZodStringDef,\n    checks.$ZodCheckStringFormatDef<Format> {}\n\nexport interface $ZodStringFormatInternals<Format extends string = string>\n  extends $ZodStringInternals<string>,\n    checks.$ZodCheckStringFormatInternals {\n  def: $ZodStringFormatDef<Format>;\n}\nexport interface $ZodStringFormat<Format extends string = string> extends $ZodType {\n  _zod: $ZodStringFormatInternals<Format>;\n}\n\nexport const $ZodStringFormat: core.$constructor<$ZodStringFormat> = /*@__PURE__*/ core.$constructor(\n  \"$ZodStringFormat\",\n  (inst, def): void => {\n    // check initialization must come first\n    checks.$ZodCheckStringFormat.init(inst, def);\n    $ZodString.init(inst, def);\n  }\n);\n\n//////////////////////////////   ZodGUID   //////////////////////////////\nexport interface $ZodGUIDDef extends $ZodStringFormatDef<\"guid\"> {}\nexport interface $ZodGUIDInternals extends $ZodStringFormatInternals<\"guid\"> {}\n\nexport interface $ZodGUID extends $ZodType {\n  _zod: $ZodGUIDInternals;\n}\n\nexport const $ZodGUID: core.$constructor<$ZodGUID> = /*@__PURE__*/ core.$constructor(\"$ZodGUID\", (inst, def): void => {\n  def.pattern ??= regexes.guid;\n  $ZodStringFormat.init(inst, def);\n});\n\n//////////////////////////////   ZodUUID   //////////////////////////////\n\nexport interface $ZodUUIDDef extends $ZodStringFormatDef<\"uuid\"> {\n  version?: \"v1\" | \"v2\" | \"v3\" | \"v4\" | \"v5\" | \"v6\" | \"v7\" | \"v8\";\n}\n\nexport interface $ZodUUIDInternals extends $ZodStringFormatInternals<\"uuid\"> {\n  def: $ZodUUIDDef;\n}\n\nexport interface $ZodUUID extends $ZodType {\n  _zod: $ZodUUIDInternals;\n}\n\nexport const $ZodUUID: core.$constructor<$ZodUUID> = /*@__PURE__*/ core.$constructor(\"$ZodUUID\", (inst, def): void => {\n  if (def.version) {\n    const versionMap: Record<string, number> = {\n      v1: 1,\n      v2: 2,\n      v3: 3,\n      v4: 4,\n      v5: 5,\n      v6: 6,\n      v7: 7,\n      v8: 8,\n    };\n    const v = versionMap[def.version];\n    if (v === undefined) throw new Error(`Invalid UUID version: \"${def.version}\"`);\n    def.pattern ??= regexes.uuid(v);\n  } else def.pattern ??= regexes.uuid();\n  $ZodStringFormat.init(inst, def);\n});\n\n//////////////////////////////   ZodEmail   //////////////////////////////\n\nexport interface $ZodEmailDef extends $ZodStringFormatDef<\"email\"> {}\nexport interface $ZodEmailInternals extends $ZodStringFormatInternals<\"email\"> {}\nexport interface $ZodEmail extends $ZodType {\n  _zod: $ZodEmailInternals;\n}\n\nexport const $ZodEmail: core.$constructor<$ZodEmail> = /*@__PURE__*/ core.$constructor(\n  \"$ZodEmail\",\n  (inst, def): void => {\n    def.pattern ??= regexes.email;\n    $ZodStringFormat.init(inst, def);\n  }\n);\n\n//////////////////////////////   ZodURL   //////////////////////////////\n\nexport interface $ZodURLDef extends $ZodStringFormatDef<\"url\"> {\n  hostname?: RegExp | undefined;\n  protocol?: RegExp | undefined;\n}\nexport interface $ZodURLInternals extends $ZodStringFormatInternals<\"url\"> {\n  def: $ZodURLDef;\n}\n\nexport interface $ZodURL extends $ZodType {\n  _zod: $ZodURLInternals;\n}\n\nexport const $ZodURL: core.$constructor<$ZodURL> = /*@__PURE__*/ core.$constructor(\"$ZodURL\", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    try {\n      const orig = payload.value;\n      const url = new URL(orig);\n      const href = url.href;\n\n      if (def.hostname) {\n        def.hostname.lastIndex = 0;\n        if (!def.hostname.test(url.hostname)) {\n          payload.issues.push({\n            code: \"invalid_format\",\n            format: \"url\",\n            note: \"Invalid hostname\",\n            pattern: regexes.hostname.source,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n          });\n        }\n      }\n\n      if (def.protocol) {\n        def.protocol.lastIndex = 0;\n        if (!def.protocol.test(url.protocol.endsWith(\":\") ? url.protocol.slice(0, -1) : url.protocol)) {\n          payload.issues.push({\n            code: \"invalid_format\",\n            format: \"url\",\n            note: \"Invalid protocol\",\n            pattern: def.protocol.source,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n          });\n        }\n      }\n\n      // payload.value = url.href;\n      if (!orig.endsWith(\"/\") && href.endsWith(\"/\")) {\n        payload.value = href.slice(0, -1);\n      } else {\n        payload.value = href;\n      }\n\n      return;\n    } catch (_) {\n      payload.issues.push({\n        code: \"invalid_format\",\n        format: \"url\",\n        input: payload.value,\n        inst,\n        continue: !def.abort,\n      });\n    }\n  };\n});\n\n//////////////////////////////   ZodEmoji   //////////////////////////////\n\nexport interface $ZodEmojiDef extends $ZodStringFormatDef<\"emoji\"> {}\nexport interface $ZodEmojiInternals extends $ZodStringFormatInternals<\"emoji\"> {}\n\nexport interface $ZodEmoji extends $ZodType {\n  _zod: $ZodEmojiInternals;\n}\n\nexport const $ZodEmoji: core.$constructor<$ZodEmoji> = /*@__PURE__*/ core.$constructor(\n  \"$ZodEmoji\",\n  (inst, def): void => {\n    def.pattern ??= regexes.emoji();\n    $ZodStringFormat.init(inst, def);\n  }\n);\n\n//////////////////////////////   ZodNanoID   //////////////////////////////\n\nexport interface $ZodNanoIDDef extends $ZodStringFormatDef<\"nanoid\"> {}\nexport interface $ZodNanoIDInternals extends $ZodStringFormatInternals<\"nanoid\"> {}\n\nexport interface $ZodNanoID extends $ZodType {\n  _zod: $ZodNanoIDInternals;\n}\n\nexport const $ZodNanoID: core.$constructor<$ZodNanoID> = /*@__PURE__*/ core.$constructor(\n  \"$ZodNanoID\",\n  (inst, def): void => {\n    def.pattern ??= regexes.nanoid;\n    $ZodStringFormat.init(inst, def);\n  }\n);\n\n//////////////////////////////   ZodCUID   //////////////////////////////\n\nexport interface $ZodCUIDDef extends $ZodStringFormatDef<\"cuid\"> {}\nexport interface $ZodCUIDInternals extends $ZodStringFormatInternals<\"cuid\"> {}\n\nexport interface $ZodCUID extends $ZodType {\n  _zod: $ZodCUIDInternals;\n}\n\nexport const $ZodCUID: core.$constructor<$ZodCUID> = /*@__PURE__*/ core.$constructor(\"$ZodCUID\", (inst, def): void => {\n  def.pattern ??= regexes.cuid;\n  $ZodStringFormat.init(inst, def);\n});\n\n//////////////////////////////   ZodCUID2   //////////////////////////////\n\nexport interface $ZodCUID2Def extends $ZodStringFormatDef<\"cuid2\"> {}\nexport interface $ZodCUID2Internals extends $ZodStringFormatInternals<\"cuid2\"> {}\n\nexport interface $ZodCUID2 extends $ZodType {\n  _zod: $ZodCUID2Internals;\n}\n\nexport const $ZodCUID2: core.$constructor<$ZodCUID2> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCUID2\",\n  (inst, def): void => {\n    def.pattern ??= regexes.cuid2;\n    $ZodStringFormat.init(inst, def);\n  }\n);\n\n//////////////////////////////   ZodULID   //////////////////////////////\n\nexport interface $ZodULIDDef extends $ZodStringFormatDef<\"ulid\"> {}\nexport interface $ZodULIDInternals extends $ZodStringFormatInternals<\"ulid\"> {}\n\nexport interface $ZodULID extends $ZodType {\n  _zod: $ZodULIDInternals;\n}\n\nexport const $ZodULID: core.$constructor<$ZodULID> = /*@__PURE__*/ core.$constructor(\"$ZodULID\", (inst, def): void => {\n  def.pattern ??= regexes.ulid;\n  $ZodStringFormat.init(inst, def);\n});\n\n//////////////////////////////   ZodXID   //////////////////////////////\n\nexport interface $ZodXIDDef extends $ZodStringFormatDef<\"xid\"> {}\nexport interface $ZodXIDInternals extends $ZodStringFormatInternals<\"xid\"> {}\n\nexport interface $ZodXID extends $ZodType {\n  _zod: $ZodXIDInternals;\n}\n\nexport const $ZodXID: core.$constructor<$ZodXID> = /*@__PURE__*/ core.$constructor(\"$ZodXID\", (inst, def): void => {\n  def.pattern ??= regexes.xid;\n  $ZodStringFormat.init(inst, def);\n});\n\n//////////////////////////////   ZodKSUID   //////////////////////////////\n\nexport interface $ZodKSUIDDef extends $ZodStringFormatDef<\"ksuid\"> {}\nexport interface $ZodKSUIDInternals extends $ZodStringFormatInternals<\"ksuid\"> {}\n\nexport interface $ZodKSUID extends $ZodType {\n  _zod: $ZodKSUIDInternals;\n}\n\nexport const $ZodKSUID: core.$constructor<$ZodKSUID> = /*@__PURE__*/ core.$constructor(\n  \"$ZodKSUID\",\n  (inst, def): void => {\n    def.pattern ??= regexes.ksuid;\n    $ZodStringFormat.init(inst, def);\n  }\n);\n\n//////////////////////////////   ZodISODateTime   //////////////////////////////\n\nexport interface $ZodISODateTimeDef extends $ZodStringFormatDef<\"datetime\"> {\n  precision: number | null;\n  offset: boolean;\n  local: boolean;\n}\n\nexport interface $ZodISODateTimeInternals extends $ZodStringFormatInternals {\n  def: $ZodISODateTimeDef;\n}\n\nexport interface $ZodISODateTime extends $ZodType {\n  _zod: $ZodISODateTimeInternals;\n}\n\nexport const $ZodISODateTime: core.$constructor<$ZodISODateTime> = /*@__PURE__*/ core.$constructor(\n  \"$ZodISODateTime\",\n  (inst, def): void => {\n    def.pattern ??= regexes.datetime(def);\n    $ZodStringFormat.init(inst, def);\n  }\n);\n\n//////////////////////////////   ZodISODate   //////////////////////////////\n\nexport interface $ZodISODateDef extends $ZodStringFormatDef<\"date\"> {}\nexport interface $ZodISODateInternals extends $ZodStringFormatInternals<\"date\"> {}\n\nexport interface $ZodISODate extends $ZodType {\n  _zod: $ZodISODateInternals;\n}\n\nexport const $ZodISODate: core.$constructor<$ZodISODate> = /*@__PURE__*/ core.$constructor(\n  \"$ZodISODate\",\n  (inst, def): void => {\n    def.pattern ??= regexes.date;\n    $ZodStringFormat.init(inst, def);\n  }\n);\n\n//////////////////////////////   ZodISOTime   //////////////////////////////\n\nexport interface $ZodISOTimeDef extends $ZodStringFormatDef<\"time\"> {\n  precision?: number | null;\n}\n\nexport interface $ZodISOTimeInternals extends $ZodStringFormatInternals<\"time\"> {\n  def: $ZodISOTimeDef;\n}\n\nexport interface $ZodISOTime extends $ZodType {\n  _zod: $ZodISOTimeInternals;\n}\n\nexport const $ZodISOTime: core.$constructor<$ZodISOTime> = /*@__PURE__*/ core.$constructor(\n  \"$ZodISOTime\",\n  (inst, def): void => {\n    def.pattern ??= regexes.time(def);\n    $ZodStringFormat.init(inst, def);\n  }\n);\n\n//////////////////////////////   ZodISODuration   //////////////////////////////\n\nexport interface $ZodISODurationDef extends $ZodStringFormatDef<\"duration\"> {}\nexport interface $ZodISODurationInternals extends $ZodStringFormatInternals<\"duration\"> {}\n\nexport interface $ZodISODuration extends $ZodType {\n  _zod: $ZodISODurationInternals;\n}\n\nexport const $ZodISODuration: core.$constructor<$ZodISODuration> = /*@__PURE__*/ core.$constructor(\n  \"$ZodISODuration\",\n  (inst, def): void => {\n    def.pattern ??= regexes.duration;\n    $ZodStringFormat.init(inst, def);\n  }\n);\n\n//////////////////////////////   ZodIPv4   //////////////////////////////\n\nexport interface $ZodIPv4Def extends $ZodStringFormatDef<\"ipv4\"> {\n  version?: \"v4\";\n}\n\nexport interface $ZodIPv4Internals extends $ZodStringFormatInternals<\"ipv4\"> {\n  def: $ZodIPv4Def;\n}\n\nexport interface $ZodIPv4 extends $ZodType {\n  _zod: $ZodIPv4Internals;\n}\n\nexport const $ZodIPv4: core.$constructor<$ZodIPv4> = /*@__PURE__*/ core.$constructor(\"$ZodIPv4\", (inst, def): void => {\n  def.pattern ??= regexes.ipv4;\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push((inst) => {\n    const bag = inst._zod.bag as $ZodStringInternals<unknown>[\"bag\"];\n    bag.format = `ipv4`;\n  });\n});\n\n//////////////////////////////   ZodIPv6   //////////////////////////////\n\nexport interface $ZodIPv6Def extends $ZodStringFormatDef<\"ipv6\"> {\n  version?: \"v6\";\n}\n\nexport interface $ZodIPv6Internals extends $ZodStringFormatInternals<\"ipv6\"> {\n  def: $ZodIPv6Def;\n}\n\nexport interface $ZodIPv6 extends $ZodType {\n  _zod: $ZodIPv6Internals;\n}\n\nexport const $ZodIPv6: core.$constructor<$ZodIPv6> = /*@__PURE__*/ core.$constructor(\"$ZodIPv6\", (inst, def): void => {\n  def.pattern ??= regexes.ipv6;\n  $ZodStringFormat.init(inst, def);\n\n  inst._zod.onattach.push((inst) => {\n    const bag = inst._zod.bag as $ZodStringInternals<unknown>[\"bag\"];\n    bag.format = `ipv6`;\n  });\n\n  inst._zod.check = (payload) => {\n    try {\n      new URL(`http://[${payload.value}]`);\n      // return;\n    } catch {\n      payload.issues.push({\n        code: \"invalid_format\",\n        format: \"ipv6\",\n        input: payload.value,\n        inst,\n        continue: !def.abort,\n      });\n    }\n  };\n});\n\n//////////////////////////////   ZodCIDRv4   //////////////////////////////\n\nexport interface $ZodCIDRv4Def extends $ZodStringFormatDef<\"cidrv4\"> {\n  version?: \"v4\";\n}\n\nexport interface $ZodCIDRv4Internals extends $ZodStringFormatInternals<\"cidrv4\"> {\n  def: $ZodCIDRv4Def;\n}\n\nexport interface $ZodCIDRv4 extends $ZodType {\n  _zod: $ZodCIDRv4Internals;\n}\n\nexport const $ZodCIDRv4: core.$constructor<$ZodCIDRv4> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCIDRv4\",\n  (inst, def): void => {\n    def.pattern ??= regexes.cidrv4;\n    $ZodStringFormat.init(inst, def);\n  }\n);\n\n//////////////////////////////   ZodCIDRv6   //////////////////////////////\n\nexport interface $ZodCIDRv6Def extends $ZodStringFormatDef<\"cidrv6\"> {\n  version?: \"v6\";\n}\n\nexport interface $ZodCIDRv6Internals extends $ZodStringFormatInternals<\"cidrv6\"> {\n  def: $ZodCIDRv6Def;\n}\n\nexport interface $ZodCIDRv6 extends $ZodType {\n  _zod: $ZodCIDRv6Internals;\n}\n\nexport const $ZodCIDRv6: core.$constructor<$ZodCIDRv6> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCIDRv6\",\n  (inst, def): void => {\n    def.pattern ??= regexes.cidrv6; // not used for validation\n    $ZodStringFormat.init(inst, def);\n\n    inst._zod.check = (payload) => {\n      const [address, prefix] = payload.value.split(\"/\");\n      try {\n        if (!prefix) throw new Error();\n        const prefixNum = Number(prefix);\n        if (`${prefixNum}` !== prefix) throw new Error();\n        if (prefixNum < 0 || prefixNum > 128) throw new Error();\n        new URL(`http://[${address}]`);\n      } catch {\n        payload.issues.push({\n          code: \"invalid_format\",\n          format: \"cidrv6\",\n          input: payload.value,\n          inst,\n          continue: !def.abort,\n        });\n      }\n    };\n  }\n);\n\n//////////////////////////////   ZodBase64   //////////////////////////////\nexport function isValidBase64(data: string): boolean {\n  if (data === \"\") return true;\n  if (data.length % 4 !== 0) return false;\n  try {\n    atob(data);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport interface $ZodBase64Def extends $ZodStringFormatDef<\"base64\"> {}\nexport interface $ZodBase64Internals extends $ZodStringFormatInternals<\"base64\"> {}\n\nexport interface $ZodBase64 extends $ZodType {\n  _zod: $ZodBase64Internals;\n}\n\nexport const $ZodBase64: core.$constructor<$ZodBase64> = /*@__PURE__*/ core.$constructor(\n  \"$ZodBase64\",\n  (inst, def): void => {\n    def.pattern ??= regexes.base64;\n    $ZodStringFormat.init(inst, def);\n\n    inst._zod.onattach.push((inst) => {\n      inst._zod.bag.contentEncoding = \"base64\";\n    });\n\n    inst._zod.check = (payload) => {\n      if (isValidBase64(payload.value)) return;\n\n      payload.issues.push({\n        code: \"invalid_format\",\n        format: \"base64\",\n        input: payload.value,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n//////////////////////////////   ZodBase64   //////////////////////////////\nexport function isValidBase64URL(data: string): boolean {\n  if (!regexes.base64url.test(data)) return false;\n  const base64 = data.replace(/[-_]/g, (c) => (c === \"-\" ? \"+\" : \"/\"));\n  const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, \"=\");\n  return isValidBase64(padded);\n}\n\nexport interface $ZodBase64URLDef extends $ZodStringFormatDef<\"base64url\"> {}\nexport interface $ZodBase64URLInternals extends $ZodStringFormatInternals<\"base64url\"> {}\n\nexport interface $ZodBase64URL extends $ZodType {\n  _zod: $ZodBase64URLInternals;\n}\n\nexport const $ZodBase64URL: core.$constructor<$ZodBase64URL> = /*@__PURE__*/ core.$constructor(\n  \"$ZodBase64URL\",\n  (inst, def): void => {\n    def.pattern ??= regexes.base64url;\n    $ZodStringFormat.init(inst, def);\n\n    inst._zod.onattach.push((inst) => {\n      inst._zod.bag.contentEncoding = \"base64url\";\n    });\n\n    inst._zod.check = (payload) => {\n      if (isValidBase64URL(payload.value)) return;\n\n      payload.issues.push({\n        code: \"invalid_format\",\n        format: \"base64url\",\n        input: payload.value,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n//////////////////////////////   ZodE164   //////////////////////////////\n\nexport interface $ZodE164Def extends $ZodStringFormatDef<\"e164\"> {}\nexport interface $ZodE164Internals extends $ZodStringFormatInternals<\"e164\"> {}\n\nexport interface $ZodE164 extends $ZodType {\n  _zod: $ZodE164Internals;\n}\n\nexport const $ZodE164: core.$constructor<$ZodE164> = /*@__PURE__*/ core.$constructor(\"$ZodE164\", (inst, def): void => {\n  def.pattern ??= regexes.e164;\n  $ZodStringFormat.init(inst, def);\n});\n\n//////////////////////////////   ZodJWT   //////////////////////////////\n\nexport function isValidJWT(token: string, algorithm: util.JWTAlgorithm | null = null): boolean {\n  try {\n    const tokensParts = token.split(\".\");\n    if (tokensParts.length !== 3) return false;\n    const [header] = tokensParts;\n    if (!header) return false;\n    const parsedHeader = JSON.parse(atob(header));\n    if (\"typ\" in parsedHeader && parsedHeader?.typ !== \"JWT\") return false;\n    if (!parsedHeader.alg) return false;\n    if (algorithm && (!(\"alg\" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport interface $ZodJWTDef extends $ZodStringFormatDef<\"jwt\"> {\n  alg?: util.JWTAlgorithm | undefined;\n}\n\nexport interface $ZodJWTInternals extends $ZodStringFormatInternals<\"jwt\"> {\n  def: $ZodJWTDef;\n}\n\nexport interface $ZodJWT extends $ZodType {\n  _zod: $ZodJWTInternals;\n}\n\nexport const $ZodJWT: core.$constructor<$ZodJWT> = /*@__PURE__*/ core.$constructor(\"$ZodJWT\", (inst, def): void => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    if (isValidJWT(payload.value, def.alg)) return;\n\n    payload.issues.push({\n      code: \"invalid_format\",\n      format: \"jwt\",\n      input: payload.value,\n      inst,\n      continue: !def.abort,\n    });\n  };\n});\n\n//////////////////////////////   ZodCustomStringFormat   //////////////////////////////\n\nexport interface $ZodCustomStringFormatDef<Format extends string = string> extends $ZodStringFormatDef<Format> {\n  fn: (val: string) => unknown;\n}\n\nexport interface $ZodCustomStringFormatInternals<Format extends string = string>\n  extends $ZodStringFormatInternals<Format> {\n  def: $ZodCustomStringFormatDef<Format>;\n}\n\nexport interface $ZodCustomStringFormat<Format extends string = string> extends $ZodStringFormat<Format> {\n  _zod: $ZodCustomStringFormatInternals<Format>;\n}\n\nexport const $ZodCustomStringFormat: core.$constructor<$ZodCustomStringFormat> = /*@__PURE__*/ core.$constructor(\n  \"$ZodCustomStringFormat\",\n  (inst, def): void => {\n    $ZodStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n      if (def.fn(payload.value)) return;\n\n      payload.issues.push({\n        code: \"invalid_format\",\n        format: def.format,\n        input: payload.value,\n        inst,\n        continue: !def.abort,\n      });\n    };\n  }\n);\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n//////////                     //////////\n//////////      ZodNumber      //////////\n//////////                     //////////\n/////////////////////////////////////////\n/////////////////////////////////////////\n\nexport interface $ZodNumberDef extends $ZodTypeDef {\n  type: \"number\";\n  coerce?: boolean;\n  // checks: checks.$ZodCheck<number>[];\n}\n\nexport interface $ZodNumberInternals<Input = unknown> extends $ZodTypeInternals<number, Input> {\n  def: $ZodNumberDef;\n  /** @deprecated Internal API, use with caution (not deprecated) */\n  pattern: RegExp;\n  /** @deprecated Internal API, use with caution (not deprecated) */\n  isst: errors.$ZodIssueInvalidType;\n  bag: util.LoosePartial<{\n    minimum: number;\n    maximum: number;\n    exclusiveMinimum: number;\n    exclusiveMaximum: number;\n    format: string;\n    pattern: RegExp;\n  }>;\n}\n\nexport interface $ZodNumber<Input = unknown> extends $ZodType {\n  _zod: $ZodNumberInternals<Input>;\n}\n\nexport const $ZodNumber: core.$constructor<$ZodNumber> = /*@__PURE__*/ core.$constructor(\"$ZodNumber\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = inst._zod.bag.pattern ?? regexes.number;\n\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce)\n      try {\n        payload.value = Number(payload.value);\n      } catch (_) {}\n    const input = payload.value;\n    if (typeof input === \"number\" && !Number.isNaN(input) && Number.isFinite(input)) {\n      return payload;\n    }\n\n    const received =\n      typeof input === \"number\"\n        ? Number.isNaN(input)\n          ? \"NaN\"\n          : !Number.isFinite(input)\n            ? \"Infinity\"\n            : undefined\n        : undefined;\n\n    payload.issues.push({\n      expected: \"number\",\n      code: \"invalid_type\",\n      input,\n      inst,\n      ...(received ? { received } : {}),\n    });\n    return payload;\n  };\n});\n\n///////////////////////////////////////////////\n//////////      ZodNumberFormat      //////////\n///////////////////////////////////////////////\nexport interface $ZodNumberFormatDef extends $ZodNumberDef, checks.$ZodCheckNumberFormatDef {}\n\nexport interface $ZodNumberFormatInternals extends $ZodNumberInternals<number>, checks.$ZodCheckNumberFormatInternals {\n  def: $ZodNumberFormatDef;\n  isst: errors.$ZodIssueInvalidType;\n}\n\nexport interface $ZodNumberFormat extends $ZodType {\n  _zod: $ZodNumberFormatInternals;\n}\n\nexport const $ZodNumberFormat: core.$constructor<$ZodNumberFormat> = /*@__PURE__*/ core.$constructor(\n  \"$ZodNumber\",\n  (inst, def) => {\n    checks.$ZodCheckNumberFormat.init(inst, def);\n    $ZodNumber.init(inst, def); // no format checksp\n  }\n);\n\n///////////////////////////////////////////\n///////////////////////////////////////////\n//////////                      ///////////\n//////////      $ZodBoolean      //////////\n//////////                      ///////////\n///////////////////////////////////////////\n///////////////////////////////////////////\n\nexport interface $ZodBooleanDef extends $ZodTypeDef {\n  type: \"boolean\";\n  coerce?: boolean;\n  checks?: checks.$ZodCheck<boolean>[];\n}\n\nexport interface $ZodBooleanInternals<T = unknown> extends $ZodTypeInternals<boolean, T> {\n  pattern: RegExp;\n  def: $ZodBooleanDef;\n  isst: errors.$ZodIssueInvalidType;\n}\n\nexport interface $ZodBoolean<T = unknown> extends $ZodType {\n  _zod: $ZodBooleanInternals<T>;\n}\n\nexport const $ZodBoolean: core.$constructor<$ZodBoolean> = /*@__PURE__*/ core.$constructor(\n  \"$ZodBoolean\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = regexes.boolean;\n\n    inst._zod.parse = (payload, _ctx) => {\n      if (def.coerce)\n        try {\n          payload.value = Boolean(payload.value);\n        } catch (_) {}\n      const input = payload.value;\n      if (typeof input === \"boolean\") return payload;\n      payload.issues.push({\n        expected: \"boolean\",\n        code: \"invalid_type\",\n        input,\n        inst,\n      });\n      return payload;\n    };\n  }\n);\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      $ZodBigInt      //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n\nexport interface $ZodBigIntDef extends $ZodTypeDef {\n  type: \"bigint\";\n  coerce?: boolean;\n  // checks: checks.$ZodCheck<bigint>[];\n}\n\nexport interface $ZodBigIntInternals<T = unknown> extends $ZodTypeInternals<bigint, T> {\n  pattern: RegExp;\n  /** @internal Internal API, use with caution */\n  def: $ZodBigIntDef;\n  isst: errors.$ZodIssueInvalidType;\n  bag: util.LoosePartial<{\n    minimum: bigint;\n    maximum: bigint;\n    format: string;\n  }>;\n}\n\nexport interface $ZodBigInt<T = unknown> extends $ZodType {\n  _zod: $ZodBigIntInternals<T>;\n}\n\nexport const $ZodBigInt: core.$constructor<$ZodBigInt> = /*@__PURE__*/ core.$constructor(\"$ZodBigInt\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = regexes.bigint;\n\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce)\n      try {\n        payload.value = BigInt(payload.value);\n      } catch (_) {}\n\n    if (typeof payload.value === \"bigint\") return payload;\n    payload.issues.push({\n      expected: \"bigint\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst,\n    });\n    return payload;\n  };\n});\n\n///////////////////////////////////////////////\n//////////      ZodBigIntFormat      //////////\n///////////////////////////////////////////////\nexport interface $ZodBigIntFormatDef extends $ZodBigIntDef, checks.$ZodCheckBigIntFormatDef {\n  check: \"bigint_format\";\n}\n\nexport interface $ZodBigIntFormatInternals extends $ZodBigIntInternals<bigint>, checks.$ZodCheckBigIntFormatInternals {\n  def: $ZodBigIntFormatDef;\n}\n\nexport interface $ZodBigIntFormat extends $ZodType {\n  _zod: $ZodBigIntFormatInternals;\n}\n\nexport const $ZodBigIntFormat: core.$constructor<$ZodBigIntFormat> = /*@__PURE__*/ core.$constructor(\n  \"$ZodBigInt\",\n  (inst, def) => {\n    checks.$ZodCheckBigIntFormat.init(inst, def);\n    $ZodBigInt.init(inst, def); // no format checks\n  }\n);\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////       $ZodSymbol       //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\nexport interface $ZodSymbolDef extends $ZodTypeDef {\n  type: \"symbol\";\n}\n\nexport interface $ZodSymbolInternals extends $ZodTypeInternals<symbol, symbol> {\n  def: $ZodSymbolDef;\n  isst: errors.$ZodIssueInvalidType;\n}\n\nexport interface $ZodSymbol extends $ZodType {\n  _zod: $ZodSymbolInternals;\n}\n\nexport const $ZodSymbol: core.$constructor<$ZodSymbol> = /*@__PURE__*/ core.$constructor(\"$ZodSymbol\", (inst, def) => {\n  $ZodType.init(inst, def);\n\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (typeof input === \"symbol\") return payload;\n    payload.issues.push({\n      expected: \"symbol\",\n      code: \"invalid_type\",\n      input,\n      inst,\n    });\n    return payload;\n  };\n});\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////      $ZodUndefined     //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\nexport interface $ZodUndefinedDef extends $ZodTypeDef {\n  type: \"undefined\";\n}\n\nexport interface $ZodUndefinedInternals extends $ZodTypeInternals<undefined, undefined> {\n  pattern: RegExp;\n  def: $ZodUndefinedDef;\n  values: util.PrimitiveSet;\n  isst: errors.$ZodIssueInvalidType;\n}\n\nexport interface $ZodUndefined extends $ZodType {\n  _zod: $ZodUndefinedInternals;\n}\n\nexport const $ZodUndefined: core.$constructor<$ZodUndefined> = /*@__PURE__*/ core.$constructor(\n  \"$ZodUndefined\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = regexes.undefined;\n    inst._zod.values = new Set([undefined]);\n    inst._zod.optin = \"optional\";\n    inst._zod.optout = \"optional\";\n\n    inst._zod.parse = (payload, _ctx) => {\n      const input = payload.value;\n      if (typeof input === \"undefined\") return payload;\n      payload.issues.push({\n        expected: \"undefined\",\n        code: \"invalid_type\",\n        input,\n        inst,\n      });\n      return payload;\n    };\n  }\n);\n\n///////////////////////////////////////\n///////////////////////////////////////\n//////////                   //////////\n//////////      $ZodNull      /////////\n//////////                   //////////\n///////////////////////////////////////\n///////////////////////////////////////\n\nexport interface $ZodNullDef extends $ZodTypeDef {\n  type: \"null\";\n}\n\nexport interface $ZodNullInternals extends $ZodTypeInternals<null, null> {\n  pattern: RegExp;\n  def: $ZodNullDef;\n  values: util.PrimitiveSet;\n  isst: errors.$ZodIssueInvalidType;\n}\n\nexport interface $ZodNull extends $ZodType {\n  _zod: $ZodNullInternals;\n}\n\nexport const $ZodNull: core.$constructor<$ZodNull> = /*@__PURE__*/ core.$constructor(\"$ZodNull\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = regexes.null;\n  inst._zod.values = new Set([null]);\n\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (input === null) return payload;\n    payload.issues.push({\n      expected: \"null\",\n      code: \"invalid_type\",\n      input,\n      inst,\n    });\n    return payload;\n  };\n});\n\n//////////////////////////////////////\n//////////////////////////////////////\n//////////                  //////////\n//////////      $ZodAny     //////////\n//////////                  //////////\n//////////////////////////////////////\n//////////////////////////////////////\n\nexport interface $ZodAnyDef extends $ZodTypeDef {\n  type: \"any\";\n}\n\nexport interface $ZodAnyInternals extends $ZodTypeInternals<any, any> {\n  def: $ZodAnyDef;\n  isst: never;\n}\n\nexport interface $ZodAny extends $ZodType {\n  _zod: $ZodAnyInternals;\n}\n\nexport const $ZodAny: core.$constructor<$ZodAny> = /*@__PURE__*/ core.$constructor(\"$ZodAny\", (inst, def) => {\n  $ZodType.init(inst, def);\n\n  inst._zod.parse = (payload) => payload;\n});\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      $ZodUnknown     //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n\nexport interface $ZodUnknownDef extends $ZodTypeDef {\n  type: \"unknown\";\n}\n\nexport interface $ZodUnknownInternals extends $ZodTypeInternals<unknown, unknown> {\n  def: $ZodUnknownDef;\n  isst: never;\n}\n\nexport interface $ZodUnknown extends $ZodType {\n  _zod: $ZodUnknownInternals;\n}\n\nexport const $ZodUnknown: core.$constructor<$ZodUnknown> = /*@__PURE__*/ core.$constructor(\n  \"$ZodUnknown\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n\n    inst._zod.parse = (payload) => payload;\n  }\n);\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n//////////                     //////////\n//////////      $ZodNever      //////////\n//////////                     //////////\n/////////////////////////////////////////\n/////////////////////////////////////////\n\nexport interface $ZodNeverDef extends $ZodTypeDef {\n  type: \"never\";\n}\n\nexport interface $ZodNeverInternals extends $ZodTypeInternals<never, never> {\n  def: $ZodNeverDef;\n  isst: errors.$ZodIssueInvalidType;\n}\n\nexport interface $ZodNever extends $ZodType {\n  _zod: $ZodNeverInternals;\n}\n\nexport const $ZodNever: core.$constructor<$ZodNever> = /*@__PURE__*/ core.$constructor(\"$ZodNever\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.issues.push({\n      expected: \"never\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst,\n    });\n    return payload;\n  };\n});\n\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      $ZodVoid      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\n\nexport interface $ZodVoidDef extends $ZodTypeDef {\n  type: \"void\";\n}\n\nexport interface $ZodVoidInternals extends $ZodTypeInternals<void, void> {\n  def: $ZodVoidDef;\n  isst: errors.$ZodIssueInvalidType;\n}\n\nexport interface $ZodVoid extends $ZodType {\n  _zod: $ZodVoidInternals;\n}\n\nexport const $ZodVoid: core.$constructor<$ZodVoid> = /*@__PURE__*/ core.$constructor(\"$ZodVoid\", (inst, def) => {\n  $ZodType.init(inst, def);\n\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (typeof input === \"undefined\") return payload;\n    payload.issues.push({\n      expected: \"void\",\n      code: \"invalid_type\",\n      input,\n      inst,\n    });\n    return payload;\n  };\n});\n\n///////////////////////////////////////\n///////////////////////////////////////\n//////////                     ////////\n//////////      $ZodDate        ////////\n//////////                     ////////\n///////////////////////////////////////\n///////////////////////////////////////\nexport interface $ZodDateDef extends $ZodTypeDef {\n  type: \"date\";\n  coerce?: boolean;\n}\n\nexport interface $ZodDateInternals<T = unknown> extends $ZodTypeInternals<Date, T> {\n  def: $ZodDateDef;\n  isst: errors.$ZodIssueInvalidType; // | errors.$ZodIssueInvalidDate;\n  bag: util.LoosePartial<{\n    minimum: Date;\n    maximum: Date;\n    format: string;\n  }>;\n}\n\nexport interface $ZodDate<T = unknown> extends $ZodType {\n  _zod: $ZodDateInternals<T>;\n}\n\nexport const $ZodDate: core.$constructor<$ZodDate> = /*@__PURE__*/ core.$constructor(\"$ZodDate\", (inst, def) => {\n  $ZodType.init(inst, def);\n\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) {\n      try {\n        payload.value = new Date(payload.value as string | number | Date);\n      } catch (_err: any) {}\n    }\n    const input = payload.value;\n\n    const isDate = input instanceof Date;\n    const isValidDate = isDate && !Number.isNaN(input.getTime());\n    if (isValidDate) return payload;\n    payload.issues.push({\n      expected: \"date\",\n      code: \"invalid_type\",\n      input,\n      ...(isDate ? { received: \"Invalid Date\" } : {}),\n      inst,\n    });\n\n    return payload;\n  };\n});\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n//////////                     //////////\n//////////      $ZodArray      //////////\n//////////                     //////////\n/////////////////////////////////////////\n/////////////////////////////////////////\n\nexport interface $ZodArrayDef<T extends SomeType = $ZodType> extends $ZodTypeDef {\n  type: \"array\";\n  element: T;\n}\n\nexport interface $ZodArrayInternals<T extends SomeType = $ZodType> extends _$ZodTypeInternals {\n  //$ZodTypeInternals<core.output<T>[], core.input<T>[]> {\n  def: $ZodArrayDef<T>;\n  isst: errors.$ZodIssueInvalidType;\n  output: core.output<T>[];\n  input: core.input<T>[];\n}\n\nexport interface $ZodArray<T extends SomeType = $ZodType> extends $ZodType<any, any, $ZodArrayInternals<T>> {}\n\nfunction handleArrayResult(result: ParsePayload<any>, final: ParsePayload<any[]>, index: number) {\n  if (result.issues.length) {\n    final.issues.push(...util.prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\n\nexport const $ZodArray: core.$constructor<$ZodArray> = /*@__PURE__*/ core.$constructor(\"$ZodArray\", (inst, def) => {\n  $ZodType.init(inst, def);\n\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        expected: \"array\",\n        code: \"invalid_type\",\n        input,\n        inst,\n      });\n      return payload;\n    }\n\n    payload.value = Array(input.length);\n    const proms: Promise<any>[] = [];\n    for (let i = 0; i < input.length; i++) {\n      const item = input[i];\n      const result = def.element._zod.run(\n        {\n          value: item,\n          issues: [],\n        },\n        ctx\n      );\n\n      if (result instanceof Promise) {\n        proms.push(result.then((result) => handleArrayResult(result, payload, i)));\n      } else {\n        handleArrayResult(result, payload, i);\n      }\n    }\n\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n\n    return payload; //handleArrayResultsAsync(parseResults, final);\n  };\n});\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      $ZodObject      //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n\ntype OptionalOutSchema = { _zod: { optout: \"optional\" } };\ntype OptionalInSchema = { _zod: { optin: \"optional\" } };\n\nexport type $InferObjectOutput<T extends $ZodLooseShape, Extra extends Record<string, unknown>> = string extends keyof T\n  ? util.IsAny<T[keyof T]> extends true\n    ? Record<string, unknown>\n    : Record<string, core.output<T[keyof T]>>\n  : keyof (T & Extra) extends never\n    ? Record<string, never>\n    : util.Prettify<\n        {\n          -readonly [k in keyof T as T[k] extends OptionalOutSchema ? never : k]: T[k][\"_zod\"][\"output\"];\n        } & {\n          -readonly [k in keyof T as T[k] extends OptionalOutSchema ? k : never]?: T[k][\"_zod\"][\"output\"];\n        } & Extra\n      >;\n\nexport type $InferObjectInput<T extends $ZodLooseShape, Extra extends Record<string, unknown>> = string extends keyof T\n  ? util.IsAny<T[keyof T]> extends true\n    ? Record<string, unknown>\n    : Record<string, core.input<T[keyof T]>>\n  : keyof (T & Extra) extends never\n    ? Record<string, never>\n    : util.Prettify<\n        {\n          -readonly [k in keyof T as T[k] extends OptionalInSchema ? never : k]: T[k][\"_zod\"][\"input\"];\n        } & {\n          -readonly [k in keyof T as T[k] extends OptionalInSchema ? k : never]?: T[k][\"_zod\"][\"input\"];\n        } & Extra\n      >;\n\nfunction handleObjectResult(result: ParsePayload, final: ParsePayload, key: PropertyKey) {\n  // if(isOptional)\n  if (result.issues.length) {\n    final.issues.push(...util.prefixIssues(key, result.issues));\n  }\n\n  (final.value as any)[key] = result.value;\n}\n\nfunction handleOptionalObjectResult(result: ParsePayload, final: ParsePayload, key: PropertyKey, input: any) {\n  if (result.issues.length) {\n    // validation failed against value schema\n    if (input[key] === undefined) {\n      // if input was undefined, ignore the error\n      if (key in input) {\n        (final.value as any)[key] = undefined;\n      } else {\n        (final.value as any)[key] = result.value;\n      }\n    } else {\n      final.issues.push(...util.prefixIssues(key, result.issues));\n    }\n  } else if (result.value === undefined) {\n    // validation returned `undefined`\n    if (key in input) (final.value as any)[key] = undefined;\n  } else {\n    // non-undefined value\n    (final.value as any)[key] = result.value;\n  }\n}\n\nexport type $ZodObjectConfig = { out: Record<string, unknown>; in: Record<string, unknown> };\n\nexport type $loose = {\n  out: Record<string, unknown>;\n  in: Record<string, unknown>;\n};\nexport type $strict = {\n  out: {};\n  in: {};\n};\nexport type $strip = {\n  out: {};\n  in: {};\n};\n\nexport type $catchall<T extends SomeType> = {\n  out: { [k: string]: core.output<T> };\n  in: { [k: string]: core.input<T> };\n};\n\nexport type $ZodShape = Readonly<{ [k: string]: $ZodType }>;\n\nexport interface $ZodObjectDef<Shape extends $ZodShape = $ZodShape> extends $ZodTypeDef {\n  type: \"object\";\n  shape: Shape;\n  catchall?: $ZodType | undefined;\n}\n\nexport interface $ZodObjectInternals<\n  /** @ts-ignore Cast variance */\n  out Shape extends Readonly<$ZodShape> = Readonly<$ZodShape>,\n  out Config extends $ZodObjectConfig = $ZodObjectConfig,\n> extends _$ZodTypeInternals {\n  def: $ZodObjectDef<Shape>;\n  config: Config;\n  isst: errors.$ZodIssueInvalidType | errors.$ZodIssueUnrecognizedKeys;\n  propValues: util.PropValues;\n  output: $InferObjectOutput<Shape, Config[\"out\"]>;\n  input: $InferObjectInput<Shape, Config[\"in\"]>;\n}\nexport type $ZodLooseShape = Record<string, any>;\n\nexport interface $ZodObject<\n  /** @ts-ignore Cast variance */\n  out Shape extends Readonly<$ZodShape> = Readonly<$ZodShape>,\n  out Params extends $ZodObjectConfig = $ZodObjectConfig,\n> extends $ZodType<any, any, $ZodObjectInternals<Shape, Params>> {\n  \"~standard\": $ZodStandardSchema<this>;\n}\n\nexport const $ZodObject: core.$constructor<$ZodObject> = /*@__PURE__*/ core.$constructor(\"$ZodObject\", (inst, def) => {\n  // requires cast because technically $ZodObject doesn't extend\n  $ZodType.init(inst, def);\n\n  const _normalized = util.cached(() => {\n    const keys = Object.keys(def.shape);\n    for (const k of keys) {\n      if (!(def.shape[k] instanceof $ZodType)) {\n        throw new Error(`Invalid element at key \"${k}\": expected a Zod schema`);\n      }\n    }\n    const okeys = util.optionalKeys(def.shape);\n\n    return {\n      shape: def.shape,\n      keys,\n      keySet: new Set(keys),\n      numKeys: keys.length,\n      optionalKeys: new Set(okeys),\n    };\n  });\n\n  util.defineLazy(inst._zod, \"propValues\", () => {\n    const shape = def.shape;\n    const propValues: util.PropValues = {};\n    for (const key in shape) {\n      const field = shape[key]!._zod;\n      if (field.values) {\n        propValues[key] ??= new Set();\n        for (const v of field.values) propValues[key].add(v);\n      }\n    }\n    return propValues;\n  });\n\n  const generateFastpass = (shape: any) => {\n    const doc = new Doc([\"shape\", \"payload\", \"ctx\"]);\n    const normalized = _normalized.value;\n\n    const parseStr = (key: string) => {\n      const k = util.esc(key);\n      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;\n    };\n\n    doc.write(`const input = payload.value;`);\n\n    const ids: any = Object.create(null);\n    let counter = 0;\n    for (const key of normalized.keys) {\n      ids[key] = `key_${counter++}`;\n    }\n\n    // A: preserve key order {\n    doc.write(`const newResult = {}`);\n    for (const key of normalized.keys) {\n      if (normalized.optionalKeys.has(key)) {\n        const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        const k = util.esc(key);\n        doc.write(`\n        if (${id}.issues.length) {\n          if (input[${k}] === undefined) {\n            if (${k} in input) {\n              newResult[${k}] = undefined;\n            }\n          } else {\n            payload.issues = payload.issues.concat(\n              ${id}.issues.map((iss) => ({\n                ...iss,\n                path: iss.path ? [${k}, ...iss.path] : [${k}],\n              }))\n            );\n          }\n        } else if (${id}.value === undefined) {\n          if (${k} in input) newResult[${k}] = undefined;\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n        `);\n      } else {\n        const id = ids[key];\n        //  const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        doc.write(`\n          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${util.esc(key)}, ...iss.path] : [${util.esc(key)}]\n          })));`);\n        doc.write(`newResult[${util.esc(key)}] = ${id}.value`);\n      }\n    }\n\n    doc.write(`payload.value = newResult;`);\n    doc.write(`return payload;`);\n    const fn = doc.compile();\n    return (payload: any, ctx: any) => fn(shape, payload, ctx);\n  };\n\n  let fastpass!: ReturnType<typeof generateFastpass>;\n\n  const isObject = util.isObject;\n  const jit = !core.globalConfig.jitless;\n  const allowsEval = util.allowsEval;\n\n  const fastEnabled = jit && allowsEval.value; // && !def.catchall;\n  const catchall = def.catchall;\n\n  let value!: typeof _normalized.value;\n\n  inst._zod.parse = (payload, ctx) => {\n    value ??= _normalized.value;\n    const input = payload.value;\n    if (!isObject(input)) {\n      payload.issues.push({\n        expected: \"object\",\n        code: \"invalid_type\",\n        input,\n        inst,\n      });\n      return payload;\n    }\n\n    const proms: Promise<any>[] = [];\n\n    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n      // always synchronous\n      if (!fastpass) fastpass = generateFastpass(def.shape);\n      payload = fastpass(payload, ctx);\n    } else {\n      payload.value = {};\n\n      const shape = value.shape;\n      for (const key of value.keys) {\n        const el = shape[key]!;\n\n        // do not add omitted optional keys\n        // if (!(key in input)) {\n        //   if (optionalKeys.has(key)) continue;\n        //   payload.issues.push({\n        //     code: \"invalid_type\",\n        //     path: [key],\n        //     expected: \"nonoptional\",\n        //     note: `Missing required key: \"${key}\"`,\n        //     input,\n        //     inst,\n        //   });\n        // }\n\n        const r = el._zod.run({ value: input[key], issues: [] }, ctx);\n        const isOptional = el._zod.optin === \"optional\" && el._zod.optout === \"optional\";\n\n        if (r instanceof Promise) {\n          proms.push(\n            r.then((r) =>\n              isOptional ? handleOptionalObjectResult(r, payload, key, input) : handleObjectResult(r, payload, key)\n            )\n          );\n        } else if (isOptional) {\n          handleOptionalObjectResult(r, payload, key, input);\n        } else {\n          handleObjectResult(r, payload, key);\n        }\n      }\n    }\n\n    if (!catchall) {\n      // return payload;\n      return proms.length ? Promise.all(proms).then(() => payload) : payload;\n    }\n    const unrecognized: string[] = [];\n    // iterate over input keys\n    const keySet = value.keySet;\n    const _catchall = catchall._zod;\n    const t = _catchall.def.type;\n    for (const key of Object.keys(input)) {\n      if (keySet.has(key)) continue;\n      if (t === \"never\") {\n        unrecognized.push(key);\n        continue;\n      }\n      const r = _catchall.run({ value: input[key], issues: [] }, ctx);\n\n      if (r instanceof Promise) {\n        proms.push(r.then((r) => handleObjectResult(r, payload, key)));\n      } else {\n        handleObjectResult(r, payload, key);\n      }\n    }\n\n    if (unrecognized.length) {\n      payload.issues.push({\n        code: \"unrecognized_keys\",\n        keys: unrecognized,\n        input,\n        inst,\n      });\n    }\n\n    if (!proms.length) return payload;\n    return Promise.all(proms).then(() => {\n      return payload;\n    });\n  };\n});\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n//////////                    ///////////\n//////////      $ZodUnion      //////////\n//////////                    ///////////\n/////////////////////////////////////////\n/////////////////////////////////////////\n// use generic to distribute union types\nexport type $InferUnionOutput<T extends SomeType> = T extends any ? core.output<T> : never;\nexport type $InferUnionInput<T extends SomeType> = T extends any ? core.input<T> : never;\nexport interface $ZodUnionDef<Options extends readonly SomeType[] = readonly $ZodType[]> extends $ZodTypeDef {\n  type: \"union\";\n  options: Options;\n}\n\ntype IsOptionalIn<T extends SomeType> = T extends OptionalInSchema ? true : false;\ntype IsOptionalOut<T extends SomeType> = T extends OptionalOutSchema ? true : false;\n\nexport interface $ZodUnionInternals<T extends readonly SomeType[] = readonly $ZodType[]> extends _$ZodTypeInternals {\n  def: $ZodUnionDef<T>;\n  isst: errors.$ZodIssueInvalidUnion;\n  pattern: T[number][\"_zod\"][\"pattern\"];\n  values: T[number][\"_zod\"][\"values\"]; //GetValues<T[number]>;\n  output: $InferUnionOutput<T[number]>;\n  input: $InferUnionInput<T[number]>;\n  // if any element in the union is optional, then the union is optional\n  optin: IsOptionalIn<T[number]> extends false ? \"optional\" | undefined : \"optional\";\n  optout: IsOptionalOut<T[number]> extends false ? \"optional\" | undefined : \"optional\";\n}\n\nexport interface $ZodUnion<T extends readonly SomeType[] = readonly $ZodType[]>\n  extends $ZodType<any, any, $ZodUnionInternals<T>> {\n  _zod: $ZodUnionInternals<T>;\n}\n\nfunction handleUnionResults(results: ParsePayload[], final: ParsePayload, inst: $ZodUnion, ctx?: ParseContext) {\n  for (const result of results) {\n    if (result.issues.length === 0) {\n      final.value = result.value;\n      return final;\n    }\n  }\n\n  final.issues.push({\n    code: \"invalid_union\",\n    input: final.value,\n    inst,\n    errors: results.map((result) => result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n  });\n\n  return final;\n}\n\nexport const $ZodUnion: core.$constructor<$ZodUnion> = /*@__PURE__*/ core.$constructor(\"$ZodUnion\", (inst, def) => {\n  $ZodType.init(inst, def);\n\n  util.defineLazy(inst._zod, \"optin\", () =>\n    def.options.some((o) => o._zod.optin === \"optional\") ? \"optional\" : undefined\n  );\n\n  util.defineLazy(inst._zod, \"optout\", () =>\n    def.options.some((o) => o._zod.optout === \"optional\") ? \"optional\" : undefined\n  );\n\n  util.defineLazy(inst._zod, \"values\", () => {\n    if (def.options.every((o) => o._zod.values)) {\n      return new Set<util.Primitive>(def.options.flatMap((option) => Array.from(option._zod.values!)));\n    }\n    return undefined;\n  });\n\n  util.defineLazy(inst._zod, \"pattern\", () => {\n    if (def.options.every((o) => o._zod.pattern)) {\n      const patterns = def.options.map((o) => o._zod.pattern);\n      return new RegExp(`^(${patterns.map((p) => util.cleanRegex(p!.source)).join(\"|\")})$`);\n    }\n    return undefined;\n  });\n\n  inst._zod.parse = (payload, ctx) => {\n    let async = false;\n\n    const results: util.MaybeAsync<ParsePayload>[] = [];\n    for (const option of def.options) {\n      const result = option._zod.run(\n        {\n          value: payload.value,\n          issues: [],\n        },\n        ctx\n      );\n      if (result instanceof Promise) {\n        results.push(result);\n        async = true;\n      } else {\n        if (result.issues.length === 0) return result;\n        results.push(result);\n      }\n    }\n\n    if (!async) return handleUnionResults(results as ParsePayload[], payload, inst, ctx);\n    return Promise.all(results).then((results) => {\n      return handleUnionResults(results as ParsePayload[], payload, inst, ctx);\n    });\n  };\n});\n\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////                                  //////////\n//////////      $ZodDiscriminatedUnion      //////////\n//////////                                  //////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n\nexport interface $ZodDiscriminatedUnionDef<Options extends readonly SomeType[] = readonly $ZodType[]>\n  extends $ZodUnionDef<Options> {\n  discriminator: string;\n  unionFallback?: boolean;\n}\n\nexport interface $ZodDiscriminatedUnionInternals<Options extends readonly SomeType[] = readonly $ZodType[]>\n  extends $ZodUnionInternals<Options> {\n  def: $ZodDiscriminatedUnionDef<Options>;\n  propValues: util.PropValues;\n}\n\nexport interface $ZodDiscriminatedUnion<T extends readonly SomeType[] = readonly $ZodType[]> extends $ZodType {\n  _zod: $ZodDiscriminatedUnionInternals<T>;\n}\n\nexport const $ZodDiscriminatedUnion: core.$constructor<$ZodDiscriminatedUnion> =\n  /*@__PURE__*/\n  core.$constructor(\"$ZodDiscriminatedUnion\", (inst, def) => {\n    $ZodUnion.init(inst, def);\n\n    const _super = inst._zod.parse;\n    util.defineLazy(inst._zod, \"propValues\", () => {\n      const propValues: util.PropValues = {};\n      for (const option of def.options) {\n        const pv = option._zod.propValues;\n        if (!pv || Object.keys(pv).length === 0)\n          throw new Error(`Invalid discriminated union option at index \"${def.options.indexOf(option)}\"`);\n        for (const [k, v] of Object.entries(pv!)) {\n          if (!propValues[k]) propValues[k] = new Set();\n          for (const val of v) {\n            propValues[k].add(val);\n          }\n        }\n      }\n      return propValues;\n    });\n\n    const disc = util.cached(() => {\n      const opts = def.options as $ZodTypeDiscriminable[];\n      const map: Map<util.Primitive, $ZodType> = new Map();\n      for (const o of opts) {\n        const values = o._zod.propValues[def.discriminator];\n        if (!values || values.size === 0)\n          throw new Error(`Invalid discriminated union option at index \"${def.options.indexOf(o)}\"`);\n        for (const v of values) {\n          if (map.has(v)) {\n            throw new Error(`Duplicate discriminator value \"${String(v)}\"`);\n          }\n          map.set(v, o);\n        }\n      }\n      return map;\n    });\n\n    inst._zod.parse = (payload, ctx) => {\n      const input = payload.value;\n      if (!util.isObject(input)) {\n        payload.issues.push({\n          code: \"invalid_type\",\n          expected: \"object\",\n          input,\n          inst,\n        });\n        return payload;\n      }\n\n      const opt = disc.value.get(input?.[def.discriminator] as any);\n      if (opt) {\n        return opt._zod.run(payload, ctx) as any;\n      }\n\n      if (def.unionFallback) {\n        return _super(payload, ctx);\n      }\n\n      // no matching discriminator\n      payload.issues.push({\n        code: \"invalid_union\",\n        errors: [],\n        note: \"No matching discriminator\",\n        input,\n        path: [def.discriminator],\n        inst,\n      });\n\n      return payload;\n    };\n  });\n\n////////////////////////////////////////////////\n////////////////////////////////////////////////\n//////////                            //////////\n//////////      $ZodIntersection      //////////\n//////////                            //////////\n////////////////////////////////////////////////\n////////////////////////////////////////////////\n\nexport interface $ZodIntersectionDef<Left extends SomeType = $ZodType, Right extends SomeType = $ZodType>\n  extends $ZodTypeDef {\n  type: \"intersection\";\n  left: Left;\n  right: Right;\n}\n\nexport interface $ZodIntersectionInternals<A extends SomeType = $ZodType, B extends SomeType = $ZodType>\n  extends $ZodTypeInternals<core.output<A> & core.output<B>, core.input<A> & core.input<B>> {\n  def: $ZodIntersectionDef<A, B>;\n  isst: never;\n  optin: A[\"_zod\"][\"optin\"] | B[\"_zod\"][\"optin\"];\n  optout: A[\"_zod\"][\"optout\"] | B[\"_zod\"][\"optout\"];\n}\n\nexport interface $ZodIntersection<A extends SomeType = $ZodType, B extends SomeType = $ZodType> extends $ZodType {\n  _zod: $ZodIntersectionInternals<A, B>;\n}\n\nexport const $ZodIntersection: core.$constructor<$ZodIntersection> = /*@__PURE__*/ core.$constructor(\n  \"$ZodIntersection\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n\n    inst._zod.parse = (payload, ctx) => {\n      const input = payload.value;\n      const left = def.left._zod.run({ value: input, issues: [] }, ctx);\n      const right = def.right._zod.run({ value: input, issues: [] }, ctx);\n      const async = left instanceof Promise || right instanceof Promise;\n\n      if (async) {\n        return Promise.all([left, right]).then(([left, right]) => {\n          return handleIntersectionResults(payload, left, right);\n        });\n      }\n\n      return handleIntersectionResults(payload, left, right);\n    };\n  }\n);\n\nfunction mergeValues(\n  a: any,\n  b: any\n): { valid: true; data: any } | { valid: false; mergeErrorPath: (string | number)[] } {\n  // const aType = parse.t(a);\n  // const bType = parse.t(b);\n\n  if (a === b) {\n    return { valid: true, data: a };\n  }\n  if (a instanceof Date && b instanceof Date && +a === +b) {\n    return { valid: true, data: a };\n  }\n  if (util.isPlainObject(a) && util.isPlainObject(b)) {\n    const bKeys = Object.keys(b);\n    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);\n\n    const newObj: any = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [key, ...sharedValue.mergeErrorPath],\n        };\n      }\n      newObj[key] = sharedValue.data;\n    }\n\n    return { valid: true, data: newObj };\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return { valid: false, mergeErrorPath: [] };\n    }\n\n    const newArray: unknown[] = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [index, ...sharedValue.mergeErrorPath],\n        };\n      }\n\n      newArray.push(sharedValue.data);\n    }\n\n    return { valid: true, data: newArray };\n  }\n\n  return { valid: false, mergeErrorPath: [] };\n}\n\nfunction handleIntersectionResults(result: ParsePayload, left: ParsePayload, right: ParsePayload): ParsePayload {\n  if (left.issues.length) {\n    result.issues.push(...left.issues);\n  }\n  if (right.issues.length) {\n    result.issues.push(...right.issues);\n  }\n  if (util.aborted(result)) return result;\n\n  const merged = mergeValues(left.value, right.value);\n\n  if (!merged.valid) {\n    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);\n  }\n\n  result.value = merged.data;\n  return result;\n}\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n//////////                     //////////\n//////////      $ZodTuple      //////////\n//////////                     //////////\n/////////////////////////////////////////\n/////////////////////////////////////////\n\nexport interface $ZodTupleDef<\n  T extends util.TupleItems = readonly $ZodType[],\n  Rest extends SomeType | null = $ZodType | null,\n> extends $ZodTypeDef {\n  type: \"tuple\";\n  items: T;\n  rest: Rest;\n}\n\nexport type $InferTupleInputType<T extends util.TupleItems, Rest extends SomeType | null> = [\n  ...TupleInputTypeWithOptionals<T>,\n  ...(Rest extends SomeType ? core.input<Rest>[] : []),\n];\ntype TupleInputTypeNoOptionals<T extends util.TupleItems> = {\n  [k in keyof T]: core.input<T[k]>;\n};\ntype TupleInputTypeWithOptionals<T extends util.TupleItems> = T extends readonly [\n  ...infer Prefix extends SomeType[],\n  infer Tail extends SomeType,\n]\n  ? Tail[\"_zod\"][\"optin\"] extends \"optional\"\n    ? [...TupleInputTypeWithOptionals<Prefix>, core.input<Tail>?]\n    : TupleInputTypeNoOptionals<T>\n  : [];\n\nexport type $InferTupleOutputType<T extends util.TupleItems, Rest extends SomeType | null> = [\n  ...TupleOutputTypeWithOptionals<T>,\n  ...(Rest extends SomeType ? core.output<Rest>[] : []),\n];\ntype TupleOutputTypeNoOptionals<T extends util.TupleItems> = {\n  [k in keyof T]: core.output<T[k]>;\n};\ntype TupleOutputTypeWithOptionals<T extends util.TupleItems> = T extends readonly [\n  ...infer Prefix extends SomeType[],\n  infer Tail extends SomeType,\n]\n  ? Tail[\"_zod\"][\"optout\"] extends \"optional\"\n    ? [...TupleOutputTypeWithOptionals<Prefix>, core.output<Tail>?]\n    : TupleOutputTypeNoOptionals<T>\n  : [];\n\nexport interface $ZodTupleInternals<\n  T extends util.TupleItems = readonly $ZodType[],\n  Rest extends SomeType | null = $ZodType | null,\n> extends $ZodTypeInternals<$InferTupleOutputType<T, Rest>, $InferTupleInputType<T, Rest>> {\n  def: $ZodTupleDef<T, Rest>;\n  isst: errors.$ZodIssueInvalidType | errors.$ZodIssueTooBig<unknown[]> | errors.$ZodIssueTooSmall<unknown[]>;\n}\n\nexport interface $ZodTuple<\n  T extends util.TupleItems = readonly $ZodType[],\n  Rest extends SomeType | null = $ZodType | null,\n> extends $ZodType {\n  _zod: $ZodTupleInternals<T, Rest>;\n}\n\nexport const $ZodTuple: core.$constructor<$ZodTuple> = /*@__PURE__*/ core.$constructor(\"$ZodTuple\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const items = def.items;\n  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== \"optional\");\n\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        input,\n        inst,\n        expected: \"tuple\",\n        code: \"invalid_type\",\n      });\n      return payload;\n    }\n\n    payload.value = [];\n    const proms: Promise<any>[] = [];\n\n    if (!def.rest) {\n      const tooBig = input.length > items.length;\n      const tooSmall = input.length < optStart - 1;\n      if (tooBig || tooSmall) {\n        payload.issues.push({\n          input,\n          inst,\n          origin: \"array\" as const,\n          ...(tooBig ? { code: \"too_big\", maximum: items.length } : { code: \"too_small\", minimum: items.length }),\n        });\n        return payload;\n      }\n    }\n\n    let i = -1;\n    for (const item of items) {\n      i++;\n      if (i >= input.length) if (i >= optStart) continue;\n      const result = item._zod.run(\n        {\n          value: input[i],\n          issues: [],\n        },\n        ctx\n      );\n\n      if (result instanceof Promise) {\n        proms.push(result.then((result) => handleTupleResult(result, payload, i)));\n      } else {\n        handleTupleResult(result, payload, i);\n      }\n    }\n\n    if (def.rest) {\n      const rest = input.slice(items.length);\n      for (const el of rest) {\n        i++;\n        const result = def.rest._zod.run(\n          {\n            value: el,\n            issues: [],\n          },\n          ctx\n        );\n\n        if (result instanceof Promise) {\n          proms.push(result.then((result) => handleTupleResult(result, payload, i)));\n        } else {\n          handleTupleResult(result, payload, i);\n        }\n      }\n    }\n\n    if (proms.length) return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\n\nfunction handleTupleResult(result: ParsePayload, final: ParsePayload<any[]>, index: number) {\n  if (result.issues.length) {\n    final.issues.push(...util.prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      $ZodRecord      //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n\nexport type $ZodRecordKey = $ZodType<string | number | symbol, string | number | symbol>; // $HasValues | $HasPattern;\nexport interface $ZodRecordDef<Key extends $ZodRecordKey = $ZodRecordKey, Value extends SomeType = $ZodType>\n  extends $ZodTypeDef {\n  type: \"record\";\n  keyType: Key;\n  valueType: Value;\n}\n\n// export type $InferZodRecordOutput<\n//   Key extends $ZodRecordKey = $ZodRecordKey,\n//   Value extends SomeType = $ZodType,\n// > = undefined extends Key[\"_zod\"][\"values\"]\n//   ? string extends core.output<Key>\n//     ? Record<core.output<Key>, core.output<Value>>\n//     : number extends core.output<Key>\n//       ? Record<core.output<Key>, core.output<Value>>\n//       : symbol extends core.output<Key>\n//         ? Record<core.output<Key>, core.output<Value>>\n//         : Record<core.output<Key>, core.output<Value>>\n//   : Record<core.output<Key>, core.output<Value>>;\nexport type $InferZodRecordOutput<\n  Key extends $ZodRecordKey = $ZodRecordKey,\n  Value extends SomeType = $ZodType,\n> = Key extends $partial\n  ? Partial<Record<core.output<Key>, core.output<Value>>>\n  : Record<core.output<Key>, core.output<Value>>;\n\n// export type $InferZodRecordInput<\n//   Key extends $ZodRecordKey = $ZodRecordKey,\n//   Value extends SomeType = $ZodType,\n// > = undefined extends Key[\"_zod\"][\"values\"]\n//   ? string extends core.input<Key>\n//     ? Record<core.input<Key>, core.input<Value>>\n//     : number extends core.input<Key>\n//       ? Record<core.input<Key>, core.input<Value>>\n//       : symbol extends core.input<Key>\n//         ? Record<core.input<Key>, core.input<Value>>\n//         : Record<core.input<Key>, core.input<Value>>\n//   : Record<core.input<Key>, core.input<Value>>;\nexport type $InferZodRecordInput<\n  Key extends $ZodRecordKey = $ZodRecordKey,\n  Value extends SomeType = $ZodType,\n> = Key extends $partial\n  ? Partial<Record<core.input<Key>, core.input<Value>>>\n  : Record<core.input<Key>, core.input<Value>>;\n\nexport interface $ZodRecordInternals<Key extends $ZodRecordKey = $ZodRecordKey, Value extends SomeType = $ZodType>\n  extends $ZodTypeInternals<$InferZodRecordOutput<Key, Value>, $InferZodRecordInput<Key, Value>> {\n  def: $ZodRecordDef<Key, Value>;\n  isst: errors.$ZodIssueInvalidType | errors.$ZodIssueInvalidKey<Record<PropertyKey, unknown>>;\n  optin?: \"optional\" | undefined;\n  optout?: \"optional\" | undefined;\n}\n\nexport type $partial = { \"~~partial\": true };\nexport interface $ZodRecord<Key extends $ZodRecordKey = $ZodRecordKey, Value extends SomeType = $ZodType>\n  extends $ZodType {\n  _zod: $ZodRecordInternals<Key, Value>;\n}\n\nexport const $ZodRecord: core.$constructor<$ZodRecord> = /*@__PURE__*/ core.$constructor(\"$ZodRecord\", (inst, def) => {\n  $ZodType.init(inst, def);\n\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n\n    if (!util.isPlainObject(input)) {\n      payload.issues.push({\n        expected: \"record\",\n        code: \"invalid_type\",\n        input,\n        inst,\n      });\n      return payload;\n    }\n\n    const proms: Promise<any>[] = [];\n\n    if (def.keyType._zod.values) {\n      const values = def.keyType._zod.values!;\n      payload.value = {};\n      for (const key of values) {\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"symbol\") {\n          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);\n\n          if (result instanceof Promise) {\n            proms.push(\n              result.then((result) => {\n                if (result.issues.length) {\n                  payload.issues.push(...util.prefixIssues(key, result.issues));\n                }\n                payload.value[key] = result.value;\n              })\n            );\n          } else {\n            if (result.issues.length) {\n              payload.issues.push(...util.prefixIssues(key, result.issues));\n            }\n            payload.value[key] = result.value;\n          }\n        }\n      }\n\n      let unrecognized!: string[];\n      for (const key in input) {\n        if (!values.has(key)) {\n          unrecognized = unrecognized ?? [];\n          unrecognized.push(key);\n        }\n      }\n      if (unrecognized && unrecognized.length > 0) {\n        payload.issues.push({\n          code: \"unrecognized_keys\",\n          input,\n          inst,\n          keys: unrecognized,\n        });\n      }\n    } else {\n      payload.value = {};\n      for (const key of Reflect.ownKeys(input)) {\n        if (key === \"__proto__\") continue;\n        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);\n\n        if (keyResult instanceof Promise) {\n          throw new Error(\"Async schemas not supported in object keys currently\");\n        }\n\n        if (keyResult.issues.length) {\n          payload.issues.push({\n            origin: \"record\",\n            code: \"invalid_key\",\n            issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n            input: key,\n            path: [key],\n            inst,\n          });\n          payload.value[keyResult.value as PropertyKey] = keyResult.value;\n          continue;\n        }\n\n        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);\n\n        if (result instanceof Promise) {\n          proms.push(\n            result.then((result) => {\n              if (result.issues.length) {\n                payload.issues.push(...util.prefixIssues(key, result.issues));\n              }\n              payload.value[keyResult.value as PropertyKey] = result.value;\n            })\n          );\n        } else {\n          if (result.issues.length) {\n            payload.issues.push(...util.prefixIssues(key, result.issues));\n          }\n          payload.value[keyResult.value as PropertyKey] = result.value;\n        }\n      }\n    }\n\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\n\n///////////////////////////////////////\n///////////////////////////////////////\n//////////                   //////////\n//////////      $ZodMap      //////////\n//////////                   //////////\n///////////////////////////////////////\n///////////////////////////////////////\nexport interface $ZodMapDef<Key extends SomeType = $ZodType, Value extends SomeType = $ZodType> extends $ZodTypeDef {\n  type: \"map\";\n  keyType: Key;\n  valueType: Value;\n}\n\nexport interface $ZodMapInternals<Key extends SomeType = $ZodType, Value extends SomeType = $ZodType>\n  extends $ZodTypeInternals<Map<core.output<Key>, core.output<Value>>, Map<core.input<Key>, core.input<Value>>> {\n  def: $ZodMapDef<Key, Value>;\n  isst: errors.$ZodIssueInvalidType | errors.$ZodIssueInvalidKey | errors.$ZodIssueInvalidElement<unknown>;\n  optin?: \"optional\" | undefined;\n  optout?: \"optional\" | undefined;\n}\n\nexport interface $ZodMap<Key extends SomeType = $ZodType, Value extends SomeType = $ZodType> extends $ZodType {\n  _zod: $ZodMapInternals<Key, Value>;\n}\n\nexport const $ZodMap: core.$constructor<$ZodMap> = /*@__PURE__*/ core.$constructor(\"$ZodMap\", (inst, def) => {\n  $ZodType.init(inst, def);\n\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!(input instanceof Map)) {\n      payload.issues.push({\n        expected: \"map\",\n        code: \"invalid_type\",\n        input,\n        inst,\n      });\n      return payload;\n    }\n\n    const proms: Promise<any>[] = [];\n    payload.value = new Map();\n\n    for (const [key, value] of input) {\n      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);\n      const valueResult = def.valueType._zod.run({ value: value, issues: [] }, ctx);\n\n      if (keyResult instanceof Promise || valueResult instanceof Promise) {\n        proms.push(\n          Promise.all([keyResult, valueResult]).then(([keyResult, valueResult]) => {\n            handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);\n          })\n        );\n      } else {\n        handleMapResult(keyResult as ParsePayload, valueResult as ParsePayload, payload, key, input, inst, ctx);\n      }\n    }\n\n    if (proms.length) return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\n\nfunction handleMapResult(\n  keyResult: ParsePayload,\n  valueResult: ParsePayload,\n  final: ParsePayload<Map<unknown, unknown>>,\n  key: unknown,\n  input: Map<any, any>,\n  inst: $ZodMap,\n  ctx?: ParseContext | undefined\n): void {\n  if (keyResult.issues.length) {\n    if (util.propertyKeyTypes.has(typeof key)) {\n      final.issues.push(...util.prefixIssues(key as PropertyKey, keyResult.issues));\n    } else {\n      final.issues.push({\n        origin: \"map\",\n        code: \"invalid_key\",\n        input,\n        inst,\n        issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n      });\n    }\n  }\n  if (valueResult.issues.length) {\n    if (util.propertyKeyTypes.has(typeof key)) {\n      final.issues.push(...util.prefixIssues(key as PropertyKey, valueResult.issues));\n    } else {\n      final.issues.push({\n        origin: \"map\",\n        code: \"invalid_element\",\n        input,\n        inst,\n        key: key,\n        issues: valueResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n      });\n    }\n  }\n  final.value.set(keyResult.value, valueResult.value);\n}\n\n///////////////////////////////////////\n///////////////////////////////////////\n//////////                   //////////\n//////////      $ZodSet      //////////\n//////////                   //////////\n///////////////////////////////////////\n///////////////////////////////////////\nexport interface $ZodSetDef<T extends SomeType = $ZodType> extends $ZodTypeDef {\n  type: \"set\";\n  valueType: T;\n}\n\nexport interface $ZodSetInternals<T extends SomeType = $ZodType>\n  extends $ZodTypeInternals<Set<core.output<T>>, Set<core.input<T>>> {\n  def: $ZodSetDef<T>;\n  isst: errors.$ZodIssueInvalidType;\n  optin?: \"optional\" | undefined;\n  optout?: \"optional\" | undefined;\n}\n\nexport interface $ZodSet<T extends SomeType = $ZodType> extends $ZodType {\n  _zod: $ZodSetInternals<T>;\n}\n\nexport const $ZodSet: core.$constructor<$ZodSet> = /*@__PURE__*/ core.$constructor(\"$ZodSet\", (inst, def) => {\n  $ZodType.init(inst, def);\n\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!(input instanceof Set)) {\n      payload.issues.push({\n        input,\n        inst,\n        expected: \"set\",\n        code: \"invalid_type\",\n      });\n      return payload;\n    }\n\n    const proms: Promise<any>[] = [];\n    payload.value = new Set();\n    for (const item of input) {\n      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then((result) => handleSetResult(result, payload)));\n      } else handleSetResult(result, payload);\n    }\n\n    if (proms.length) return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\n\nfunction handleSetResult(result: ParsePayload, final: ParsePayload<Set<any>>) {\n  if (result.issues.length) {\n    final.issues.push(...result.issues);\n  }\n  final.value.add(result.value);\n}\n\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      $ZodEnum      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nexport type $InferEnumOutput<T extends util.EnumLike> = T[keyof T] & {};\nexport type $InferEnumInput<T extends util.EnumLike> = T[keyof T] & {};\n\nexport interface $ZodEnumDef<T extends util.EnumLike = util.EnumLike> extends $ZodTypeDef {\n  type: \"enum\";\n  entries: T;\n}\n\nexport interface $ZodEnumInternals<\n  /** @ts-ignore Cast variance */\n  out T extends util.EnumLike = util.EnumLike,\n> extends $ZodTypeInternals<$InferEnumOutput<T>, $InferEnumInput<T>> {\n  // enum: T;\n\n  def: $ZodEnumDef<T>;\n  /** @deprecated Internal API, use with caution (not deprecated) */\n  values: util.PrimitiveSet;\n  /** @deprecated Internal API, use with caution (not deprecated) */\n  pattern: RegExp;\n  isst: errors.$ZodIssueInvalidValue;\n}\n\nexport interface $ZodEnum<T extends util.EnumLike = util.EnumLike> extends $ZodType {\n  _zod: $ZodEnumInternals<T>;\n}\n\nexport const $ZodEnum: core.$constructor<$ZodEnum> = /*@__PURE__*/ core.$constructor(\"$ZodEnum\", (inst, def) => {\n  $ZodType.init(inst, def);\n\n  const values = util.getEnumValues(def.entries);\n\n  inst._zod.values = new Set<util.Primitive>(values);\n\n  inst._zod.pattern = new RegExp(\n    `^(${values\n      .filter((k) => util.propertyKeyTypes.has(typeof k))\n      .map((o) => (typeof o === \"string\" ? util.escapeRegex(o) : o.toString()))\n      .join(\"|\")})$`\n  );\n\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (inst._zod.values.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: \"invalid_value\",\n      values,\n      input,\n      inst,\n    });\n    return payload;\n  };\n});\n\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      $ZodLiteral      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\n\nexport interface $ZodLiteralDef<T extends util.Literal> extends $ZodTypeDef {\n  type: \"literal\";\n  values: T[];\n}\n\nexport interface $ZodLiteralInternals<T extends util.Literal = util.Literal> extends $ZodTypeInternals<T, T> {\n  def: $ZodLiteralDef<T>;\n  values: Set<T>;\n  pattern: RegExp;\n  isst: errors.$ZodIssueInvalidValue;\n}\n\nexport interface $ZodLiteral<T extends util.Literal = util.Literal> extends $ZodType {\n  _zod: $ZodLiteralInternals<T>;\n}\n\nexport const $ZodLiteral: core.$constructor<$ZodLiteral> = /*@__PURE__*/ core.$constructor(\n  \"$ZodLiteral\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n\n    inst._zod.values = new Set<util.Literal>(def.values);\n    inst._zod.pattern = new RegExp(\n      `^(${def.values\n\n        .map((o) => (typeof o === \"string\" ? util.escapeRegex(o) : o ? o.toString() : String(o)))\n        .join(\"|\")})$`\n    );\n\n    inst._zod.parse = (payload, _ctx) => {\n      const input = payload.value;\n      if (inst._zod.values.has(input)) {\n        return payload;\n      }\n      payload.issues.push({\n        code: \"invalid_value\",\n        values: def.values,\n        input,\n        inst,\n      });\n      return payload;\n    };\n  }\n);\n\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      $ZodConst      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\n\n// export interface $ZodConstDef extends $ZodTypeDef {\n//   type: \"const\";\n//   value: unknown;\n// }\n\n// export _interface $ZodConstInternals<T extends util.Literal = util.Literal> extends $ZodTypeInternals<T, T> {\n//   _def: $ZodConstDef;\n//   _values: util.PrimitiveSet;\n//   _pattern: RegExp;\n//   _isst: errors.$ZodIssueInvalidValue;\n// }\n\n// export const $ZodConst: core.$constructor<{_zod: $ZodConstInternals}> = /*@__PURE__*/ core.$constructor(\"$ZodConst\", (inst, def) => {\n//   $ZodType.init(inst, def);\n\n//   if (util.primitiveTypes.has(typeof def.value) || def.value === null) {\n//     inst._zod.values = new Set<util.Primitive>(def.value as any);\n//   }\n\n//   if (util.propertyKeyTypes.has(typeof def.value)) {\n//     inst._zod.pattern = new RegExp(\n//       `^(${typeof def.value === \"string\" ? util.escapeRegex(def.value) : (def.value as any).toString()})$`\n//     );\n//   } else {\n//     throw new Error(\"Const value cannot be converted to regex\");\n//   }\n\n//   inst._zod.parse = (payload, _ctx) => {\n//     payload.value = def.value; // always override\n//     return payload;\n//   };\n// });\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      $ZodFile        //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n\n// provide a fallback in case the File interface isn't provided in the environment\ndeclare global {\n  interface File {}\n}\n\nexport interface $ZodFileDef extends $ZodTypeDef {\n  type: \"file\";\n}\n\nexport interface $ZodFileInternals extends $ZodTypeInternals<File, File> {\n  def: $ZodFileDef;\n  isst: errors.$ZodIssueInvalidType;\n  bag: util.LoosePartial<{\n    minimum: number;\n    maximum: number;\n    mime: util.MimeTypes[];\n  }>;\n}\n\nexport interface $ZodFile extends $ZodType {\n  _zod: $ZodFileInternals;\n}\n\nexport const $ZodFile: core.$constructor<$ZodFile> = /*@__PURE__*/ core.$constructor(\"$ZodFile\", (inst, def) => {\n  $ZodType.init(inst, def);\n\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (input instanceof File) return payload;\n    payload.issues.push({\n      expected: \"file\",\n      code: \"invalid_type\",\n      input,\n      inst,\n    });\n    return payload;\n  };\n});\n\n//////////////////////////////////////////////\n//////////////////////////////////////////////\n//////////                          //////////\n//////////        $ZodTransform        //////////\n//////////                          //////////\n//////////////////////////////////////////////\n//////////////////////////////////////////////\nexport interface $ZodTransformDef extends $ZodTypeDef {\n  type: \"transform\";\n  transform: (input: unknown, payload: ParsePayload<unknown>) => util.MaybeAsync<unknown>;\n}\nexport interface $ZodTransformInternals<O = unknown, I = unknown> extends $ZodTypeInternals<O, I> {\n  def: $ZodTransformDef;\n  isst: never;\n}\n\nexport interface $ZodTransform<O = unknown, I = unknown> extends $ZodType {\n  _zod: $ZodTransformInternals<O, I>;\n}\n\nexport const $ZodTransform: core.$constructor<$ZodTransform> = /*@__PURE__*/ core.$constructor(\n  \"$ZodTransform\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n      const _out = def.transform(payload.value, payload);\n      if (_ctx.async) {\n        const output = _out instanceof Promise ? _out : Promise.resolve(_out);\n        return output.then((output) => {\n          payload.value = output;\n          return payload;\n        });\n      }\n\n      if (_out instanceof Promise) {\n        throw new core.$ZodAsyncError();\n      }\n\n      payload.value = _out;\n      return payload;\n    };\n  }\n);\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////      $ZodOptional      //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\nexport interface $ZodOptionalDef<T extends SomeType = $ZodType> extends $ZodTypeDef {\n  type: \"optional\";\n  innerType: T;\n}\n\nexport interface $ZodOptionalInternals<T extends SomeType = $ZodType>\n  extends $ZodTypeInternals<core.output<T> | undefined, core.input<T> | undefined> {\n  def: $ZodOptionalDef<T>;\n  optin: \"optional\";\n  optout: \"optional\";\n  isst: never;\n  values: T[\"_zod\"][\"values\"];\n  pattern: T[\"_zod\"][\"pattern\"];\n}\n\nexport interface $ZodOptional<T extends SomeType = $ZodType> extends $ZodType {\n  _zod: $ZodOptionalInternals<T>;\n}\n\nexport const $ZodOptional: core.$constructor<$ZodOptional> = /*@__PURE__*/ core.$constructor(\n  \"$ZodOptional\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.optin = \"optional\";\n    inst._zod.optout = \"optional\";\n\n    util.defineLazy(inst._zod, \"values\", () => {\n      return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;\n    });\n    util.defineLazy(inst._zod, \"pattern\", () => {\n      const pattern = def.innerType._zod.pattern;\n      return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)})?$`) : undefined;\n    });\n\n    inst._zod.parse = (payload, ctx) => {\n      if (def.innerType._zod.optin === \"optional\") {\n        return def.innerType._zod.run(payload, ctx);\n      }\n      if (payload.value === undefined) {\n        return payload;\n      }\n      return def.innerType._zod.run(payload, ctx);\n    };\n  }\n);\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////      $ZodNullable      //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\nexport interface $ZodNullableDef<T extends SomeType = $ZodType> extends $ZodTypeDef {\n  type: \"nullable\";\n  innerType: T;\n}\n\nexport interface $ZodNullableInternals<T extends SomeType = $ZodType>\n  extends $ZodTypeInternals<core.output<T> | null, core.input<T> | null> {\n  def: $ZodNullableDef<T>;\n  optin: T[\"_zod\"][\"optin\"];\n  optout: T[\"_zod\"][\"optout\"];\n  isst: never;\n  values: T[\"_zod\"][\"values\"];\n  pattern: T[\"_zod\"][\"pattern\"];\n}\n\nexport interface $ZodNullable<T extends SomeType = $ZodType> extends $ZodType {\n  _zod: $ZodNullableInternals<T>;\n}\n\nexport const $ZodNullable: core.$constructor<$ZodNullable> = /*@__PURE__*/ core.$constructor(\n  \"$ZodNullable\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n\n    util.defineLazy(inst._zod, \"pattern\", () => {\n      const pattern = def.innerType._zod.pattern;\n      return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)}|null)$`) : undefined;\n    });\n\n    util.defineLazy(inst._zod, \"values\", () => {\n      return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;\n    });\n\n    inst._zod.parse = (payload, ctx) => {\n      if (payload.value === null) return payload;\n      return def.innerType._zod.run(payload, ctx);\n    };\n  }\n);\n// );\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////      $ZodDefault       //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\nexport interface $ZodDefaultDef<T extends SomeType = $ZodType> extends $ZodTypeDef {\n  type: \"default\";\n  innerType: T;\n  /** The default value. May be a getter. */\n  defaultValue: util.NoUndefined<core.output<T>>;\n}\n\nexport interface $ZodDefaultInternals<T extends SomeType = $ZodType>\n  extends $ZodTypeInternals<util.NoUndefined<core.output<T>>, core.input<T> | undefined> {\n  def: $ZodDefaultDef<T>;\n  optin: \"optional\";\n  optout?: \"optional\" | undefined; // required\n  isst: never;\n  values: T[\"_zod\"][\"values\"];\n}\n\nexport interface $ZodDefault<T extends SomeType = $ZodType> extends $ZodType {\n  _zod: $ZodDefaultInternals<T>;\n}\n\nexport const $ZodDefault: core.$constructor<$ZodDefault> = /*@__PURE__*/ core.$constructor(\n  \"$ZodDefault\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n\n    // inst._zod.qin = \"true\";\n    inst._zod.optin = \"optional\";\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n\n    inst._zod.parse = (payload, ctx) => {\n      if (payload.value === undefined) {\n        payload.value = def.defaultValue;\n        /**\n         * $ZodDefault always returns the default value immediately.\n         * It doesn't pass the default value into the validator (\"prefault\"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a \"prefault\" for the pipe.   */\n        return payload;\n      }\n      const result = def.innerType._zod.run(payload, ctx);\n      if (result instanceof Promise) {\n        return result.then((result) => handleDefaultResult(result, def));\n      }\n      return handleDefaultResult(result, def);\n    };\n  }\n);\n\nfunction handleDefaultResult(payload: ParsePayload, def: $ZodDefaultDef) {\n  if (payload.value === undefined) {\n    payload.value = def.defaultValue;\n  }\n  return payload;\n}\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////      $ZodPrefault      //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\n\nexport interface $ZodPrefaultDef<T extends SomeType = $ZodType> extends $ZodTypeDef {\n  type: \"prefault\";\n  innerType: T;\n  /** The default value. May be a getter. */\n  defaultValue: core.input<T>;\n}\n\nexport interface $ZodPrefaultInternals<T extends SomeType = $ZodType>\n  extends $ZodTypeInternals<util.NoUndefined<core.output<T>>, core.input<T> | undefined> {\n  def: $ZodPrefaultDef<T>;\n  optin: \"optional\";\n  optout?: \"optional\" | undefined;\n  isst: never;\n  values: T[\"_zod\"][\"values\"];\n}\n\nexport interface $ZodPrefault<T extends SomeType = $ZodType> extends $ZodType {\n  _zod: $ZodPrefaultInternals<T>;\n}\n\nexport const $ZodPrefault: core.$constructor<$ZodPrefault> = /*@__PURE__*/ core.$constructor(\n  \"$ZodPrefault\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n\n    inst._zod.optin = \"optional\";\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n\n    inst._zod.parse = (payload, ctx) => {\n      if (payload.value === undefined) {\n        payload.value = def.defaultValue;\n      }\n      return def.innerType._zod.run(payload, ctx);\n    };\n  }\n);\n\n///////////////////////////////////////////////\n///////////////////////////////////////////////\n//////////                           //////////\n//////////      $ZodNonOptional      //////////\n//////////                           //////////\n///////////////////////////////////////////////\n///////////////////////////////////////////////\nexport interface $ZodNonOptionalDef<T extends SomeType = $ZodType> extends $ZodTypeDef {\n  type: \"nonoptional\";\n  innerType: T;\n}\n\nexport interface $ZodNonOptionalInternals<T extends SomeType = $ZodType>\n  extends $ZodTypeInternals<util.NoUndefined<core.output<T>>, util.NoUndefined<core.input<T>>> {\n  def: $ZodNonOptionalDef<T>;\n  isst: errors.$ZodIssueInvalidType;\n  values: T[\"_zod\"][\"values\"];\n  optin: \"optional\" | undefined;\n  optout: \"optional\" | undefined;\n}\n\nexport interface $ZodNonOptional<T extends SomeType = $ZodType> extends $ZodType {\n  _zod: $ZodNonOptionalInternals<T>;\n}\n\nexport const $ZodNonOptional: core.$constructor<$ZodNonOptional> = /*@__PURE__*/ core.$constructor(\n  \"$ZodNonOptional\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n\n    util.defineLazy(inst._zod, \"values\", () => {\n      const v = def.innerType._zod.values;\n      return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;\n    });\n\n    inst._zod.parse = (payload, ctx) => {\n      const result = def.innerType._zod.run(payload, ctx);\n      if (result instanceof Promise) {\n        return result.then((result) => handleNonOptionalResult(result, inst));\n      }\n      return handleNonOptionalResult(result, inst);\n    };\n  }\n);\n\nfunction handleNonOptionalResult(payload: ParsePayload, inst: $ZodNonOptional) {\n  if (!payload.issues.length && payload.value === undefined) {\n    payload.issues.push({\n      code: \"invalid_type\",\n      expected: \"nonoptional\",\n      input: payload.value,\n      inst,\n    });\n  }\n  return payload;\n}\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////      $ZodCoalesce      //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\n// export interface $ZodCoalesceDef<T extends $ZodType = $ZodType> extends $ZodTypeDef {\n//   type: \"coalesce\";\n//   innerType: T;\n//   defaultValue: () => NonNullable<T['_zod'][\"output\"]>;\n// }\n\n// export _interface $ZodCoalesceInternals<T extends $ZodType = $ZodType>\n//   extends $ZodTypeInternals<NonNullable<T['_zod'][\"output\"]>, T['_zod'][\"input\"] | undefined | null> {\n//   _def: $ZodCoalesceDef<T>;\n//   _isst: errors.$ZodIssueInvalidType;\n//   _qin: \"true\";\n// }\n\n// function handleCoalesceResult(payload: ParsePayload, def: $ZodCoalesceDef) {\n//   payload.value ??= def.defaultValue();\n//   return payload;\n// }\n\n// export const $ZodCoalesce: core.$constructor<{_zod: $ZodCoalesceInternals}> = /*@__PURE__*/ core.$constructor(\n//   \"$ZodCoalesce\",\n//   (inst, def) => {\n//     $ZodType.init(inst, def);\n// inst._zod.qin = \"true\";\n//     inst._zod.parse = (payload, ctx) => {\n//       const result = def.innerType._zod.run(payload, ctx);\n//       if (result instanceof Promise) {\n//         return result.then((result) => handleCoalesceResult(result, def));\n//       }\n//       return handleCoalesceResult(result, def);\n//     };\n//   }\n// );\n\n/////////////////////////////////////////////\n/////////////////////////////////////////////\n//////////                         //////////\n//////////      $ZodSuccess        //////////\n//////////                         //////////\n/////////////////////////////////////////////\n/////////////////////////////////////////////\nexport interface $ZodSuccessDef<T extends SomeType = $ZodType> extends $ZodTypeDef {\n  type: \"success\";\n  innerType: T;\n}\n\nexport interface $ZodSuccessInternals<T extends SomeType = $ZodType> extends $ZodTypeInternals<boolean, core.input<T>> {\n  def: $ZodSuccessDef<T>;\n  isst: never;\n  optin: T[\"_zod\"][\"optin\"];\n  optout: \"optional\" | undefined;\n}\n\nexport interface $ZodSuccess<T extends SomeType = $ZodType> extends $ZodType {\n  _zod: $ZodSuccessInternals<T>;\n}\n\nexport const $ZodSuccess: core.$constructor<$ZodSuccess> = /*@__PURE__*/ core.$constructor(\n  \"$ZodSuccess\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n\n    inst._zod.parse = (payload, ctx) => {\n      const result = def.innerType._zod.run(payload, ctx);\n      if (result instanceof Promise) {\n        return result.then((result) => {\n          payload.value = result.issues.length === 0;\n          return payload;\n        });\n      }\n      payload.value = result.issues.length === 0;\n      return payload;\n    };\n  }\n);\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////       $ZodCatch        //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\nexport interface $ZodCatchCtx extends ParsePayload {\n  /** @deprecated Use `ctx.issues` */\n  error: { issues: errors.$ZodIssue[] };\n  /** @deprecated Use `ctx.value` */\n  input: unknown;\n}\nexport interface $ZodCatchDef<T extends SomeType = $ZodType> extends $ZodTypeDef {\n  type: \"catch\";\n  innerType: T;\n  catchValue: (ctx: $ZodCatchCtx) => unknown;\n}\n\nexport interface $ZodCatchInternals<T extends SomeType = $ZodType>\n  extends $ZodTypeInternals<core.output<T>, core.input<T> | util.Whatever> {\n  def: $ZodCatchDef<T>;\n  // qin: T[\"_zod\"][\"qin\"];\n  // qout: T[\"_zod\"][\"qout\"];\n\n  optin: T[\"_zod\"][\"optin\"];\n  optout: T[\"_zod\"][\"optout\"];\n  isst: never;\n  values: T[\"_zod\"][\"values\"];\n}\n\nexport interface $ZodCatch<T extends SomeType = $ZodType> extends $ZodType {\n  _zod: $ZodCatchInternals<T>;\n}\n\nexport const $ZodCatch: core.$constructor<$ZodCatch> = /*@__PURE__*/ core.$constructor(\"$ZodCatch\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result) => {\n        payload.value = result.value;\n        if (result.issues.length) {\n          payload.value = def.catchValue({\n            ...payload,\n            error: {\n              issues: result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n            },\n            input: payload.value,\n          });\n          payload.issues = [];\n        }\n\n        return payload;\n      });\n    }\n\n    payload.value = result.value;\n    if (result.issues.length) {\n      payload.value = def.catchValue({\n        ...payload,\n        error: {\n          issues: result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n        },\n        input: payload.value,\n      });\n      payload.issues = [];\n    }\n\n    return payload;\n  };\n});\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////        $ZodNaN         //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\nexport interface $ZodNaNDef extends $ZodTypeDef {\n  type: \"nan\";\n}\n\nexport interface $ZodNaNInternals extends $ZodTypeInternals<number, number> {\n  def: $ZodNaNDef;\n  isst: errors.$ZodIssueInvalidType;\n}\n\nexport interface $ZodNaN extends $ZodType {\n  _zod: $ZodNaNInternals;\n}\n\nexport const $ZodNaN: core.$constructor<$ZodNaN> = /*@__PURE__*/ core.$constructor(\"$ZodNaN\", (inst, def) => {\n  $ZodType.init(inst, def);\n\n  inst._zod.parse = (payload, _ctx) => {\n    if (typeof payload.value !== \"number\" || !Number.isNaN(payload.value)) {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        expected: \"nan\",\n        code: \"invalid_type\",\n      });\n      return payload;\n    }\n    return payload;\n  };\n});\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////      $ZodPipe      //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\nexport interface $ZodPipeDef<A extends SomeType = $ZodType, B extends SomeType = $ZodType> extends $ZodTypeDef {\n  type: \"pipe\";\n  in: A;\n  out: B;\n}\n\nexport interface $ZodPipeInternals<A extends SomeType = $ZodType, B extends SomeType = $ZodType>\n  extends $ZodTypeInternals<core.output<B>, core.input<A>> {\n  def: $ZodPipeDef<A, B>;\n  isst: never;\n  values: A[\"_zod\"][\"values\"];\n  optin: A[\"_zod\"][\"optin\"];\n  optout: B[\"_zod\"][\"optout\"];\n}\n\nexport interface $ZodPipe<A extends SomeType = $ZodType, B extends SomeType = $ZodType> extends $ZodType {\n  _zod: $ZodPipeInternals<A, B>;\n}\n\nexport const $ZodPipe: core.$constructor<$ZodPipe> = /*@__PURE__*/ core.$constructor(\"$ZodPipe\", (inst, def) => {\n  $ZodType.init(inst, def);\n  util.defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n  util.defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n  util.defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n\n  inst._zod.parse = (payload, ctx) => {\n    const left = def.in._zod.run(payload, ctx);\n    if (left instanceof Promise) {\n      return left.then((left) => handlePipeResult(left, def, ctx));\n    }\n    return handlePipeResult(left, def, ctx);\n  };\n});\n\nfunction handlePipeResult(left: ParsePayload, def: $ZodPipeDef, ctx: ParseContext) {\n  if (util.aborted(left)) {\n    return left;\n  }\n  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);\n}\n\n////////////////////////////////////////////\n////////////////////////////////////////////\n//////////                        //////////\n//////////      $ZodReadonly      //////////\n//////////                        //////////\n////////////////////////////////////////////\n////////////////////////////////////////////\n\nexport interface $ZodReadonlyDef<T extends SomeType = $ZodType> extends $ZodTypeDef {\n  type: \"readonly\";\n  innerType: T;\n}\n\nexport interface $ZodReadonlyInternals<T extends SomeType = $ZodType>\n  extends $ZodTypeInternals<util.MakeReadonly<core.output<T>>, util.MakeReadonly<core.input<T>>> {\n  def: $ZodReadonlyDef<T>;\n  optin: T[\"_zod\"][\"optin\"];\n  optout: T[\"_zod\"][\"optout\"];\n  isst: never;\n  propValues: T[\"_zod\"][\"propValues\"];\n  values: T[\"_zod\"][\"values\"];\n}\n\nexport interface $ZodReadonly<T extends SomeType = $ZodType> extends $ZodType {\n  _zod: $ZodReadonlyInternals<T>;\n}\n\nexport const $ZodReadonly: core.$constructor<$ZodReadonly> = /*@__PURE__*/ core.$constructor(\n  \"$ZodReadonly\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"propValues\", () => def.innerType._zod.propValues);\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n    util.defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n\n    inst._zod.parse = (payload, ctx) => {\n      const result = def.innerType._zod.run(payload, ctx);\n      if (result instanceof Promise) {\n        return result.then(handleReadonlyResult);\n      }\n      return handleReadonlyResult(result);\n    };\n  }\n);\n\nfunction handleReadonlyResult(payload: ParsePayload): ParsePayload {\n  payload.value = Object.freeze(payload.value);\n  return payload;\n}\n\n/////////////////////////////////////////////\n/////////////////////////////////////////////\n//////////                         //////////\n//////////   $ZodTemplateLiteral   //////////\n//////////                         //////////\n/////////////////////////////////////////////\n/////////////////////////////////////////////\n\nexport interface $ZodTemplateLiteralDef extends $ZodTypeDef {\n  type: \"template_literal\";\n  parts: $ZodTemplateLiteralPart[];\n}\nexport interface $ZodTemplateLiteralInternals<Template extends string = string>\n  extends $ZodTypeInternals<Template, Template> {\n  pattern: RegExp;\n  def: $ZodTemplateLiteralDef;\n  isst: errors.$ZodIssueInvalidType;\n}\n\nexport interface $ZodTemplateLiteral<Template extends string = string> extends $ZodType {\n  _zod: $ZodTemplateLiteralInternals<Template>;\n}\n\ntype LiteralPart = Exclude<util.Literal, symbol>; //string | number | boolean | null | undefined;\ninterface SchemaPartInternals extends $ZodTypeInternals<LiteralPart, LiteralPart> {\n  pattern: RegExp;\n}\ninterface SchemaPart extends $ZodType {\n  _zod: SchemaPartInternals;\n}\nexport type $ZodTemplateLiteralPart = LiteralPart | SchemaPart;\n\ntype UndefinedToEmptyString<T> = T extends undefined ? \"\" : T;\ntype AppendToTemplateLiteral<\n  Template extends string,\n  Suffix extends LiteralPart | $ZodType,\n> = Suffix extends LiteralPart\n  ? `${Template}${UndefinedToEmptyString<Suffix>}`\n  : Suffix extends $ZodType\n    ? `${Template}${core.output<Suffix> extends infer T extends LiteralPart ? UndefinedToEmptyString<T> : never}`\n    : never;\n\nexport type ConcatenateTupleOfStrings<T extends string[]> = T extends [\n  infer First extends string,\n  ...infer Rest extends string[],\n]\n  ? Rest extends string[]\n    ? First extends \"\"\n      ? ConcatenateTupleOfStrings<Rest>\n      : `${First}${ConcatenateTupleOfStrings<Rest>}`\n    : never\n  : \"\";\nexport type ConvertPartsToStringTuple<Parts extends $ZodTemplateLiteralPart[]> = {\n  [K in keyof Parts]: Parts[K] extends LiteralPart\n    ? `${UndefinedToEmptyString<Parts[K]>}`\n    : Parts[K] extends $ZodType\n      ? `${core.output<Parts[K]> extends infer T extends LiteralPart ? UndefinedToEmptyString<T> : never}`\n      : never;\n};\n\nexport type ToTemplateLiteral<Parts extends $ZodTemplateLiteralPart[]> = ConcatenateTupleOfStrings<\n  ConvertPartsToStringTuple<Parts>\n>;\n// type lkjasd = ConcatenateTupleOfStrings<[\"Hello\", \" \", \"World\", \"!\"]>; // \"Hello World!\"\nexport type $PartsToTemplateLiteral<Parts extends $ZodTemplateLiteralPart[]> = [] extends Parts\n  ? ``\n  : Parts extends [...infer Rest, infer Last extends $ZodTemplateLiteralPart]\n    ? Rest extends $ZodTemplateLiteralPart[]\n      ? AppendToTemplateLiteral<$PartsToTemplateLiteral<Rest>, Last>\n      : never\n    : never;\n\nexport const $ZodTemplateLiteral: core.$constructor<$ZodTemplateLiteral> = /*@__PURE__*/ core.$constructor(\n  \"$ZodTemplateLiteral\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n    const regexParts: string[] = [];\n    for (const part of def.parts) {\n      if (part instanceof $ZodType) {\n        if (!part._zod.pattern) {\n          // if (!source)\n          throw new Error(`Invalid template literal part, no pattern found: ${[...(part as any)._zod.traits].shift()}`);\n        }\n\n        const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;\n\n        if (!source) throw new Error(`Invalid template literal part: ${part._zod.traits}`);\n\n        const start = source.startsWith(\"^\") ? 1 : 0;\n        const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n        regexParts.push(source.slice(start, end));\n      } else if (part === null || util.primitiveTypes.has(typeof part)) {\n        regexParts.push(util.escapeRegex(`${part}`));\n      } else {\n        throw new Error(`Invalid template literal part: ${part}`);\n      }\n    }\n    inst._zod.pattern = new RegExp(`^${regexParts.join(\"\")}$`);\n\n    inst._zod.parse = (payload, _ctx) => {\n      if (typeof payload.value !== \"string\") {\n        payload.issues.push({\n          input: payload.value,\n          inst,\n          expected: \"template_literal\",\n          code: \"invalid_type\",\n        });\n        return payload;\n      }\n\n      inst._zod.pattern.lastIndex = 0;\n\n      if (!inst._zod.pattern.test(payload.value)) {\n        payload.issues.push({\n          input: payload.value,\n          inst,\n          code: \"invalid_format\",\n          format: \"template_literal\",\n          pattern: inst._zod.pattern.source,\n        });\n        return payload;\n      }\n\n      return payload;\n    };\n  }\n);\n\n/////////////////////////////////////////\n/////////////////////////////////////////\n//////////                     //////////\n//////////     $ZodPromise     //////////\n//////////                     //////////\n/////////////////////////////////////////\n/////////////////////////////////////////\nexport interface $ZodPromiseDef<T extends SomeType = $ZodType> extends $ZodTypeDef {\n  type: \"promise\";\n  innerType: T;\n}\n\nexport interface $ZodPromiseInternals<T extends SomeType = $ZodType>\n  extends $ZodTypeInternals<core.output<T>, util.MaybeAsync<core.input<T>>> {\n  def: $ZodPromiseDef<T>;\n  isst: never;\n}\n\nexport interface $ZodPromise<T extends SomeType = $ZodType> extends $ZodType {\n  _zod: $ZodPromiseInternals<T>;\n}\n\nexport const $ZodPromise: core.$constructor<$ZodPromise> = /*@__PURE__*/ core.$constructor(\n  \"$ZodPromise\",\n  (inst, def) => {\n    $ZodType.init(inst, def);\n\n    inst._zod.parse = (payload, ctx) => {\n      return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));\n    };\n  }\n);\n\n//////////////////////////////////////////\n//////////////////////////////////////////\n//////////                      //////////\n//////////      $ZodLazy        //////////\n//////////                      //////////\n//////////////////////////////////////////\n//////////////////////////////////////////\n\nexport interface $ZodLazyDef<T extends SomeType = $ZodType> extends $ZodTypeDef {\n  type: \"lazy\";\n  getter: () => T;\n}\n\nexport interface $ZodLazyInternals<T extends SomeType = $ZodType>\n  extends $ZodTypeInternals<core.output<T>, core.input<T>> {\n  def: $ZodLazyDef<T>;\n  isst: never;\n  /** Auto-cached way to retrieve the inner schema */\n  innerType: T;\n  pattern: T[\"_zod\"][\"pattern\"];\n  propValues: T[\"_zod\"][\"propValues\"];\n  optin: T[\"_zod\"][\"optin\"];\n  optout: T[\"_zod\"][\"optout\"];\n}\n\nexport interface $ZodLazy<T extends SomeType = $ZodType> extends $ZodType {\n  _zod: $ZodLazyInternals<T>;\n}\n\nexport const $ZodLazy: core.$constructor<$ZodLazy> = /*@__PURE__*/ core.$constructor(\"$ZodLazy\", (inst, def) => {\n  $ZodType.init(inst, def);\n\n  util.defineLazy(inst._zod, \"innerType\", () => def.getter() as $ZodType);\n  util.defineLazy(inst._zod, \"pattern\", () => inst._zod.innerType._zod.pattern);\n  util.defineLazy(inst._zod, \"propValues\", () => inst._zod.innerType._zod.propValues);\n  util.defineLazy(inst._zod, \"optin\", () => inst._zod.innerType._zod.optin);\n  util.defineLazy(inst._zod, \"optout\", () => inst._zod.innerType._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const inner = inst._zod.innerType;\n    return inner._zod.run(payload, ctx);\n  };\n});\n\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////     $ZodCustom     //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nexport interface $ZodCustomDef<O = unknown> extends $ZodTypeDef, checks.$ZodCheckDef {\n  type: \"custom\";\n  check: \"custom\";\n  path?: PropertyKey[] | undefined;\n  error?: errors.$ZodErrorMap | undefined;\n  params?: Record<string, any> | undefined;\n  fn: (arg: O) => unknown;\n}\n\nexport interface $ZodCustomInternals<O = unknown, I = unknown>\n  extends $ZodTypeInternals<O, I>,\n    checks.$ZodCheckInternals<O> {\n  def: $ZodCustomDef;\n  issc: errors.$ZodIssue;\n  isst: never;\n  bag: util.LoosePartial<{\n    Class: typeof util.Class;\n  }>;\n}\n\nexport interface $ZodCustom<O = unknown, I = unknown> extends $ZodType {\n  _zod: $ZodCustomInternals<O, I>;\n}\n\nexport const $ZodCustom: core.$constructor<$ZodCustom> = /*@__PURE__*/ core.$constructor(\"$ZodCustom\", (inst, def) => {\n  checks.$ZodCheck.init(inst, def);\n  $ZodType.init(inst, def);\n\n  inst._zod.parse = (payload, _) => {\n    return payload;\n  };\n\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const r = def.fn(input as any);\n    if (r instanceof Promise) {\n      return r.then((r) => handleRefineResult(r, payload, input, inst));\n    }\n    handleRefineResult(r, payload, input, inst);\n    return;\n  };\n});\n\nfunction handleRefineResult(result: unknown, payload: ParsePayload, input: unknown, inst: $ZodCustom): void {\n  if (!result) {\n    const _iss: any = {\n      code: \"custom\",\n      input,\n      inst, // incorporates params.error into issue reporting\n      path: [...(inst._zod.def.path ?? [])], // incorporates params.error into issue reporting\n      continue: !inst._zod.def.abort,\n      // params: inst._zod.def.params,\n    };\n    if (inst._zod.def.params) _iss.params = inst._zod.def.params;\n    payload.issues.push(util.issue(_iss));\n  }\n}\n\nexport type $ZodTypes =\n  | $ZodString\n  | $ZodNumber\n  | $ZodBigInt\n  | $ZodBoolean\n  | $ZodDate\n  | $ZodSymbol\n  | $ZodUndefined\n  | $ZodNullable\n  | $ZodNull\n  | $ZodAny\n  | $ZodUnknown\n  | $ZodNever\n  | $ZodVoid\n  | $ZodArray\n  | $ZodObject\n  | $ZodUnion\n  | $ZodIntersection\n  | $ZodTuple\n  | $ZodRecord\n  | $ZodMap\n  | $ZodSet\n  | $ZodLiteral\n  | $ZodEnum\n  | $ZodPromise\n  | $ZodLazy\n  | $ZodOptional\n  | $ZodDefault\n  | $ZodPrefault\n  | $ZodTemplateLiteral\n  | $ZodCustom\n  | $ZodTransform\n  | $ZodNonOptional\n  | $ZodReadonly\n  | $ZodNaN\n  | $ZodPipe\n  | $ZodSuccess\n  | $ZodCatch\n  | $ZodFile;\n\nexport type $ZodStringFormatTypes =\n  | $ZodGUID\n  | $ZodUUID\n  | $ZodEmail\n  | $ZodURL\n  | $ZodEmoji\n  | $ZodNanoID\n  | $ZodCUID\n  | $ZodCUID2\n  | $ZodULID\n  | $ZodXID\n  | $ZodKSUID\n  | $ZodISODateTime\n  | $ZodISODate\n  | $ZodISOTime\n  | $ZodISODuration\n  | $ZodIPv4\n  | $ZodIPv6\n  | $ZodCIDRv4\n  | $ZodCIDRv6\n  | $ZodBase64\n  | $ZodBase64URL\n  | $ZodE164\n  | $ZodJWT;\n",
    "symbols": [
      {
        "name": "isValidBase64",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 800,
        "endLine": 809
      },
      {
        "name": "isValidBase64URL",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 843,
        "endLine": 848
      },
      {
        "name": "isValidJWT",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 897,
        "endLine": 911
      },
      {
        "name": "handleArrayResult",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 1510,
        "endLine": 1515
      },
      {
        "name": "handleObjectResult",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 1599,
        "endLine": 1606
      },
      {
        "name": "handleOptionalObjectResult",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 1608,
        "endLine": 1628
      },
      {
        "name": "handleUnionResults",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 1920,
        "endLine": 1936
      },
      {
        "name": "mergeValues",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 2139,
        "endLine": 2195
      },
      {
        "name": "handleIntersectionResults",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 2197,
        "endLine": 2214
      },
      {
        "name": "handleTupleResult",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 2358,
        "endLine": 2363
      },
      {
        "name": "handleMapResult",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 2604,
        "endLine": 2641
      },
      {
        "name": "handleSetResult",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 2696,
        "endLine": 2701
      },
      {
        "name": "handleDefaultResult",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 3106,
        "endLine": 3111
      },
      {
        "name": "handleNonOptionalResult",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 3203,
        "endLine": 3213
      },
      {
        "name": "handlePipeResult",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 3452,
        "endLine": 3457
      },
      {
        "name": "handleReadonlyResult",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 3505,
        "endLine": 3508
      },
      {
        "name": "handleRefineResult",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/schemas.ts",
        "startLine": 3764,
        "endLine": 3777
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/standard-schema.ts",
    "content": "/** The Standard Schema interface. */\nexport interface StandardSchemaV1<Input = unknown, Output = Input> {\n  /** The Standard Schema properties. */\n  readonly \"~standard\": StandardSchemaV1.Props<Input, Output>;\n}\n\nexport declare namespace StandardSchemaV1 {\n  /** The Standard Schema properties interface. */\n  export interface Props<Input = unknown, Output = Input> {\n    /** The version number of the standard. */\n    readonly version: 1;\n    /** The vendor name of the schema library. */\n    readonly vendor: string;\n    /** Validates unknown input values. */\n    readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n    /** Inferred types associated with the schema. */\n    readonly types?: Types<Input, Output> | undefined;\n  }\n\n  /** The result interface of the validate function. */\n  export type Result<Output> = SuccessResult<Output> | FailureResult;\n\n  /** The result interface if validation succeeds. */\n  export interface SuccessResult<Output> {\n    /** The typed output value. */\n    readonly value: Output;\n    /** The non-existent issues. */\n    readonly issues?: undefined;\n  }\n\n  /** The result interface if validation fails. */\n  export interface FailureResult {\n    /** The issues of failed validation. */\n    readonly issues: ReadonlyArray<Issue>;\n  }\n\n  /** The issue interface of the failure output. */\n  export interface Issue {\n    /** The error message of the issue. */\n    readonly message: string;\n    /** The path of the issue, if any. */\n    readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;\n  }\n\n  /** The path segment interface of the issue. */\n  export interface PathSegment {\n    /** The key representing a path segment. */\n    readonly key: PropertyKey;\n  }\n\n  /** The Standard Schema types interface. */\n  export interface Types<Input = unknown, Output = Input> {\n    /** The input type of the schema. */\n    readonly input: Input;\n    /** The output type of the schema. */\n    readonly output: Output;\n  }\n\n  /** Infers the input type of a Standard Schema. */\n  export type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"input\"];\n\n  /** Infers the output type of a Standard Schema. */\n  export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"output\"];\n}\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
    "content": "import type * as checks from \"./checks.js\";\nimport type * as JSONSchema from \"./json-schema.js\";\nimport { $ZodRegistry, globalRegistry } from \"./registries.js\";\nimport type * as schemas from \"./schemas.js\";\nimport { getEnumValues } from \"./util.js\";\n\ninterface JSONSchemaGeneratorParams {\n  /** A registry used to look up metadata for each schema. Any schema with an `id` property will be extracted as a $def.\n   *  @default globalRegistry */\n  metadata?: $ZodRegistry<Record<string, any>>;\n  /** The JSON Schema version to target.\n   * - `\"draft-2020-12\"` — Default. JSON Schema Draft 2020-12\n   * - `\"draft-7\"` — JSON Schema Draft 7 */\n  target?: \"draft-7\" | \"draft-2020-12\";\n  /** How to handle unrepresentable types.\n   * - `\"throw\"` — Default. Unrepresentable types throw an error\n   * - `\"any\"` — Unrepresentable types become `{}` */\n  unrepresentable?: \"throw\" | \"any\";\n  /** Arbitrary custom logic that can be used to modify the generated JSON Schema. */\n  override?: (ctx: {\n    zodSchema: schemas.$ZodTypes;\n    jsonSchema: JSONSchema.BaseSchema;\n    path: (string | number)[];\n  }) => void;\n  /** Whether to extract the `\"input\"` or `\"output\"` type. Relevant to transforms, Error converting schema to JSONz, defaults, coerced primitives, etc.\n   * - `\"output\"` — Default. Convert the output schema.\n   * - `\"input\"` — Convert the input schema. */\n  io?: \"input\" | \"output\";\n}\n\ninterface ProcessParams {\n  schemaPath: schemas.$ZodType[];\n  path: (string | number)[];\n}\n\ninterface EmitParams {\n  /** How to handle cycles.\n   * - `\"ref\"` — Default. Cycles will be broken using $defs\n   * - `\"throw\"` — Cycles will throw an error if encountered */\n  cycles?: \"ref\" | \"throw\";\n  /* How to handle reused schemas.\n   * - `\"inline\"` — Default. Reused schemas will be inlined\n   * - `\"ref\"` — Reused schemas will be extracted as $defs */\n  reused?: \"ref\" | \"inline\";\n\n  external?:\n    | {\n        /**  */\n        registry: $ZodRegistry<{ id?: string | undefined }>;\n        uri?: ((id: string) => string) | undefined;\n        defs: Record<string, JSONSchema.BaseSchema>;\n      }\n    | undefined;\n}\n\ninterface Seen {\n  /** JSON Schema result for this Zod schema */\n  schema: JSONSchema.BaseSchema;\n  /** A cached version of the schema that doesn't get overwritten during ref resolution */\n  def?: JSONSchema.BaseSchema;\n  defId?: string | undefined;\n  /** Number of times this schema was encountered during traversal */\n  count: number;\n  /** Cycle path */\n  cycle?: (string | number)[] | undefined;\n  isParent?: boolean | undefined;\n  ref?: schemas.$ZodType | undefined | null;\n  /** JSON Schema property path for this schema */\n  path?: (string | number)[] | undefined;\n}\n\nexport class JSONSchemaGenerator {\n  metadataRegistry: $ZodRegistry<Record<string, any>>;\n  target: \"draft-7\" | \"draft-2020-12\";\n  unrepresentable: \"throw\" | \"any\";\n  override: (ctx: {\n    zodSchema: schemas.$ZodTypes;\n    jsonSchema: JSONSchema.BaseSchema;\n    path: (string | number)[];\n  }) => void;\n  io: \"input\" | \"output\";\n\n  counter = 0;\n  seen: Map<schemas.$ZodType, Seen>;\n\n  constructor(params?: JSONSchemaGeneratorParams) {\n    this.metadataRegistry = params?.metadata ?? globalRegistry;\n    this.target = params?.target ?? \"draft-2020-12\";\n    this.unrepresentable = params?.unrepresentable ?? \"throw\";\n    this.override = params?.override ?? (() => {});\n    this.io = params?.io ?? \"output\";\n\n    this.seen = new Map();\n  }\n\n  process(schema: schemas.$ZodType, _params: ProcessParams = { path: [], schemaPath: [] }): JSONSchema.BaseSchema {\n    const def = (schema as schemas.$ZodTypes)._zod.def;\n\n    const formatMap: Partial<Record<checks.$ZodStringFormats, string | undefined>> = {\n      guid: \"uuid\",\n      url: \"uri\",\n      datetime: \"date-time\",\n      json_string: \"json-string\",\n      regex: \"\", // do not set\n    };\n\n    // check for schema in seens\n    const seen = this.seen.get(schema);\n\n    if (seen) {\n      seen.count++;\n\n      // check if cycle\n      const isCycle = _params.schemaPath.includes(schema);\n      if (isCycle) {\n        seen.cycle = _params.path;\n      }\n\n      return seen.schema;\n    }\n\n    // initialize\n    const result: Seen = { schema: {}, count: 1, cycle: undefined, path: _params.path };\n    this.seen.set(schema, result);\n\n    // custom method overrides default behavior\n    const overrideSchema = schema._zod.toJSONSchema?.();\n    if (overrideSchema) {\n      result.schema = overrideSchema as any;\n    } else {\n      const params = {\n        ..._params,\n        schemaPath: [..._params.schemaPath, schema],\n        path: _params.path,\n      };\n\n      const parent = schema._zod.parent;\n\n      if (parent) {\n        // schema was cloned from another schema\n        result.ref = parent;\n        this.process(parent, params);\n        this.seen.get(parent)!.isParent = true;\n      } else {\n        const _json = result.schema;\n        switch (def.type) {\n          case \"string\": {\n            const json: JSONSchema.StringSchema = _json as any;\n            json.type = \"string\";\n            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod\n              .bag as schemas.$ZodStringInternals<unknown>[\"bag\"];\n            if (typeof minimum === \"number\") json.minLength = minimum;\n            if (typeof maximum === \"number\") json.maxLength = maximum;\n            // custom pattern overrides format\n            if (format) {\n              json.format = formatMap[format as checks.$ZodStringFormats] ?? format;\n              if (json.format === \"\") delete json.format; // empty format is not valid\n            }\n            if (contentEncoding) json.contentEncoding = contentEncoding;\n            if (patterns && patterns.size > 0) {\n              const regexes = [...patterns];\n              if (regexes.length === 1) json.pattern = regexes[0]!.source;\n              else if (regexes.length > 1) {\n                result.schema.allOf = [\n                  ...regexes.map((regex) => ({\n                    ...(this.target === \"draft-7\" ? ({ type: \"string\" } as const) : {}),\n                    pattern: regex.source,\n                  })),\n                ];\n              }\n            }\n\n            break;\n          }\n          case \"number\": {\n            const json: JSONSchema.NumberSchema | JSONSchema.IntegerSchema = _json as any;\n            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;\n            if (typeof format === \"string\" && format.includes(\"int\")) json.type = \"integer\";\n            else json.type = \"number\";\n\n            if (typeof exclusiveMinimum === \"number\") json.exclusiveMinimum = exclusiveMinimum;\n            if (typeof minimum === \"number\") {\n              json.minimum = minimum;\n              if (typeof exclusiveMinimum === \"number\") {\n                if (exclusiveMinimum >= minimum) delete json.minimum;\n                else delete json.exclusiveMinimum;\n              }\n            }\n\n            if (typeof exclusiveMaximum === \"number\") json.exclusiveMaximum = exclusiveMaximum;\n            if (typeof maximum === \"number\") {\n              json.maximum = maximum;\n              if (typeof exclusiveMaximum === \"number\") {\n                if (exclusiveMaximum <= maximum) delete json.maximum;\n                else delete json.exclusiveMaximum;\n              }\n            }\n\n            if (typeof multipleOf === \"number\") json.multipleOf = multipleOf;\n\n            break;\n          }\n          case \"boolean\": {\n            const json = _json as JSONSchema.BooleanSchema;\n            json.type = \"boolean\";\n            break;\n          }\n          case \"bigint\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"BigInt cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"symbol\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Symbols cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"null\": {\n            _json.type = \"null\";\n            break;\n          }\n          case \"any\": {\n            break;\n          }\n          case \"unknown\": {\n            break;\n          }\n          case \"undefined\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Undefined cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"void\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Void cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"never\": {\n            _json.not = {};\n            break;\n          }\n          case \"date\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Date cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"array\": {\n            const json: JSONSchema.ArraySchema = _json as any;\n            const { minimum, maximum } = schema._zod.bag;\n            if (typeof minimum === \"number\") json.minItems = minimum;\n            if (typeof maximum === \"number\") json.maxItems = maximum;\n\n            json.type = \"array\";\n            json.items = this.process(def.element, { ...params, path: [...params.path, \"items\"] });\n            break;\n          }\n          case \"object\": {\n            const json: JSONSchema.ObjectSchema = _json as any;\n            json.type = \"object\";\n            json.properties = {};\n            const shape = def.shape; // params.shapeCache.get(schema)!;\n\n            for (const key in shape) {\n              json.properties[key] = this.process(shape[key]!, {\n                ...params,\n                path: [...params.path, \"properties\", key],\n              });\n            }\n\n            // required keys\n            const allKeys = new Set(Object.keys(shape));\n            // const optionalKeys = new Set(def.optional);\n            const requiredKeys = new Set(\n              [...allKeys].filter((key) => {\n                const v = def.shape[key]!._zod;\n                if (this.io === \"input\") {\n                  return v.optin === undefined;\n                } else {\n                  return v.optout === undefined;\n                }\n              })\n            );\n\n            if (requiredKeys.size > 0) {\n              json.required = Array.from(requiredKeys);\n            }\n\n            // catchall\n            if (def.catchall?._zod.def.type === \"never\") {\n              // strict\n              json.additionalProperties = false;\n            } else if (!def.catchall) {\n              // regular\n              if (this.io === \"output\") json.additionalProperties = false;\n            } else if (def.catchall) {\n              json.additionalProperties = this.process(def.catchall, {\n                ...params,\n                path: [...params.path, \"additionalProperties\"],\n              });\n            }\n\n            break;\n          }\n          case \"union\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            json.anyOf = def.options.map((x, i) =>\n              this.process(x, {\n                ...params,\n                path: [...params.path, \"anyOf\", i],\n              })\n            );\n            break;\n          }\n          case \"intersection\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            const a = this.process(def.left, {\n              ...params,\n              path: [...params.path, \"allOf\", 0],\n            });\n            const b = this.process(def.right, {\n              ...params,\n              path: [...params.path, \"allOf\", 1],\n            });\n\n            const isSimpleIntersection = (val: any) => \"allOf\" in val && Object.keys(val).length === 1;\n            const allOf = [\n              ...(isSimpleIntersection(a) ? (a.allOf as any[]) : [a]),\n              ...(isSimpleIntersection(b) ? (b.allOf as any[]) : [b]),\n            ];\n            json.allOf = allOf;\n            break;\n          }\n          case \"tuple\": {\n            const json: JSONSchema.ArraySchema = _json as any;\n            json.type = \"array\";\n            const prefixItems = def.items.map((x, i) =>\n              this.process(x, { ...params, path: [...params.path, \"prefixItems\", i] })\n            );\n            if (this.target === \"draft-2020-12\") {\n              json.prefixItems = prefixItems;\n            } else {\n              json.items = prefixItems;\n            }\n\n            if (def.rest) {\n              const rest = this.process(def.rest, {\n                ...params,\n                path: [...params.path, \"items\"],\n              });\n              if (this.target === \"draft-2020-12\") {\n                json.items = rest;\n              } else {\n                json.additionalItems = rest;\n              }\n            }\n\n            // additionalItems\n            if (def.rest) {\n              json.items = this.process(def.rest, {\n                ...params,\n                path: [...params.path, \"items\"],\n              });\n            }\n\n            // length\n            const { minimum, maximum } = schema._zod.bag as {\n              minimum?: number;\n              maximum?: number;\n            };\n            if (typeof minimum === \"number\") json.minItems = minimum;\n            if (typeof maximum === \"number\") json.maxItems = maximum;\n            break;\n          }\n          case \"record\": {\n            const json: JSONSchema.ObjectSchema = _json as any;\n            json.type = \"object\";\n            json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, \"propertyNames\"] });\n            json.additionalProperties = this.process(def.valueType, {\n              ...params,\n              path: [...params.path, \"additionalProperties\"],\n            });\n            break;\n          }\n          case \"map\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Map cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"set\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Set cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"enum\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            const values = getEnumValues(def.entries);\n            // Number enums can have both string and number values\n            if (values.every((v) => typeof v === \"number\")) json.type = \"number\";\n            if (values.every((v) => typeof v === \"string\")) json.type = \"string\";\n            json.enum = values;\n            break;\n          }\n          case \"literal\": {\n            const json: JSONSchema.BaseSchema = _json as any;\n            const vals: (string | number | boolean | null)[] = [];\n            for (const val of def.values) {\n              if (val === undefined) {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                } else {\n                  // do not add to vals\n                }\n              } else if (typeof val === \"bigint\") {\n                if (this.unrepresentable === \"throw\") {\n                  throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                } else {\n                  vals.push(Number(val));\n                }\n              } else {\n                vals.push(val);\n              }\n            }\n            if (vals.length === 0) {\n              // do nothing (an undefined literal was stripped)\n            } else if (vals.length === 1) {\n              const val = vals[0]!;\n              json.type = val === null ? (\"null\" as const) : (typeof val as any);\n              json.const = val;\n            } else {\n              if (vals.every((v) => typeof v === \"number\")) json.type = \"number\";\n              if (vals.every((v) => typeof v === \"string\")) json.type = \"string\";\n              if (vals.every((v) => typeof v === \"boolean\")) json.type = \"string\";\n              if (vals.every((v) => v === null)) json.type = \"null\";\n              json.enum = vals;\n            }\n            break;\n          }\n\n          case \"file\": {\n            const json: JSONSchema.StringSchema = _json as any;\n            const file: JSONSchema.StringSchema = {\n              type: \"string\",\n              format: \"binary\",\n              contentEncoding: \"binary\",\n            };\n\n            const { minimum, maximum, mime } = schema._zod.bag as schemas.$ZodFileInternals[\"bag\"];\n            if (minimum !== undefined) file.minLength = minimum;\n            if (maximum !== undefined) file.maxLength = maximum;\n            if (mime) {\n              if (mime.length === 1) {\n                file.contentMediaType = mime[0]!;\n                Object.assign(json, file);\n              } else {\n                json.anyOf = mime.map((m) => {\n                  const mFile: JSONSchema.StringSchema = { ...file, contentMediaType: m };\n                  return mFile;\n                });\n              }\n            } else {\n              Object.assign(json, file);\n            }\n\n            // if (this.unrepresentable === \"throw\") {\n            //   throw new Error(\"File cannot be represented in JSON Schema\");\n            // }\n            break;\n          }\n          case \"transform\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Transforms cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n\n          case \"nullable\": {\n            const inner = this.process(def.innerType, params);\n            _json.anyOf = [inner, { type: \"null\" }];\n            break;\n          }\n          case \"nonoptional\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            break;\n          }\n          case \"success\": {\n            const json = _json as JSONSchema.BooleanSchema;\n            json.type = \"boolean\";\n            break;\n          }\n          case \"default\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n            break;\n          }\n          case \"prefault\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            if (this.io === \"input\") _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n\n            break;\n          }\n          case \"catch\": {\n            // use conditionals\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            let catchValue: any;\n            try {\n              catchValue = def.catchValue(undefined as any);\n            } catch {\n              throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n            }\n            _json.default = catchValue;\n            break;\n          }\n          case \"nan\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"NaN cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          case \"template_literal\": {\n            const json = _json as JSONSchema.StringSchema;\n            const pattern = schema._zod.pattern;\n            if (!pattern) throw new Error(\"Pattern not found in template literal\");\n            json.type = \"string\";\n            json.pattern = pattern.source;\n            break;\n          }\n          case \"pipe\": {\n            const innerType = this.io === \"input\" ? (def.in._zod.def.type === \"transform\" ? def.out : def.in) : def.out;\n            this.process(innerType, params);\n            result.ref = innerType;\n            break;\n          }\n          case \"readonly\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            _json.readOnly = true;\n            break;\n          }\n          // passthrough types\n          case \"promise\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            break;\n          }\n          case \"optional\": {\n            this.process(def.innerType, params);\n            result.ref = def.innerType;\n            break;\n          }\n          case \"lazy\": {\n            const innerType = (schema as schemas.$ZodLazy)._zod.innerType;\n            this.process(innerType, params);\n            result.ref = innerType;\n            break;\n          }\n          case \"custom\": {\n            if (this.unrepresentable === \"throw\") {\n              throw new Error(\"Custom types cannot be represented in JSON Schema\");\n            }\n            break;\n          }\n          default: {\n            def satisfies never;\n          }\n        }\n      }\n    }\n\n    // metadata\n    const meta = this.metadataRegistry.get(schema);\n    if (meta) Object.assign(result.schema, meta);\n\n    if (this.io === \"input\" && isTransforming(schema)) {\n      // examples/defaults only apply to output type of pipe\n      delete result.schema.examples;\n      delete result.schema.default;\n    }\n\n    // set prefault as default\n    if (this.io === \"input\" && result.schema._prefault) result.schema.default ??= result.schema._prefault;\n    delete result.schema._prefault;\n\n    // pulling fresh from this.seen in case it was overwritten\n    const _result = this.seen.get(schema)!;\n\n    return _result.schema;\n  }\n\n  emit(schema: schemas.$ZodType, _params?: EmitParams): JSONSchema.BaseSchema {\n    const params = {\n      cycles: _params?.cycles ?? \"ref\",\n      reused: _params?.reused ?? \"inline\",\n      // unrepresentable: _params?.unrepresentable ?? \"throw\",\n      // uri: _params?.uri ?? ((id) => `${id}`),\n      external: _params?.external ?? undefined,\n    } satisfies EmitParams;\n\n    // iterate over seen map;\n    const root = this.seen.get(schema);\n\n    if (!root) throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n\n    // initialize result with root schema fields\n    // Object.assign(result, seen.cached);\n\n    // returns a ref to the schema\n    // defId will be empty if the ref points to an external schema (or #)\n    const makeURI = (entry: [schemas.$ZodType<unknown, unknown>, Seen]): { ref: string; defId?: string } => {\n      // comparing the seen objects because sometimes\n      // multiple schemas map to the same seen object.\n      // e.g. lazy\n\n      // external is configured\n      const defsSegment = this.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      if (params.external) {\n        const externalId = params.external.registry.get(entry[0])?.id; // ?? \"__shared\";// `__schema${this.counter++}`;\n\n        // check if schema is in the external registry\n        const uriGenerator = params.external.uri ?? ((id) => id);\n        if (externalId) {\n          return { ref: uriGenerator(externalId) };\n        }\n\n        // otherwise, add to __shared\n        const id: string = entry[1].defId ?? (entry[1].schema.id as string) ?? `schema${this.counter++}`;\n        entry[1].defId = id; // set defId so it will be reused if needed\n        return { defId: id, ref: `${uriGenerator(\"__shared\")}#/${defsSegment}/${id}` };\n      }\n\n      if (entry[1] === root) {\n        return { ref: \"#\" };\n      }\n\n      // self-contained schema\n      const uriPrefix = `#`;\n      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;\n      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;\n      return { defId, ref: defUriPrefix + defId };\n    };\n\n    // stored cached version in `def` property\n    // remove all properties, set $ref\n    const extractToDef = (entry: [schemas.$ZodType<unknown, unknown>, Seen]): void => {\n      // if the schema is already a reference, do not extract it\n      if (entry[1].schema.$ref) {\n        return;\n      }\n      const seen = entry[1];\n      const { ref, defId } = makeURI(entry);\n\n      seen.def = { ...seen.schema };\n      // defId won't be set if the schema is a reference to an external schema\n      if (defId) seen.defId = defId;\n      // wipe away all properties except $ref\n      const schema = seen.schema;\n      for (const key in schema) {\n        delete schema[key];\n      }\n      schema.$ref = ref;\n    };\n\n    // throw on cycles\n\n    // break cycles\n    if (params.cycles === \"throw\") {\n      for (const entry of this.seen.entries()) {\n        const seen = entry[1];\n        if (seen.cycle) {\n          throw new Error(\n            \"Cycle detected: \" +\n              `#/${seen.cycle?.join(\"/\")}/<root>` +\n              '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.'\n          );\n        }\n      }\n    }\n\n    // extract schemas into $defs\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n\n      // convert root schema to # $ref\n      if (schema === entry[0]) {\n        extractToDef(entry); // this has special handling for the root schema\n        continue;\n      }\n\n      // extract schemas that are in the external registry\n      if (params.external) {\n        const ext = params.external.registry.get(entry[0])?.id;\n        if (schema !== entry[0] && ext) {\n          extractToDef(entry);\n          continue;\n        }\n      }\n\n      // extract schemas with `id` meta\n      const id = this.metadataRegistry.get(entry[0])?.id;\n      if (id) {\n        extractToDef(entry);\n        continue;\n      }\n\n      // break cycles\n      if (seen.cycle) {\n        // any\n        extractToDef(entry);\n        continue;\n      }\n\n      // extract reused schemas\n      if (seen.count > 1) {\n        if (params.reused === \"ref\") {\n          extractToDef(entry);\n          // biome-ignore lint:\n          continue;\n        }\n      }\n    }\n\n    // flatten _refs\n    const flattenRef = (zodSchema: schemas.$ZodType, params: Pick<ToJSONSchemaParams, \"target\">) => {\n      const seen = this.seen.get(zodSchema)!;\n      const schema = seen.def ?? seen.schema;\n\n      const _cached = { ...schema };\n\n      // already seen\n      if (seen.ref === null) {\n        return;\n      }\n\n      // flatten ref if defined\n      const ref = seen.ref;\n      seen.ref = null; // prevent recursion\n      if (ref) {\n        flattenRef(ref, params);\n\n        // merge referenced schema into current\n        const refSchema = this.seen.get(ref)!.schema;\n        if (refSchema.$ref && params.target === \"draft-7\") {\n          schema.allOf = schema.allOf ?? [];\n          schema.allOf.push(refSchema);\n        } else {\n          Object.assign(schema, refSchema);\n          Object.assign(schema, _cached); // prevent overwriting any fields in the original schema\n        }\n      }\n\n      // execute overrides\n      if (!seen.isParent)\n        this.override({\n          zodSchema: zodSchema as schemas.$ZodTypes,\n          jsonSchema: schema,\n          path: seen.path ?? [],\n        });\n    };\n\n    for (const entry of [...this.seen.entries()].reverse()) {\n      flattenRef(entry[0], { target: this.target });\n    }\n\n    const result: JSONSchema.BaseSchema = {};\n    if (this.target === \"draft-2020-12\") {\n      result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n    } else if (this.target === \"draft-7\") {\n      result.$schema = \"http://json-schema.org/draft-07/schema#\";\n    } else {\n      console.warn(`Invalid target: ${this.target}`);\n    }\n\n    if (params.external?.uri) {\n      const id = params.external.registry.get(schema)?.id;\n      if (!id) throw new Error(\"Schema is missing an `id` property\");\n      result.$id = params.external.uri(id);\n    }\n\n    Object.assign(result, root.def);\n\n    // build defs object\n    const defs: JSONSchema.BaseSchema[\"$defs\"] = params.external?.defs ?? {};\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n      if (seen.def && seen.defId) {\n        defs[seen.defId] = seen.def;\n      }\n    }\n\n    // set definitions in result\n    if (params.external) {\n    } else {\n      if (Object.keys(defs).length > 0) {\n        if (this.target === \"draft-2020-12\") {\n          result.$defs = defs;\n        } else {\n          result.definitions = defs;\n        }\n      }\n    }\n\n    try {\n      // this \"finalizes\" this schema and ensures all cycles are removed\n      // each call to .emit() is functionally independent\n      // though the seen map is shared\n      return JSON.parse(JSON.stringify(result));\n    } catch (_err) {\n      throw new Error(\"Error converting schema to JSON.\");\n    }\n  }\n}\n\ninterface ToJSONSchemaParams extends Omit<JSONSchemaGeneratorParams & EmitParams, \"external\"> {}\ninterface RegistryToJSONSchemaParams extends Omit<JSONSchemaGeneratorParams & EmitParams, \"external\"> {\n  uri?: (id: string) => string;\n}\n\nexport function toJSONSchema(schema: schemas.$ZodType, _params?: ToJSONSchemaParams): JSONSchema.BaseSchema;\nexport function toJSONSchema(\n  registry: $ZodRegistry<{ id?: string | undefined }>,\n  _params?: RegistryToJSONSchemaParams\n): { schemas: Record<string, JSONSchema.BaseSchema> };\nexport function toJSONSchema(\n  input: schemas.$ZodType | $ZodRegistry<{ id?: string | undefined }>,\n  _params?: ToJSONSchemaParams\n): any {\n  if (input instanceof $ZodRegistry) {\n    const gen = new JSONSchemaGenerator(_params);\n    const defs: any = {};\n    for (const entry of input._idmap.entries()) {\n      const [_, schema] = entry;\n      gen.process(schema);\n    }\n\n    const schemas: Record<string, JSONSchema.BaseSchema> = {};\n    const external = {\n      registry: input,\n      uri: (_params as RegistryToJSONSchemaParams)?.uri,\n      defs,\n    };\n    for (const entry of input._idmap.entries()) {\n      const [key, schema] = entry;\n      schemas[key] = gen.emit(schema, {\n        ..._params,\n        external,\n      });\n    }\n\n    if (Object.keys(defs).length > 0) {\n      const defsSegment = gen.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      schemas.__shared = {\n        [defsSegment]: defs,\n      };\n    }\n\n    return { schemas };\n  }\n\n  const gen = new JSONSchemaGenerator(_params);\n  gen.process(input);\n\n  return gen.emit(input, _params);\n}\n\nfunction isTransforming(\n  _schema: schemas.$ZodType,\n  _ctx?: {\n    seen: Set<schemas.$ZodType>;\n  }\n): boolean {\n  const ctx = _ctx ?? { seen: new Set() };\n\n  if (ctx.seen.has(_schema)) return false;\n  ctx.seen.add(_schema);\n\n  const schema = _schema as schemas.$ZodTypes;\n  const def = schema._zod.def;\n  switch (def.type) {\n    case \"string\":\n    case \"number\":\n    case \"bigint\":\n    case \"boolean\":\n    case \"date\":\n    case \"symbol\":\n    case \"undefined\":\n    case \"null\":\n    case \"any\":\n    case \"unknown\":\n    case \"never\":\n    case \"void\":\n    case \"literal\":\n    case \"enum\":\n    case \"nan\":\n    case \"file\":\n    case \"template_literal\":\n      return false;\n    case \"array\": {\n      return isTransforming(def.element, ctx);\n    }\n    case \"object\": {\n      for (const key in def.shape) {\n        if (isTransforming(def.shape[key]!, ctx)) return true;\n      }\n      return false;\n    }\n    case \"union\": {\n      for (const option of def.options) {\n        if (isTransforming(option, ctx)) return true;\n      }\n      return false;\n    }\n    case \"intersection\": {\n      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n    }\n    case \"tuple\": {\n      for (const item of def.items) {\n        if (isTransforming(item, ctx)) return true;\n      }\n      if (def.rest && isTransforming(def.rest, ctx)) return true;\n      return false;\n    }\n    case \"record\": {\n      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n    }\n    case \"map\": {\n      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n    }\n    case \"set\": {\n      return isTransforming(def.valueType, ctx);\n    }\n\n    // inner types\n    case \"promise\":\n    case \"optional\":\n    case \"nonoptional\":\n    case \"nullable\":\n    case \"readonly\":\n      return isTransforming(def.innerType, ctx);\n    case \"lazy\":\n      return isTransforming(def.getter(), ctx);\n    case \"default\": {\n      return isTransforming(def.innerType, ctx);\n    }\n    case \"prefault\": {\n      return isTransforming(def.innerType, ctx);\n    }\n    case \"custom\": {\n      return false;\n    }\n    case \"transform\": {\n      return true;\n    }\n    case \"pipe\": {\n      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n    }\n    case \"success\": {\n      return false;\n    }\n    case \"catch\": {\n      return false;\n    }\n\n    default:\n      def satisfies never;\n  }\n  throw new Error(`Unknown schema type: ${(def as any).type}`);\n}\n",
    "symbols": [
      {
        "name": "JSONSchemaGenerator",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
        "startLine": 72,
        "endLine": 821
      },
      {
        "name": "JSONSchemaGenerator.process",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
        "startLine": 96,
        "endLine": 598
      },
      {
        "name": "JSONSchemaGenerator.emit",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
        "startLine": 600,
        "endLine": 820
      },
      {
        "name": "toJSONSchema",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
        "startLine": 828,
        "endLine": 828
      },
      {
        "name": "toJSONSchema",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
        "startLine": 829,
        "endLine": 832
      },
      {
        "name": "toJSONSchema",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
        "startLine": 833,
        "endLine": 873
      },
      {
        "name": "isTransforming",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/to-json-schema.ts",
        "startLine": 875,
        "endLine": 977
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
    "content": "import type * as checks from \"./checks.js\";\nimport type { $ZodConfig } from \"./core.js\";\nimport type * as errors from \"./errors.js\";\nimport type * as schemas from \"./schemas.js\";\n\n// json\nexport type JSONType = string | number | boolean | null | JSONType[] | { [key: string]: JSONType };\nexport type JWTAlgorithm =\n  | \"HS256\"\n  | \"HS384\"\n  | \"HS512\"\n  | \"RS256\"\n  | \"RS384\"\n  | \"RS512\"\n  | \"ES256\"\n  | \"ES384\"\n  | \"ES512\"\n  | \"PS256\"\n  | \"PS384\"\n  | \"PS512\"\n  | \"EdDSA\"\n  | (string & {});\nexport type IPVersion = \"v4\" | \"v6\";\nexport type MimeTypes =\n  | \"application/json\"\n  | \"application/xml\"\n  | \"application/x-www-form-urlencoded\"\n  | \"application/javascript\"\n  | \"application/pdf\"\n  | \"application/zip\"\n  | \"application/vnd.ms-excel\"\n  | \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n  | \"application/msword\"\n  | \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\"\n  | \"application/vnd.ms-powerpoint\"\n  | \"application/vnd.openxmlformats-officedocument.presentationml.presentation\"\n  | \"application/octet-stream\"\n  | \"application/graphql\"\n  | \"text/html\"\n  | \"text/plain\"\n  | \"text/css\"\n  | \"text/javascript\"\n  | \"text/csv\"\n  | \"image/png\"\n  | \"image/jpeg\"\n  | \"image/gif\"\n  | \"image/svg+xml\"\n  | \"image/webp\"\n  | \"audio/mpeg\"\n  | \"audio/ogg\"\n  | \"audio/wav\"\n  | \"audio/webm\"\n  | \"video/mp4\"\n  | \"video/webm\"\n  | \"video/ogg\"\n  | \"font/woff\"\n  | \"font/woff2\"\n  | \"font/ttf\"\n  | \"font/otf\"\n  | \"multipart/form-data\"\n  | (string & {});\nexport type ParsedTypes =\n  | \"string\"\n  | \"number\"\n  | \"bigint\"\n  | \"boolean\"\n  | \"symbol\"\n  | \"undefined\"\n  | \"object\"\n  | \"function\"\n  | \"file\"\n  | \"date\"\n  | \"array\"\n  | \"map\"\n  | \"set\"\n  | \"nan\"\n  | \"null\"\n  | \"promise\";\n\n// utils\nexport type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;\nexport type AssertNotEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? false : true;\nexport type AssertExtends<T, U> = T extends U ? T : never;\nexport type IsAny<T> = 0 extends 1 & T ? true : false;\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\nexport type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;\nexport type MakePartial<T, K extends keyof T> = Omit<T, K> & InexactPartial<Pick<T, K>>;\nexport type MakeRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\n\nexport type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;\nexport type NoUndefined<T> = T extends undefined ? never : T;\nexport type Whatever = {} | undefined | null;\nexport type LoosePartial<T extends object> = InexactPartial<T> & {\n  [k: string]: unknown;\n};\nexport type Mask<Keys extends PropertyKey> = { [K in Keys]?: true };\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] } & {};\nexport type InexactPartial<T> = {\n  [P in keyof T]?: T[P] | undefined;\n};\nexport type EmptyObject = Record<string, never>;\nexport type BuiltIn =\n  | (((...args: any[]) => any) | (new (...args: any[]) => any))\n  | { readonly [Symbol.toStringTag]: string }\n  | Date\n  | Error\n  | Generator\n  | Promise<unknown>\n  | RegExp;\nexport type MakeReadonly<T> = T extends Map<infer K, infer V>\n  ? ReadonlyMap<K, V>\n  : T extends Set<infer V>\n    ? ReadonlySet<V>\n    : T extends [infer Head, ...infer Tail]\n      ? readonly [Head, ...Tail]\n      : T extends Array<infer V>\n        ? ReadonlyArray<V>\n        : T extends BuiltIn\n          ? T\n          : Readonly<T>;\nexport type SomeObject = Record<PropertyKey, any>;\nexport type Identity<T> = T;\nexport type Flatten<T> = Identity<{ [k in keyof T]: T[k] }>;\nexport type Mapped<T> = { [k in keyof T]: T[k] };\nexport type Prettify<T> = {\n  [K in keyof T]: T[K];\n} & {};\n\nexport type NoNeverKeys<T> = {\n  [k in keyof T]: [T[k]] extends [never] ? never : k;\n}[keyof T];\nexport type NoNever<T> = Identity<{\n  [k in NoNeverKeys<T>]: k extends keyof T ? T[k] : never;\n}>;\nexport type Extend<A extends SomeObject, B extends SomeObject> = Flatten<\n  // fast path when there is no keys overlap\n  keyof A & keyof B extends never\n    ? A & B\n    : {\n        [K in keyof A as K extends keyof B ? never : K]: A[K];\n      } & {\n        [K in keyof B]: B[K];\n      }\n>;\n\nexport type TupleItems = ReadonlyArray<schemas.SomeType>;\nexport type AnyFunc = (...args: any[]) => any;\nexport type IsProp<T, K extends keyof T> = T[K] extends AnyFunc ? never : K;\nexport type MaybeAsync<T> = T | Promise<T>;\nexport type KeyOf<T> = keyof OmitIndexSignature<T>;\nexport type OmitIndexSignature<T> = {\n  [K in keyof T as string extends K ? never : K extends string ? K : never]: T[K];\n};\nexport type ExtractIndexSignature<T> = {\n  [K in keyof T as string extends K ? K : K extends string ? never : K]: T[K];\n};\nexport type Keys<T extends object> = keyof OmitIndexSignature<T>;\n\nexport type SchemaClass<T extends schemas.SomeType> = {\n  new (def: T[\"_zod\"][\"def\"]): T;\n};\nexport type EnumValue = string | number; // | bigint | boolean | symbol;\nexport type EnumLike = Readonly<Record<string, EnumValue>>;\nexport type ToEnum<T extends EnumValue> = Flatten<{ [k in T]: k }>;\nexport type KeysEnum<T extends object> = ToEnum<Exclude<keyof T, symbol>>;\nexport type KeysArray<T extends object> = Flatten<(keyof T & string)[]>;\nexport type Literal = string | number | bigint | boolean | null | undefined;\nexport type LiteralArray = Array<Literal>;\nexport type Primitive = string | number | symbol | bigint | boolean | null | undefined;\nexport type PrimitiveArray = Array<Primitive>;\nexport type HasSize = { size: number };\nexport type HasLength = { length: number }; // string | Array<unknown> | Set<unknown> | File;\nexport type Numeric = number | bigint | Date;\nexport type SafeParseResult<T> = SafeParseSuccess<T> | SafeParseError<T>;\nexport type SafeParseSuccess<T> = { success: true; data: T; error?: never };\nexport type SafeParseError<T> = {\n  success: false;\n  data?: never;\n  error: errors.$ZodError<T>;\n};\n\nexport type PropValues = Record<string, Set<Primitive>>;\nexport type PrimitiveSet = Set<Primitive>;\n\n// functions\nexport function assertEqual<A, B>(val: AssertEqual<A, B>): AssertEqual<A, B> {\n  return val;\n}\n\nexport function assertNotEqual<A, B>(val: AssertNotEqual<A, B>): AssertNotEqual<A, B> {\n  return val;\n}\n\nexport function assertIs<T>(_arg: T): void {}\n\nexport function assertNever(_x: never): never {\n  throw new Error();\n}\nexport function assert<T>(_: any): asserts _ is T {}\n\nexport function getEnumValues(entries: EnumLike): EnumValue[] {\n  const numericValues = Object.values(entries).filter((v) => typeof v === \"number\");\n  const values = Object.entries(entries)\n    .filter(([k, _]) => numericValues.indexOf(+k) === -1)\n    .map(([_, v]) => v);\n  return values;\n}\n\nexport function joinValues<T extends Primitive[]>(array: T, separator = \"|\"): string {\n  return array.map((val) => stringifyPrimitive(val)).join(separator);\n}\n\nexport function jsonStringifyReplacer(_: string, value: any): any {\n  if (typeof value === \"bigint\") return value.toString();\n  return value;\n}\n\nexport function cached<T>(getter: () => T): { value: T } {\n  const set = false;\n  return {\n    get value() {\n      if (!set) {\n        const value = getter();\n        Object.defineProperty(this, \"value\", { value });\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    },\n  };\n}\n\nexport function nullish(input: any): boolean {\n  return input === null || input === undefined;\n}\n\nexport function cleanRegex(source: string): string {\n  const start = source.startsWith(\"^\") ? 1 : 0;\n  const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n  return source.slice(start, end);\n}\n\nexport function floatSafeRemainder(val: number, step: number): number {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return (valInt % stepInt) / 10 ** decCount;\n}\n\nexport function defineLazy<T, K extends keyof T>(object: T, key: K, getter: () => T[K]): void {\n  const set = false;\n  Object.defineProperty(object, key, {\n    get() {\n      if (!set) {\n        const value = getter();\n        object[key] = value;\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    },\n    set(v) {\n      Object.defineProperty(object, key, {\n        value: v,\n        // configurable: true,\n      });\n      // object[key] = v;\n    },\n    configurable: true,\n  });\n}\n\nexport function assignProp<T extends object, K extends PropertyKey>(\n  target: T,\n  prop: K,\n  value: K extends keyof T ? T[K] : any\n): void {\n  Object.defineProperty(target, prop, {\n    value,\n    writable: true,\n    enumerable: true,\n    configurable: true,\n  });\n}\n\nexport function getElementAtPath(obj: any, path: (string | number)[] | null | undefined): any {\n  if (!path) return obj;\n  return path.reduce((acc, key) => acc?.[key], obj);\n}\n\nexport function promiseAllObject<T extends object>(promisesObj: T): Promise<{ [k in keyof T]: Awaited<T[k]> }> {\n  const keys = Object.keys(promisesObj);\n  const promises = keys.map((key) => (promisesObj as any)[key]);\n\n  return Promise.all(promises).then((results) => {\n    const resolvedObj: any = {};\n    for (let i = 0; i < keys.length; i++) {\n      resolvedObj[keys[i]!] = results[i];\n    }\n    return resolvedObj;\n  });\n}\n\nexport function randomString(length = 10): string {\n  const chars = \"abcdefghijklmnopqrstuvwxyz\";\n  let str = \"\";\n  for (let i = 0; i < length; i++) {\n    str += chars[Math.floor(Math.random() * chars.length)];\n  }\n  return str;\n}\n\nexport function esc(str: string): string {\n  return JSON.stringify(str);\n}\n\nexport const captureStackTrace: (targetObject: object, constructorOpt?: Function) => void = Error.captureStackTrace\n  ? Error.captureStackTrace\n  : (..._args) => {};\n\nexport function isObject(data: any): data is Record<PropertyKey, unknown> {\n  return typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\n\nexport const allowsEval: { value: boolean } = cached(() => {\n  if (typeof navigator !== \"undefined\" && navigator?.userAgent?.includes(\"Cloudflare\")) {\n    return false;\n  }\n\n  try {\n    const F = Function;\n    new F(\"\");\n    return true;\n  } catch (_) {\n    return false;\n  }\n});\n\nexport function isPlainObject(o: any): o is Record<PropertyKey, unknown> {\n  if (isObject(o) === false) return false;\n\n  // modified constructor\n  const ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // modified prototype\n  const prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // ctor doesn't have static `isPrototypeOf`\n  if (Object.prototype.hasOwnProperty.call(prot, \"isPrototypeOf\") === false) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function numKeys(data: any): number {\n  let keyCount = 0;\n  for (const key in data) {\n    if (Object.prototype.hasOwnProperty.call(data, key)) {\n      keyCount++;\n    }\n  }\n  return keyCount;\n}\n\nexport const getParsedType = (data: any): ParsedTypes => {\n  const t = typeof data;\n\n  switch (t) {\n    case \"undefined\":\n      return \"undefined\";\n\n    case \"string\":\n      return \"string\";\n\n    case \"number\":\n      return Number.isNaN(data) ? \"nan\" : \"number\";\n\n    case \"boolean\":\n      return \"boolean\";\n\n    case \"function\":\n      return \"function\";\n\n    case \"bigint\":\n      return \"bigint\";\n\n    case \"symbol\":\n      return \"symbol\";\n\n    case \"object\":\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      if (data === null) {\n        return \"null\";\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return \"promise\";\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return \"map\";\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return \"set\";\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return \"date\";\n      }\n      if (typeof File !== \"undefined\" && data instanceof File) {\n        return \"file\";\n      }\n      return \"object\";\n\n    default:\n      throw new Error(`Unknown data type: ${t}`);\n  }\n};\n\nexport const propertyKeyTypes: Set<string> = new Set([\"string\", \"number\", \"symbol\"]);\nexport const primitiveTypes: Set<string> = new Set([\"string\", \"number\", \"bigint\", \"boolean\", \"symbol\", \"undefined\"]);\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\n// zod-specific utils\nexport function clone<T extends schemas.$ZodType>(inst: T, def?: T[\"_zod\"][\"def\"], params?: { parent: boolean }): T {\n  const cl = new inst._zod.constr(def ?? inst._zod.def);\n  if (!def || params?.parent) cl._zod.parent = inst;\n  return cl as any;\n}\n\nexport type EmptyToNever<T> = keyof T extends never ? never : T;\n\nexport type Normalize<T> = T extends undefined\n  ? never\n  : T extends Record<any, any>\n    ? Flatten<\n        {\n          [k in keyof Omit<T, \"error\" | \"message\">]: T[k];\n        } & (\"error\" extends keyof T\n          ? {\n              error?: Exclude<T[\"error\"], string>;\n              // path?: PropertyKey[] | undefined;\n              // message?: string | undefined;\n            }\n          : unknown)\n      >\n    : never;\n\nexport function normalizeParams<T>(_params: T): Normalize<T> {\n  const params: any = _params;\n\n  if (!params) return {} as any;\n  if (typeof params === \"string\") return { error: () => params } as any;\n  if (params?.message !== undefined) {\n    if (params?.error !== undefined) throw new Error(\"Cannot specify both `message` and `error` params\");\n    params.error = params.message;\n  }\n  delete params.message;\n  if (typeof params.error === \"string\") return { ...params, error: () => params.error } as any;\n  return params;\n}\n\nexport function createTransparentProxy<T extends object>(getter: () => T): T {\n  let target: T;\n  return new Proxy(\n    {},\n    {\n      get(_, prop, receiver) {\n        target ??= getter();\n        return Reflect.get(target, prop, receiver);\n      },\n      set(_, prop, value, receiver) {\n        target ??= getter();\n        return Reflect.set(target, prop, value, receiver);\n      },\n      has(_, prop) {\n        target ??= getter();\n        return Reflect.has(target, prop);\n      },\n      deleteProperty(_, prop) {\n        target ??= getter();\n        return Reflect.deleteProperty(target, prop);\n      },\n      ownKeys(_) {\n        target ??= getter();\n        return Reflect.ownKeys(target);\n      },\n      getOwnPropertyDescriptor(_, prop) {\n        target ??= getter();\n        return Reflect.getOwnPropertyDescriptor(target, prop);\n      },\n      defineProperty(_, prop, descriptor) {\n        target ??= getter();\n        return Reflect.defineProperty(target, prop, descriptor);\n      },\n    }\n  ) as T;\n}\n\nexport function stringifyPrimitive(value: any): string {\n  if (typeof value === \"bigint\") return value.toString() + \"n\";\n  if (typeof value === \"string\") return `\"${value}\"`;\n  return `${value}`;\n}\n\nexport function optionalKeys(shape: schemas.$ZodShape): string[] {\n  return Object.keys(shape).filter((k) => {\n    return shape[k]!._zod.optin === \"optional\" && shape[k]!._zod.optout === \"optional\";\n  });\n}\n\nexport type CleanKey<T extends PropertyKey> = T extends `?${infer K}` ? K : T extends `${infer K}?` ? K : T;\nexport type ToCleanMap<T extends schemas.$ZodLooseShape> = {\n  [k in keyof T]: k extends `?${infer K}` ? K : k extends `${infer K}?` ? K : k;\n};\nexport type FromCleanMap<T extends schemas.$ZodLooseShape> = {\n  [k in keyof T as k extends `?${infer K}` ? K : k extends `${infer K}?` ? K : k]: k;\n};\n\nexport const NUMBER_FORMAT_RANGES: Record<checks.$ZodNumberFormats, [number, number]> = {\n  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n  int32: [-2147483648, 2147483647],\n  uint32: [0, 4294967295],\n  float32: [-3.4028234663852886e38, 3.4028234663852886e38],\n  float64: [-Number.MAX_VALUE, Number.MAX_VALUE],\n};\n\nexport const BIGINT_FORMAT_RANGES: Record<checks.$ZodBigIntFormats, [bigint, bigint]> = {\n  int64: [/* @__PURE__*/ BigInt(\"-9223372036854775808\"), /* @__PURE__*/ BigInt(\"9223372036854775807\")],\n  uint64: [/* @__PURE__*/ BigInt(0), /* @__PURE__*/ BigInt(\"18446744073709551615\")],\n};\n\nexport function pick(schema: schemas.$ZodObject, mask: Record<string, unknown>): any {\n  const newShape: Writeable<schemas.$ZodShape> = {};\n  const currDef = schema._zod.def; //.shape;\n\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!mask[key]) continue;\n\n    // pick key\n    newShape[key] = currDef.shape[key]!;\n  }\n\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: [],\n  }) as any;\n}\n\nexport function omit(schema: schemas.$ZodObject, mask: object): any {\n  const newShape: Writeable<schemas.$ZodShape> = { ...schema._zod.def.shape };\n  const currDef = schema._zod.def; //.shape;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!(mask as any)[key]) continue;\n\n    delete newShape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: [],\n  });\n}\n\nexport function extend(schema: schemas.$ZodObject, shape: schemas.$ZodShape): any {\n  if (!isPlainObject(shape)) {\n    throw new Error(\"Invalid input to extend: expected a plain object\");\n  }\n  const def = {\n    ...schema._zod.def,\n    get shape() {\n      const _shape = { ...schema._zod.def.shape, ...shape };\n      assignProp(this, \"shape\", _shape); // self-caching\n      return _shape;\n    },\n    checks: [], // delete existing checks\n  } as any;\n  return clone(schema, def) as any;\n}\n\nexport function merge(a: schemas.$ZodObject, b: schemas.$ZodObject): any {\n  return clone(a, {\n    ...a._zod.def,\n    get shape() {\n      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };\n      assignProp(this, \"shape\", _shape); // self-caching\n      return _shape;\n    },\n    catchall: b._zod.def.catchall,\n    checks: [], // delete existing checks\n  }) as any;\n}\n\nexport function partial(\n  Class: SchemaClass<schemas.$ZodOptional> | null,\n  schema: schemas.$ZodObject,\n  mask: object | undefined\n): any {\n  const oldShape = schema._zod.def.shape;\n  const shape: Writeable<schemas.$ZodShape> = { ...oldShape };\n\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in oldShape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!(mask as any)[key]) continue;\n      // if (oldShape[key]!._zod.optin === \"optional\") continue;\n      shape[key] = Class\n        ? new Class({\n            type: \"optional\",\n            innerType: oldShape[key]!,\n          })\n        : oldShape[key]!;\n    }\n  } else {\n    for (const key in oldShape) {\n      // if (oldShape[key]!._zod.optin === \"optional\") continue;\n      shape[key] = Class\n        ? new Class({\n            type: \"optional\",\n            innerType: oldShape[key]!,\n          })\n        : oldShape[key]!;\n    }\n  }\n\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    checks: [],\n  }) as any;\n}\n\nexport function required(\n  Class: SchemaClass<schemas.$ZodNonOptional>,\n  schema: schemas.$ZodObject,\n  mask: object | undefined\n): any {\n  const oldShape = schema._zod.def.shape;\n  const shape: Writeable<schemas.$ZodShape> = { ...oldShape };\n\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in shape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!(mask as any)[key]) continue;\n      // overwrite with non-optional\n      shape[key] = new Class({\n        type: \"nonoptional\",\n        innerType: oldShape[key]!,\n      });\n    }\n  } else {\n    for (const key in oldShape) {\n      // overwrite with non-optional\n      shape[key] = new Class({\n        type: \"nonoptional\",\n        innerType: oldShape[key]!,\n      });\n    }\n  }\n\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    // optional: [],\n    checks: [],\n  }) as any;\n}\n\nexport type Constructor<T, Def extends any[] = any[]> = new (...args: Def) => T;\n\nexport function aborted(x: schemas.ParsePayload, startIndex = 0): boolean {\n  for (let i = startIndex; i < x.issues.length; i++) {\n    if (x.issues[i]?.continue !== true) return true;\n  }\n  return false;\n}\n\nexport function prefixIssues(path: PropertyKey, issues: errors.$ZodRawIssue[]): errors.$ZodRawIssue[] {\n  return issues.map((iss) => {\n    (iss as any).path ??= [];\n    (iss as any).path.unshift(path);\n    return iss;\n  });\n}\n\nexport function unwrapMessage(message: string | { message: string } | undefined | null): string | undefined {\n  return typeof message === \"string\" ? message : message?.message;\n}\n\nexport function finalizeIssue(\n  iss: errors.$ZodRawIssue,\n  ctx: schemas.ParseContextInternal | undefined,\n  config: $ZodConfig\n): errors.$ZodIssue {\n  const full = { ...iss, path: iss.path ?? [] } as errors.$ZodIssue;\n\n  // for backwards compatibility\n  if (!iss.message) {\n    const message =\n      unwrapMessage(iss.inst?._zod.def?.error?.(iss as never)) ??\n      unwrapMessage(ctx?.error?.(iss as never)) ??\n      unwrapMessage(config.customError?.(iss)) ??\n      unwrapMessage(config.localeError?.(iss)) ??\n      \"Invalid input\";\n    (full as any).message = message;\n  }\n\n  // delete (full as any).def;\n  delete (full as any).inst;\n  delete (full as any).continue;\n  if (!ctx?.reportInput) {\n    delete (full as any).input;\n  }\n\n  return full;\n}\n\nexport function getSizableOrigin(input: any): \"set\" | \"map\" | \"file\" | \"unknown\" {\n  if (input instanceof Set) return \"set\";\n  if (input instanceof Map) return \"map\";\n  if (input instanceof File) return \"file\";\n  return \"unknown\";\n}\n\nexport function getLengthableOrigin(input: any): \"array\" | \"string\" | \"unknown\" {\n  if (Array.isArray(input)) return \"array\";\n  if (typeof input === \"string\") return \"string\";\n  return \"unknown\";\n}\n\n//////////    REFINES     //////////\nexport function issue(_iss: string, input: any, inst: any): errors.$ZodRawIssue;\nexport function issue(_iss: errors.$ZodRawIssue): errors.$ZodRawIssue;\nexport function issue(...args: [string | errors.$ZodRawIssue, any?, any?]): errors.$ZodRawIssue {\n  const [iss, input, inst] = args;\n  if (typeof iss === \"string\") {\n    return {\n      message: iss,\n      code: \"custom\",\n      input,\n      inst,\n    };\n  }\n\n  return { ...iss };\n}\n\nexport function cleanEnum(obj: Record<string, EnumValue>): EnumValue[] {\n  return Object.entries(obj)\n    .filter(([k, _]) => {\n      // return true if NaN, meaning it's not a number, thus a string key\n      return Number.isNaN(Number.parseInt(k, 10));\n    })\n    .map((el) => el[1]);\n}\n\n// instanceof\nexport abstract class Class {\n  constructor(..._args: any[]) {}\n}\n",
    "symbols": [
      {
        "name": "assertEqual",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 186,
        "endLine": 188
      },
      {
        "name": "assertNotEqual",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 190,
        "endLine": 192
      },
      {
        "name": "assertIs",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 194,
        "endLine": 194
      },
      {
        "name": "assertNever",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 196,
        "endLine": 198
      },
      {
        "name": "assert",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 199,
        "endLine": 199
      },
      {
        "name": "getEnumValues",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 201,
        "endLine": 207
      },
      {
        "name": "joinValues",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 209,
        "endLine": 211
      },
      {
        "name": "jsonStringifyReplacer",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 213,
        "endLine": 216
      },
      {
        "name": "cached",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 218,
        "endLine": 230
      },
      {
        "name": "nullish",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 232,
        "endLine": 234
      },
      {
        "name": "cleanRegex",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 236,
        "endLine": 240
      },
      {
        "name": "floatSafeRemainder",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 242,
        "endLine": 249
      },
      {
        "name": "defineLazy",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 251,
        "endLine": 271
      },
      {
        "name": "assignProp",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 273,
        "endLine": 284
      },
      {
        "name": "getElementAtPath",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 286,
        "endLine": 289
      },
      {
        "name": "promiseAllObject",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 291,
        "endLine": 302
      },
      {
        "name": "randomString",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 304,
        "endLine": 311
      },
      {
        "name": "esc",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 313,
        "endLine": 315
      },
      {
        "name": "isObject",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 321,
        "endLine": 323
      },
      {
        "name": "isPlainObject",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 339,
        "endLine": 356
      },
      {
        "name": "numKeys",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 358,
        "endLine": 366
      },
      {
        "name": "escapeRegex",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 424,
        "endLine": 426
      },
      {
        "name": "clone",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 429,
        "endLine": 433
      },
      {
        "name": "normalizeParams",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 453,
        "endLine": 465
      },
      {
        "name": "createTransparentProxy",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 467,
        "endLine": 502
      },
      {
        "name": "stringifyPrimitive",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 504,
        "endLine": 508
      },
      {
        "name": "optionalKeys",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 510,
        "endLine": 514
      },
      {
        "name": "pick",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 537,
        "endLine": 556
      },
      {
        "name": "omit",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 558,
        "endLine": 574
      },
      {
        "name": "extend",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 576,
        "endLine": 590
      },
      {
        "name": "merge",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 592,
        "endLine": 603
      },
      {
        "name": "partial",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 605,
        "endLine": 644
      },
      {
        "name": "required",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 646,
        "endLine": 682
      },
      {
        "name": "aborted",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 686,
        "endLine": 691
      },
      {
        "name": "prefixIssues",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 693,
        "endLine": 699
      },
      {
        "name": "unwrapMessage",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 701,
        "endLine": 703
      },
      {
        "name": "finalizeIssue",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 705,
        "endLine": 731
      },
      {
        "name": "getSizableOrigin",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 733,
        "endLine": 738
      },
      {
        "name": "getLengthableOrigin",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 740,
        "endLine": 744
      },
      {
        "name": "issue",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 747,
        "endLine": 747
      },
      {
        "name": "issue",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 748,
        "endLine": 748
      },
      {
        "name": "issue",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 749,
        "endLine": 761
      },
      {
        "name": "cleanEnum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 763,
        "endLine": 770
      },
      {
        "name": "Class",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/core/util.ts",
        "startLine": 773,
        "endLine": 775
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/versions.ts",
    "content": "export const version = {\n  major: 4,\n  minor: 0,\n  patch: 0 as number,\n} as const;\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/zsf.ts",
    "content": "///////////////////////////////////////////////////\n////////////////      TYPES     ///////////////////\n///////////////////////////////////////////////////\n\nexport interface $ZSF {\n  $zsf: { version: number };\n  type: string;\n  // default value if not defined\n  default: unknown;\n  // fallback value if validation fails\n  fallback: unknown;\n}\n\nexport interface $ZSFString extends $ZSF {\n  type: \"string\";\n  min_length?: number;\n  max_length?: number;\n  pattern?: string;\n}\n\nexport type NumberTypes = \"float32\" | \"int32\" | \"uint32\" | \"float64\" | \"int64\" | \"uint64\" | \"bigint\" | \"bigdecimal\";\n\nexport interface $ZSFNumber extends $ZSF {\n  type: \"number\";\n  format?: NumberTypes;\n  minimum?: number;\n  maximum?: number;\n  multiple_of?: number;\n}\n\nexport interface $ZSFBoolean extends $ZSF {\n  type: \"boolean\";\n}\n\nexport interface $ZSFNull extends $ZSF {\n  type: \"null\";\n}\n\nexport interface $ZSFUndefined extends $ZSF {\n  type: \"undefined\";\n}\n\nexport interface $ZSFOptional<T extends $ZSF = $ZSF> extends $ZSF {\n  type: \"optional\";\n  inner: T;\n}\n\nexport interface $ZSFNever extends $ZSF {\n  type: \"never\";\n}\n\nexport interface $ZSFAny extends $ZSF {\n  type: \"any\";\n}\n\n/** Supports */\nexport interface $ZSFEnum<Elements extends { [k: string]: $ZSFLiteral } = { [k: string]: $ZSFLiteral }> extends $ZSF {\n  type: \"enum\";\n  elements: Elements;\n}\n\nexport interface $ZSFArray<PrefixItems extends $ZSF[] = $ZSF[], Items extends $ZSF = $ZSF> extends $ZSF {\n  type: \"array\";\n  prefixItems: PrefixItems;\n  items: Items;\n}\n\n// type $ZSFObjectProperties = { [k: string]: $ZSF };\ntype $ZSFObjectProperties = Array<{\n  key: string;\n  value: $ZSF;\n  format?: \"literal\" | \"pattern\";\n  ordering?: number;\n}>;\nexport interface $ZSFObject<Properties extends $ZSFObjectProperties = $ZSFObjectProperties> extends $ZSF {\n  type: \"object\";\n  properties: Properties;\n}\n\n// export interface $ZSFTuple<\n//   Items extends $ZSF[] = $ZSF[],\n//   Rest extends $ZSF = $ZSF,\n// > extends $ZSF {\n//   type: \"array\";\n//   items: Items;\n//   rest: Rest;\n// }\n\n/** Supports arbitrary literal values */\nexport interface $ZSFLiteral<T extends $ZSF = $ZSF> extends $ZSF {\n  type: \"literal\";\n  schema: T;\n  value: unknown;\n}\n\nexport interface $ZSFUnion<Elements extends $ZSF[] = $ZSF[]> extends $ZSF {\n  type: \"union\";\n  elements: Elements;\n}\n\nexport interface $ZSFIntersection extends $ZSF {\n  type: \"intersection\";\n  elements: $ZSF[];\n}\n\nexport interface $ZSFMap<K extends $ZSF = $ZSF, V extends $ZSF = $ZSF> extends $ZSF {\n  type: \"map\";\n  keys: K;\n  values: V;\n}\n\nexport interface $ZSFConditional<If extends $ZSF, Then extends $ZSF, Else extends $ZSF> extends $ZSF {\n  type: \"conditional\";\n  if: If;\n  then: Then;\n  else: Else;\n}\n\n/////////////////////////////////////////////////\n////////////////      CHECKS     ////////////////\n/////////////////////////////////////////////////\n\n// export interface $ZSFCheckRegex {\n//   check: \"regex\";\n//   pattern: string;\n// }\n\n// export interface $ZSFCheckEmail {\n//   check: \"email\";\n// }\n\n// export interface $ZSFCheckURL {\n//   check: \"url\";\n// }\n\n// export interface $ZSFCheckEmoji {\n//   check: \"emoji\";\n// }\n\n// export interface $ZSFCheckUUID {\n//   check: \"uuid\";\n// }\n\n// export interface $ZSFCheckUUIDv4 {\n//   check: \"uuidv4\";\n// }\n\n// export interface $ZSFCheckUUIDv6 {\n//   check: \"uuidv6\";\n// }\n\n// export interface $ZSFCheckNanoid {\n//   check: \"nanoid\";\n// }\n\n// export interface $ZSFCheckGUID {\n//   check: \"guid\";\n// }\n\n// export interface $ZSFCheckCUID {\n//   check: \"cuid\";\n// }\n\n// export interface $ZSFCheckCUID2 {\n//   check: \"cuid2\";\n// }\n\n// export interface $ZSFCheckULID {\n//   check: \"ulid\";\n// }\n\n// export interface $ZSFCheckXID {\n//   check: \"xid\";\n// }\n\n// export interface $ZSFCheckKSUID {\n//   check: \"ksuid\";\n// }\n\n// export interface $ZSFCheckISODateTime {\n//   check: \"datetime\";\n//   precision?: number;\n//   local?: boolean;\n// }\n\n// export interface $ZSFCheckISODate {\n//   check: \"date\";\n// }\n\n// export interface $ZSFCheckISOTime {\n//   check: \"time\";\n//   precision?: number;\n//   local?: boolean;\n// }\n\n// export interface $ZSFCheckDuration {\n//   check: \"duration\";\n// }\n\n// export interface $ZSFCheckIP {\n//   check: \"ip\";\n// }\n\n// export interface $ZSFCheckIPv4 {\n//   check: \"ipv4\";\n// }\n\n// export interface $ZSFCheckIPv6 {\n//   check: \"ipv6\";\n// }\n\n// export interface $ZSFCheckBase64 {\n//   check: \"base64\";\n// }\n\n// export interface $ZSFCheckJWT {\n//   check: \"jwt\";\n// }\n\n// export interface $ZSFCheckJSONString {\n//   check: \"json_string\";\n// }\n\n// export interface $ZSFCheckPrefix {\n//   check: \"prefix\";\n//   prefix: string;\n// }\n\n// export interface $ZSFCheckSuffix {\n//   check: \"suffix\";\n//   suffix: string;\n// }\n\n// export interface $ZSFCheckIncludes {\n//   check: \"includes\";\n//   includes: string;\n// }\n\n// export interface $ZSFCheckMinSize {\n//   check: \"min_size\";\n//   minimum: number;\n// }\n\n// export interface $ZSFCheckMaxSize {\n//   check: \"max_size\";\n//   maximum: number;\n// }\n\n// export interface $ZSFCheckSizeEquals {\n//   check: \"size_equals\";\n//   size: number;\n// }\n\n// export interface $ZSFCheckLessThan {\n//   check: \"less_than\";\n//   maximum: number | bigint | Date;\n// }\n\n// export interface $ZSFCheckLessThanOrEqual {\n//   check: \"less_than_or_equal\";\n//   maximum: number | bigint | Date;\n// }\n\n// export interface $ZSFCheckGreaterThan {\n//   check: \"greater_than\";\n//   minimum: number | bigint | Date;\n// }\n\n// export interface $ZSFCheckGreaterThanOrEqual {\n//   check: \"greater_than_or_equal\";\n//   minimum: number | bigint | Date;\n// }\n\n// export interface $ZSFCheckEquals {\n//   check: \"equals\";\n//   value: number | bigint | Date;\n// }\n\n// export interface $ZSFCheckMultipleOf {\n//   check: \"multiple_of\";\n//   multipleOf: number;\n// }\n\n// export type $ZSFStringFormatChecks =\n//   | $ZSFCheckRegex\n//   | $ZSFCheckEmail\n//   | $ZSFCheckURL\n//   | $ZSFCheckEmoji\n//   | $ZSFCheckUUID\n//   | $ZSFCheckUUIDv4\n//   | $ZSFCheckUUIDv6\n//   | $ZSFCheckNanoid\n//   | $ZSFCheckGUID\n//   | $ZSFCheckCUID\n//   | $ZSFCheckCUID2\n//   | $ZSFCheckULID\n//   | $ZSFCheckXID\n//   | $ZSFCheckKSUID\n//   | $ZSFCheckISODateTime\n//   | $ZSFCheckISODate\n//   | $ZSFCheckISOTime\n//   | $ZSFCheckDuration\n//   | $ZSFCheckIP\n//   | $ZSFCheckIPv4\n//   | $ZSFCheckIPv6\n//   | $ZSFCheckBase64\n//   | $ZSFCheckJWT\n//   | $ZSFCheckJSONString\n//   | $ZSFCheckPrefix\n//   | $ZSFCheckSuffix\n//   | $ZSFCheckIncludes;\n\n// export type $ZSFCheck =\n//   | $ZSFStringFormatChecks\n//   | $ZSFCheckMinSize\n//   | $ZSFCheckMaxSize\n//   | $ZSFCheckSizeEquals\n//   | $ZSFCheckLessThan\n//   | $ZSFCheckLessThanOrEqual\n//   | $ZSFCheckGreaterThan\n//   | $ZSFCheckGreaterThanOrEqual\n//   | $ZSFCheckEquals\n//   | $ZSFCheckMultipleOf;\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/ar.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"حرف\", verb: \"أن يحوي\" },\n    file: { unit: \"بايت\", verb: \"أن يحوي\" },\n    array: { unit: \"عنصر\", verb: \"أن يحوي\" },\n    set: { unit: \"عنصر\", verb: \"أن يحوي\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"مدخل\",\n    email: \"بريد إلكتروني\",\n    url: \"رابط\",\n    emoji: \"إيموجي\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"تاريخ ووقت بمعيار ISO\",\n    date: \"تاريخ بمعيار ISO\",\n    time: \"وقت بمعيار ISO\",\n    duration: \"مدة بمعيار ISO\",\n    ipv4: \"عنوان IPv4\",\n    ipv6: \"عنوان IPv6\",\n    cidrv4: \"مدى عناوين بصيغة IPv4\",\n    cidrv6: \"مدى عناوين بصيغة IPv6\",\n    base64: \"نَص بترميز base64-encoded\",\n    base64url: \"نَص بترميز base64url-encoded\",\n    json_string: \"نَص على هيئة JSON\",\n    e164: \"رقم هاتف بمعيار E.164\",\n    jwt: \"JWT\",\n    template_literal: \"مدخل\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `مدخلات غير مقبولة: يفترض إدخال ${issue.expected}، ولكن تم إدخال ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `مدخلات غير مقبولة: يفترض إدخال ${util.stringifyPrimitive(issue.values[0])}`;\n        return `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return ` أكبر من اللازم: يفترض أن تكون ${issue.origin ?? \"القيمة\"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"عنصر\"}`;\n        return `أكبر من اللازم: يفترض أن تكون ${issue.origin ?? \"القيمة\"} ${adj} ${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `أصغر من اللازم: يفترض لـ ${issue.origin} أن يكون ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `أصغر من اللازم: يفترض لـ ${issue.origin} أن يكون ${adj} ${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `نَص غير مقبول: يجب أن يبدأ بـ \"${issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `نَص غير مقبول: يجب أن ينتهي بـ \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `نَص غير مقبول: يجب أن يتضمَّن \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `نَص غير مقبول: يجب أن يطابق النمط ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} غير مقبول`;\n      }\n      case \"not_multiple_of\":\n        return `رقم غير مقبول: يجب أن يكون من مضاعفات ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `معرف${issue.keys.length > 1 ? \"ات\" : \"\"} غريب${issue.keys.length > 1 ? \"ة\" : \"\"}: ${util.joinValues(issue.keys, \"، \")}`;\n      case \"invalid_key\":\n        return `معرف غير مقبول في ${issue.origin}`;\n      case \"invalid_union\":\n        return \"مدخل غير مقبول\";\n      case \"invalid_element\":\n        return `مدخل غير مقبول في ${issue.origin}`;\n      default:\n        return \"مدخل غير مقبول\";\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ar.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/az.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"simvol\", verb: \"olmalıdır\" },\n    file: { unit: \"bayt\", verb: \"olmalıdır\" },\n    array: { unit: \"element\", verb: \"olmalıdır\" },\n    set: { unit: \"element\", verb: \"olmalıdır\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"email address\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datetime\",\n    date: \"ISO date\",\n    time: \"ISO time\",\n    duration: \"ISO duration\",\n    ipv4: \"IPv4 address\",\n    ipv6: \"IPv6 address\",\n    cidrv4: \"IPv4 range\",\n    cidrv6: \"IPv6 range\",\n    base64: \"base64-encoded string\",\n    base64url: \"base64url-encoded string\",\n    json_string: \"JSON string\",\n    e164: \"E.164 number\",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Yanlış dəyər: gözlənilən ${issue.expected}, daxil olan ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Yanlış dəyər: gözlənilən ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Yanlış seçim: aşağıdakılardan biri olmalıdır: ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Çox böyük: gözlənilən ${issue.origin ?? \"dəyər\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"element\"}`;\n        return `Çox böyük: gözlənilən ${issue.origin ?? \"dəyər\"} ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) return `Çox kiçik: gözlənilən ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        return `Çox kiçik: gözlənilən ${issue.origin} ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Yanlış mətn: \"${_issue.prefix}\" ilə başlamalıdır`;\n        if (_issue.format === \"ends_with\") return `Yanlış mətn: \"${_issue.suffix}\" ilə bitməlidir`;\n        if (_issue.format === \"includes\") return `Yanlış mətn: \"${_issue.includes}\" daxil olmalıdır`;\n        if (_issue.format === \"regex\") return `Yanlış mətn: ${_issue.pattern} şablonuna uyğun olmalıdır`;\n        return `Yanlış ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Yanlış ədəd: ${issue.divisor} ilə bölünə bilən olmalıdır`;\n      case \"unrecognized_keys\":\n        return `Tanınmayan açar${issue.keys.length > 1 ? \"lar\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue.origin} daxilində yanlış açar`;\n      case \"invalid_union\":\n        return \"Yanlış dəyər\";\n      case \"invalid_element\":\n        return `${issue.origin} daxilində yanlış dəyər`;\n      default:\n        return `Yanlış dəyər`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/az.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/be.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nfunction getBelarusianPlural(count: number, one: string, few: string, many: string): string {\n  const absCount = Math.abs(count);\n  const lastDigit = absCount % 10;\n  const lastTwoDigits = absCount % 100;\n\n  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n    return many;\n  }\n\n  if (lastDigit === 1) {\n    return one;\n  }\n\n  if (lastDigit >= 2 && lastDigit <= 4) {\n    return few;\n  }\n\n  return many;\n}\n\ninterface BelarusianSizable {\n  unit: {\n    one: string;\n    few: string;\n    many: string;\n  };\n  verb: string;\n}\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, BelarusianSizable> = {\n    string: {\n      unit: {\n        one: \"сімвал\",\n        few: \"сімвалы\",\n        many: \"сімвалаў\",\n      },\n      verb: \"мець\",\n    },\n    array: {\n      unit: {\n        one: \"элемент\",\n        few: \"элементы\",\n        many: \"элементаў\",\n      },\n      verb: \"мець\",\n    },\n    set: {\n      unit: {\n        one: \"элемент\",\n        few: \"элементы\",\n        many: \"элементаў\",\n      },\n      verb: \"мець\",\n    },\n    file: {\n      unit: {\n        one: \"байт\",\n        few: \"байты\",\n        many: \"байтаў\",\n      },\n      verb: \"мець\",\n    },\n  };\n\n  function getSizing(origin: string): BelarusianSizable | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"лік\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"масіў\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"увод\",\n    email: \"email адрас\",\n    url: \"URL\",\n    emoji: \"эмодзі\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO дата і час\",\n    date: \"ISO дата\",\n    time: \"ISO час\",\n    duration: \"ISO працягласць\",\n    ipv4: \"IPv4 адрас\",\n    ipv6: \"IPv6 адрас\",\n    cidrv4: \"IPv4 дыяпазон\",\n    cidrv6: \"IPv6 дыяпазон\",\n    base64: \"радок у фармаце base64\",\n    base64url: \"радок у фармаце base64url\",\n    json_string: \"JSON радок\",\n    e164: \"нумар E.164\",\n    jwt: \"JWT\",\n    template_literal: \"увод\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Няправільны ўвод: чакаўся ${issue.expected}, атрымана ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Няправільны ўвод: чакалася ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Няправільны варыянт: чакаўся адзін з ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          const maxValue = Number(issue.maximum);\n          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return `Занадта вялікі: чакалася, што ${issue.origin ?? \"значэнне\"} павінна ${sizing.verb} ${adj}${issue.maximum.toString()} ${unit}`;\n        }\n        return `Занадта вялікі: чакалася, што ${issue.origin ?? \"значэнне\"} павінна быць ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          const minValue = Number(issue.minimum);\n          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return `Занадта малы: чакалася, што ${issue.origin} павінна ${sizing.verb} ${adj}${issue.minimum.toString()} ${unit}`;\n        }\n        return `Занадта малы: чакалася, што ${issue.origin} павінна быць ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Няправільны радок: павінен пачынацца з \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Няправільны радок: павінен заканчвацца на \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Няправільны радок: павінен змяшчаць \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Няправільны радок: павінен адпавядаць шаблону ${_issue.pattern}`;\n        return `Няправільны ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Няправільны лік: павінен быць кратным ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Нераспазнаны ${issue.keys.length > 1 ? \"ключы\" : \"ключ\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Няправільны ключ у ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Няправільны ўвод\";\n      case \"invalid_element\":\n        return `Няправільнае значэнне ў ${issue.origin}`;\n      default:\n        return `Няправільны ўвод`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getBelarusianPlural",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/be.ts",
        "startLine": 5,
        "endLine": 23
      },
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/be.ts",
        "startLine": 69,
        "endLine": 71
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/ca.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"caràcters\", verb: \"contenir\" },\n    file: { unit: \"bytes\", verb: \"contenir\" },\n    array: { unit: \"elements\", verb: \"contenir\" },\n    set: { unit: \"elements\", verb: \"contenir\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"entrada\",\n    email: \"adreça electrònica\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data i hora ISO\",\n    date: \"data ISO\",\n    time: \"hora ISO\",\n    duration: \"durada ISO\",\n    ipv4: \"adreça IPv4\",\n    ipv6: \"adreça IPv6\",\n    cidrv4: \"rang IPv4\",\n    cidrv6: \"rang IPv6\",\n    base64: \"cadena codificada en base64\",\n    base64url: \"cadena codificada en base64url\",\n    json_string: \"cadena JSON\",\n    e164: \"número E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entrada\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Tipus invàlid: s'esperava ${issue.expected}, s'ha rebut ${parsedType(issue.input)}`;\n      // return `Tipus invàlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Valor invàlid: s'esperava ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Opció invàlida: s'esperava una de ${util.joinValues(issue.values, \" o \")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"com a màxim\" : \"menys de\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Massa gran: s'esperava que ${issue.origin ?? \"el valor\"} contingués ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"elements\"}`;\n        return `Massa gran: s'esperava que ${issue.origin ?? \"el valor\"} fos ${adj} ${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \"com a mínim\" : \"més de\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Massa petit: s'esperava que ${issue.origin} contingués ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Massa petit: s'esperava que ${issue.origin} fos ${adj} ${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `Format invàlid: ha de començar amb \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `Format invàlid: ha d'acabar amb \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Format invàlid: ha d'incloure \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Format invàlid: ha de coincidir amb el patró ${_issue.pattern}`;\n        return `Format invàlid per a ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Número invàlid: ha de ser múltiple de ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Clau${issue.keys.length > 1 ? \"s\" : \"\"} no reconeguda${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Clau invàlida a ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Entrada invàlida\"; // Could also be \"Tipus d'unió invàlid\" but \"Entrada invàlida\" is more general\n      case \"invalid_element\":\n        return `Element invàlid a ${issue.origin}`;\n      default:\n        return `Entrada invàlida`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ca.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/cs.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"znaků\", verb: \"mít\" },\n    file: { unit: \"bajtů\", verb: \"mít\" },\n    array: { unit: \"prvků\", verb: \"mít\" },\n    set: { unit: \"prvků\", verb: \"mít\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"číslo\";\n      }\n      case \"string\": {\n        return \"řetězec\";\n      }\n      case \"boolean\": {\n        return \"boolean\";\n      }\n      case \"bigint\": {\n        return \"bigint\";\n      }\n      case \"function\": {\n        return \"funkce\";\n      }\n      case \"symbol\": {\n        return \"symbol\";\n      }\n      case \"undefined\": {\n        return \"undefined\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"pole\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"regulární výraz\",\n    email: \"e-mailová adresa\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"datum a čas ve formátu ISO\",\n    date: \"datum ve formátu ISO\",\n    time: \"čas ve formátu ISO\",\n    duration: \"doba trvání ISO\",\n    ipv4: \"IPv4 adresa\",\n    ipv6: \"IPv6 adresa\",\n    cidrv4: \"rozsah IPv4\",\n    cidrv6: \"rozsah IPv6\",\n    base64: \"řetězec zakódovaný ve formátu base64\",\n    base64url: \"řetězec zakódovaný ve formátu base64url\",\n    json_string: \"řetězec ve formátu JSON\",\n    e164: \"číslo E.164\",\n    jwt: \"JWT\",\n    template_literal: \"vstup\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Neplatný vstup: očekáváno ${issue.expected}, obdrženo ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Neplatný vstup: očekáváno ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Neplatná možnost: očekávána jedna z hodnot ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Hodnota je příliš velká: ${issue.origin ?? \"hodnota\"} musí mít ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"prvků\"}`;\n        }\n        return `Hodnota je příliš velká: ${issue.origin ?? \"hodnota\"} musí být ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Hodnota je příliš malá: ${issue.origin ?? \"hodnota\"} musí mít ${adj}${issue.minimum.toString()} ${sizing.unit ?? \"prvků\"}`;\n        }\n        return `Hodnota je příliš malá: ${issue.origin ?? \"hodnota\"} musí být ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Neplatný řetězec: musí začínat na \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Neplatný řetězec: musí končit na \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Neplatný řetězec: musí obsahovat \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Neplatný řetězec: musí odpovídat vzoru ${_issue.pattern}`;\n        return `Neplatný formát ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Neplatné číslo: musí být násobkem ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Neznámé klíče: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Neplatný klíč v ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Neplatný vstup\";\n      case \"invalid_element\":\n        return `Neplatná hodnota v ${issue.origin}`;\n      default:\n        return `Neplatný vstup`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/cs.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/de.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"Zeichen\", verb: \"zu haben\" },\n    file: { unit: \"Bytes\", verb: \"zu haben\" },\n    array: { unit: \"Elemente\", verb: \"zu haben\" },\n    set: { unit: \"Elemente\", verb: \"zu haben\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"Zahl\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"Array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"Eingabe\",\n    email: \"E-Mail-Adresse\",\n    url: \"URL\",\n    emoji: \"Emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO-Datum und -Uhrzeit\",\n    date: \"ISO-Datum\",\n    time: \"ISO-Uhrzeit\",\n    duration: \"ISO-Dauer\",\n    ipv4: \"IPv4-Adresse\",\n    ipv6: \"IPv6-Adresse\",\n    cidrv4: \"IPv4-Bereich\",\n    cidrv6: \"IPv6-Bereich\",\n    base64: \"Base64-codierter String\",\n    base64url: \"Base64-URL-codierter String\",\n    json_string: \"JSON-String\",\n    e164: \"E.164-Nummer\",\n    jwt: \"JWT\",\n    template_literal: \"Eingabe\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Ungültige Eingabe: erwartet ${issue.expected}, erhalten ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Ungültige Eingabe: erwartet ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Ungültige Option: erwartet eine von ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Zu groß: erwartet, dass ${issue.origin ?? \"Wert\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"Elemente\"} hat`;\n        return `Zu groß: erwartet, dass ${issue.origin ?? \"Wert\"} ${adj}${issue.maximum.toString()} ist`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} hat`;\n        }\n\n        return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ist`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Ungültiger String: muss mit \"${_issue.prefix}\" beginnen`;\n        if (_issue.format === \"ends_with\") return `Ungültiger String: muss mit \"${_issue.suffix}\" enden`;\n        if (_issue.format === \"includes\") return `Ungültiger String: muss \"${_issue.includes}\" enthalten`;\n        if (_issue.format === \"regex\") return `Ungültiger String: muss dem Muster ${_issue.pattern} entsprechen`;\n        return `Ungültig: ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Ungültige Zahl: muss ein Vielfaches von ${issue.divisor} sein`;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"Unbekannte Schlüssel\" : \"Unbekannter Schlüssel\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Ungültiger Schlüssel in ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Ungültige Eingabe\";\n      case \"invalid_element\":\n        return `Ungültiger Wert in ${issue.origin}`;\n      default:\n        return `Ungültige Eingabe`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/de.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/en.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nexport const parsedType = (data: any): string => {\n  const t = typeof data;\n\n  switch (t) {\n    case \"number\": {\n      return Number.isNaN(data) ? \"NaN\" : \"number\";\n    }\n    case \"object\": {\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      if (data === null) {\n        return \"null\";\n      }\n\n      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n        return data.constructor.name;\n      }\n    }\n  }\n  return t;\n};\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"characters\", verb: \"to have\" },\n    file: { unit: \"bytes\", verb: \"to have\" },\n    array: { unit: \"items\", verb: \"to have\" },\n    set: { unit: \"items\", verb: \"to have\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"email address\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datetime\",\n    date: \"ISO date\",\n    time: \"ISO time\",\n    duration: \"ISO duration\",\n    ipv4: \"IPv4 address\",\n    ipv6: \"IPv6 address\",\n    cidrv4: \"IPv4 range\",\n    cidrv6: \"IPv6 range\",\n    base64: \"base64-encoded string\",\n    base64url: \"base64url-encoded string\",\n    json_string: \"JSON string\",\n    e164: \"E.164 number\",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Invalid input: expected ${issue.expected}, received ${parsedType(issue.input)}`;\n\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Invalid input: expected ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Invalid option: expected one of ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Too big: expected ${issue.origin ?? \"value\"} to have ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elements\"}`;\n        return `Too big: expected ${issue.origin ?? \"value\"} to be ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Too small: expected ${issue.origin} to have ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Too small: expected ${issue.origin} to be ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `Invalid string: must start with \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `Invalid string: must end with \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Invalid string: must include \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Invalid string: must match pattern ${_issue.pattern}`;\n        return `Invalid ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Invalid number: must be a multiple of ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Unrecognized key${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Invalid key in ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Invalid input\";\n      case \"invalid_element\":\n        return `Invalid value in ${issue.origin}`;\n      default:\n        return `Invalid input`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/en.ts",
        "startLine": 36,
        "endLine": 38
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/eo.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nexport const parsedType = (data: any): string => {\n  const t = typeof data;\n\n  switch (t) {\n    case \"number\": {\n      return Number.isNaN(data) ? \"NaN\" : \"nombro\";\n    }\n    case \"object\": {\n      if (Array.isArray(data)) {\n        return \"tabelo\";\n      }\n      if (data === null) {\n        return \"senvalora\";\n      }\n\n      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n        return data.constructor.name;\n      }\n    }\n  }\n  return t;\n};\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"karaktrojn\", verb: \"havi\" },\n    file: { unit: \"bajtojn\", verb: \"havi\" },\n    array: { unit: \"elementojn\", verb: \"havi\" },\n    set: { unit: \"elementojn\", verb: \"havi\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"enigo\",\n    email: \"retadreso\",\n    url: \"URL\",\n    emoji: \"emoĝio\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO-datotempo\",\n    date: \"ISO-dato\",\n    time: \"ISO-tempo\",\n    duration: \"ISO-daŭro\",\n    ipv4: \"IPv4-adreso\",\n    ipv6: \"IPv6-adreso\",\n    cidrv4: \"IPv4-rango\",\n    cidrv6: \"IPv6-rango\",\n    base64: \"64-ume kodita karaktraro\",\n    base64url: \"URL-64-ume kodita karaktraro\",\n    json_string: \"JSON-karaktraro\",\n    e164: \"E.164-nombro\",\n    jwt: \"JWT\",\n    template_literal: \"enigo\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Nevalida enigo: atendiĝis ${issue.expected}, riceviĝis ${parsedType(issue.input)}`;\n\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Nevalida enigo: atendiĝis ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Nevalida opcio: atendiĝis unu el ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Tro granda: atendiĝis ke ${issue.origin ?? \"valoro\"} havu ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementojn\"}`;\n        return `Tro granda: atendiĝis ke ${issue.origin ?? \"valoro\"} havu ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Tro malgranda: atendiĝis ke ${issue.origin} havu ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Tro malgranda: atendiĝis ke ${issue.origin} estu ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Nevalida karaktraro: devas komenciĝi per \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Nevalida karaktraro: devas finiĝi per \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Nevalida karaktraro: devas inkluzivi \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;\n        return `Nevalida ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Nevalida nombro: devas esti oblo de ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Nekonata${issue.keys.length > 1 ? \"j\" : \"\"} ŝlosilo${issue.keys.length > 1 ? \"j\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Nevalida ŝlosilo en ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Nevalida enigo\";\n      case \"invalid_element\":\n        return `Nevalida valoro en ${issue.origin}`;\n      default:\n        return `Nevalida enigo`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/eo.ts",
        "startLine": 36,
        "endLine": 38
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/es.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"caracteres\", verb: \"tener\" },\n    file: { unit: \"bytes\", verb: \"tener\" },\n    array: { unit: \"elementos\", verb: \"tener\" },\n    set: { unit: \"elementos\", verb: \"tener\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"número\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"arreglo\";\n        }\n        if (data === null) {\n          return \"nulo\";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"entrada\",\n    email: \"dirección de correo electrónico\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"fecha y hora ISO\",\n    date: \"fecha ISO\",\n    time: \"hora ISO\",\n    duration: \"duración ISO\",\n    ipv4: \"dirección IPv4\",\n    ipv6: \"dirección IPv6\",\n    cidrv4: \"rango IPv4\",\n    cidrv6: \"rango IPv6\",\n    base64: \"cadena codificada en base64\",\n    base64url: \"URL codificada en base64\",\n    json_string: \"cadena JSON\",\n    e164: \"número E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entrada\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Entrada inválida: se esperaba ${issue.expected}, recibido ${parsedType(issue.input)}`;\n      // return `Entrada inválida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Entrada inválida: se esperaba ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Opción inválida: se esperaba una de ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Demasiado grande: se esperaba que ${issue.origin ?? \"valor\"} tuviera ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementos\"}`;\n        return `Demasiado grande: se esperaba que ${issue.origin ?? \"valor\"} fuera ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Demasiado pequeño: se esperaba que ${issue.origin} tuviera ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Demasiado pequeño: se esperaba que ${issue.origin} fuera ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Cadena inválida: debe comenzar con \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Cadena inválida: debe terminar en \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Cadena inválida: debe incluir \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Cadena inválida: debe coincidir con el patrón ${_issue.pattern}`;\n        return `Inválido ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Número inválido: debe ser múltiplo de ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Llave${issue.keys.length > 1 ? \"s\" : \"\"} desconocida${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Llave inválida en ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Entrada inválida\";\n      case \"invalid_element\":\n        return `Valor inválido en ${issue.origin}`;\n      default:\n        return `Entrada inválida`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/es.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/fa.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"کاراکتر\", verb: \"داشته باشد\" },\n    file: { unit: \"بایت\", verb: \"داشته باشد\" },\n    array: { unit: \"آیتم\", verb: \"داشته باشد\" },\n    set: { unit: \"آیتم\", verb: \"داشته باشد\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"عدد\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"آرایه\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"ورودی\",\n    email: \"آدرس ایمیل\",\n    url: \"URL\",\n    emoji: \"ایموجی\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"تاریخ و زمان ایزو\",\n    date: \"تاریخ ایزو\",\n    time: \"زمان ایزو\",\n    duration: \"مدت زمان ایزو\",\n    ipv4: \"IPv4 آدرس\",\n    ipv6: \"IPv6 آدرس\",\n    cidrv4: \"IPv4 دامنه\",\n    cidrv6: \"IPv6 دامنه\",\n    base64: \"base64-encoded رشته\",\n    base64url: \"base64url-encoded رشته\",\n    json_string: \"JSON رشته\",\n    e164: \"E.164 عدد\",\n    jwt: \"JWT\",\n    template_literal: \"ورودی\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `ورودی نامعتبر: می‌بایست ${issue.expected} می‌بود، ${parsedType(issue.input)} دریافت شد`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) {\n          return `ورودی نامعتبر: می‌بایست ${util.stringifyPrimitive(issue.values[0])} می‌بود`;\n        }\n        return `گزینه نامعتبر: می‌بایست یکی از ${util.joinValues(issue.values, \"|\")} می‌بود`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `خیلی بزرگ: ${issue.origin ?? \"مقدار\"} باید ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"عنصر\"} باشد`;\n        }\n        return `خیلی بزرگ: ${issue.origin ?? \"مقدار\"} باید ${adj}${issue.maximum.toString()} باشد`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `خیلی کوچک: ${issue.origin} باید ${adj}${issue.minimum.toString()} ${sizing.unit} باشد`;\n        }\n        return `خیلی کوچک: ${issue.origin} باید ${adj}${issue.minimum.toString()} باشد`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `رشته نامعتبر: باید با \"${_issue.prefix}\" شروع شود`;\n        }\n        if (_issue.format === \"ends_with\") {\n          return `رشته نامعتبر: باید با \"${_issue.suffix}\" تمام شود`;\n        }\n        if (_issue.format === \"includes\") {\n          return `رشته نامعتبر: باید شامل \"${_issue.includes}\" باشد`;\n        }\n        if (_issue.format === \"regex\") {\n          return `رشته نامعتبر: باید با الگوی ${_issue.pattern} مطابقت داشته باشد`;\n        }\n        return `${Nouns[_issue.format] ?? issue.format} نامعتبر`;\n      }\n      case \"not_multiple_of\":\n        return `عدد نامعتبر: باید مضرب ${issue.divisor} باشد`;\n      case \"unrecognized_keys\":\n        return `کلید${issue.keys.length > 1 ? \"های\" : \"\"} ناشناس: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `کلید ناشناس در ${issue.origin}`;\n      case \"invalid_union\":\n        return `ورودی نامعتبر`;\n      case \"invalid_element\":\n        return `مقدار نامعتبر در ${issue.origin}`;\n      default:\n        return `ورودی نامعتبر`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/fa.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/fi.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; subject: string }> = {\n    string: { unit: \"merkkiä\", subject: \"merkkijonon\" },\n    file: { unit: \"tavua\", subject: \"tiedoston\" },\n    array: { unit: \"alkiota\", subject: \"listan\" },\n    set: { unit: \"alkiota\", subject: \"joukon\" },\n    number: { unit: \"\", subject: \"luvun\" },\n    bigint: { unit: \"\", subject: \"suuren kokonaisluvun\" },\n    int: { unit: \"\", subject: \"kokonaisluvun\" },\n    date: { unit: \"\", subject: \"päivämäärän\" },\n  };\n\n  function getSizing(origin: string): { unit: string; subject: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"säännöllinen lauseke\",\n    email: \"sähköpostiosoite\",\n    url: \"URL-osoite\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO-aikaleima\",\n    date: \"ISO-päivämäärä\",\n    time: \"ISO-aika\",\n    duration: \"ISO-kesto\",\n    ipv4: \"IPv4-osoite\",\n    ipv6: \"IPv6-osoite\",\n    cidrv4: \"IPv4-alue\",\n    cidrv6: \"IPv6-alue\",\n    base64: \"base64-koodattu merkkijono\",\n    base64url: \"base64url-koodattu merkkijono\",\n    json_string: \"JSON-merkkijono\",\n    e164: \"E.164-luku\",\n    jwt: \"JWT\",\n    template_literal: \"templaattimerkkijono\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Virheellinen tyyppi: odotettiin ${issue.expected}, oli ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Virheellinen syöte: täytyy olla ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Virheellinen valinta: täytyy olla yksi seuraavista: ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Liian suuri: ${sizing.subject} täytyy olla ${adj}${issue.maximum.toString()} ${sizing.unit}`.trim();\n        }\n        return `Liian suuri: arvon täytyy olla ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Liian pieni: ${sizing.subject} täytyy olla ${adj}${issue.minimum.toString()} ${sizing.unit}`.trim();\n        }\n        return `Liian pieni: arvon täytyy olla ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Virheellinen syöte: täytyy alkaa \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Virheellinen syöte: täytyy loppua \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Virheellinen syöte: täytyy sisältää \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") {\n          return `Virheellinen syöte: täytyy vastata säännöllistä lauseketta ${_issue.pattern}`;\n        }\n        return `Virheellinen ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Virheellinen luku: täytyy olla luvun ${issue.divisor} monikerta`;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"Tuntemattomat avaimet\" : \"Tuntematon avain\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return \"Virheellinen avain tietueessa\";\n      case \"invalid_union\":\n        return \"Virheellinen unioni\";\n      case \"invalid_element\":\n        return \"Virheellinen arvo joukossa\";\n      default:\n        return `Virheellinen syöte`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/fi.ts",
        "startLine": 17,
        "endLine": 19
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/fr-CA.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"caractères\", verb: \"avoir\" },\n    file: { unit: \"octets\", verb: \"avoir\" },\n    array: { unit: \"éléments\", verb: \"avoir\" },\n    set: { unit: \"éléments\", verb: \"avoir\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"entrée\",\n    email: \"adresse courriel\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"date-heure ISO\",\n    date: \"date ISO\",\n    time: \"heure ISO\",\n    duration: \"durée ISO\",\n    ipv4: \"adresse IPv4\",\n    ipv6: \"adresse IPv6\",\n    cidrv4: \"plage IPv4\",\n    cidrv6: \"plage IPv6\",\n    base64: \"chaîne encodée en base64\",\n    base64url: \"chaîne encodée en base64url\",\n    json_string: \"chaîne JSON\",\n    e164: \"numéro E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entrée\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Entrée invalide : attendu ${issue.expected}, reçu ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Entrée invalide : attendu ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Option invalide : attendu l'une des valeurs suivantes ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"≤\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Trop grand : attendu que ${issue.origin ?? \"la valeur\"} ait ${adj}${issue.maximum.toString()} ${sizing.unit}`;\n        return `Trop grand : attendu que ${issue.origin ?? \"la valeur\"} soit ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \"≥\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Trop petit : attendu que ${issue.origin} ait ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Trop petit : attendu que ${issue.origin} soit ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `Chaîne invalide : doit commencer par \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `Chaîne invalide : doit se terminer par \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Chaîne invalide : doit inclure \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Chaîne invalide : doit correspondre au motif ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} invalide`;\n      }\n      case \"not_multiple_of\":\n        return `Nombre invalide : doit être un multiple de ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Clé${issue.keys.length > 1 ? \"s\" : \"\"} non reconnue${issue.keys.length > 1 ? \"s\" : \"\"} : ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Clé invalide dans ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Entrée invalide\";\n      case \"invalid_element\":\n        return `Valeur invalide dans ${issue.origin}`;\n      default:\n        return `Entrée invalide`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/fr-CA.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/fr.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"caractères\", verb: \"avoir\" },\n    file: { unit: \"octets\", verb: \"avoir\" },\n    array: { unit: \"éléments\", verb: \"avoir\" },\n    set: { unit: \"éléments\", verb: \"avoir\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"nombre\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"tableau\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"entrée\",\n    email: \"adresse e-mail\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"date et heure ISO\",\n    date: \"date ISO\",\n    time: \"heure ISO\",\n    duration: \"durée ISO\",\n    ipv4: \"adresse IPv4\",\n    ipv6: \"adresse IPv6\",\n    cidrv4: \"plage IPv4\",\n    cidrv6: \"plage IPv6\",\n    base64: \"chaîne encodée en base64\",\n    base64url: \"chaîne encodée en base64url\",\n    json_string: \"chaîne JSON\",\n    e164: \"numéro E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entrée\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Entrée invalide : ${issue.expected} attendu, ${parsedType(issue.input)} reçu`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Entrée invalide : ${util.stringifyPrimitive(issue.values[0])} attendu`;\n        return `Option invalide : une valeur parmi ${util.joinValues(issue.values, \"|\")} attendue`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Trop grand : ${issue.origin ?? \"valeur\"} doit ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"élément(s)\"}`;\n        return `Trop grand : ${issue.origin ?? \"valeur\"} doit être ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Trop petit : ${issue.origin} doit ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Trop petit : ${issue.origin} doit être ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Chaîne invalide : doit commencer par \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Chaîne invalide : doit se terminer par \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Chaîne invalide : doit inclure \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Chaîne invalide : doit correspondre au modèle ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} invalide`;\n      }\n      case \"not_multiple_of\":\n        return `Nombre invalide : doit être un multiple de ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Clé${issue.keys.length > 1 ? \"s\" : \"\"} non reconnue${issue.keys.length > 1 ? \"s\" : \"\"} : ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Clé invalide dans ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Entrée invalide\";\n      case \"invalid_element\":\n        return `Valeur invalide dans ${issue.origin}`;\n      default:\n        return `Entrée invalide`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/fr.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/he.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"אותיות\", verb: \"לכלול\" },\n    file: { unit: \"בייטים\", verb: \"לכלול\" },\n    array: { unit: \"פריטים\", verb: \"לכלול\" },\n    set: { unit: \"פריטים\", verb: \"לכלול\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"קלט\",\n    email: \"כתובת אימייל\",\n    url: \"כתובת רשת\",\n    emoji: \"אימוג'י\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"תאריך וזמן ISO\",\n    date: \"תאריך ISO\",\n    time: \"זמן ISO\",\n    duration: \"משך זמן ISO\",\n    ipv4: \"כתובת IPv4\",\n    ipv6: \"כתובת IPv6\",\n    cidrv4: \"טווח IPv4\",\n    cidrv6: \"טווח IPv6\",\n    base64: \"מחרוזת בבסיס 64\",\n    base64url: \"מחרוזת בבסיס 64 לכתובות רשת\",\n    json_string: \"מחרוזת JSON\",\n    e164: \"מספר E.164\",\n    jwt: \"JWT\",\n    template_literal: \"קלט\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `קלט לא תקין: צריך ${issue.expected}, התקבל ${parsedType(issue.input)}`;\n      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `קלט לא תקין: צריך ${util.stringifyPrimitive(issue.values[0])}`;\n        return `קלט לא תקין: צריך אחת מהאפשרויות  ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `גדול מדי: ${issue.origin ?? \"value\"} צריך להיות ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elements\"}`;\n        return `גדול מדי: ${issue.origin ?? \"value\"} צריך להיות ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `קטן מדי: ${issue.origin} צריך להיות ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `קטן מדי: ${issue.origin} צריך להיות ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `מחרוזת לא תקינה: חייבת להתחיל ב\"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `מחרוזת לא תקינה: חייבת להסתיים ב \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `מחרוזת לא תקינה: חייבת לכלול \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `מחרוזת לא תקינה: חייבת להתאים לתבנית ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} לא תקין`;\n      }\n      case \"not_multiple_of\":\n        return `מספר לא תקין: חייב להיות מכפלה של ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `מפתח${issue.keys.length > 1 ? \"ות\" : \"\"} לא מזוה${issue.keys.length > 1 ? \"ים\" : \"ה\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `מפתח לא תקין ב${issue.origin}`;\n      case \"invalid_union\":\n        return \"קלט לא תקין\";\n      case \"invalid_element\":\n        return `ערך לא תקין ב${issue.origin}`;\n      default:\n        return `קלט לא תקין`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/he.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/hu.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"karakter\", verb: \"legyen\" },\n    file: { unit: \"byte\", verb: \"legyen\" },\n    array: { unit: \"elem\", verb: \"legyen\" },\n    set: { unit: \"elem\", verb: \"legyen\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"szám\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"tömb\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"bemenet\",\n    email: \"email cím\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO időbélyeg\",\n    date: \"ISO dátum\",\n    time: \"ISO idő\",\n    duration: \"ISO időintervallum\",\n    ipv4: \"IPv4 cím\",\n    ipv6: \"IPv6 cím\",\n    cidrv4: \"IPv4 tartomány\",\n    cidrv6: \"IPv6 tartomány\",\n    base64: \"base64-kódolt string\",\n    base64url: \"base64url-kódolt string\",\n    json_string: \"JSON string\",\n    e164: \"E.164 szám\",\n    jwt: \"JWT\",\n    template_literal: \"bemenet\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Érvénytelen bemenet: a várt érték ${issue.expected}, a kapott érték ${parsedType(issue.input)}`;\n      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Érvénytelen bemenet: a várt érték ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Érvénytelen opció: valamelyik érték várt ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Túl nagy: ${issue.origin ?? \"érték\"} mérete túl nagy ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elem\"}`;\n        return `Túl nagy: a bemeneti érték ${issue.origin ?? \"érték\"} túl nagy: ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Túl kicsi: a bemeneti érték ${issue.origin} mérete túl kicsi ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Túl kicsi: a bemeneti érték ${issue.origin} túl kicsi ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Érvénytelen string: \"${_issue.prefix}\" értékkel kell kezdődnie`;\n        if (_issue.format === \"ends_with\") return `Érvénytelen string: \"${_issue.suffix}\" értékkel kell végződnie`;\n        if (_issue.format === \"includes\") return `Érvénytelen string: \"${_issue.includes}\" értéket kell tartalmaznia`;\n        if (_issue.format === \"regex\") return `Érvénytelen string: ${_issue.pattern} mintának kell megfelelnie`;\n        return `Érvénytelen ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Érvénytelen szám: ${issue.divisor} többszörösének kell lennie`;\n      case \"unrecognized_keys\":\n        return `Ismeretlen kulcs${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Érvénytelen kulcs ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Érvénytelen bemenet\";\n      case \"invalid_element\":\n        return `Érvénytelen érték: ${issue.origin}`;\n      default:\n        return `Érvénytelen bemenet`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/hu.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/id.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"karakter\", verb: \"memiliki\" },\n    file: { unit: \"byte\", verb: \"memiliki\" },\n    array: { unit: \"item\", verb: \"memiliki\" },\n    set: { unit: \"item\", verb: \"memiliki\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"alamat email\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"tanggal dan waktu format ISO\",\n    date: \"tanggal format ISO\",\n    time: \"jam format ISO\",\n    duration: \"durasi format ISO\",\n    ipv4: \"alamat IPv4\",\n    ipv6: \"alamat IPv6\",\n    cidrv4: \"rentang alamat IPv4\",\n    cidrv6: \"rentang alamat IPv6\",\n    base64: \"string dengan enkode base64\",\n    base64url: \"string dengan enkode base64url\",\n    json_string: \"string JSON\",\n    e164: \"angka E.164\",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Input tidak valid: diharapkan ${issue.expected}, diterima ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Input tidak valid: diharapkan ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Pilihan tidak valid: diharapkan salah satu dari ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Terlalu besar: diharapkan ${issue.origin ?? \"value\"} memiliki ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elemen\"}`;\n        return `Terlalu besar: diharapkan ${issue.origin ?? \"value\"} menjadi ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Terlalu kecil: diharapkan ${issue.origin} memiliki ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Terlalu kecil: diharapkan ${issue.origin} menjadi ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `String tidak valid: harus dimulai dengan \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `String tidak valid: harus berakhir dengan \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `String tidak valid: harus menyertakan \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `String tidak valid: harus sesuai pola ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} tidak valid`;\n      }\n      case \"not_multiple_of\":\n        return `Angka tidak valid: harus kelipatan dari ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Kunci tidak dikenali ${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Kunci tidak valid di ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Input tidak valid\";\n      case \"invalid_element\":\n        return `Nilai tidak valid di ${issue.origin}`;\n      default:\n        return `Input tidak valid`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/id.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/index.ts",
    "content": "export { default as ar } from \"./ar.js\";\nexport { default as az } from \"./az.js\";\nexport { default as be } from \"./be.js\";\nexport { default as ca } from \"./ca.js\";\nexport { default as cs } from \"./cs.js\";\nexport { default as de } from \"./de.js\";\nexport { default as en } from \"./en.js\";\nexport { default as eo } from \"./eo.js\";\nexport { default as es } from \"./es.js\";\nexport { default as fa } from \"./fa.js\";\nexport { default as fi } from \"./fi.js\";\nexport { default as fr } from \"./fr.js\";\nexport { default as frCA } from \"./fr-CA.js\";\nexport { default as he } from \"./he.js\";\nexport { default as hu } from \"./hu.js\";\nexport { default as id } from \"./id.js\";\nexport { default as it } from \"./it.js\";\nexport { default as ja } from \"./ja.js\";\nexport { default as kh } from \"./kh.js\";\nexport { default as ko } from \"./ko.js\";\nexport { default as mk } from \"./mk.js\";\nexport { default as ms } from \"./ms.js\";\nexport { default as nl } from \"./nl.js\";\nexport { default as no } from \"./no.js\";\nexport { default as ota } from \"./ota.js\";\nexport { default as ps } from \"./ps.js\";\nexport { default as pl } from \"./pl.js\";\nexport { default as pt } from \"./pt.js\";\nexport { default as ru } from \"./ru.js\";\nexport { default as sl } from \"./sl.js\";\nexport { default as sv } from \"./sv.js\";\nexport { default as ta } from \"./ta.js\";\nexport { default as th } from \"./th.js\";\nexport { default as tr } from \"./tr.js\";\nexport { default as ua } from \"./ua.js\";\nexport { default as ur } from \"./ur.js\";\nexport { default as vi } from \"./vi.js\";\nexport { default as zhCN } from \"./zh-CN.js\";\nexport { default as zhTW } from \"./zh-TW.js\";\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/it.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"caratteri\", verb: \"avere\" },\n    file: { unit: \"byte\", verb: \"avere\" },\n    array: { unit: \"elementi\", verb: \"avere\" },\n    set: { unit: \"elementi\", verb: \"avere\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"numero\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"vettore\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"indirizzo email\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data e ora ISO\",\n    date: \"data ISO\",\n    time: \"ora ISO\",\n    duration: \"durata ISO\",\n    ipv4: \"indirizzo IPv4\",\n    ipv6: \"indirizzo IPv6\",\n    cidrv4: \"intervallo IPv4\",\n    cidrv6: \"intervallo IPv6\",\n    base64: \"stringa codificata in base64\",\n    base64url: \"URL codificata in base64\",\n    json_string: \"stringa JSON\",\n    e164: \"numero E.164\",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Input non valido: atteso ${issue.expected}, ricevuto ${parsedType(issue.input)}`;\n      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Input non valido: atteso ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Opzione non valida: atteso uno tra ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Troppo grande: ${issue.origin ?? \"valore\"} deve avere ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementi\"}`;\n        return `Troppo grande: ${issue.origin ?? \"valore\"} deve essere ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Troppo piccolo: ${issue.origin} deve avere ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Troppo piccolo: ${issue.origin} deve essere ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Stringa non valida: deve iniziare con \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Stringa non valida: deve terminare con \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Stringa non valida: deve includere \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;\n        return `Invalid ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Numero non valido: deve essere un multiplo di ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Chiav${issue.keys.length > 1 ? \"i\" : \"e\"} non riconosciut${issue.keys.length > 1 ? \"e\" : \"a\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Chiave non valida in ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Input non valido\";\n      case \"invalid_element\":\n        return `Valore non valido in ${issue.origin}`;\n      default:\n        return `Input non valido`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/it.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/ja.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"文字\", verb: \"である\" },\n    file: { unit: \"バイト\", verb: \"である\" },\n    array: { unit: \"要素\", verb: \"である\" },\n    set: { unit: \"要素\", verb: \"である\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"数値\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"配列\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"入力値\",\n    email: \"メールアドレス\",\n    url: \"URL\",\n    emoji: \"絵文字\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO日時\",\n    date: \"ISO日付\",\n    time: \"ISO時刻\",\n    duration: \"ISO期間\",\n    ipv4: \"IPv4アドレス\",\n    ipv6: \"IPv6アドレス\",\n    cidrv4: \"IPv4範囲\",\n    cidrv6: \"IPv6範囲\",\n    base64: \"base64エンコード文字列\",\n    base64url: \"base64urlエンコード文字列\",\n    json_string: \"JSON文字列\",\n    e164: \"E.164番号\",\n    jwt: \"JWT\",\n    template_literal: \"入力値\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `無効な入力: ${issue.expected}が期待されましたが、${parsedType(issue.input)}が入力されました`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `無効な入力: ${util.stringifyPrimitive(issue.values[0])}が期待されました`;\n        return `無効な選択: ${util.joinValues(issue.values, \"、\")}のいずれかである必要があります`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"以下である\" : \"より小さい\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `大きすぎる値: ${issue.origin ?? \"値\"}は${issue.maximum.toString()}${sizing.unit ?? \"要素\"}${adj}必要があります`;\n        return `大きすぎる値: ${issue.origin ?? \"値\"}は${issue.maximum.toString()}${adj}必要があります`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \"以上である\" : \"より大きい\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `小さすぎる値: ${issue.origin}は${issue.minimum.toString()}${sizing.unit}${adj}必要があります`;\n        return `小さすぎる値: ${issue.origin}は${issue.minimum.toString()}${adj}必要があります`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `無効な文字列: \"${_issue.prefix}\"で始まる必要があります`;\n        if (_issue.format === \"ends_with\") return `無効な文字列: \"${_issue.suffix}\"で終わる必要があります`;\n        if (_issue.format === \"includes\") return `無効な文字列: \"${_issue.includes}\"を含む必要があります`;\n        if (_issue.format === \"regex\") return `無効な文字列: パターン${_issue.pattern}に一致する必要があります`;\n        return `無効な${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `無効な数値: ${issue.divisor}の倍数である必要があります`;\n      case \"unrecognized_keys\":\n        return `認識されていないキー${issue.keys.length > 1 ? \"群\" : \"\"}: ${util.joinValues(issue.keys, \"、\")}`;\n      case \"invalid_key\":\n        return `${issue.origin}内の無効なキー`;\n      case \"invalid_union\":\n        return \"無効な入力\";\n      case \"invalid_element\":\n        return `${issue.origin}内の無効な値`;\n      default:\n        return `無効な入力`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ja.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/kh.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"តួអក្សរ\", verb: \"គួរមាន\" },\n    file: { unit: \"បៃ\", verb: \"គួរមាន\" },\n    array: { unit: \"ធាតុ\", verb: \"គួរមាន\" },\n    set: { unit: \"ធាតុ\", verb: \"គួរមាន\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"មិនមែនជាលេខ (NaN)\" : \"លេខ\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"អារេ (Array)\";\n        }\n        if (data === null) {\n          return \"គ្មានតម្លៃ (null)\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"ទិន្នន័យបញ្ចូល\",\n    email: \"អាសយដ្ឋានអ៊ីមែល\",\n    url: \"URL\",\n    emoji: \"សញ្ញាអារម្មណ៍\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"កាលបរិច្ឆេទ និងម៉ោង ISO\",\n    date: \"កាលបរិច្ឆេទ ISO\",\n    time: \"ម៉ោង ISO\",\n    duration: \"រយៈពេល ISO\",\n    ipv4: \"អាសយដ្ឋាន IPv4\",\n    ipv6: \"អាសយដ្ឋាន IPv6\",\n    cidrv4: \"ដែនអាសយដ្ឋាន IPv4\",\n    cidrv6: \"ដែនអាសយដ្ឋាន IPv6\",\n    base64: \"ខ្សែអក្សរអ៊ិកូដ base64\",\n    base64url: \"ខ្សែអក្សរអ៊ិកូដ base64url\",\n    json_string: \"ខ្សែអក្សរ JSON\",\n    e164: \"លេខ E.164\",\n    jwt: \"JWT\",\n    template_literal: \"ទិន្នន័យបញ្ចូល\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${issue.expected} ប៉ុន្តែទទួលបាន ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${util.stringifyPrimitive(issue.values[0])}`;\n        return `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `ធំពេក៖ ត្រូវការ ${issue.origin ?? \"តម្លៃ\"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"ធាតុ\"}`;\n        return `ធំពេក៖ ត្រូវការ ${issue.origin ?? \"តម្លៃ\"} ${adj} ${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `តូចពេក៖ ត្រូវការ ${issue.origin} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `តូចពេក៖ ត្រូវការ ${issue.origin} ${adj} ${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${_issue.pattern}`;\n        return `មិនត្រឹមត្រូវ៖ ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `រកឃើញសោមិនស្គាល់៖ ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `សោមិនត្រឹមត្រូវនៅក្នុង ${issue.origin}`;\n      case \"invalid_union\":\n        return `ទិន្នន័យមិនត្រឹមត្រូវ`;\n      case \"invalid_element\":\n        return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${issue.origin}`;\n      default:\n        return `ទិន្នន័យមិនត្រឹមត្រូវ`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/kh.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/ko.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"문자\", verb: \"to have\" },\n    file: { unit: \"바이트\", verb: \"to have\" },\n    array: { unit: \"개\", verb: \"to have\" },\n    set: { unit: \"개\", verb: \"to have\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"입력\",\n    email: \"이메일 주소\",\n    url: \"URL\",\n    emoji: \"이모지\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO 날짜시간\",\n    date: \"ISO 날짜\",\n    time: \"ISO 시간\",\n    duration: \"ISO 기간\",\n    ipv4: \"IPv4 주소\",\n    ipv6: \"IPv6 주소\",\n    cidrv4: \"IPv4 범위\",\n    cidrv6: \"IPv6 범위\",\n    base64: \"base64 인코딩 문자열\",\n    base64url: \"base64url 인코딩 문자열\",\n    json_string: \"JSON 문자열\",\n    e164: \"E.164 번호\",\n    jwt: \"JWT\",\n    template_literal: \"입력\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `잘못된 입력: 예상 타입은 ${issue.expected}, 받은 타입은 ${parsedType(issue.input)}입니다`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `잘못된 입력: 값은 ${util.stringifyPrimitive(issue.values[0])} 이어야 합니다`;\n        return `잘못된 옵션: ${util.joinValues(issue.values, \"또는 \")} 중 하나여야 합니다`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"이하\" : \"미만\";\n        const suffix = adj === \"미만\" ? \"이어야 합니다\" : \"여야 합니다\";\n        const sizing = getSizing(issue.origin);\n        const unit = sizing?.unit ?? \"요소\";\n        if (sizing) return `${issue.origin ?? \"값\"}이 너무 큽니다: ${issue.maximum.toString()}${unit} ${adj}${suffix}`;\n\n        return `${issue.origin ?? \"값\"}이 너무 큽니다: ${issue.maximum.toString()} ${adj}${suffix}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \"이상\" : \"초과\";\n        const suffix = adj === \"이상\" ? \"이어야 합니다\" : \"여야 합니다\";\n        const sizing = getSizing(issue.origin);\n        const unit = sizing?.unit ?? \"요소\";\n        if (sizing) {\n          return `${issue.origin ?? \"값\"}이 너무 작습니다: ${issue.minimum.toString()}${unit} ${adj}${suffix}`;\n        }\n\n        return `${issue.origin ?? \"값\"}이 너무 작습니다: ${issue.minimum.toString()} ${adj}${suffix}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `잘못된 문자열: \"${_issue.prefix}\"(으)로 시작해야 합니다`;\n        }\n        if (_issue.format === \"ends_with\") return `잘못된 문자열: \"${_issue.suffix}\"(으)로 끝나야 합니다`;\n        if (_issue.format === \"includes\") return `잘못된 문자열: \"${_issue.includes}\"을(를) 포함해야 합니다`;\n        if (_issue.format === \"regex\") return `잘못된 문자열: 정규식 ${_issue.pattern} 패턴과 일치해야 합니다`;\n        return `잘못된 ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `잘못된 숫자: ${issue.divisor}의 배수여야 합니다`;\n      case \"unrecognized_keys\":\n        return `인식할 수 없는 키: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `잘못된 키: ${issue.origin}`;\n      case \"invalid_union\":\n        return `잘못된 입력`;\n      case \"invalid_element\":\n        return `잘못된 값: ${issue.origin}`;\n      default:\n        return `잘못된 입력`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ko.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/mk.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"знаци\", verb: \"да имаат\" },\n    file: { unit: \"бајти\", verb: \"да имаат\" },\n    array: { unit: \"ставки\", verb: \"да имаат\" },\n    set: { unit: \"ставки\", verb: \"да имаат\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"број\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"низа\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"внес\",\n    email: \"адреса на е-пошта\",\n    url: \"URL\",\n    emoji: \"емоџи\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO датум и време\",\n    date: \"ISO датум\",\n    time: \"ISO време\",\n    duration: \"ISO времетраење\",\n    ipv4: \"IPv4 адреса\",\n    ipv6: \"IPv6 адреса\",\n    cidrv4: \"IPv4 опсег\",\n    cidrv6: \"IPv6 опсег\",\n    base64: \"base64-енкодирана низа\",\n    base64url: \"base64url-енкодирана низа\",\n    json_string: \"JSON низа\",\n    e164: \"E.164 број\",\n    jwt: \"JWT\",\n    template_literal: \"внес\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Грешен внес: се очекува ${issue.expected}, примено ${parsedType(issue.input)}`;\n      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Invalid input: expected ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Грешана опција: се очекува една ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Премногу голем: се очекува ${issue.origin ?? \"вредноста\"} да има ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"елементи\"}`;\n        return `Премногу голем: се очекува ${issue.origin ?? \"вредноста\"} да биде ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Премногу мал: се очекува ${issue.origin} да има ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Премногу мал: се очекува ${issue.origin} да биде ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `Неважечка низа: мора да започнува со \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `Неважечка низа: мора да завршува со \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Неважечка низа: мора да вклучува \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Неважечка низа: мора да одгоара на патернот ${_issue.pattern}`;\n        return `Invalid ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Грешен број: мора да биде делив со ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"Непрепознаени клучеви\" : \"Непрепознаен клуч\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Грешен клуч во ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Грешен внес\";\n      case \"invalid_element\":\n        return `Грешна вредност во ${issue.origin}`;\n      default:\n        return `Грешен внес`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/mk.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/ms.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"aksara\", verb: \"mempunyai\" },\n    file: { unit: \"bait\", verb: \"mempunyai\" },\n    array: { unit: \"elemen\", verb: \"mempunyai\" },\n    set: { unit: \"elemen\", verb: \"mempunyai\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"nombor\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"alamat e-mel\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"tarikh masa ISO\",\n    date: \"tarikh ISO\",\n    time: \"masa ISO\",\n    duration: \"tempoh ISO\",\n    ipv4: \"alamat IPv4\",\n    ipv6: \"alamat IPv6\",\n    cidrv4: \"julat IPv4\",\n    cidrv6: \"julat IPv6\",\n    base64: \"string dikodkan base64\",\n    base64url: \"string dikodkan base64url\",\n    json_string: \"string JSON\",\n    e164: \"nombor E.164\",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Input tidak sah: dijangka ${issue.expected}, diterima ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Input tidak sah: dijangka ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Pilihan tidak sah: dijangka salah satu daripada ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Terlalu besar: dijangka ${issue.origin ?? \"nilai\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elemen\"}`;\n        return `Terlalu besar: dijangka ${issue.origin ?? \"nilai\"} adalah ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Terlalu kecil: dijangka ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Terlalu kecil: dijangka ${issue.origin} adalah ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `String tidak sah: mesti bermula dengan \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `String tidak sah: mesti berakhir dengan \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `String tidak sah: mesti mengandungi \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} tidak sah`;\n      }\n      case \"not_multiple_of\":\n        return `Nombor tidak sah: perlu gandaan ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Kunci tidak dikenali: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Kunci tidak sah dalam ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Input tidak sah\";\n      case \"invalid_element\":\n        return `Nilai tidak sah dalam ${issue.origin}`;\n      default:\n        return `Input tidak sah`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ms.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/nl.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string }> = {\n    string: { unit: \"tekens\" },\n    file: { unit: \"bytes\" },\n    array: { unit: \"elementen\" },\n    set: { unit: \"elementen\" },\n  };\n\n  function getSizing(origin: string): { unit: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"getal\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"invoer\",\n    email: \"emailadres\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datum en tijd\",\n    date: \"ISO datum\",\n    time: \"ISO tijd\",\n    duration: \"ISO duur\",\n    ipv4: \"IPv4-adres\",\n    ipv6: \"IPv6-adres\",\n    cidrv4: \"IPv4-bereik\",\n    cidrv6: \"IPv6-bereik\",\n    base64: \"base64-gecodeerde tekst\",\n    base64url: \"base64 URL-gecodeerde tekst\",\n    json_string: \"JSON string\",\n    e164: \"E.164-nummer\",\n    jwt: \"JWT\",\n    template_literal: \"invoer\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Ongeldige invoer: verwacht ${issue.expected}, ontving ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Ongeldige invoer: verwacht ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Ongeldige optie: verwacht één van ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Te lang: verwacht dat ${issue.origin ?? \"waarde\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementen\"} bevat`;\n        return `Te lang: verwacht dat ${issue.origin ?? \"waarde\"} ${adj}${issue.maximum.toString()} is`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Te kort: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} bevat`;\n        }\n\n        return `Te kort: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} is`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `Ongeldige tekst: moet met \"${_issue.prefix}\" beginnen`;\n        }\n        if (_issue.format === \"ends_with\") return `Ongeldige tekst: moet op \"${_issue.suffix}\" eindigen`;\n        if (_issue.format === \"includes\") return `Ongeldige tekst: moet \"${_issue.includes}\" bevatten`;\n        if (_issue.format === \"regex\") return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;\n        return `Ongeldig: ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Ongeldig getal: moet een veelvoud van ${issue.divisor} zijn`;\n      case \"unrecognized_keys\":\n        return `Onbekende key${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Ongeldige key in ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Ongeldige invoer\";\n      case \"invalid_element\":\n        return `Ongeldige waarde in ${issue.origin}`;\n      default:\n        return `Ongeldige invoer`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/nl.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/no.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"tegn\", verb: \"å ha\" },\n    file: { unit: \"bytes\", verb: \"å ha\" },\n    array: { unit: \"elementer\", verb: \"å inneholde\" },\n    set: { unit: \"elementer\", verb: \"å inneholde\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"tall\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"liste\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"input\",\n    email: \"e-postadresse\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO dato- og klokkeslett\",\n    date: \"ISO-dato\",\n    time: \"ISO-klokkeslett\",\n    duration: \"ISO-varighet\",\n    ipv4: \"IPv4-område\",\n    ipv6: \"IPv6-område\",\n    cidrv4: \"IPv4-spekter\",\n    cidrv6: \"IPv6-spekter\",\n    base64: \"base64-enkodet streng\",\n    base64url: \"base64url-enkodet streng\",\n    json_string: \"JSON-streng\",\n    e164: \"E.164-nummer\",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Ugyldig input: forventet ${issue.expected}, fikk ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Ugyldig verdi: forventet ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Ugyldig valg: forventet en av ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `For stor(t): forventet ${issue.origin ?? \"value\"} til å ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementer\"}`;\n        return `For stor(t): forventet ${issue.origin ?? \"value\"} til å ha ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `For lite(n): forventet ${issue.origin} til å ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `For lite(n): forventet ${issue.origin} til å ha ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Ugyldig streng: må starte med \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Ugyldig streng: må ende med \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Ugyldig streng: må inneholde \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Ugyldig streng: må matche mønsteret ${_issue.pattern}`;\n        return `Ugyldig ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Ugyldig tall: må være et multiplum av ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"Ukjente nøkler\" : \"Ukjent nøkkel\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Ugyldig nøkkel i ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Ugyldig input\";\n      case \"invalid_element\":\n        return `Ugyldig verdi i ${issue.origin}`;\n      default:\n        return `Ugyldig input`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/no.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/ota.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"harf\", verb: \"olmalıdır\" },\n    file: { unit: \"bayt\", verb: \"olmalıdır\" },\n    array: { unit: \"unsur\", verb: \"olmalıdır\" },\n    set: { unit: \"unsur\", verb: \"olmalıdır\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"numara\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"saf\";\n        }\n        if (data === null) {\n          return \"gayb\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"giren\",\n    email: \"epostagâh\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO hengâmı\",\n    date: \"ISO tarihi\",\n    time: \"ISO zamanı\",\n    duration: \"ISO müddeti\",\n    ipv4: \"IPv4 nişânı\",\n    ipv6: \"IPv6 nişânı\",\n    cidrv4: \"IPv4 menzili\",\n    cidrv6: \"IPv6 menzili\",\n    base64: \"base64-şifreli metin\",\n    base64url: \"base64url-şifreli metin\",\n    json_string: \"JSON metin\",\n    e164: \"E.164 sayısı\",\n    jwt: \"JWT\",\n    template_literal: \"giren\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Fâsit giren: umulan ${issue.expected}, alınan ${parsedType(issue.input)}`;\n      // return `Fâsit giren: umulan ${issue.expected}, alınan ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Fâsit giren: umulan ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Fâsit tercih: mûteberler ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Fazla büyük: ${issue.origin ?? \"value\"}, ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elements\"} sahip olmalıydı.`;\n        return `Fazla büyük: ${issue.origin ?? \"value\"}, ${adj}${issue.maximum.toString()} olmalıydı.`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Fazla küçük: ${issue.origin}, ${adj}${issue.minimum.toString()} ${sizing.unit} sahip olmalıydı.`;\n        }\n\n        return `Fazla küçük: ${issue.origin}, ${adj}${issue.minimum.toString()} olmalıydı.`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Fâsit metin: \"${_issue.prefix}\" ile başlamalı.`;\n        if (_issue.format === \"ends_with\") return `Fâsit metin: \"${_issue.suffix}\" ile bitmeli.`;\n        if (_issue.format === \"includes\") return `Fâsit metin: \"${_issue.includes}\" ihtivâ etmeli.`;\n        if (_issue.format === \"regex\") return `Fâsit metin: ${_issue.pattern} nakşına uymalı.`;\n        return `Fâsit ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Fâsit sayı: ${issue.divisor} katı olmalıydı.`;\n      case \"unrecognized_keys\":\n        return `Tanınmayan anahtar ${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue.origin} için tanınmayan anahtar var.`;\n      case \"invalid_union\":\n        return \"Giren tanınamadı.\";\n      case \"invalid_element\":\n        return `${issue.origin} için tanınmayan kıymet var.`;\n      default:\n        return `Kıymet tanınamadı.`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ota.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/pl.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"znaków\", verb: \"mieć\" },\n    file: { unit: \"bajtów\", verb: \"mieć\" },\n    array: { unit: \"elementów\", verb: \"mieć\" },\n    set: { unit: \"elementów\", verb: \"mieć\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"liczba\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"tablica\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"wyrażenie\",\n    email: \"adres email\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data i godzina w formacie ISO\",\n    date: \"data w formacie ISO\",\n    time: \"godzina w formacie ISO\",\n    duration: \"czas trwania ISO\",\n    ipv4: \"adres IPv4\",\n    ipv6: \"adres IPv6\",\n    cidrv4: \"zakres IPv4\",\n    cidrv6: \"zakres IPv6\",\n    base64: \"ciąg znaków zakodowany w formacie base64\",\n    base64url: \"ciąg znaków zakodowany w formacie base64url\",\n    json_string: \"ciąg znaków w formacie JSON\",\n    e164: \"liczba E.164\",\n    jwt: \"JWT\",\n    template_literal: \"wejście\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Nieprawidłowe dane wejściowe: oczekiwano ${issue.expected}, otrzymano ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Nieprawidłowe dane wejściowe: oczekiwano ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Nieprawidłowa opcja: oczekiwano jednej z wartości ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Za duża wartość: oczekiwano, że ${issue.origin ?? \"wartość\"} będzie mieć ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementów\"}`;\n        }\n        return `Zbyt duż(y/a/e): oczekiwano, że ${issue.origin ?? \"wartość\"} będzie wynosić ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Za mała wartość: oczekiwano, że ${issue.origin ?? \"wartość\"} będzie mieć ${adj}${issue.minimum.toString()} ${sizing.unit ?? \"elementów\"}`;\n        }\n        return `Zbyt mał(y/a/e): oczekiwano, że ${issue.origin ?? \"wartość\"} będzie wynosić ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\")\n          return `Nieprawidłowy ciąg znaków: musi zaczynać się od \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Nieprawidłowy ciąg znaków: musi kończyć się na \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Nieprawidłowy ciąg znaków: musi zawierać \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Nieprawidłowy ciąg znaków: musi odpowiadać wzorcowi ${_issue.pattern}`;\n        return `Nieprawidłow(y/a/e) ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Nieprawidłowa liczba: musi być wielokrotnością ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Nierozpoznane klucze${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Nieprawidłowy klucz w ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Nieprawidłowe dane wejściowe\";\n      case \"invalid_element\":\n        return `Nieprawidłowa wartość w ${issue.origin}`;\n      default:\n        return `Nieprawidłowe dane wejściowe`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/pl.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/ps.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"توکي\", verb: \"ولري\" },\n    file: { unit: \"بایټس\", verb: \"ولري\" },\n    array: { unit: \"توکي\", verb: \"ولري\" },\n    set: { unit: \"توکي\", verb: \"ولري\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"عدد\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"ارې\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"ورودي\",\n    email: \"بریښنالیک\",\n    url: \"یو آر ال\",\n    emoji: \"ایموجي\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"نیټه او وخت\",\n    date: \"نېټه\",\n    time: \"وخت\",\n    duration: \"موده\",\n    ipv4: \"د IPv4 پته\",\n    ipv6: \"د IPv6 پته\",\n    cidrv4: \"د IPv4 ساحه\",\n    cidrv6: \"د IPv6 ساحه\",\n    base64: \"base64-encoded متن\",\n    base64url: \"base64url-encoded متن\",\n    json_string: \"JSON متن\",\n    e164: \"د E.164 شمېره\",\n    jwt: \"JWT\",\n    template_literal: \"ورودي\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `ناسم ورودي: باید ${issue.expected} وای, مګر ${parsedType(issue.input)} ترلاسه شو`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) {\n          return `ناسم ورودي: باید ${util.stringifyPrimitive(issue.values[0])} وای`;\n        }\n        return `ناسم انتخاب: باید یو له ${util.joinValues(issue.values, \"|\")} څخه وای`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `ډیر لوی: ${issue.origin ?? \"ارزښت\"} باید ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"عنصرونه\"} ولري`;\n        }\n        return `ډیر لوی: ${issue.origin ?? \"ارزښت\"} باید ${adj}${issue.maximum.toString()} وي`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `ډیر کوچنی: ${issue.origin} باید ${adj}${issue.minimum.toString()} ${sizing.unit} ولري`;\n        }\n        return `ډیر کوچنی: ${issue.origin} باید ${adj}${issue.minimum.toString()} وي`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `ناسم متن: باید د \"${_issue.prefix}\" سره پیل شي`;\n        }\n        if (_issue.format === \"ends_with\") {\n          return `ناسم متن: باید د \"${_issue.suffix}\" سره پای ته ورسيږي`;\n        }\n        if (_issue.format === \"includes\") {\n          return `ناسم متن: باید \"${_issue.includes}\" ولري`;\n        }\n        if (_issue.format === \"regex\") {\n          return `ناسم متن: باید د ${_issue.pattern} سره مطابقت ولري`;\n        }\n        return `${Nouns[_issue.format] ?? issue.format} ناسم دی`;\n      }\n      case \"not_multiple_of\":\n        return `ناسم عدد: باید د ${issue.divisor} مضرب وي`;\n      case \"unrecognized_keys\":\n        return `ناسم ${issue.keys.length > 1 ? \"کلیډونه\" : \"کلیډ\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `ناسم کلیډ په ${issue.origin} کې`;\n      case \"invalid_union\":\n        return `ناسمه ورودي`;\n      case \"invalid_element\":\n        return `ناسم عنصر په ${issue.origin} کې`;\n      default:\n        return `ناسمه ورودي`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ps.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/pt.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"caracteres\", verb: \"ter\" },\n    file: { unit: \"bytes\", verb: \"ter\" },\n    array: { unit: \"itens\", verb: \"ter\" },\n    set: { unit: \"itens\", verb: \"ter\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"número\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"nulo\";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"padrão\",\n    email: \"endereço de e-mail\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"data e hora ISO\",\n    date: \"data ISO\",\n    time: \"hora ISO\",\n    duration: \"duração ISO\",\n    ipv4: \"endereço IPv4\",\n    ipv6: \"endereço IPv6\",\n    cidrv4: \"faixa de IPv4\",\n    cidrv6: \"faixa de IPv6\",\n    base64: \"texto codificado em base64\",\n    base64url: \"URL codificada em base64\",\n    json_string: \"texto JSON\",\n    e164: \"número E.164\",\n    jwt: \"JWT\",\n    template_literal: \"entrada\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Tipo inválido: esperado ${issue.expected}, recebido ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Entrada inválida: esperado ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Opção inválida: esperada uma das ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Muito grande: esperado que ${issue.origin ?? \"valor\"} tivesse ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementos\"}`;\n        return `Muito grande: esperado que ${issue.origin ?? \"valor\"} fosse ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Muito pequeno: esperado que ${issue.origin} tivesse ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Muito pequeno: esperado que ${issue.origin} fosse ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Texto inválido: deve começar com \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Texto inválido: deve terminar com \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Texto inválido: deve incluir \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Texto inválido: deve corresponder ao padrão ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} inválido`;\n      }\n      case \"not_multiple_of\":\n        return `Número inválido: deve ser múltiplo de ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Chave${issue.keys.length > 1 ? \"s\" : \"\"} desconhecida${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Chave inválida em ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Entrada inválida\";\n      case \"invalid_element\":\n        return `Valor inválido em ${issue.origin}`;\n      default:\n        return `Campo inválido`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/pt.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/ru.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nfunction getRussianPlural(count: number, one: string, few: string, many: string): string {\n  const absCount = Math.abs(count);\n  const lastDigit = absCount % 10;\n  const lastTwoDigits = absCount % 100;\n\n  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n    return many;\n  }\n\n  if (lastDigit === 1) {\n    return one;\n  }\n\n  if (lastDigit >= 2 && lastDigit <= 4) {\n    return few;\n  }\n\n  return many;\n}\n\ninterface RussianSizable {\n  unit: {\n    one: string;\n    few: string;\n    many: string;\n  };\n  verb: string;\n}\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, RussianSizable> = {\n    string: {\n      unit: {\n        one: \"символ\",\n        few: \"символа\",\n        many: \"символов\",\n      },\n      verb: \"иметь\",\n    },\n    file: {\n      unit: {\n        one: \"байт\",\n        few: \"байта\",\n        many: \"байт\",\n      },\n      verb: \"иметь\",\n    },\n    array: {\n      unit: {\n        one: \"элемент\",\n        few: \"элемента\",\n        many: \"элементов\",\n      },\n      verb: \"иметь\",\n    },\n    set: {\n      unit: {\n        one: \"элемент\",\n        few: \"элемента\",\n        many: \"элементов\",\n      },\n      verb: \"иметь\",\n    },\n  };\n\n  function getSizing(origin: string): RussianSizable | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"число\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"массив\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"ввод\",\n    email: \"email адрес\",\n    url: \"URL\",\n    emoji: \"эмодзи\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO дата и время\",\n    date: \"ISO дата\",\n    time: \"ISO время\",\n    duration: \"ISO длительность\",\n    ipv4: \"IPv4 адрес\",\n    ipv6: \"IPv6 адрес\",\n    cidrv4: \"IPv4 диапазон\",\n    cidrv6: \"IPv6 диапазон\",\n    base64: \"строка в формате base64\",\n    base64url: \"строка в формате base64url\",\n    json_string: \"JSON строка\",\n    e164: \"номер E.164\",\n    jwt: \"JWT\",\n    template_literal: \"ввод\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Неверный ввод: ожидалось ${issue.expected}, получено ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Неверный ввод: ожидалось ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Неверный вариант: ожидалось одно из ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          const maxValue = Number(issue.maximum);\n          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return `Слишком большое значение: ожидалось, что ${issue.origin ?? \"значение\"} будет иметь ${adj}${issue.maximum.toString()} ${unit}`;\n        }\n        return `Слишком большое значение: ожидалось, что ${issue.origin ?? \"значение\"} будет ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          const minValue = Number(issue.minimum);\n          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return `Слишком маленькое значение: ожидалось, что ${issue.origin} будет иметь ${adj}${issue.minimum.toString()} ${unit}`;\n        }\n        return `Слишком маленькое значение: ожидалось, что ${issue.origin} будет ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Неверная строка: должна начинаться с \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Неверная строка: должна заканчиваться на \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Неверная строка: должна содержать \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Неверная строка: должна соответствовать шаблону ${_issue.pattern}`;\n        return `Неверный ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Неверное число: должно быть кратным ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Нераспознанн${issue.keys.length > 1 ? \"ые\" : \"ый\"} ключ${issue.keys.length > 1 ? \"и\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Неверный ключ в ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Неверные входные данные\";\n      case \"invalid_element\":\n        return `Неверное значение в ${issue.origin}`;\n      default:\n        return `Неверные входные данные`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getRussianPlural",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ru.ts",
        "startLine": 5,
        "endLine": 23
      },
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ru.ts",
        "startLine": 69,
        "endLine": 71
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/sl.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"znakov\", verb: \"imeti\" },\n    file: { unit: \"bajtov\", verb: \"imeti\" },\n    array: { unit: \"elementov\", verb: \"imeti\" },\n    set: { unit: \"elementov\", verb: \"imeti\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"število\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"tabela\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"vnos\",\n    email: \"e-poštni naslov\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO datum in čas\",\n    date: \"ISO datum\",\n    time: \"ISO čas\",\n    duration: \"ISO trajanje\",\n    ipv4: \"IPv4 naslov\",\n    ipv6: \"IPv6 naslov\",\n    cidrv4: \"obseg IPv4\",\n    cidrv6: \"obseg IPv6\",\n    base64: \"base64 kodiran niz\",\n    base64url: \"base64url kodiran niz\",\n    json_string: \"JSON niz\",\n    e164: \"E.164 številka\",\n    jwt: \"JWT\",\n    template_literal: \"vnos\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Neveljaven vnos: pričakovano ${issue.expected}, prejeto ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Neveljaven vnos: pričakovano ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Neveljavna možnost: pričakovano eno izmed ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Preveliko: pričakovano, da bo ${issue.origin ?? \"vrednost\"} imelo ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementov\"}`;\n        return `Preveliko: pričakovano, da bo ${issue.origin ?? \"vrednost\"} ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Premajhno: pričakovano, da bo ${issue.origin} imelo ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Premajhno: pričakovano, da bo ${issue.origin} ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `Neveljaven niz: mora se začeti z \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `Neveljaven niz: mora se končati z \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Neveljaven niz: mora vsebovati \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;\n        return `Neveljaven ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Neveljavno število: mora biti večkratnik ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Neprepoznan${issue.keys.length > 1 ? \"i ključi\" : \" ključ\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Neveljaven ključ v ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Neveljaven vnos\";\n      case \"invalid_element\":\n        return `Neveljavna vrednost v ${issue.origin}`;\n      default:\n        return \"Neveljaven vnos\";\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/sl.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/sv.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"tecken\", verb: \"att ha\" },\n    file: { unit: \"bytes\", verb: \"att ha\" },\n    array: { unit: \"objekt\", verb: \"att innehålla\" },\n    set: { unit: \"objekt\", verb: \"att innehålla\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"antal\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"lista\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"reguljärt uttryck\",\n    email: \"e-postadress\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO-datum och tid\",\n    date: \"ISO-datum\",\n    time: \"ISO-tid\",\n    duration: \"ISO-varaktighet\",\n    ipv4: \"IPv4-intervall\",\n    ipv6: \"IPv6-intervall\",\n    cidrv4: \"IPv4-spektrum\",\n    cidrv6: \"IPv6-spektrum\",\n    base64: \"base64-kodad sträng\",\n    base64url: \"base64url-kodad sträng\",\n    json_string: \"JSON-sträng\",\n    e164: \"E.164-nummer\",\n    jwt: \"JWT\",\n    template_literal: \"mall-literal\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Ogiltig inmatning: förväntat ${issue.expected}, fick ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Ogiltig inmatning: förväntat ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Ogiltigt val: förväntade en av ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `För stor(t): förväntade ${issue.origin ?? \"värdet\"} att ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"element\"}`;\n        }\n        return `För stor(t): förväntat ${issue.origin ?? \"värdet\"} att ha ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `För lite(t): förväntade ${issue.origin ?? \"värdet\"} att ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n        return `För lite(t): förväntade ${issue.origin ?? \"värdet\"} att ha ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `Ogiltig sträng: måste börja med \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `Ogiltig sträng: måste sluta med \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Ogiltig sträng: måste innehålla \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Ogiltig sträng: måste matcha mönstret \"${_issue.pattern}\"`;\n        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Ogiltigt tal: måste vara en multipel av ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `${issue.keys.length > 1 ? \"Okända nycklar\" : \"Okänd nyckel\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Ogiltig nyckel i ${issue.origin ?? \"värdet\"}`;\n      case \"invalid_union\":\n        return \"Ogiltig input\";\n      case \"invalid_element\":\n        return `Ogiltigt värde i ${issue.origin ?? \"värdet\"}`;\n      default:\n        return `Ogiltig input`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/sv.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/ta.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"எழுத்துக்கள்\", verb: \"கொண்டிருக்க வேண்டும்\" },\n    file: { unit: \"பைட்டுகள்\", verb: \"கொண்டிருக்க வேண்டும்\" },\n    array: { unit: \"உறுப்புகள்\", verb: \"கொண்டிருக்க வேண்டும்\" },\n    set: { unit: \"உறுப்புகள்\", verb: \"கொண்டிருக்க வேண்டும்\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"எண் அல்லாதது\" : \"எண்\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"அணி\";\n        }\n        if (data === null) {\n          return \"வெறுமை\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"உள்ளீடு\",\n    email: \"மின்னஞ்சல் முகவரி\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO தேதி நேரம்\",\n    date: \"ISO தேதி\",\n    time: \"ISO நேரம்\",\n    duration: \"ISO கால அளவு\",\n    ipv4: \"IPv4 முகவரி\",\n    ipv6: \"IPv6 முகவரி\",\n    cidrv4: \"IPv4 வரம்பு\",\n    cidrv6: \"IPv6 வரம்பு\",\n    base64: \"base64-encoded சரம்\",\n    base64url: \"base64url-encoded சரம்\",\n    json_string: \"JSON சரம்\",\n    e164: \"E.164 எண்\",\n    jwt: \"JWT\",\n    template_literal: \"input\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${issue.expected}, பெறப்பட்டது ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${util.stringifyPrimitive(issue.values[0])}`;\n        return `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${util.joinValues(issue.values, \"|\")} இல் ஒன்று`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue.origin ?? \"மதிப்பு\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"உறுப்புகள்\"} ஆக இருக்க வேண்டும்`;\n        }\n        return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue.origin ?? \"மதிப்பு\"} ${adj}${issue.maximum.toString()} ஆக இருக்க வேண்டும்`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} ஆக இருக்க வேண்டும்`; //\n        }\n\n        return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue.origin} ${adj}${issue.minimum.toString()} ஆக இருக்க வேண்டும்`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `தவறான சரம்: \"${_issue.prefix}\" இல் தொடங்க வேண்டும்`;\n        if (_issue.format === \"ends_with\") return `தவறான சரம்: \"${_issue.suffix}\" இல் முடிவடைய வேண்டும்`;\n        if (_issue.format === \"includes\") return `தவறான சரம்: \"${_issue.includes}\" ஐ உள்ளடக்க வேண்டும்`;\n        if (_issue.format === \"regex\") return `தவறான சரம்: ${_issue.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்`;\n        return `தவறான ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `தவறான எண்: ${issue.divisor} இன் பலமாக இருக்க வேண்டும்`;\n      case \"unrecognized_keys\":\n        return `அடையாளம் தெரியாத விசை${issue.keys.length > 1 ? \"கள்\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue.origin} இல் தவறான விசை`;\n      case \"invalid_union\":\n        return \"தவறான உள்ளீடு\";\n      case \"invalid_element\":\n        return `${issue.origin} இல் தவறான மதிப்பு`;\n      default:\n        return `தவறான உள்ளீடு`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ta.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/th.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"ตัวอักษร\", verb: \"ควรมี\" },\n    file: { unit: \"ไบต์\", verb: \"ควรมี\" },\n    array: { unit: \"รายการ\", verb: \"ควรมี\" },\n    set: { unit: \"รายการ\", verb: \"ควรมี\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"ไม่ใช่ตัวเลข (NaN)\" : \"ตัวเลข\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"อาร์เรย์ (Array)\";\n        }\n        if (data === null) {\n          return \"ไม่มีค่า (null)\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"ข้อมูลที่ป้อน\",\n    email: \"ที่อยู่อีเมล\",\n    url: \"URL\",\n    emoji: \"อิโมจิ\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"วันที่เวลาแบบ ISO\",\n    date: \"วันที่แบบ ISO\",\n    time: \"เวลาแบบ ISO\",\n    duration: \"ช่วงเวลาแบบ ISO\",\n    ipv4: \"ที่อยู่ IPv4\",\n    ipv6: \"ที่อยู่ IPv6\",\n    cidrv4: \"ช่วง IP แบบ IPv4\",\n    cidrv6: \"ช่วง IP แบบ IPv6\",\n    base64: \"ข้อความแบบ Base64\",\n    base64url: \"ข้อความแบบ Base64 สำหรับ URL\",\n    json_string: \"ข้อความแบบ JSON\",\n    e164: \"เบอร์โทรศัพท์ระหว่างประเทศ (E.164)\",\n    jwt: \"โทเคน JWT\",\n    template_literal: \"ข้อมูลที่ป้อน\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${issue.expected} แต่ได้รับ ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `ค่าไม่ถูกต้อง: ควรเป็น ${util.stringifyPrimitive(issue.values[0])}`;\n        return `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"ไม่เกิน\" : \"น้อยกว่า\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `เกินกำหนด: ${issue.origin ?? \"ค่า\"} ควรมี${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"รายการ\"}`;\n        return `เกินกำหนด: ${issue.origin ?? \"ค่า\"} ควรมี${adj} ${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \"อย่างน้อย\" : \"มากกว่า\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `น้อยกว่ากำหนด: ${issue.origin} ควรมี${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `น้อยกว่ากำหนด: ${issue.origin} ควรมี${adj} ${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย \"${_issue.prefix}\"`;\n        }\n        if (_issue.format === \"ends_with\") return `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `รูปแบบไม่ถูกต้อง: ข้อความต้องมี \"${_issue.includes}\" อยู่ในข้อความ`;\n        if (_issue.format === \"regex\") return `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${_issue.pattern}`;\n        return `รูปแบบไม่ถูกต้อง: ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${issue.divisor} ได้ลงตัว`;\n      case \"unrecognized_keys\":\n        return `พบคีย์ที่ไม่รู้จัก: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `คีย์ไม่ถูกต้องใน ${issue.origin}`;\n      case \"invalid_union\":\n        return \"ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้\";\n      case \"invalid_element\":\n        return `ข้อมูลไม่ถูกต้องใน ${issue.origin}`;\n      default:\n        return `ข้อมูลไม่ถูกต้อง`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/th.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/tr.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nexport const parsedType = (data: any): string => {\n  const t = typeof data;\n\n  switch (t) {\n    case \"number\": {\n      return Number.isNaN(data) ? \"NaN\" : \"number\";\n    }\n    case \"object\": {\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      if (data === null) {\n        return \"null\";\n      }\n\n      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n        return data.constructor.name;\n      }\n    }\n  }\n  return t;\n};\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"karakter\", verb: \"olmalı\" },\n    file: { unit: \"bayt\", verb: \"olmalı\" },\n    array: { unit: \"öğe\", verb: \"olmalı\" },\n    set: { unit: \"öğe\", verb: \"olmalı\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"girdi\",\n    email: \"e-posta adresi\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO tarih ve saat\",\n    date: \"ISO tarih\",\n    time: \"ISO saat\",\n    duration: \"ISO süre\",\n    ipv4: \"IPv4 adresi\",\n    ipv6: \"IPv6 adresi\",\n    cidrv4: \"IPv4 aralığı\",\n    cidrv6: \"IPv6 aralığı\",\n    base64: \"base64 ile şifrelenmiş metin\",\n    base64url: \"base64url ile şifrelenmiş metin\",\n    json_string: \"JSON dizesi\",\n    e164: \"E.164 sayısı\",\n    jwt: \"JWT\",\n    template_literal: \"Şablon dizesi\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Geçersiz değer: beklenen ${issue.expected}, alınan ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `Geçersiz değer: beklenen ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Geçersiz seçenek: aşağıdakilerden biri olmalı: ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Çok büyük: beklenen ${issue.origin ?? \"değer\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"öğe\"}`;\n        return `Çok büyük: beklenen ${issue.origin ?? \"değer\"} ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) return `Çok küçük: beklenen ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        return `Çok küçük: beklenen ${issue.origin} ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Geçersiz metin: \"${_issue.prefix}\" ile başlamalı`;\n        if (_issue.format === \"ends_with\") return `Geçersiz metin: \"${_issue.suffix}\" ile bitmeli`;\n        if (_issue.format === \"includes\") return `Geçersiz metin: \"${_issue.includes}\" içermeli`;\n        if (_issue.format === \"regex\") return `Geçersiz metin: ${_issue.pattern} desenine uymalı`;\n        return `Geçersiz ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Geçersiz sayı: ${issue.divisor} ile tam bölünebilmeli`;\n      case \"unrecognized_keys\":\n        return `Tanınmayan anahtar${issue.keys.length > 1 ? \"lar\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue.origin} içinde geçersiz anahtar`;\n      case \"invalid_union\":\n        return \"Geçersiz değer\";\n      case \"invalid_element\":\n        return `${issue.origin} içinde geçersiz değer`;\n      default:\n        return `Geçersiz değer`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/tr.ts",
        "startLine": 36,
        "endLine": 38
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/ua.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"символів\", verb: \"матиме\" },\n    file: { unit: \"байтів\", verb: \"матиме\" },\n    array: { unit: \"елементів\", verb: \"матиме\" },\n    set: { unit: \"елементів\", verb: \"матиме\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"число\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"масив\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"вхідні дані\",\n    email: \"адреса електронної пошти\",\n    url: \"URL\",\n    emoji: \"емодзі\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"дата та час ISO\",\n    date: \"дата ISO\",\n    time: \"час ISO\",\n    duration: \"тривалість ISO\",\n    ipv4: \"адреса IPv4\",\n    ipv6: \"адреса IPv6\",\n    cidrv4: \"діапазон IPv4\",\n    cidrv6: \"діапазон IPv6\",\n    base64: \"рядок у кодуванні base64\",\n    base64url: \"рядок у кодуванні base64url\",\n    json_string: \"рядок JSON\",\n    e164: \"номер E.164\",\n    jwt: \"JWT\",\n    template_literal: \"вхідні дані\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Неправильні вхідні дані: очікується ${issue.expected}, отримано ${parsedType(issue.input)}`;\n      // return `Неправильні вхідні дані: очікується ${issue.expected}, отримано ${util.getParsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Неправильні вхідні дані: очікується ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Неправильна опція: очікується одне з ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Занадто велике: очікується, що ${issue.origin ?? \"значення\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"елементів\"}`;\n        return `Занадто велике: очікується, що ${issue.origin ?? \"значення\"} буде ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Занадто мале: очікується, що ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Занадто мале: очікується, що ${issue.origin} буде ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Неправильний рядок: повинен починатися з \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Неправильний рядок: повинен закінчуватися на \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Неправильний рядок: повинен містити \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Неправильний рядок: повинен відповідати шаблону ${_issue.pattern}`;\n        return `Неправильний ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `Неправильне число: повинно бути кратним ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Нерозпізнаний ключ${issue.keys.length > 1 ? \"і\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Неправильний ключ у ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Неправильні вхідні дані\";\n      case \"invalid_element\":\n        return `Неправильне значення у ${issue.origin}`;\n      default:\n        return `Неправильні вхідні дані`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ua.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/ur.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"حروف\", verb: \"ہونا\" },\n    file: { unit: \"بائٹس\", verb: \"ہونا\" },\n    array: { unit: \"آئٹمز\", verb: \"ہونا\" },\n    set: { unit: \"آئٹمز\", verb: \"ہونا\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"نمبر\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"آرے\";\n        }\n        if (data === null) {\n          return \"نل\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"ان پٹ\",\n    email: \"ای میل ایڈریس\",\n    url: \"یو آر ایل\",\n    emoji: \"ایموجی\",\n    uuid: \"یو یو آئی ڈی\",\n    uuidv4: \"یو یو آئی ڈی وی 4\",\n    uuidv6: \"یو یو آئی ڈی وی 6\",\n    nanoid: \"نینو آئی ڈی\",\n    guid: \"جی یو آئی ڈی\",\n    cuid: \"سی یو آئی ڈی\",\n    cuid2: \"سی یو آئی ڈی 2\",\n    ulid: \"یو ایل آئی ڈی\",\n    xid: \"ایکس آئی ڈی\",\n    ksuid: \"کے ایس یو آئی ڈی\",\n    datetime: \"آئی ایس او ڈیٹ ٹائم\",\n    date: \"آئی ایس او تاریخ\",\n    time: \"آئی ایس او وقت\",\n    duration: \"آئی ایس او مدت\",\n    ipv4: \"آئی پی وی 4 ایڈریس\",\n    ipv6: \"آئی پی وی 6 ایڈریس\",\n    cidrv4: \"آئی پی وی 4 رینج\",\n    cidrv6: \"آئی پی وی 6 رینج\",\n    base64: \"بیس 64 ان کوڈڈ سٹرنگ\",\n    base64url: \"بیس 64 یو آر ایل ان کوڈڈ سٹرنگ\",\n    json_string: \"جے ایس او این سٹرنگ\",\n    e164: \"ای 164 نمبر\",\n    jwt: \"جے ڈبلیو ٹی\",\n    template_literal: \"ان پٹ\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `غلط ان پٹ: ${issue.expected} متوقع تھا، ${parsedType(issue.input)} موصول ہوا`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `غلط ان پٹ: ${util.stringifyPrimitive(issue.values[0])} متوقع تھا`;\n        return `غلط آپشن: ${util.joinValues(issue.values, \"|\")} میں سے ایک متوقع تھا`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `بہت بڑا: ${issue.origin ?? \"ویلیو\"} کے ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"عناصر\"} ہونے متوقع تھے`;\n        return `بہت بڑا: ${issue.origin ?? \"ویلیو\"} کا ${adj}${issue.maximum.toString()} ہونا متوقع تھا`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `بہت چھوٹا: ${issue.origin} کے ${adj}${issue.minimum.toString()} ${sizing.unit} ہونے متوقع تھے`;\n        }\n\n        return `بہت چھوٹا: ${issue.origin} کا ${adj}${issue.minimum.toString()} ہونا متوقع تھا`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `غلط سٹرنگ: \"${_issue.prefix}\" سے شروع ہونا چاہیے`;\n        }\n        if (_issue.format === \"ends_with\") return `غلط سٹرنگ: \"${_issue.suffix}\" پر ختم ہونا چاہیے`;\n        if (_issue.format === \"includes\") return `غلط سٹرنگ: \"${_issue.includes}\" شامل ہونا چاہیے`;\n        if (_issue.format === \"regex\") return `غلط سٹرنگ: پیٹرن ${_issue.pattern} سے میچ ہونا چاہیے`;\n        return `غلط ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `غلط نمبر: ${issue.divisor} کا مضاعف ہونا چاہیے`;\n      case \"unrecognized_keys\":\n        return `غیر تسلیم شدہ کی${issue.keys.length > 1 ? \"ز\" : \"\"}: ${util.joinValues(issue.keys, \"، \")}`;\n      case \"invalid_key\":\n        return `${issue.origin} میں غلط کی`;\n      case \"invalid_union\":\n        return \"غلط ان پٹ\";\n      case \"invalid_element\":\n        return `${issue.origin} میں غلط ویلیو`;\n      default:\n        return `غلط ان پٹ`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/ur.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/vi.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"ký tự\", verb: \"có\" },\n    file: { unit: \"byte\", verb: \"có\" },\n    array: { unit: \"phần tử\", verb: \"có\" },\n    set: { unit: \"phần tử\", verb: \"có\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"số\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"mảng\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"đầu vào\",\n    email: \"địa chỉ email\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ngày giờ ISO\",\n    date: \"ngày ISO\",\n    time: \"giờ ISO\",\n    duration: \"khoảng thời gian ISO\",\n    ipv4: \"địa chỉ IPv4\",\n    ipv6: \"địa chỉ IPv6\",\n    cidrv4: \"dải IPv4\",\n    cidrv6: \"dải IPv6\",\n    base64: \"chuỗi mã hóa base64\",\n    base64url: \"chuỗi mã hóa base64url\",\n    json_string: \"chuỗi JSON\",\n    e164: \"số E.164\",\n    jwt: \"JWT\",\n    template_literal: \"đầu vào\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `Đầu vào không hợp lệ: mong đợi ${issue.expected}, nhận được ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1)\n          return `Đầu vào không hợp lệ: mong đợi ${util.stringifyPrimitive(issue.values[0])}`;\n        return `Tùy chọn không hợp lệ: mong đợi một trong các giá trị ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `Quá lớn: mong đợi ${issue.origin ?? \"giá trị\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"phần tử\"}`;\n        return `Quá lớn: mong đợi ${issue.origin ?? \"giá trị\"} ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `Quá nhỏ: mong đợi ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n\n        return `Quá nhỏ: mong đợi ${issue.origin} ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `Chuỗi không hợp lệ: phải bắt đầu bằng \"${_issue.prefix}\"`;\n        if (_issue.format === \"ends_with\") return `Chuỗi không hợp lệ: phải kết thúc bằng \"${_issue.suffix}\"`;\n        if (_issue.format === \"includes\") return `Chuỗi không hợp lệ: phải bao gồm \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `Chuỗi không hợp lệ: phải khớp với mẫu ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue.format} không hợp lệ`;\n      }\n      case \"not_multiple_of\":\n        return `Số không hợp lệ: phải là bội số của ${issue.divisor}`;\n      case \"unrecognized_keys\":\n        return `Khóa không được nhận dạng: ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `Khóa không hợp lệ trong ${issue.origin}`;\n      case \"invalid_union\":\n        return \"Đầu vào không hợp lệ\";\n      case \"invalid_element\":\n        return `Giá trị không hợp lệ trong ${issue.origin}`;\n      default:\n        return `Đầu vào không hợp lệ`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/vi.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/zh-CN.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"字符\", verb: \"包含\" },\n    file: { unit: \"字节\", verb: \"包含\" },\n    array: { unit: \"项\", verb: \"包含\" },\n    set: { unit: \"项\", verb: \"包含\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"非数字(NaN)\" : \"数字\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"数组\";\n        }\n        if (data === null) {\n          return \"空值(null)\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"输入\",\n    email: \"电子邮件\",\n    url: \"URL\",\n    emoji: \"表情符号\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO日期时间\",\n    date: \"ISO日期\",\n    time: \"ISO时间\",\n    duration: \"ISO时长\",\n    ipv4: \"IPv4地址\",\n    ipv6: \"IPv6地址\",\n    cidrv4: \"IPv4网段\",\n    cidrv6: \"IPv6网段\",\n    base64: \"base64编码字符串\",\n    base64url: \"base64url编码字符串\",\n    json_string: \"JSON字符串\",\n    e164: \"E.164号码\",\n    jwt: \"JWT\",\n    template_literal: \"输入\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `无效输入：期望 ${issue.expected}，实际接收 ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `无效输入：期望 ${util.stringifyPrimitive(issue.values[0])}`;\n        return `无效选项：期望以下之一 ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `数值过大：期望 ${issue.origin ?? \"值\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"个元素\"}`;\n        return `数值过大：期望 ${issue.origin ?? \"值\"} ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `数值过小：期望 ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n        return `数值过小：期望 ${issue.origin} ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") return `无效字符串：必须以 \"${_issue.prefix}\" 开头`;\n        if (_issue.format === \"ends_with\") return `无效字符串：必须以 \"${_issue.suffix}\" 结尾`;\n        if (_issue.format === \"includes\") return `无效字符串：必须包含 \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `无效字符串：必须满足正则表达式 ${_issue.pattern}`;\n        return `无效${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `无效数字：必须是 ${issue.divisor} 的倍数`;\n      case \"unrecognized_keys\":\n        return `出现未知的键(key): ${util.joinValues(issue.keys, \", \")}`;\n      case \"invalid_key\":\n        return `${issue.origin} 中的键(key)无效`;\n      case \"invalid_union\":\n        return \"无效输入\";\n      case \"invalid_element\":\n        return `${issue.origin} 中包含无效值(value)`;\n      default:\n        return `无效输入`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/zh-CN.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/locales/zh-TW.ts",
    "content": "import type { $ZodStringFormats } from \"../core/checks.js\";\nimport type * as errors from \"../core/errors.js\";\nimport * as util from \"../core/util.js\";\n\nconst error: () => errors.$ZodErrorMap = () => {\n  const Sizable: Record<string, { unit: string; verb: string }> = {\n    string: { unit: \"字元\", verb: \"擁有\" },\n    file: { unit: \"位元組\", verb: \"擁有\" },\n    array: { unit: \"項目\", verb: \"擁有\" },\n    set: { unit: \"項目\", verb: \"擁有\" },\n  };\n\n  function getSizing(origin: string): { unit: string; verb: string } | null {\n    return Sizable[origin] ?? null;\n  }\n\n  const parsedType = (data: any): string => {\n    const t = typeof data;\n\n    switch (t) {\n      case \"number\": {\n        return Number.isNaN(data) ? \"NaN\" : \"number\";\n      }\n      case \"object\": {\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n        if (data === null) {\n          return \"null\";\n        }\n\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t;\n  };\n\n  const Nouns: {\n    [k in $ZodStringFormats | (string & {})]?: string;\n  } = {\n    regex: \"輸入\",\n    email: \"郵件地址\",\n    url: \"URL\",\n    emoji: \"emoji\",\n    uuid: \"UUID\",\n    uuidv4: \"UUIDv4\",\n    uuidv6: \"UUIDv6\",\n    nanoid: \"nanoid\",\n    guid: \"GUID\",\n    cuid: \"cuid\",\n    cuid2: \"cuid2\",\n    ulid: \"ULID\",\n    xid: \"XID\",\n    ksuid: \"KSUID\",\n    datetime: \"ISO 日期時間\",\n    date: \"ISO 日期\",\n    time: \"ISO 時間\",\n    duration: \"ISO 期間\",\n    ipv4: \"IPv4 位址\",\n    ipv6: \"IPv6 位址\",\n    cidrv4: \"IPv4 範圍\",\n    cidrv6: \"IPv6 範圍\",\n    base64: \"base64 編碼字串\",\n    base64url: \"base64url 編碼字串\",\n    json_string: \"JSON 字串\",\n    e164: \"E.164 數值\",\n    jwt: \"JWT\",\n    template_literal: \"輸入\",\n  };\n\n  return (issue) => {\n    switch (issue.code) {\n      case \"invalid_type\":\n        return `無效的輸入值：預期為 ${issue.expected}，但收到 ${parsedType(issue.input)}`;\n      case \"invalid_value\":\n        if (issue.values.length === 1) return `無效的輸入值：預期為 ${util.stringifyPrimitive(issue.values[0])}`;\n        return `無效的選項：預期為以下其中之一 ${util.joinValues(issue.values, \"|\")}`;\n      case \"too_big\": {\n        const adj = issue.inclusive ? \"<=\" : \"<\";\n        const sizing = getSizing(issue.origin);\n        if (sizing)\n          return `數值過大：預期 ${issue.origin ?? \"值\"} 應為 ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"個元素\"}`;\n        return `數值過大：預期 ${issue.origin ?? \"值\"} 應為 ${adj}${issue.maximum.toString()}`;\n      }\n      case \"too_small\": {\n        const adj = issue.inclusive ? \">=\" : \">\";\n        const sizing = getSizing(issue.origin);\n        if (sizing) {\n          return `數值過小：預期 ${issue.origin} 應為 ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n        }\n        return `數值過小：預期 ${issue.origin} 應為 ${adj}${issue.minimum.toString()}`;\n      }\n      case \"invalid_format\": {\n        const _issue = issue as errors.$ZodStringFormatIssues;\n        if (_issue.format === \"starts_with\") {\n          return `無效的字串：必須以 \"${_issue.prefix}\" 開頭`;\n        }\n        if (_issue.format === \"ends_with\") return `無效的字串：必須以 \"${_issue.suffix}\" 結尾`;\n        if (_issue.format === \"includes\") return `無效的字串：必須包含 \"${_issue.includes}\"`;\n        if (_issue.format === \"regex\") return `無效的字串：必須符合格式 ${_issue.pattern}`;\n        return `無效的 ${Nouns[_issue.format] ?? issue.format}`;\n      }\n      case \"not_multiple_of\":\n        return `無效的數字：必須為 ${issue.divisor} 的倍數`;\n      case \"unrecognized_keys\":\n        return `無法識別的鍵值${issue.keys.length > 1 ? \"們\" : \"\"}：${util.joinValues(issue.keys, \"、\")}`;\n      case \"invalid_key\":\n        return `${issue.origin} 中有無效的鍵值`;\n      case \"invalid_union\":\n        return \"無效的輸入值\";\n      case \"invalid_element\":\n        return `${issue.origin} 中有無效的值`;\n      default:\n        return `無效的輸入值`;\n    }\n  };\n};\n\nexport default function (): { localeError: errors.$ZodErrorMap } {\n  return {\n    localeError: error(),\n  };\n}\n",
    "symbols": [
      {
        "name": "getSizing",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/locales/zh-TW.ts",
        "startLine": 13,
        "endLine": 15
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/checks.ts",
    "content": "export {\n  _lt as lt,\n  _lte as lte,\n  _lte as maximum,\n  _gt as gt,\n  _gte as gte,\n  _gte as minimum,\n  _positive as positive,\n  _negative as negative,\n  _nonpositive as nonpositive,\n  _nonnegative as nonnegative,\n  _multipleOf as multipleOf,\n  _maxSize as maxSize,\n  _minSize as minSize,\n  _size as size,\n  _maxLength as maxLength,\n  _minLength as minLength,\n  _length as length,\n  _regex as regex,\n  _lowercase as lowercase,\n  _uppercase as uppercase,\n  _includes as includes,\n  _startsWith as startsWith,\n  _endsWith as endsWith,\n  _property as property,\n  _mime as mime,\n  _overwrite as overwrite,\n  _normalize as normalize,\n  _trim as trim,\n  _toLowerCase as toLowerCase,\n  _toUpperCase as toUpperCase,\n} from \"../core/index.js\";\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts",
    "content": "import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\n\nexport function string<T = unknown>(params?: string | core.$ZodStringParams): schemas.ZodMiniString<T> {\n  return core._coercedString(schemas.ZodMiniString, params) as schemas.ZodMiniString<T>;\n}\n\nexport function number<T = unknown>(params?: string | core.$ZodNumberParams): schemas.ZodMiniNumber<T> {\n  return core._coercedNumber(schemas.ZodMiniNumber, params) as schemas.ZodMiniNumber<T>;\n}\n\nexport function boolean<T = unknown>(params?: string | core.$ZodBooleanParams): schemas.ZodMiniBoolean<T> {\n  return core._coercedBoolean(schemas.ZodMiniBoolean, params) as schemas.ZodMiniBoolean<T>;\n}\n\nexport function bigint<T = unknown>(params?: string | core.$ZodBigIntParams): schemas.ZodMiniBigInt<T> {\n  return core._coercedBigint(schemas.ZodMiniBigInt, params) as schemas.ZodMiniBigInt<T>;\n}\n\nexport function date<T = unknown>(params?: string | core.$ZodDateParams): schemas.ZodMiniDate<T> {\n  return core._coercedDate(schemas.ZodMiniDate, params) as schemas.ZodMiniDate<T>;\n}\n",
    "symbols": [
      {
        "name": "string",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts",
        "startLine": 4,
        "endLine": 6
      },
      {
        "name": "number",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts",
        "startLine": 8,
        "endLine": 10
      },
      {
        "name": "boolean",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts",
        "startLine": 12,
        "endLine": 14
      },
      {
        "name": "bigint",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts",
        "startLine": 16,
        "endLine": 18
      },
      {
        "name": "date",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/coerce.ts",
        "startLine": 20,
        "endLine": 22
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/external.ts",
    "content": "export * as core from \"../core/index.js\";\nexport * from \"./parse.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\n\nexport type { infer, output, input } from \"../core/index.js\";\nexport {\n  globalRegistry,\n  registry,\n  config,\n  $output,\n  $input,\n  $brand,\n  function,\n  clone,\n  regexes,\n  treeifyError,\n  prettifyError,\n  formatError,\n  flattenError,\n  toJSONSchema,\n  TimePrecision,\n  NEVER,\n} from \"../core/index.js\";\n\nexport * as locales from \"../locales/index.js\";\n/** A special constant with type `never` */\n// export const NEVER = {} as never;\n\n// iso\nexport * as iso from \"./iso.js\";\nexport {\n  ZodMiniISODateTime,\n  ZodMiniISODate,\n  ZodMiniISOTime,\n  ZodMiniISODuration,\n} from \"./iso.js\";\n\n// coerce\nexport * as coerce from \"./coerce.js\";\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/index.ts",
    "content": "import * as z from \"./external.js\";\nexport * from \"./external.js\";\nexport { z };\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/iso.ts",
    "content": "import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\n\n// iso time\nexport interface ZodMiniISODateTime extends schemas.ZodMiniStringFormat<\"datetime\"> {\n  _zod: core.$ZodISODateTimeInternals;\n}\nexport const ZodMiniISODateTime: core.$constructor<ZodMiniISODateTime> = /*@__PURE__*/ core.$constructor(\n  \"$ZodISODateTime\",\n  (inst, def) => {\n    core.$ZodISODateTime.init(inst, def);\n    schemas.ZodMiniStringFormat.init(inst, def);\n  }\n);\nexport function datetime(params?: string | core.$ZodISODateTimeParams): ZodMiniISODateTime {\n  return core._isoDateTime(ZodMiniISODateTime, params);\n}\n\n// iso date\nexport interface ZodMiniISODate extends schemas.ZodMiniStringFormat<\"date\"> {\n  _zod: core.$ZodISODateInternals;\n}\nexport const ZodMiniISODate: core.$constructor<ZodMiniISODate> = /*@__PURE__*/ core.$constructor(\n  \"$ZodISODate\",\n  (inst, def) => {\n    core.$ZodISODate.init(inst, def);\n    schemas.ZodMiniStringFormat.init(inst, def);\n  }\n);\nexport function date(params?: string | core.$ZodISODateParams): ZodMiniISODate {\n  return core._isoDate(ZodMiniISODate, params);\n}\n\n// iso time\nexport interface ZodMiniISOTime extends schemas.ZodMiniStringFormat<\"time\"> {\n  _zod: core.$ZodISOTimeInternals;\n}\nexport const ZodMiniISOTime: core.$constructor<ZodMiniISOTime> = /*@__PURE__*/ core.$constructor(\n  \"$ZodISOTime\",\n  (inst, def) => {\n    core.$ZodISOTime.init(inst, def);\n    schemas.ZodMiniStringFormat.init(inst, def);\n  }\n);\nexport function time(params?: string | core.$ZodISOTimeParams): ZodMiniISOTime {\n  return core._isoTime(ZodMiniISOTime, params);\n}\n\n// iso duration\nexport interface ZodMiniISODuration extends schemas.ZodMiniStringFormat<\"duration\"> {\n  _zod: core.$ZodISODurationInternals;\n}\nexport const ZodMiniISODuration: core.$constructor<ZodMiniISODuration> = /*@__PURE__*/ core.$constructor(\n  \"$ZodISODuration\",\n  (inst, def) => {\n    core.$ZodISODuration.init(inst, def);\n    schemas.ZodMiniStringFormat.init(inst, def);\n  }\n);\nexport function duration(params?: string | core.$ZodISODurationParams): ZodMiniISODuration {\n  return core._isoDuration(ZodMiniISODuration, params);\n}\n",
    "symbols": [
      {
        "name": "datetime",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/iso.ts",
        "startLine": 15,
        "endLine": 17
      },
      {
        "name": "date",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/iso.ts",
        "startLine": 30,
        "endLine": 32
      },
      {
        "name": "time",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/iso.ts",
        "startLine": 45,
        "endLine": 47
      },
      {
        "name": "duration",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/iso.ts",
        "startLine": 60,
        "endLine": 62
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/parse.ts",
    "content": "export { parse, safeParse, parseAsync, safeParseAsync } from \"../core/index.js\";\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
    "content": "import * as core from \"../core/index.js\";\nimport { util } from \"../core/index.js\";\nimport * as parse from \"./parse.js\";\n\ntype SomeType = core.SomeType;\n\nexport interface ZodMiniType<\n  out Output = unknown,\n  out Input = unknown,\n  out Internals extends core.$ZodTypeInternals<Output, Input> = core.$ZodTypeInternals<Output, Input>,\n> extends core.$ZodType<Output, Input, Internals> {\n  check(...checks: (core.CheckFn<core.output<this>> | core.$ZodCheck<core.output<this>>)[]): this;\n  clone(def?: Internals[\"def\"], params?: { parent: boolean }): this;\n  register<R extends core.$ZodRegistry>(\n    registry: R,\n    ...meta: this extends R[\"_schema\"]\n      ? undefined extends R[\"_meta\"]\n        ? [core.$replace<R[\"_meta\"], this>?]\n        : [core.$replace<R[\"_meta\"], this>]\n      : [\"Incompatible schema\"]\n  ): this;\n  brand<T extends PropertyKey = PropertyKey>(\n    value?: T\n  ): PropertyKey extends T ? this : this & Record<\"_zod\", Record<\"output\", core.output<this> & core.$brand<T>>>;\n\n  def: Internals[\"def\"];\n\n  parse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): core.output<this>;\n  safeParse(data: unknown, params?: core.ParseContext<core.$ZodIssue>): util.SafeParseResult<core.output<this>>;\n  parseAsync(data: unknown, params?: core.ParseContext<core.$ZodIssue>): Promise<core.output<this>>;\n  safeParseAsync(\n    data: unknown,\n    params?: core.ParseContext<core.$ZodIssue>\n  ): Promise<util.SafeParseResult<core.output<this>>>;\n}\n\ninterface _ZodMiniType<out Internals extends core.$ZodTypeInternals = core.$ZodTypeInternals>\n  extends ZodMiniType<any, any, Internals> {}\n\nexport const ZodMiniType: core.$constructor<ZodMiniType> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniType\",\n  (inst, def) => {\n    if (!inst._zod) throw new Error(\"Uninitialized schema in ZodMiniType.\");\n\n    core.$ZodType.init(inst, def);\n    inst.def = def;\n    inst.parse = (data, params) => parse.parse(inst, data, params, { callee: inst.parse });\n    inst.safeParse = (data, params) => parse.safeParse(inst, data, params);\n    inst.parseAsync = async (data, params) => parse.parseAsync(inst, data, params, { callee: inst.parseAsync });\n    inst.safeParseAsync = async (data, params) => parse.safeParseAsync(inst, data, params);\n    inst.check = (...checks) => {\n      return inst.clone(\n        {\n          ...def,\n          checks: [\n            ...(def.checks ?? []),\n            ...checks.map((ch) =>\n              typeof ch === \"function\" ? { _zod: { check: ch, def: { check: \"custom\" }, onattach: [] } } : ch\n            ),\n          ],\n        }\n        // { parent: true }\n      );\n    };\n    inst.clone = (_def, params) => core.clone(inst, _def, params);\n    inst.brand = () => inst as any;\n    inst.register = ((reg: any, meta: any) => {\n      reg.add(inst, meta);\n      return inst;\n    }) as any;\n  }\n);\n\nexport interface _ZodMiniString<T extends core.$ZodStringInternals<unknown> = core.$ZodStringInternals<unknown>>\n  extends _ZodMiniType<T>,\n    core.$ZodString<T[\"input\"]> {\n  _zod: T;\n}\n\n// ZodMiniString\nexport interface ZodMiniString<Input = unknown>\n  extends _ZodMiniString<core.$ZodStringInternals<Input>>,\n    core.$ZodString<Input> {}\nexport const ZodMiniString: core.$constructor<ZodMiniString> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniString\",\n  (inst, def) => {\n    core.$ZodString.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function string(params?: string | core.$ZodStringParams): ZodMiniString<string> {\n  return core._string(ZodMiniString, params) as any;\n}\n\n// ZodMiniStringFormat\nexport interface ZodMiniStringFormat<Format extends string = string>\n  extends _ZodMiniString<core.$ZodStringFormatInternals<Format>>,\n    core.$ZodStringFormat<Format> {\n  // _zod: core.$ZodStringFormatInternals<Format>;\n}\nexport const ZodMiniStringFormat: core.$constructor<ZodMiniStringFormat> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniStringFormat\",\n  (inst, def) => {\n    core.$ZodStringFormat.init(inst, def);\n    ZodMiniString.init(inst, def);\n  }\n);\n\n// ZodMiniEmail\nexport interface ZodMiniEmail extends _ZodMiniString<core.$ZodEmailInternals> {}\nexport const ZodMiniEmail: core.$constructor<ZodMiniEmail> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniEmail\",\n  (inst, def) => {\n    core.$ZodEmail.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function email(params?: string | core.$ZodEmailParams): ZodMiniEmail {\n  return core._email(ZodMiniEmail, params);\n}\n\n// ZodMiniGUID\nexport interface ZodMiniGUID extends _ZodMiniString<core.$ZodGUIDInternals> {\n  // _zod: core.$ZodGUIDInternals;\n}\nexport const ZodMiniGUID: core.$constructor<ZodMiniGUID> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniGUID\",\n  (inst, def) => {\n    core.$ZodGUID.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function guid(params?: string | core.$ZodGUIDParams): ZodMiniGUID {\n  return core._guid(ZodMiniGUID, params);\n}\n\n// ZodMiniUUID\nexport interface ZodMiniUUID extends _ZodMiniString<core.$ZodUUIDInternals> {\n  // _zod: core.$ZodUUIDInternals;\n}\nexport const ZodMiniUUID: core.$constructor<ZodMiniUUID> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniUUID\",\n  (inst, def) => {\n    core.$ZodUUID.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function uuid(params?: string | core.$ZodUUIDParams): ZodMiniUUID {\n  return core._uuid(ZodMiniUUID, params);\n}\n\nexport function uuidv4(params?: string | core.$ZodUUIDv4Params): ZodMiniUUID {\n  return core._uuidv4(ZodMiniUUID, params);\n}\n\n// ZodMiniUUIDv6\n\nexport function uuidv6(params?: string | core.$ZodUUIDv6Params): ZodMiniUUID {\n  return core._uuidv6(ZodMiniUUID, params);\n}\n\n// ZodMiniUUIDv7\n\nexport function uuidv7(params?: string | core.$ZodUUIDv7Params): ZodMiniUUID {\n  return core._uuidv7(ZodMiniUUID, params);\n}\n\n// ZodMiniURL\nexport interface ZodMiniURL extends _ZodMiniString<core.$ZodURLInternals> {\n  // _zod: core.$ZodURLInternals;\n}\nexport const ZodMiniURL: core.$constructor<ZodMiniURL> = /*@__PURE__*/ core.$constructor(\"ZodMiniURL\", (inst, def) => {\n  core.$ZodURL.init(inst, def);\n  ZodMiniStringFormat.init(inst, def);\n});\n\nexport function url(params?: string | core.$ZodURLParams): ZodMiniURL {\n  return core._url(ZodMiniURL, params);\n}\n\n// ZodMiniEmoji\nexport interface ZodMiniEmoji extends _ZodMiniString<core.$ZodEmojiInternals> {\n  // _zod: core.$ZodEmojiInternals;\n}\nexport const ZodMiniEmoji: core.$constructor<ZodMiniEmoji> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniEmoji\",\n  (inst, def) => {\n    core.$ZodEmoji.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function emoji(params?: string | core.$ZodEmojiParams): ZodMiniEmoji {\n  return core._emoji(ZodMiniEmoji, params);\n}\n\n// ZodMiniNanoID\nexport interface ZodMiniNanoID extends _ZodMiniString<core.$ZodNanoIDInternals> {\n  // _zod: core.$ZodNanoIDInternals;\n}\nexport const ZodMiniNanoID: core.$constructor<ZodMiniNanoID> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniNanoID\",\n  (inst, def) => {\n    core.$ZodNanoID.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function nanoid(params?: string | core.$ZodNanoIDParams): ZodMiniNanoID {\n  return core._nanoid(ZodMiniNanoID, params);\n}\n\n// ZodMiniCUID\nexport interface ZodMiniCUID extends _ZodMiniString<core.$ZodCUIDInternals> {\n  // _zod: core.$ZodCUIDInternals;\n}\nexport const ZodMiniCUID: core.$constructor<ZodMiniCUID> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniCUID\",\n  (inst, def) => {\n    core.$ZodCUID.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function cuid(params?: string | core.$ZodCUIDParams): ZodMiniCUID {\n  return core._cuid(ZodMiniCUID, params);\n}\n\n// ZodMiniCUID2\nexport interface ZodMiniCUID2 extends _ZodMiniString<core.$ZodCUID2Internals> {\n  // _zod: core.$ZodCUID2Internals;\n}\nexport const ZodMiniCUID2: core.$constructor<ZodMiniCUID2> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniCUID2\",\n  (inst, def) => {\n    core.$ZodCUID2.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function cuid2(params?: string | core.$ZodCUID2Params): ZodMiniCUID2 {\n  return core._cuid2(ZodMiniCUID2, params);\n}\n\n// ZodMiniULID\nexport interface ZodMiniULID extends _ZodMiniString<core.$ZodULIDInternals> {\n  // _zod: core.$ZodULIDInternals;\n}\nexport const ZodMiniULID: core.$constructor<ZodMiniULID> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniULID\",\n  (inst, def) => {\n    core.$ZodULID.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function ulid(params?: string | core.$ZodULIDParams): ZodMiniULID {\n  return core._ulid(ZodMiniULID, params);\n}\n\n// ZodMiniXID\nexport interface ZodMiniXID extends _ZodMiniString<core.$ZodXIDInternals> {\n  // _zod: core.$ZodXIDInternals;\n}\nexport const ZodMiniXID: core.$constructor<ZodMiniXID> = /*@__PURE__*/ core.$constructor(\"ZodMiniXID\", (inst, def) => {\n  core.$ZodXID.init(inst, def);\n  ZodMiniStringFormat.init(inst, def);\n});\n\nexport function xid(params?: string | core.$ZodXIDParams): ZodMiniXID {\n  return core._xid(ZodMiniXID, params);\n}\n\n// ZodMiniKSUID\nexport interface ZodMiniKSUID extends _ZodMiniString<core.$ZodKSUIDInternals> {\n  // _zod: core.$ZodKSUIDInternals;\n}\nexport const ZodMiniKSUID: core.$constructor<ZodMiniKSUID> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniKSUID\",\n  (inst, def) => {\n    core.$ZodKSUID.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function ksuid(params?: string | core.$ZodKSUIDParams): ZodMiniKSUID {\n  return core._ksuid(ZodMiniKSUID, params);\n}\n\n// ZodMiniIPv4\nexport interface ZodMiniIPv4 extends _ZodMiniString<core.$ZodIPv4Internals> {\n  // _zod: core.$ZodIPv4Internals;\n}\nexport const ZodMiniIPv4: core.$constructor<ZodMiniIPv4> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniIPv4\",\n  (inst, def) => {\n    core.$ZodIPv4.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function ipv4(params?: string | core.$ZodIPv4Params): ZodMiniIPv4 {\n  return core._ipv4(ZodMiniIPv4, params);\n}\n\n// ZodMiniIPv6\nexport interface ZodMiniIPv6 extends _ZodMiniString<core.$ZodIPv6Internals> {\n  // _zod: core.$ZodIPv6Internals;\n}\nexport const ZodMiniIPv6: core.$constructor<ZodMiniIPv6> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniIPv6\",\n  (inst, def) => {\n    core.$ZodIPv6.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function ipv6(params?: string | core.$ZodIPv6Params): ZodMiniIPv6 {\n  return core._ipv6(ZodMiniIPv6, params);\n}\n\n// ZodMiniCIDRv4\nexport interface ZodMiniCIDRv4 extends _ZodMiniString<core.$ZodCIDRv4Internals> {\n  // _zod: core.$ZodCIDRv4Internals;\n}\nexport const ZodMiniCIDRv4: core.$constructor<ZodMiniCIDRv4> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniCIDRv4\",\n  (inst, def) => {\n    core.$ZodCIDRv4.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function cidrv4(params?: string | core.$ZodCIDRv4Params): ZodMiniCIDRv4 {\n  return core._cidrv4(ZodMiniCIDRv4, params);\n}\n\n// ZodMiniCIDRv6\nexport interface ZodMiniCIDRv6 extends _ZodMiniString<core.$ZodCIDRv6Internals> {\n  // _zod: core.$ZodCIDRv6Internals;\n}\nexport const ZodMiniCIDRv6: core.$constructor<ZodMiniCIDRv6> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniCIDRv6\",\n  (inst, def) => {\n    core.$ZodCIDRv6.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function cidrv6(params?: string | core.$ZodCIDRv6Params): ZodMiniCIDRv6 {\n  return core._cidrv6(ZodMiniCIDRv6, params);\n}\n\n// ZodMiniBase64\nexport interface ZodMiniBase64 extends _ZodMiniString<core.$ZodBase64Internals> {\n  // _zod: core.$ZodBase64Internals;\n}\nexport const ZodMiniBase64: core.$constructor<ZodMiniBase64> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniBase64\",\n  (inst, def) => {\n    core.$ZodBase64.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\nexport function base64(params?: string | core.$ZodBase64Params): ZodMiniBase64 {\n  return core._base64(ZodMiniBase64, params);\n}\n\n// ZodMiniBase64URL\nexport interface ZodMiniBase64URL extends _ZodMiniString<core.$ZodBase64URLInternals> {\n  // _zod: core.$ZodBase64URLInternals;\n}\nexport const ZodMiniBase64URL: core.$constructor<ZodMiniBase64URL> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniBase64URL\",\n  (inst, def) => {\n    core.$ZodBase64URL.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\nexport function base64url(params?: string | core.$ZodBase64URLParams): ZodMiniBase64URL {\n  return core._base64url(ZodMiniBase64URL, params);\n}\n\n// ZodMiniE164\nexport interface ZodMiniE164 extends _ZodMiniString<core.$ZodE164Internals> {\n  // _zod: core.$ZodE164Internals;\n}\nexport const ZodMiniE164: core.$constructor<ZodMiniE164> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniE164\",\n  (inst, def) => {\n    core.$ZodE164.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function e164(params?: string | core.$ZodE164Params): ZodMiniE164 {\n  return core._e164(ZodMiniE164, params);\n}\n\n// ZodMiniJWT\nexport interface ZodMiniJWT extends _ZodMiniString<core.$ZodJWTInternals> {\n  // _zod: core.$ZodJWTInternals;\n}\nexport const ZodMiniJWT: core.$constructor<ZodMiniJWT> = /*@__PURE__*/ core.$constructor(\"ZodMiniJWT\", (inst, def) => {\n  core.$ZodJWT.init(inst, def);\n  ZodMiniStringFormat.init(inst, def);\n});\n\nexport function jwt(params?: string | core.$ZodJWTParams): ZodMiniJWT {\n  return core._jwt(ZodMiniJWT, params);\n}\n\n// ZodMiniCustomStringFormat\nexport interface ZodMiniCustomStringFormat<Format extends string = string>\n  extends ZodMiniStringFormat<Format>,\n    core.$ZodCustomStringFormat<Format> {\n  _zod: core.$ZodCustomStringFormatInternals<Format>;\n}\nexport const ZodMiniCustomStringFormat: core.$constructor<ZodMiniCustomStringFormat> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniCustomStringFormat\",\n  (inst, def) => {\n    core.$ZodCustomStringFormat.init(inst, def);\n    ZodMiniStringFormat.init(inst, def);\n  }\n);\n\nexport function stringFormat<Format extends string>(\n  format: Format,\n  fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp,\n  _params: string | core.$ZodStringFormatParams = {}\n): ZodMiniCustomStringFormat<Format> {\n  return core._stringFormat(ZodMiniCustomStringFormat, format, fnOrRegex, _params) as any;\n}\n\n// ZodMiniNumber\ninterface _ZodMiniNumber<T extends core.$ZodNumberInternals<unknown> = core.$ZodNumberInternals<unknown>>\n  extends _ZodMiniType<T>,\n    core.$ZodNumber<T[\"input\"]> {\n  _zod: T;\n}\nexport interface ZodMiniNumber<Input = unknown>\n  extends _ZodMiniNumber<core.$ZodNumberInternals<Input>>,\n    core.$ZodNumber<Input> {}\nexport const ZodMiniNumber: core.$constructor<ZodMiniNumber> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniNumber\",\n  (inst, def) => {\n    core.$ZodNumber.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function number(params?: string | core.$ZodNumberParams): ZodMiniNumber<number> {\n  return core._number(ZodMiniNumber, params) as any;\n}\n\n// ZodMiniNumberFormat\nexport interface ZodMiniNumberFormat extends _ZodMiniNumber<core.$ZodNumberFormatInternals>, core.$ZodNumberFormat {}\nexport const ZodMiniNumberFormat: core.$constructor<ZodMiniNumberFormat> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniNumberFormat\",\n  (inst, def) => {\n    core.$ZodNumberFormat.init(inst, def);\n    ZodMiniNumber.init(inst, def);\n  }\n);\n\n// int\n\nexport function int(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat {\n  return core._int(ZodMiniNumberFormat, params);\n}\n\n// float32\n\nexport function float32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat {\n  return core._float32(ZodMiniNumberFormat, params);\n}\n\n// float64\n\nexport function float64(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat {\n  return core._float64(ZodMiniNumberFormat, params);\n}\n\n// int32\n\nexport function int32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat {\n  return core._int32(ZodMiniNumberFormat, params);\n}\n\n// uint32\n\nexport function uint32(params?: string | core.$ZodCheckNumberFormatParams): ZodMiniNumberFormat {\n  return core._uint32(ZodMiniNumberFormat, params);\n}\n\n// ZodMiniBoolean\nexport interface ZodMiniBoolean<T = unknown> extends _ZodMiniType<core.$ZodBooleanInternals<T>> {\n  // _zod: core.$ZodBooleanInternals<T>;\n}\nexport const ZodMiniBoolean: core.$constructor<ZodMiniBoolean> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniBoolean\",\n  (inst, def) => {\n    core.$ZodBoolean.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function boolean(params?: string | core.$ZodBooleanParams): ZodMiniBoolean<boolean> {\n  return core._boolean(ZodMiniBoolean, params) as any;\n}\n\n// ZodMiniBigInt\nexport interface ZodMiniBigInt<T = unknown> extends _ZodMiniType<core.$ZodBigIntInternals<T>>, core.$ZodBigInt<T> {\n  // _zod: core.$ZodBigIntInternals<T>;\n}\nexport const ZodMiniBigInt: core.$constructor<ZodMiniBigInt> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniBigInt\",\n  (inst, def) => {\n    core.$ZodBigInt.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function bigint(params?: string | core.$ZodBigIntParams): ZodMiniBigInt<bigint> {\n  return core._bigint(ZodMiniBigInt, params) as any;\n}\n\n// bigint formats\n\n// ZodMiniBigIntFormat\nexport interface ZodMiniBigIntFormat extends _ZodMiniType<core.$ZodBigIntFormatInternals> {\n  // _zod: core.$ZodBigIntFormatInternals;\n}\nexport const ZodMiniBigIntFormat: core.$constructor<ZodMiniBigIntFormat> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniBigIntFormat\",\n  (inst, def) => {\n    core.$ZodBigIntFormat.init(inst, def);\n    ZodMiniBigInt.init(inst, def);\n  }\n);\n\n// int64\n\nexport function int64(params?: string | core.$ZodBigIntFormatParams): ZodMiniBigIntFormat {\n  return core._int64(ZodMiniBigIntFormat, params);\n}\n\n// uint64\n\nexport function uint64(params?: string | core.$ZodBigIntFormatParams): ZodMiniBigIntFormat {\n  return core._uint64(ZodMiniBigIntFormat, params);\n}\n\n// ZodMiniSymbol\nexport interface ZodMiniSymbol extends _ZodMiniType<core.$ZodSymbolInternals> {\n  // _zod: core.$ZodSymbolInternals;\n}\nexport const ZodMiniSymbol: core.$constructor<ZodMiniSymbol> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniSymbol\",\n  (inst, def) => {\n    core.$ZodSymbol.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function symbol(params?: string | core.$ZodSymbolParams): ZodMiniSymbol {\n  return core._symbol(ZodMiniSymbol, params) as any;\n}\n\n// ZodMiniUndefined\nexport interface ZodMiniUndefined extends _ZodMiniType<core.$ZodUndefinedInternals> {\n  // _zod: core.$ZodUndefinedInternals;\n}\nexport const ZodMiniUndefined: core.$constructor<ZodMiniUndefined> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniUndefined\",\n  (inst, def) => {\n    core.$ZodUndefined.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nfunction _undefined(params?: string | core.$ZodUndefinedParams): ZodMiniUndefined {\n  return core._undefined(ZodMiniUndefined, params) as any;\n}\nexport { _undefined as undefined };\n\n// ZodMiniNull\nexport interface ZodMiniNull extends _ZodMiniType<core.$ZodNullInternals> {\n  // _zod: core.$ZodNullInternals;\n}\nexport const ZodMiniNull: core.$constructor<ZodMiniNull> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniNull\",\n  (inst, def) => {\n    core.$ZodNull.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nfunction _null(params?: string | core.$ZodNullParams): ZodMiniNull {\n  return core._null(ZodMiniNull, params) as any;\n}\nexport { _null as null };\n\n// ZodMiniAny\nexport interface ZodMiniAny extends _ZodMiniType<core.$ZodAnyInternals> {\n  // _zod: core.$ZodAnyInternals;\n}\nexport const ZodMiniAny: core.$constructor<ZodMiniAny> = /*@__PURE__*/ core.$constructor(\"ZodMiniAny\", (inst, def) => {\n  core.$ZodAny.init(inst, def);\n  ZodMiniType.init(inst, def);\n});\n\nexport function any(): ZodMiniAny {\n  return core._any(ZodMiniAny) as any;\n}\n\n// ZodMiniUnknown\nexport interface ZodMiniUnknown extends _ZodMiniType<core.$ZodUnknownInternals> {\n  // _zod: core.$ZodUnknownInternals;\n}\nexport const ZodMiniUnknown: core.$constructor<ZodMiniUnknown> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniUnknown\",\n  (inst, def) => {\n    core.$ZodUnknown.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function unknown(): ZodMiniUnknown {\n  return core._unknown(ZodMiniUnknown) as any;\n}\n\n// ZodMiniNever\nexport interface ZodMiniNever extends _ZodMiniType<core.$ZodNeverInternals> {\n  // _zod: core.$ZodNeverInternals;\n}\nexport const ZodMiniNever: core.$constructor<ZodMiniNever> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniNever\",\n  (inst, def) => {\n    core.$ZodNever.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function never(params?: string | core.$ZodNeverParams): ZodMiniNever {\n  return core._never(ZodMiniNever, params) as any;\n}\n\n// ZodMiniVoid\nexport interface ZodMiniVoid extends _ZodMiniType<core.$ZodVoidInternals> {\n  // _zod: core.$ZodVoidInternals;\n}\nexport const ZodMiniVoid: core.$constructor<ZodMiniVoid> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniVoid\",\n  (inst, def) => {\n    core.$ZodVoid.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nfunction _void(params?: string | core.$ZodVoidParams): ZodMiniVoid {\n  return core._void(ZodMiniVoid, params) as any;\n}\nexport { _void as void };\n\n// ZodMiniDate\nexport interface ZodMiniDate<T = unknown> extends _ZodMiniType<core.$ZodDateInternals<T>> {\n  // _zod: core.$ZodDateInternals<T>;\n}\n\nexport const ZodMiniDate: core.$constructor<ZodMiniDate> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniDate\",\n  (inst, def) => {\n    core.$ZodDate.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function date(params?: string | core.$ZodDateParams): ZodMiniDate<Date> {\n  return core._date(ZodMiniDate, params) as any;\n}\n\n// ZodMiniArray\nexport interface ZodMiniArray<T extends SomeType = core.$ZodType>\n  extends _ZodMiniType<core.$ZodArrayInternals<T>>,\n    core.$ZodArray<T> {\n  // _zod: core.$ZodArrayInternals<T>;\n}\nexport const ZodMiniArray: core.$constructor<ZodMiniArray> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniArray\",\n  (inst, def) => {\n    core.$ZodArray.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function array<T extends SomeType>(element: T, params?: string | core.$ZodArrayParams): ZodMiniArray<T>;\nexport function array<T extends SomeType>(element: SomeType, params?: any): ZodMiniArray<T> {\n  return new ZodMiniArray({\n    type: \"array\",\n    element: element as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// .keyof\nexport function keyof<T extends ZodMiniObject>(schema: T): ZodMiniLiteral<Exclude<keyof T[\"shape\"], symbol>> {\n  const shape = schema._zod.def.shape;\n  return literal(Object.keys(shape)) as any;\n}\n\n// ZodMiniObject\nexport interface ZodMiniObject<\n  /** @ts-ignore Cast variance */\n  out Shape extends core.$ZodShape = core.$ZodShape,\n  out Config extends core.$ZodObjectConfig = core.$strip,\n> extends ZodMiniType<any, any, core.$ZodObjectInternals<Shape, Config>>,\n    core.$ZodObject<Shape, Config> {\n  shape: Shape;\n}\nexport const ZodMiniObject: core.$constructor<ZodMiniObject> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniObject\",\n  (inst, def) => {\n    core.$ZodObject.init(inst, def);\n    ZodMiniType.init(inst, def);\n    util.defineLazy(inst, \"shape\", () => def.shape);\n  }\n);\nexport function object<T extends core.$ZodLooseShape = Record<never, SomeType>>(\n  shape?: T,\n  params?: string | core.$ZodObjectParams\n): ZodMiniObject<T, core.$strip> {\n  const def: core.$ZodObjectDef = {\n    type: \"object\",\n    get shape() {\n      util.assignProp(this, \"shape\", { ...shape });\n      return this.shape;\n    },\n    ...util.normalizeParams(params),\n  };\n  return new ZodMiniObject(def) as any;\n}\n\n// strictObject\nexport function strictObject<T extends core.$ZodLooseShape>(\n  shape: T,\n  params?: string | core.$ZodObjectParams\n): ZodMiniObject<T, core.$strict> {\n  return new ZodMiniObject({\n    type: \"object\",\n    // shape: shape as core.$ZodLooseShape,\n    get shape() {\n      util.assignProp(this, \"shape\", { ...shape });\n      return this.shape;\n    },\n    catchall: never(),\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// looseObject\nexport function looseObject<T extends core.$ZodLooseShape>(\n  shape: T,\n  params?: string | core.$ZodObjectParams\n): ZodMiniObject<T, core.$loose> {\n  return new ZodMiniObject({\n    type: \"object\",\n    // shape: shape as core.$ZodLooseShape,\n    get shape() {\n      util.assignProp(this, \"shape\", { ...shape });\n      return this.shape;\n    },\n    // get optional() {\n    //   return util.optionalKeys(shape);\n    // },\n    catchall: unknown(),\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// object methods\nexport function extend<T extends ZodMiniObject, U extends core.$ZodLooseShape>(\n  schema: T,\n  shape: U\n): ZodMiniObject<util.Extend<T[\"shape\"], U>, T[\"_zod\"][\"config\"]> {\n  return util.extend(schema, shape);\n}\n\n/** @deprecated Identical to `z.extend(A, B)` */\nexport function merge<T extends ZodMiniObject, U extends ZodMiniObject>(\n  a: T,\n  b: U\n): ZodMiniObject<util.Extend<T[\"shape\"], U[\"shape\"]>, T[\"_zod\"][\"config\"]>;\nexport function merge(schema: ZodMiniObject, shape: any): ZodMiniObject {\n  return util.extend(schema, shape);\n}\n\nexport function pick<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(\n  schema: T,\n  mask: M\n): ZodMiniObject<util.Flatten<Pick<T[\"shape\"], keyof T[\"shape\"] & keyof M>>, T[\"_zod\"][\"config\"]> {\n  return util.pick(schema, mask as any);\n}\n\n// .omit\n\nexport function omit<T extends ZodMiniObject, const M extends util.Mask<keyof T[\"shape\"]>>(\n  schema: T,\n  mask: M\n): ZodMiniObject<util.Flatten<Omit<T[\"shape\"], keyof M>>, T[\"_zod\"][\"config\"]> {\n  return util.omit(schema, mask);\n}\n\nexport function partial<T extends ZodMiniObject>(\n  schema: T\n): ZodMiniObject<\n  {\n    [k in keyof T[\"shape\"]]: ZodMiniOptional<T[\"shape\"][k]>;\n  },\n  T[\"_zod\"][\"config\"]\n>;\nexport function partial<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(\n  schema: T,\n  mask: M\n): ZodMiniObject<\n  {\n    [k in keyof T[\"shape\"]]: k extends keyof M ? ZodMiniOptional<T[\"shape\"][k]> : T[\"shape\"][k];\n  },\n  T[\"_zod\"][\"config\"]\n>;\nexport function partial(schema: ZodMiniObject, mask?: object) {\n  return util.partial(ZodMiniOptional, schema, mask);\n}\n\nexport type RequiredInterfaceShape<\n  Shape extends core.$ZodLooseShape,\n  Keys extends PropertyKey = keyof Shape,\n> = util.Identity<\n  {\n    [k in keyof Shape as k extends Keys ? k : never]: ZodMiniNonOptional<Shape[k]>;\n  } & {\n    [k in keyof Shape as k extends Keys ? never : k]: Shape[k];\n  }\n>;\n\nexport function required<T extends ZodMiniObject>(\n  schema: T\n): ZodMiniObject<\n  {\n    [k in keyof T[\"shape\"]]: ZodMiniNonOptional<T[\"shape\"][k]>;\n  },\n  T[\"_zod\"][\"config\"]\n>;\nexport function required<T extends ZodMiniObject, M extends util.Mask<keyof T[\"shape\"]>>(\n  schema: T,\n  mask: M\n): ZodMiniObject<\n  util.Extend<\n    T[\"shape\"],\n    {\n      [k in keyof M & keyof T[\"shape\"]]: ZodMiniNonOptional<T[\"shape\"][k]>;\n    }\n  >,\n  T[\"_zod\"][\"config\"]\n>;\nexport function required(schema: ZodMiniObject, mask?: object) {\n  return util.required(ZodMiniNonOptional, schema, mask);\n}\n\nexport function catchall<T extends ZodMiniObject, U extends SomeType>(\n  inst: T,\n  catchall: U\n): ZodMiniObject<T[\"shape\"], core.$catchall<U>> {\n  return inst.clone({ ...inst._zod.def, catchall: catchall as any }) as any;\n}\n\n// ZodMiniUnion\nexport interface ZodMiniUnion<T extends readonly SomeType[] = readonly core.$ZodType[]>\n  extends _ZodMiniType<core.$ZodUnionInternals<T>> {\n  // _zod: core.$ZodUnionInternals<T>;\n}\nexport const ZodMiniUnion: core.$constructor<ZodMiniUnion> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniUnion\",\n  (inst, def) => {\n    core.$ZodUnion.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function union<const T extends readonly SomeType[]>(\n  options: T,\n  params?: string | core.$ZodUnionParams\n): ZodMiniUnion<T> {\n  return new ZodMiniUnion({\n    type: \"union\",\n    options: options as any as core.$ZodType[],\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodMiniDiscriminatedUnion\nexport interface ZodMiniDiscriminatedUnion<Options extends readonly SomeType[] = readonly core.$ZodType[]>\n  extends ZodMiniUnion<Options> {\n  _zod: core.$ZodDiscriminatedUnionInternals<Options>;\n}\nexport const ZodMiniDiscriminatedUnion: core.$constructor<ZodMiniDiscriminatedUnion> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniDiscriminatedUnion\",\n  (inst, def) => {\n    core.$ZodDiscriminatedUnion.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function discriminatedUnion<\n  Types extends readonly [core.$ZodTypeDiscriminable, ...core.$ZodTypeDiscriminable[]],\n>(\n  discriminator: string,\n  options: Types,\n  params?: string | core.$ZodDiscriminatedUnionParams\n): ZodMiniDiscriminatedUnion<Types> {\n  return new ZodMiniDiscriminatedUnion({\n    type: \"union\",\n    options,\n    discriminator,\n    ...util.normalizeParams(params),\n  }) as ZodMiniDiscriminatedUnion<Types>;\n}\n\n// ZodMiniIntersection\nexport interface ZodMiniIntersection<A extends SomeType = core.$ZodType, B extends SomeType = core.$ZodType>\n  extends _ZodMiniType<core.$ZodIntersectionInternals<A, B>> {\n  // _zod: core.$ZodIntersectionInternals<A, B>;\n}\nexport const ZodMiniIntersection: core.$constructor<ZodMiniIntersection> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniIntersection\",\n  (inst, def) => {\n    core.$ZodIntersection.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function intersection<T extends SomeType, U extends SomeType>(left: T, right: U): ZodMiniIntersection<T, U> {\n  return new ZodMiniIntersection({\n    type: \"intersection\",\n    left: left as any as core.$ZodType,\n    right: right as any as core.$ZodType,\n  }) as any;\n}\n\n// ZodMiniTuple\nexport interface ZodMiniTuple<\n  T extends util.TupleItems = readonly core.$ZodType[],\n  Rest extends SomeType | null = core.$ZodType | null,\n> extends _ZodMiniType<core.$ZodTupleInternals<T, Rest>> {\n  // _zod: core.$ZodTupleInternals<T, Rest>;\n}\nexport const ZodMiniTuple: core.$constructor<ZodMiniTuple> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniTuple\",\n  (inst, def) => {\n    core.$ZodTuple.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function tuple<const T extends readonly [SomeType, ...SomeType[]]>(\n  items: T,\n  params?: string | core.$ZodTupleParams\n): ZodMiniTuple<T, null>;\nexport function tuple<const T extends readonly [SomeType, ...SomeType[]], Rest extends SomeType>(\n  items: T,\n  rest: Rest,\n  params?: string | core.$ZodTupleParams\n): ZodMiniTuple<T, Rest>;\nexport function tuple(items: [], params?: string | core.$ZodTupleParams): ZodMiniTuple<[], null>;\nexport function tuple(\n  items: SomeType[],\n  _paramsOrRest?: string | core.$ZodTupleParams | SomeType,\n  _params?: string | core.$ZodTupleParams\n) {\n  const hasRest = _paramsOrRest instanceof core.$ZodType;\n  const params = hasRest ? _params : _paramsOrRest;\n  const rest = hasRest ? _paramsOrRest : null;\n  return new ZodMiniTuple({\n    type: \"tuple\",\n    items: items as any as core.$ZodType[],\n    rest,\n    ...util.normalizeParams(params),\n  });\n}\n\n// ZodMiniRecord\nexport interface ZodMiniRecord<\n  Key extends core.$ZodRecordKey = core.$ZodRecordKey,\n  Value extends SomeType = core.$ZodType,\n> extends _ZodMiniType<core.$ZodRecordInternals<Key, Value>> {\n  // _zod: core.$ZodRecordInternals<Key, Value>;\n}\nexport const ZodMiniRecord: core.$constructor<ZodMiniRecord> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniRecord\",\n  (inst, def) => {\n    core.$ZodRecord.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function record<Key extends core.$ZodRecordKey, Value extends SomeType>(\n  keyType: Key,\n  valueType: Value,\n  params?: string | core.$ZodRecordParams\n): ZodMiniRecord<Key, Value> {\n  return new ZodMiniRecord({\n    type: \"record\",\n    keyType,\n    valueType: valueType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}\nexport function partialRecord<Key extends core.$ZodRecordKey, Value extends SomeType>(\n  keyType: Key,\n  valueType: Value,\n  params?: string | core.$ZodRecordParams\n): ZodMiniRecord<Key & core.$partial, Value> {\n  return new ZodMiniRecord({\n    type: \"record\",\n    keyType: union([keyType, never()]),\n    valueType: valueType as any,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodMiniMap\nexport interface ZodMiniMap<Key extends SomeType = core.$ZodType, Value extends SomeType = core.$ZodType>\n  extends _ZodMiniType<core.$ZodMapInternals<Key, Value>> {\n  // _zod: core.$ZodMapInternals<Key, Value>;\n}\nexport const ZodMiniMap: core.$constructor<ZodMiniMap> = /*@__PURE__*/ core.$constructor(\"ZodMiniMap\", (inst, def) => {\n  core.$ZodMap.init(inst, def);\n  ZodMiniType.init(inst, def);\n});\n\nexport function map<Key extends SomeType, Value extends SomeType>(\n  keyType: Key,\n  valueType: Value,\n  params?: string | core.$ZodMapParams\n): ZodMiniMap<Key, Value> {\n  return new ZodMiniMap({\n    type: \"map\",\n    keyType: keyType as any as core.$ZodType,\n    valueType: valueType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodMiniSet\nexport interface ZodMiniSet<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodSetInternals<T>> {\n  // _zod: core.$ZodSetInternals<T>;\n}\nexport const ZodMiniSet: core.$constructor<ZodMiniSet> = /*@__PURE__*/ core.$constructor(\"ZodMiniSet\", (inst, def) => {\n  core.$ZodSet.init(inst, def);\n  ZodMiniType.init(inst, def);\n});\n\nexport function set<Value extends SomeType>(valueType: Value, params?: string | core.$ZodSetParams): ZodMiniSet<Value> {\n  return new ZodMiniSet({\n    type: \"set\",\n    valueType: valueType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodMiniEnum\nexport interface ZodMiniEnum<T extends util.EnumLike = util.EnumLike> extends _ZodMiniType<core.$ZodEnumInternals<T>> {\n  // _zod: core.$ZodEnumInternals<T>;\n}\nexport const ZodMiniEnum: core.$constructor<ZodMiniEnum> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniEnum\",\n  (inst, def) => {\n    core.$ZodEnum.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nfunction _enum<const T extends readonly string[]>(\n  values: T,\n  params?: string | core.$ZodEnumParams\n): ZodMiniEnum<util.ToEnum<T[number]>>;\nfunction _enum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodMiniEnum<T>;\nfunction _enum(values: any, params?: string | core.$ZodEnumParams) {\n  const entries: any = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n\n  return new ZodMiniEnum({\n    type: \"enum\",\n    entries,\n    ...util.normalizeParams(params),\n  }) as any;\n}\nexport { _enum as enum };\n\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport function nativeEnum<T extends util.EnumLike>(entries: T, params?: string | core.$ZodEnumParams): ZodMiniEnum<T> {\n  return new ZodMiniEnum({\n    type: \"enum\",\n    entries,\n    ...util.normalizeParams(params),\n  }) as any as ZodMiniEnum<T>;\n}\n\n// ZodMiniLiteral\nexport interface ZodMiniLiteral<T extends util.Literal = util.Literal>\n  extends _ZodMiniType<core.$ZodLiteralInternals<T>> {\n  // _zod: core.$ZodLiteralInternals<T>;\n}\nexport const ZodMiniLiteral: core.$constructor<ZodMiniLiteral> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniLiteral\",\n  (inst, def) => {\n    core.$ZodLiteral.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function literal<const T extends ReadonlyArray<util.Literal>>(\n  value: T,\n  params?: string | core.$ZodLiteralParams\n): ZodMiniLiteral<T[number]>;\nexport function literal<const T extends util.Literal>(\n  value: T,\n  params?: string | core.$ZodLiteralParams\n): ZodMiniLiteral<T>;\nexport function literal(value: any, params: any) {\n  return new ZodMiniLiteral({\n    type: \"literal\",\n    values: Array.isArray(value) ? value : [value],\n    ...util.normalizeParams(params),\n  });\n}\n\n// ZodMiniFile\nexport interface ZodMiniFile extends _ZodMiniType<core.$ZodFileInternals> {\n  // _zod: core.$ZodFileInternals;\n}\nexport const ZodMiniFile: core.$constructor<ZodMiniFile> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniFile\",\n  (inst, def) => {\n    core.$ZodFile.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function file(params?: string | core.$ZodFileParams): ZodMiniFile {\n  return core._file(ZodMiniFile, params) as any;\n}\n\n// ZodMiniTransform\nexport interface ZodMiniTransform<O = unknown, I = unknown> extends _ZodMiniType<core.$ZodTransformInternals<O, I>> {\n  // _zod: core.$ZodTransformInternals<O, I>;\n}\nexport const ZodMiniTransform: core.$constructor<ZodMiniTransform> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniTransform\",\n  (inst, def) => {\n    core.$ZodTransform.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function transform<I = unknown, O = I>(\n  fn: (input: I, ctx: core.ParsePayload) => O\n): ZodMiniTransform<Awaited<O>, I> {\n  return new ZodMiniTransform({\n    type: \"transform\",\n    transform: fn as any,\n  }) as any;\n}\n\n// ZodMiniOptional\nexport interface ZodMiniOptional<T extends SomeType = core.$ZodType>\n  extends _ZodMiniType<core.$ZodOptionalInternals<T>>,\n    core.$ZodOptional<T> {\n  // _zod: core.$ZodOptionalInternals<T>;\n}\nexport const ZodMiniOptional: core.$constructor<ZodMiniOptional> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniOptional\",\n  (inst, def) => {\n    core.$ZodOptional.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function optional<T extends SomeType>(innerType: T): ZodMiniOptional<T> {\n  return new ZodMiniOptional({\n    type: \"optional\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}\n\n// ZodMiniNullable\nexport interface ZodMiniNullable<T extends SomeType = core.$ZodType>\n  extends _ZodMiniType<core.$ZodNullableInternals<T>> {\n  // _zod: core.$ZodNullableInternals<T>;\n}\nexport const ZodMiniNullable: core.$constructor<ZodMiniNullable> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniNullable\",\n  (inst, def) => {\n    core.$ZodNullable.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function nullable<T extends SomeType>(innerType: T): ZodMiniNullable<T> {\n  return new ZodMiniNullable({\n    type: \"nullable\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}\n\n// nullish\nexport function nullish<T extends SomeType>(innerType: T): ZodMiniOptional<ZodMiniNullable<T>> {\n  return optional(nullable(innerType));\n}\n\n// ZodMiniDefault\nexport interface ZodMiniDefault<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodDefaultInternals<T>> {\n  // _zod: core.$ZodDefaultInternals<T>;\n}\nexport const ZodMiniDefault: core.$constructor<ZodMiniDefault> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniDefault\",\n  (inst, def) => {\n    core.$ZodDefault.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function _default<T extends SomeType>(\n  innerType: T,\n  defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)\n): ZodMiniDefault<T> {\n  return new ZodMiniDefault({\n    type: \"default\",\n    innerType: innerType as any as core.$ZodType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? (defaultValue as Function)() : defaultValue;\n    },\n  }) as any;\n}\n\n// ZodMiniPrefault\nexport interface ZodMiniPrefault<T extends SomeType = core.$ZodType>\n  extends _ZodMiniType<core.$ZodPrefaultInternals<T>> {\n  // _zod: core.$ZodPrefaultInternals<T>;\n}\nexport const ZodMiniPrefault: core.$constructor<ZodMiniPrefault> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniPrefault\",\n  (inst, def) => {\n    core.$ZodPrefault.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\nexport function prefault<T extends SomeType>(\n  innerType: T,\n  defaultValue: util.NoUndefined<core.input<T>> | (() => util.NoUndefined<core.input<T>>)\n): ZodMiniPrefault<T> {\n  return new ZodMiniPrefault({\n    type: \"prefault\",\n    innerType: innerType as any as core.$ZodType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? (defaultValue as Function)() : defaultValue;\n    },\n  }) as any;\n}\n\n// ZodMiniNonOptional\nexport interface ZodMiniNonOptional<T extends SomeType = core.$ZodType>\n  extends _ZodMiniType<core.$ZodNonOptionalInternals<T>> {\n  // _zod: core.$ZodNonOptionalInternals<T>;\n}\nexport const ZodMiniNonOptional: core.$constructor<ZodMiniNonOptional> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniNonOptional\",\n  (inst, def) => {\n    core.$ZodNonOptional.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function nonoptional<T extends SomeType>(\n  innerType: T,\n  params?: string | core.$ZodNonOptionalParams\n): ZodMiniNonOptional<T> {\n  return new ZodMiniNonOptional({\n    type: \"nonoptional\",\n    innerType: innerType as any as core.$ZodType,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodMiniSuccess\nexport interface ZodMiniSuccess<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodSuccessInternals<T>> {\n  // _zod: core.$ZodSuccessInternals<T>;\n}\nexport const ZodMiniSuccess: core.$constructor<ZodMiniSuccess> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniSuccess\",\n  (inst, def) => {\n    core.$ZodSuccess.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function success<T extends SomeType>(innerType: T): ZodMiniSuccess<T> {\n  return new ZodMiniSuccess({\n    type: \"success\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}\n\n// ZodMiniCatch\nexport interface ZodMiniCatch<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodCatchInternals<T>> {\n  // _zod: core.$ZodCatchInternals<T>;\n}\nexport const ZodMiniCatch: core.$constructor<ZodMiniCatch> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniCatch\",\n  (inst, def) => {\n    core.$ZodCatch.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nfunction _catch<T extends SomeType>(\n  innerType: T,\n  catchValue: core.output<T> | ((ctx: core.$ZodCatchCtx) => core.output<T>)\n): ZodMiniCatch<T> {\n  return new ZodMiniCatch({\n    type: \"catch\",\n    innerType: innerType as any as core.$ZodType,\n    catchValue: (typeof catchValue === \"function\" ? catchValue : () => catchValue) as (\n      ctx: core.$ZodCatchCtx\n    ) => core.output<T>,\n  }) as any;\n}\nexport { _catch as catch };\n\n// ZodMiniNaN\nexport interface ZodMiniNaN extends _ZodMiniType<core.$ZodNaNInternals> {\n  // _zod: core.$ZodNaNInternals;\n}\nexport const ZodMiniNaN: core.$constructor<ZodMiniNaN> = /*@__PURE__*/ core.$constructor(\"ZodMiniNaN\", (inst, def) => {\n  core.$ZodNaN.init(inst, def);\n  ZodMiniType.init(inst, def);\n});\n\nexport function nan(params?: string | core.$ZodNaNParams): ZodMiniNaN {\n  return core._nan(ZodMiniNaN, params) as any;\n}\n\n// ZodMiniPipe\nexport interface ZodMiniPipe<A extends SomeType = core.$ZodType, B extends SomeType = core.$ZodType>\n  extends _ZodMiniType<core.$ZodPipeInternals<A, B>> {\n  // _zod: core.$ZodPipeInternals<A, B>;\n}\nexport const ZodMiniPipe: core.$constructor<ZodMiniPipe> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniPipe\",\n  (inst, def) => {\n    core.$ZodPipe.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function pipe<\n  const A extends SomeType,\n  B extends core.$ZodType<unknown, core.output<A>> = core.$ZodType<unknown, core.output<A>>,\n>(in_: A, out: B | core.$ZodType<unknown, core.output<A>>): ZodMiniPipe<A, B> {\n  return new ZodMiniPipe({\n    type: \"pipe\",\n    in: in_ as any as core.$ZodType,\n    out: out as any as core.$ZodType,\n  }) as any;\n}\n\n// /** @deprecated Use `z.pipe()` and `z.transform()` instead. */\n// export function preprocess<A, U extends core.$ZodType>(\n//   fn: (arg: unknown, ctx: core.ParsePayload) => A,\n//   schema: U,\n//   params?: ZodPreprocessParams\n// ): ZodPipe<ZodTransform<A, unknown>, U> {\n//   return pipe(transform(fn as any, params), schema as any, params);\n// }\n\n// ZodMiniReadonly\nexport interface ZodMiniReadonly<T extends SomeType = core.$ZodType>\n  extends _ZodMiniType<core.$ZodReadonlyInternals<T>> {\n  // _zod: core.$ZodReadonlyInternals<T>;\n}\nexport const ZodMiniReadonly: core.$constructor<ZodMiniReadonly> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniReadonly\",\n  (inst, def) => {\n    core.$ZodReadonly.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function readonly<T extends SomeType>(innerType: T): ZodMiniReadonly<T> {\n  return new ZodMiniReadonly({\n    type: \"readonly\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}\n\n// ZodMiniTemplateLiteral\nexport interface ZodMiniTemplateLiteral<Template extends string = string>\n  extends _ZodMiniType<core.$ZodTemplateLiteralInternals<Template>> {\n  // _zod: core.$ZodTemplateLiteralInternals<Template>;\n}\nexport const ZodMiniTemplateLiteral: core.$constructor<ZodMiniTemplateLiteral> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniTemplateLiteral\",\n  (inst, def) => {\n    core.$ZodTemplateLiteral.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function templateLiteral<const Parts extends core.$ZodTemplateLiteralPart[]>(\n  parts: Parts,\n  params?: string | core.$ZodTemplateLiteralParams\n): ZodMiniTemplateLiteral<core.$PartsToTemplateLiteral<Parts>> {\n  return new ZodMiniTemplateLiteral({\n    type: \"template_literal\",\n    parts,\n    ...util.normalizeParams(params),\n  }) as any;\n}\n\n// ZodMiniLazy\nexport interface ZodMiniLazy<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodLazyInternals<T>> {\n  // _zod: core.$ZodLazyInternals<T>;\n}\nexport const ZodMiniLazy: core.$constructor<ZodMiniLazy> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniLazy\",\n  (inst, def) => {\n    core.$ZodLazy.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\n// export function lazy<T extends object>(getter: () => T): T {\n//   return util.createTransparentProxy<T>(getter);\n// }\nfunction _lazy<T extends SomeType>(getter: () => T): ZodMiniLazy<T> {\n  return new ZodMiniLazy({\n    type: \"lazy\",\n    getter: getter as any,\n  }) as any;\n}\nexport { _lazy as lazy };\n\n// ZodMiniPromise\nexport interface ZodMiniPromise<T extends SomeType = core.$ZodType> extends _ZodMiniType<core.$ZodPromiseInternals<T>> {\n  // _zod: core.$ZodPromiseInternals<T>;\n}\nexport const ZodMiniPromise: core.$constructor<ZodMiniPromise> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniPromise\",\n  (inst, def) => {\n    core.$ZodPromise.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\nexport function promise<T extends SomeType>(innerType: T): ZodMiniPromise<T> {\n  return new ZodMiniPromise({\n    type: \"promise\",\n    innerType: innerType as any as core.$ZodType,\n  }) as any;\n}\n\n// ZodMiniCustom\nexport interface ZodMiniCustom<O = unknown, I = unknown> extends _ZodMiniType<core.$ZodCustomInternals<O, I>> {\n  // _zod: core.$ZodCustomInternals<O, I>;\n}\nexport const ZodMiniCustom: core.$constructor<ZodMiniCustom> = /*@__PURE__*/ core.$constructor(\n  \"ZodMiniCustom\",\n  (inst, def) => {\n    core.$ZodCustom.init(inst, def);\n    ZodMiniType.init(inst, def);\n  }\n);\n\n// custom checks\nexport function check<O = unknown>(fn: core.CheckFn<O>, params?: string | core.$ZodCustomParams): core.$ZodCheck<O> {\n  const ch = new core.$ZodCheck({\n    check: \"custom\",\n    ...util.normalizeParams(params),\n  });\n\n  ch._zod.check = fn;\n  return ch;\n}\n\n// ZodCustom\n// custom schema\nexport function custom<O = unknown, I = O>(\n  fn?: (data: O) => unknown,\n  _params?: string | core.$ZodCustomParams | undefined\n): ZodMiniCustom<O, I> {\n  return core._custom(ZodMiniCustom, fn ?? (() => true), _params) as any;\n}\n\n// refine\nexport function refine<T>(\n  fn: (arg: NoInfer<T>) => util.MaybeAsync<unknown>,\n  _params: string | core.$ZodCustomParams = {}\n): core.$ZodCheck<T> {\n  return core._refine(ZodMiniCustom, fn, _params);\n}\n\n// instanceof\nabstract class Class {\n  constructor(..._args: any[]) {}\n}\nfunction _instanceof<T extends typeof Class>(\n  cls: T,\n  params: core.$ZodCustomParams = {\n    error: `Input not instance of ${cls.name}`,\n  }\n): ZodMiniCustom<InstanceType<T>, InstanceType<T>> {\n  const inst = custom((data) => data instanceof cls, params);\n  inst._zod.bag.Class = cls;\n  return inst as any;\n}\nexport { _instanceof as instanceof };\n\n// stringbool\nexport const stringbool: (\n  _params?: string | core.$ZodStringBoolParams\n) => ZodMiniPipe<ZodMiniPipe<ZodMiniString, ZodMiniTransform<boolean, string>>, ZodMiniBoolean> = (...args) =>\n  core._stringbool(\n    {\n      Pipe: ZodMiniPipe,\n      Boolean: ZodMiniBoolean,\n      String: ZodMiniString,\n      Transform: ZodMiniTransform,\n    },\n    ...args\n  ) as any;\n\n// json\n\n// json\ntype _ZodMiniJSONSchema = ZodMiniUnion<\n  [\n    ZodMiniString,\n    ZodMiniNumber,\n    ZodMiniBoolean,\n    ZodMiniNull,\n    ZodMiniArray<ZodMiniJSONSchema>,\n    ZodMiniRecord<ZodMiniString<string>, ZodMiniJSONSchema>,\n  ]\n>;\ntype _ZodMiniJSONSchemaInternals = _ZodMiniJSONSchema[\"_zod\"];\n\nexport interface ZodMiniJSONSchemaInternals extends _ZodMiniJSONSchemaInternals {\n  output: util.JSONType;\n  input: util.JSONType;\n}\nexport interface ZodMiniJSONSchema extends _ZodMiniJSONSchema {\n  _zod: ZodMiniJSONSchemaInternals;\n}\n\nexport function json(): ZodMiniJSONSchema {\n  const jsonSchema: any = _lazy(() => {\n    return union([string(), number(), boolean(), _null(), array(jsonSchema), record(string(), jsonSchema)]);\n  });\n  return jsonSchema;\n}\n",
    "symbols": [
      {
        "name": "string",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 92,
        "endLine": 94
      },
      {
        "name": "email",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 120,
        "endLine": 122
      },
      {
        "name": "guid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 136,
        "endLine": 138
      },
      {
        "name": "uuid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 152,
        "endLine": 154
      },
      {
        "name": "uuidv4",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 156,
        "endLine": 158
      },
      {
        "name": "uuidv6",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 162,
        "endLine": 164
      },
      {
        "name": "uuidv7",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 168,
        "endLine": 170
      },
      {
        "name": "url",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 181,
        "endLine": 183
      },
      {
        "name": "emoji",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 197,
        "endLine": 199
      },
      {
        "name": "nanoid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 213,
        "endLine": 215
      },
      {
        "name": "cuid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 229,
        "endLine": 231
      },
      {
        "name": "cuid2",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 245,
        "endLine": 247
      },
      {
        "name": "ulid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 261,
        "endLine": 263
      },
      {
        "name": "xid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 274,
        "endLine": 276
      },
      {
        "name": "ksuid",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 290,
        "endLine": 292
      },
      {
        "name": "ipv4",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 306,
        "endLine": 308
      },
      {
        "name": "ipv6",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 322,
        "endLine": 324
      },
      {
        "name": "cidrv4",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 338,
        "endLine": 340
      },
      {
        "name": "cidrv6",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 354,
        "endLine": 356
      },
      {
        "name": "base64",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 369,
        "endLine": 371
      },
      {
        "name": "base64url",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 384,
        "endLine": 386
      },
      {
        "name": "e164",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 400,
        "endLine": 402
      },
      {
        "name": "jwt",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 413,
        "endLine": 415
      },
      {
        "name": "stringFormat",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 431,
        "endLine": 437
      },
      {
        "name": "number",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 456,
        "endLine": 458
      },
      {
        "name": "int",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 472,
        "endLine": 474
      },
      {
        "name": "float32",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 478,
        "endLine": 480
      },
      {
        "name": "float64",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 484,
        "endLine": 486
      },
      {
        "name": "int32",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 490,
        "endLine": 492
      },
      {
        "name": "uint32",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 496,
        "endLine": 498
      },
      {
        "name": "boolean",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 512,
        "endLine": 514
      },
      {
        "name": "bigint",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 528,
        "endLine": 530
      },
      {
        "name": "int64",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 548,
        "endLine": 550
      },
      {
        "name": "uint64",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 554,
        "endLine": 556
      },
      {
        "name": "symbol",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 570,
        "endLine": 572
      },
      {
        "name": "_undefined",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 586,
        "endLine": 588
      },
      {
        "name": "_null",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 603,
        "endLine": 605
      },
      {
        "name": "any",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 617,
        "endLine": 619
      },
      {
        "name": "unknown",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 633,
        "endLine": 635
      },
      {
        "name": "never",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 649,
        "endLine": 651
      },
      {
        "name": "_void",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 665,
        "endLine": 667
      },
      {
        "name": "date",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 683,
        "endLine": 685
      },
      {
        "name": "array",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 701,
        "endLine": 701
      },
      {
        "name": "array",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 702,
        "endLine": 708
      },
      {
        "name": "keyof",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 711,
        "endLine": 714
      },
      {
        "name": "object",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 733,
        "endLine": 746
      },
      {
        "name": "strictObject",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 749,
        "endLine": 763
      },
      {
        "name": "looseObject",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 766,
        "endLine": 783
      },
      {
        "name": "extend",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 786,
        "endLine": 791
      },
      {
        "name": "merge",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 794,
        "endLine": 797
      },
      {
        "name": "merge",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 798,
        "endLine": 800
      },
      {
        "name": "pick",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 802,
        "endLine": 807
      },
      {
        "name": "omit",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 811,
        "endLine": 816
      },
      {
        "name": "partial",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 818,
        "endLine": 825
      },
      {
        "name": "partial",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 826,
        "endLine": 834
      },
      {
        "name": "partial",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 835,
        "endLine": 837
      },
      {
        "name": "required",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 850,
        "endLine": 857
      },
      {
        "name": "required",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 858,
        "endLine": 869
      },
      {
        "name": "required",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 870,
        "endLine": 872
      },
      {
        "name": "catchall",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 874,
        "endLine": 879
      },
      {
        "name": "union",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 894,
        "endLine": 903
      },
      {
        "name": "discriminatedUnion",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 918,
        "endLine": 931
      },
      {
        "name": "intersection",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 946,
        "endLine": 952
      },
      {
        "name": "tuple",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 969,
        "endLine": 972
      },
      {
        "name": "tuple",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 973,
        "endLine": 977
      },
      {
        "name": "tuple",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 978,
        "endLine": 978
      },
      {
        "name": "tuple",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 979,
        "endLine": 993
      },
      {
        "name": "record",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1010,
        "endLine": 1021
      },
      {
        "name": "partialRecord",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1022,
        "endLine": 1033
      },
      {
        "name": "map",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1045,
        "endLine": 1056
      },
      {
        "name": "set",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1067,
        "endLine": 1073
      },
      {
        "name": "_enum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1087,
        "endLine": 1090
      },
      {
        "name": "_enum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1091,
        "endLine": 1091
      },
      {
        "name": "_enum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1092,
        "endLine": 1100
      },
      {
        "name": "nativeEnum",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1110,
        "endLine": 1116
      },
      {
        "name": "literal",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1131,
        "endLine": 1134
      },
      {
        "name": "literal",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1135,
        "endLine": 1138
      },
      {
        "name": "literal",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1139,
        "endLine": 1145
      },
      {
        "name": "file",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1159,
        "endLine": 1161
      },
      {
        "name": "transform",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1175,
        "endLine": 1182
      },
      {
        "name": "optional",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1198,
        "endLine": 1203
      },
      {
        "name": "nullable",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1218,
        "endLine": 1223
      },
      {
        "name": "nullish",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1226,
        "endLine": 1228
      },
      {
        "name": "_default",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1242,
        "endLine": 1253
      },
      {
        "name": "prefault",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1267,
        "endLine": 1278
      },
      {
        "name": "nonoptional",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1293,
        "endLine": 1302
      },
      {
        "name": "success",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1316,
        "endLine": 1321
      },
      {
        "name": "_catch",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1335,
        "endLine": 1346
      },
      {
        "name": "nan",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1358,
        "endLine": 1360
      },
      {
        "name": "pipe",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1375,
        "endLine": 1384
      },
      {
        "name": "readonly",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1408,
        "endLine": 1413
      },
      {
        "name": "templateLiteral",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1428,
        "endLine": 1437
      },
      {
        "name": "_lazy",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1454,
        "endLine": 1459
      },
      {
        "name": "promise",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1474,
        "endLine": 1479
      },
      {
        "name": "check",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1494,
        "endLine": 1502
      },
      {
        "name": "custom",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1506,
        "endLine": 1511
      },
      {
        "name": "refine",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1514,
        "endLine": 1519
      },
      {
        "name": "Class",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1522,
        "endLine": 1524
      },
      {
        "name": "_instanceof",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1525,
        "endLine": 1534
      },
      {
        "name": "json",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/schemas.ts",
        "startLine": 1574,
        "endLine": 1579
      }
    ]
  },
  {
    "path": "node_modules/madge/test/typescript/custom-paths/subfolder/index.ts",
    "content": "export default 42;\n",
    "symbols": []
  },
  {
    "path": "node_modules/madge/test/typescript/custom-paths/subfolder2/export.ts",
    "content": "class ExportClass {\n\tstringLength(s: string) {\n\t\treturn s.length;\n\t}\n}\n\nexport = ExportClass;\n",
    "symbols": [
      {
        "name": "ExportClass",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/custom-paths/subfolder2/export.ts",
        "startLine": 1,
        "endLine": 5
      },
      {
        "name": "ExportClass.stringLength",
        "kind": "method",
        "file": "C:/Users/Vipac/Desktop/final_project/node_modules/madge/test/typescript/custom-paths/subfolder2/export.ts",
        "startLine": 2,
        "endLine": 4
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/anyunknown.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"check any inference\", () => {\n  const t1 = z.any();\n  t1.optional();\n  t1.nullable();\n  type t1 = z.infer<typeof t1>;\n  expectTypeOf<t1>().toEqualTypeOf<any>();\n});\n\ntest(\"check unknown inference\", () => {\n  const t1 = z.unknown();\n  t1.optional();\n  t1.nullable();\n  type t1 = z.infer<typeof t1>;\n  expectTypeOf<t1>().toEqualTypeOf<unknown>();\n});\n\ntest(\"check never inference\", () => {\n  const t1 = z.never();\n  expect(() => t1.parse(undefined)).toThrow();\n  expect(() => t1.parse(\"asdf\")).toThrow();\n  expect(() => t1.parse(null)).toThrow();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/array.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"type inference\", () => {\n  const schema = z.string().array();\n  expectTypeOf<z.infer<typeof schema>>().toEqualTypeOf<string[]>();\n});\n\ntest(\"array min/max\", async () => {\n  const schema = z.array(z.string()).min(2).max(2);\n  const r1 = await schema.safeParse([\"asdf\"]);\n  expect(r1.success).toEqual(false);\n  expect(r1.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"too_small\",\n        \"inclusive\": true,\n        \"message\": \"Too small: expected array to have >=2 items\",\n        \"minimum\": 2,\n        \"origin\": \"array\",\n        \"path\": [],\n      },\n    ]\n  `);\n\n  const r2 = await schema.safeParse([\"asdf\", \"asdf\", \"asdf\"]);\n  expect(r2.success).toEqual(false);\n  expect(r2.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"too_big\",\n        \"inclusive\": true,\n        \"maximum\": 2,\n        \"message\": \"Too big: expected array to have <=2 items\",\n        \"origin\": \"array\",\n        \"path\": [],\n      },\n    ]\n  `);\n});\n\ntest(\"array length\", async () => {\n  const schema = z.array(z.string()).length(2);\n  schema.parse([\"asdf\", \"asdf\"]);\n\n  const r1 = await schema.safeParse([\"asdf\"]);\n  expect(r1.success).toEqual(false);\n  expect(r1.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"too_small\",\n        \"exact\": true,\n        \"inclusive\": true,\n        \"message\": \"Too small: expected array to have >=2 items\",\n        \"minimum\": 2,\n        \"origin\": \"array\",\n        \"path\": [],\n      },\n    ]\n  `);\n\n  const r2 = await schema.safeParse([\"asdf\", \"asdf\", \"asdf\"]);\n  expect(r2.success).toEqual(false);\n  expect(r2.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"too_big\",\n        \"exact\": true,\n        \"inclusive\": true,\n        \"maximum\": 2,\n        \"message\": \"Too big: expected array to have <=2 items\",\n        \"origin\": \"array\",\n        \"path\": [],\n      },\n    ]\n  `);\n});\n\ntest(\"array.nonempty()\", () => {\n  const schema = z.string().array().nonempty();\n  schema.parse([\"a\"]);\n  expect(() => schema.parse([])).toThrow();\n});\n\ntest(\"array.nonempty().max()\", () => {\n  const schema = z.string().array().nonempty().max(2);\n  schema.parse([\"a\"]);\n  expect(() => schema.parse([])).toThrow();\n  expect(() => schema.parse([\"a\", \"a\", \"a\"])).toThrow();\n});\n\ntest(\"parse empty array in nonempty\", () => {\n  expect(() =>\n    z\n      .array(z.string())\n      .nonempty()\n      .parse([] as any)\n  ).toThrow();\n});\n\ntest(\"get element\", () => {\n  const schema = z.string().array();\n  schema.element.parse(\"asdf\");\n  expect(() => schema.element.parse(12)).toThrow();\n});\n\ntest(\"continue parsing despite array size error\", () => {\n  const schema = z.object({\n    people: z.string().array().min(2),\n  });\n\n  const result = schema.safeParse({\n    people: [123],\n  });\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"people\",\n          0\n        ],\n        \"message\": \"Invalid input: expected string, received number\"\n      },\n      {\n        \"origin\": \"array\",\n        \"code\": \"too_small\",\n        \"minimum\": 2,\n        \"inclusive\": true,\n        \"path\": [\n          \"people\"\n        ],\n        \"message\": \"Too small: expected array to have >=2 items\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"parse should fail given sparse array\", () => {\n  const schema = z.array(z.string()).nonempty().min(1).max(3);\n  const result = schema.safeParse(new Array(3));\n  expect(result.success).toEqual(false);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          0\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      },\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          1\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      },\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          2\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\n// const unique = z.string().array().unique();\n// const uniqueArrayOfObjects = z.array(z.object({ name: z.string() })).unique({ identifier: (item) => item.name });\n\n// test(\"passing unique validation\", () => {\n//   unique.parse([\"a\", \"b\", \"c\"]);\n//   uniqueArrayOfObjects.parse([{ name: \"Leo\" }, { name: \"Joe\" }]);\n// });\n\n// test(\"failing unique validation\", () => {\n//   expect(() => unique.parse([\"a\", \"a\", \"b\"])).toThrow();\n//   expect(() => uniqueArrayOfObjects.parse([{ name: \"Leo\" }, { name: \"Leo\" }])).toThrow();\n// });\n\n// test(\"continue parsing despite array of primitives uniqueness error\", () => {\n//   const schema = z.number().array().unique();\n\n//   const result = schema.safeParse([1, 1, 2, 2, 3]);\n\n//   expect(result.success).toEqual(false);\n//   if (!result.success) {\n//     const issue = result.error.issues.find(({ code }) => code === \"not_unique\");\n//     expect(issue?.message).toEqual(\"Values must be unique\");\n//   }\n// });\n\n// test(\"continue parsing despite array of objects not_unique error\", () => {\n//   const schema = z.array(z.object({ name: z.string() })).unique({\n//     identifier: (item) => item.name,\n//     showDuplicates: true,\n//   });\n\n//   const result = schema.safeParse([\n//     { name: \"Leo\" },\n//     { name: \"Joe\" },\n//     { name: \"Leo\" },\n//   ]);\n\n//   expect(result.success).toEqual(false);\n//   if (!result.success) {\n//     const issue = result.error.issues.find(({ code }) => code === \"not_unique\");\n//     expect(issue?.message).toEqual(\"Element(s): 'Leo' not unique\");\n//   }\n// });\n\n// test(\"returns custom error message without duplicate elements\", () => {\n//   const schema = z.number().array().unique({ message: \"Custom message\" });\n\n//   const result = schema.safeParse([1, 1, 2, 2, 3]);\n\n//   expect(result.success).toEqual(false);\n//   if (!result.success) {\n//     const issue = result.error.issues.find(({ code }) => code === \"not_unique\");\n//     expect(issue?.message).toEqual(\"Custom message\");\n//   }\n// });\n\n// test(\"returns error message with duplicate elements\", () => {\n//   const schema = z.number().array().unique({ showDuplicates: true });\n\n//   const result = schema.safeParse([1, 1, 2, 2, 3]);\n\n//   expect(result.success).toEqual(false);\n//   if (!result.success) {\n//     const issue = result.error.issues.find(({ code }) => code === \"not_unique\");\n//     expect(issue?.message).toEqual(\"Element(s): '1,2' not unique\");\n//   }\n// });\n\n// test(\"returns custom error message with duplicate elements\", () => {\n//   const schema = z\n//     .number()\n//     .array()\n//     .unique({\n//       message: (item) => `Custom message: '${item}' are not unique`,\n//       showDuplicates: true,\n//     });\n\n//   const result = schema.safeParse([1, 1, 2, 2, 3]);\n\n//   expect(result.success).toEqual(false);\n//   if (!result.success) {\n//     const issue = result.error.issues.find(({ code }) => code === \"not_unique\");\n//     expect(issue?.message).toEqual(\"Custom message: '1,2' are not unique\");\n//   }\n// });\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/assignability.test.ts",
    "content": "import { expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"assignability\", () => {\n  // $ZodString\n  z.string() satisfies z.core.$ZodString;\n  z.string() satisfies z.ZodString;\n\n  // $ZodNumber\n  z.number() satisfies z.core.$ZodNumber;\n  z.number() satisfies z.ZodNumber;\n\n  // $ZodBigInt\n  z.bigint() satisfies z.core.$ZodBigInt;\n  z.bigint() satisfies z.ZodBigInt;\n\n  // $ZodBoolean\n  z.boolean() satisfies z.core.$ZodBoolean;\n  z.boolean() satisfies z.ZodBoolean;\n\n  // $ZodDate\n  z.date() satisfies z.core.$ZodDate;\n  z.date() satisfies z.ZodDate;\n\n  // $ZodSymbol\n  z.symbol() satisfies z.core.$ZodSymbol;\n  z.symbol() satisfies z.ZodSymbol;\n\n  // $ZodUndefined\n  z.undefined() satisfies z.core.$ZodUndefined;\n  z.undefined() satisfies z.ZodUndefined;\n\n  // $ZodNullable\n  z.string().nullable() satisfies z.core.$ZodNullable;\n  z.string().nullable() satisfies z.ZodNullable;\n\n  // $ZodNull\n  z.null() satisfies z.core.$ZodNull;\n  z.null() satisfies z.ZodNull;\n\n  // $ZodAny\n  z.any() satisfies z.core.$ZodAny;\n  z.any() satisfies z.ZodAny;\n\n  // $ZodUnknown\n  z.unknown() satisfies z.core.$ZodUnknown;\n  z.unknown() satisfies z.ZodUnknown;\n\n  // $ZodNever\n  z.never() satisfies z.core.$ZodNever;\n  z.never() satisfies z.ZodNever;\n\n  // $ZodVoid\n  z.void() satisfies z.core.$ZodVoid;\n  z.void() satisfies z.ZodVoid;\n\n  // $ZodArray\n  z.array(z.string()) satisfies z.core.$ZodArray;\n  z.array(z.string()) satisfies z.ZodArray;\n  z.array(z.string()) satisfies z.ZodType<Array<unknown>>;\n\n  // $ZodObject\n  z.object({ key: z.string() }) satisfies z.core.$ZodObject;\n  z.object({ key: z.string() }) satisfies z.ZodObject<{ key: z.ZodType }>;\n  z.object({ key: z.string() }) satisfies z.ZodType<{ key: string }>;\n\n  // $ZodUnion\n  z.union([z.string(), z.number()]) satisfies z.core.$ZodUnion;\n  z.union([z.string(), z.number()]) satisfies z.ZodUnion;\n  z.union([z.string(), z.number()]) satisfies z.ZodType<string | number>;\n\n  // $ZodIntersection\n  z.intersection(z.string(), z.number()) satisfies z.core.$ZodIntersection;\n  z.intersection(z.string(), z.number()) satisfies z.ZodIntersection;\n\n  // $ZodTuple\n  z.tuple([z.string(), z.number()]) satisfies z.core.$ZodTuple;\n  z.tuple([z.string(), z.number()]) satisfies z.ZodTuple;\n\n  // $ZodRecord\n  z.record(z.string(), z.number()) satisfies z.core.$ZodRecord;\n  z.record(z.string(), z.number()) satisfies z.ZodRecord;\n\n  // $ZodMap\n  z.map(z.string(), z.number()) satisfies z.core.$ZodMap;\n  z.map(z.string(), z.number()) satisfies z.ZodMap;\n\n  // $ZodSet\n  z.set(z.string()) satisfies z.core.$ZodSet;\n  z.set(z.string()) satisfies z.ZodSet;\n\n  // $ZodLiteral\n  z.literal(\"example\") satisfies z.core.$ZodLiteral;\n  z.literal(\"example\") satisfies z.ZodLiteral;\n\n  // $ZodEnum\n  z.enum([\"a\", \"b\", \"c\"]) satisfies z.core.$ZodEnum;\n  z.enum([\"a\", \"b\", \"c\"]) satisfies z.ZodEnum;\n\n  // $ZodPromise\n  z.promise(z.string()) satisfies z.core.$ZodPromise;\n  z.promise(z.string()) satisfies z.ZodPromise;\n\n  // $ZodLazy\n  const lazySchema = z.lazy(() => z.string());\n  lazySchema satisfies z.core.$ZodLazy;\n  lazySchema satisfies z.ZodLazy;\n\n  // $ZodOptional\n  z.string().optional() satisfies z.core.$ZodOptional;\n  z.string().optional() satisfies z.ZodOptional;\n\n  // $ZodDefault\n  z.string().default(\"default\") satisfies z.core.$ZodDefault;\n  z.string().default(\"default\") satisfies z.ZodDefault;\n\n  // $ZodTemplateLiteral\n  z.templateLiteral([z.literal(\"a\"), z.literal(\"b\")]) satisfies z.core.$ZodTemplateLiteral;\n  z.templateLiteral([z.literal(\"a\"), z.literal(\"b\")]) satisfies z.ZodTemplateLiteral;\n\n  // $ZodCustom\n  z.custom<string>((val) => typeof val === \"string\") satisfies z.core.$ZodCustom;\n  z.custom<string>((val) => typeof val === \"string\") satisfies z.ZodCustom;\n\n  // $ZodTransform\n  z.transform((val) => val as string) satisfies z.core.$ZodTransform;\n  z.transform((val) => val as string) satisfies z.ZodTransform;\n\n  // $ZodNonOptional\n  z.string().optional().nonoptional() satisfies z.core.$ZodNonOptional;\n  z.string().optional().nonoptional() satisfies z.ZodNonOptional;\n\n  // $ZodReadonly\n  z.object({ key: z.string() }).readonly() satisfies z.core.$ZodReadonly;\n  z.object({ key: z.string() }).readonly() satisfies z.ZodReadonly;\n\n  // $ZodNaN\n  z.nan() satisfies z.core.$ZodNaN;\n  z.nan() satisfies z.ZodNaN;\n\n  // $ZodPipe\n  z.unknown().pipe(z.number()) satisfies z.core.$ZodPipe;\n  z.unknown().pipe(z.number()) satisfies z.ZodPipe;\n\n  // $ZodSuccess\n  z.success(z.string()) satisfies z.core.$ZodSuccess;\n  z.success(z.string()) satisfies z.ZodSuccess;\n\n  // $ZodCatch\n  z.string().catch(\"fallback\") satisfies z.core.$ZodCatch;\n  z.string().catch(\"fallback\") satisfies z.ZodCatch;\n\n  // $ZodFile\n  z.file() satisfies z.core.$ZodFile;\n  z.file() satisfies z.ZodFile;\n});\n\ntest(\"checks\", () => {\n  const _a: z.core.$ZodCheck = {} as any as z.core.$ZodChecks;\n  const _b: z.core.$ZodCheck = {} as any as z.core.$ZodStringFormatChecks;\n  const _c: z.core.$ZodType = {} as any as z.core.$ZodTypes;\n  const _d: z.core.$ZodType = {} as any as z.core.$ZodStringFormatTypes;\n});\n\ntest(\"assignability to $ZodType\", () => {\n  z.string() satisfies z.ZodType;\n  z.number() satisfies z.ZodType;\n  z.boolean() satisfies z.ZodType;\n  z.object({ key: z.string() }) satisfies z.ZodType;\n  z.object({ key: z.string() }) satisfies z.ZodType<{ key: string }>;\n  z.array(z.string()) satisfies z.ZodType;\n  z.union([z.string(), z.number()]) satisfies z.ZodType;\n  z.intersection(z.string(), z.number()) satisfies z.ZodType;\n  z.tuple([z.string(), z.number()]) satisfies z.ZodType;\n  z.record(z.string(), z.number()) satisfies z.ZodType;\n  z.map(z.string(), z.number()) satisfies z.ZodType;\n  z.set(z.string()) satisfies z.ZodType;\n  z.literal(\"example\") satisfies z.ZodType;\n\n  expectTypeOf<z.ZodType extends z.core.$ZodType ? true : false>().toEqualTypeOf<true>();\n});\n\ntest(\"assignability with narrowing\", () => {\n  type _RefinedSchema<T extends z.ZodType<object> | z.ZodUnion> = T extends z.ZodUnion\n    ? RefinedUnionSchema<T> // <-- Type instantiation is excessively deep and possibly infinite.\n    : T extends z.ZodType<object>\n      ? RefinedTypeSchema<z.output<T>> // <-- Type instantiation is excessively deep and possibly infinite.\n      : never;\n\n  type RefinedTypeSchema<T extends object> = T;\n\n  type RefinedUnionSchema<T extends z.ZodUnion> = T;\n});\n\ntest(\"generic assignability in objects\", () => {\n  interface SortItem<T extends string> {\n    key: T;\n    order: string;\n  }\n\n  const createSortItemSchema = <T extends z.ZodType<string>>(sortKeySchema: T) =>\n    z.object({\n      key: sortKeySchema,\n      order: z.string(),\n    });\n\n  <T extends z.ZodType<string>>(sortKeySchema: T, defaultSortBy: SortItem<z.output<T>>[] = []) =>\n    createSortItemSchema(sortKeySchema).array().default(defaultSortBy);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/async-parsing.test.ts",
    "content": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\n/// string\nconst stringSchema = z.string();\n\ntest(\"string async parse\", async () => {\n  const goodData = \"XXX\";\n  const badData = 12;\n\n  const goodResult = await stringSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await stringSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// number\nconst numberSchema = z.number();\ntest(\"number async parse\", async () => {\n  const goodData = 1234.2353;\n  const badData = \"1234\";\n\n  const goodResult = await numberSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await numberSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// bigInt\nconst bigIntSchema = z.bigint();\ntest(\"bigInt async parse\", async () => {\n  const goodData = BigInt(145);\n  const badData = 134;\n\n  const goodResult = await bigIntSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await bigIntSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// boolean\nconst booleanSchema = z.boolean();\ntest(\"boolean async parse\", async () => {\n  const goodData = true;\n  const badData = 1;\n\n  const goodResult = await booleanSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await booleanSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// date\nconst dateSchema = z.date();\ntest(\"date async parse\", async () => {\n  const goodData = new Date();\n  const badData = new Date().toISOString();\n\n  const goodResult = await dateSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await dateSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// undefined\nconst undefinedSchema = z.undefined();\ntest(\"undefined async parse\", async () => {\n  const goodData = undefined;\n  const badData = \"XXX\";\n\n  const goodResult = await undefinedSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(undefined);\n\n  const badResult = await undefinedSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// null\nconst nullSchema = z.null();\ntest(\"null async parse\", async () => {\n  const goodData = null;\n  const badData = undefined;\n\n  const goodResult = await nullSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await nullSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// any\nconst anySchema = z.any();\ntest(\"any async parse\", async () => {\n  const goodData = [{}];\n  // const badData = 'XXX';\n\n  const goodResult = await anySchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  // const badResult = await anySchema.safeParseAsync(badData);\n  // expect(badResult.success).toBe(false);\n  // if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// unknown\nconst unknownSchema = z.unknown();\ntest(\"unknown async parse\", async () => {\n  const goodData = [\"asdf\", 124, () => {}];\n  // const badData = 'XXX';\n\n  const goodResult = await unknownSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  // const badResult = await unknownSchema.safeParseAsync(badData);\n  // expect(badResult.success).toBe(false);\n  // if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// void\nconst voidSchema = z.void();\ntest(\"void async parse\", async () => {\n  const goodData = undefined;\n  const badData = 0;\n\n  const goodResult = await voidSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await voidSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// array\nconst arraySchema = z.array(z.string());\ntest(\"array async parse\", async () => {\n  const goodData = [\"XXX\"];\n  const badData = \"XXX\";\n\n  const goodResult = await arraySchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await arraySchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// object\nconst objectSchema = z.object({ string: z.string() });\ntest(\"object async parse\", async () => {\n  const goodData = { string: \"XXX\" };\n  const badData = { string: 12 };\n\n  const goodResult = await objectSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await objectSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// union\nconst unionSchema = z.union([z.string(), z.undefined()]);\ntest(\"union async parse\", async () => {\n  const goodData = undefined;\n  const badData = null;\n\n  const goodResult = await unionSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await unionSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// record\nconst recordSchema = z.record(z.string(), z.object({}));\ntest(\"record async parse\", async () => {\n  const goodData = { adsf: {}, asdf: {} };\n  const badData = [{}];\n\n  const goodResult = await recordSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await recordSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// function\n// const functionSchema = z.function();\n// test(\"function async parse\", async () => {\n//   const goodData = () => {};\n//   const badData = \"XXX\";\n\n//   const goodResult = await functionSchema.safeParseAsync(goodData);\n//   expect(goodResult.success).toBe(true);\n//   if (goodResult.success) expect(typeof goodResult.data).toEqual(\"function\");\n\n//   const badResult = await functionSchema.safeParseAsync(badData);\n//   expect(badResult.success).toBe(false);\n//   if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n// });\n\n/// literal\nconst literalSchema = z.literal(\"asdf\");\ntest(\"literal async parse\", async () => {\n  const goodData = \"asdf\";\n  const badData = \"asdff\";\n\n  const goodResult = await literalSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await literalSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// enum\nconst enumSchema = z.enum([\"fish\", \"whale\"]);\ntest(\"enum async parse\", async () => {\n  const goodData = \"whale\";\n  const badData = \"leopard\";\n\n  const goodResult = await enumSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await enumSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// nativeEnum\nenum nativeEnumTest {\n  asdf = \"qwer\",\n}\n// @ts-ignore\nconst nativeEnumSchema = z.nativeEnum(nativeEnumTest);\ntest(\"nativeEnum async parse\", async () => {\n  const goodData = nativeEnumTest.asdf;\n  const badData = \"asdf\";\n\n  const goodResult = await nativeEnumSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  if (goodResult.success) expect(goodResult.data).toEqual(goodData);\n\n  const badResult = await nativeEnumSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\n/// promise\nconst promiseSchema = z.promise(z.number());\ntest(\"promise async parse good\", async () => {\n  const goodData = Promise.resolve(123);\n\n  const goodResult = await promiseSchema.safeParseAsync(goodData);\n  expect(goodResult.success).toBe(true);\n  expect(typeof goodResult.data).toEqual(\"number\");\n  expect(goodResult.data).toEqual(123);\n});\n\ntest(\"promise async parse bad\", async () => {\n  const badData = Promise.resolve(\"XXX\");\n  const badResult = await promiseSchema.safeParseAsync(badData);\n  expect(badResult.success).toBe(false);\n  expect(badResult.error).toBeInstanceOf(z.ZodError);\n});\n\ntest(\"async validation non-empty strings\", async () => {\n  const base = z.object({\n    hello: z.string().refine((x) => x && x.length > 0),\n    foo: z.string().refine((x) => x && x.length > 0),\n  });\n\n  const testval = { hello: \"\", foo: \"\" };\n  const result1 = base.safeParse(testval);\n  const result2 = base.safeParseAsync(testval);\n\n  const r1 = result1;\n  await result2.then((r2) => {\n    expect(r1.error!.issues.length).toBe(r2.error!.issues.length);\n  });\n});\n\ntest(\"async validation multiple errors 1\", async () => {\n  const base = z.object({\n    hello: z.string(),\n    foo: z.number(),\n  });\n\n  const testval = { hello: 3, foo: \"hello\" };\n  const result1 = base.safeParse(testval);\n  const result2 = base.safeParseAsync(testval);\n\n  await result2.then((result2) => {\n    expect(result2.error!.issues.length).toBe(result1.error!.issues.length);\n  });\n});\n\ntest(\"async validation multiple errors 2\", async () => {\n  const base = (is_async?: boolean) =>\n    z.object({\n      hello: z.string(),\n      foo: z.object({\n        bar: z.number().refine(\n          is_async\n            ? async () =>\n                new Promise((resolve) => {\n                  setTimeout(() => resolve(false), 500);\n                })\n            : () => false\n        ),\n      }),\n    });\n\n  const testval = { hello: 3, foo: { bar: 4 } };\n  const result1 = base().safeParse(testval);\n  const result2 = base(true).safeParseAsync(testval);\n\n  await result2.then((result2) => {\n    expect(result1.error!.issues.length).toBe(result2.error!.issues.length);\n  });\n});\n\ntest(\"ensure early async failure prevents follow-up refinement checks\", async () => {\n  let count = 0;\n  const base = z.object({\n    hello: z.string(),\n    foo: z\n      .number()\n      .refine(async () => {\n        count++;\n        return true;\n      })\n      .refine(async () => {\n        count++;\n        return true;\n      }, \"Good\"),\n  });\n\n  const testval = { hello: \"bye\", foo: 3 };\n  const result = await base.safeParseAsync(testval);\n  if (result.success === false) {\n    expect(result.error.issues.length).toBe(1);\n    expect(count).toBe(1);\n  }\n\n  // await result.then((r) => {\n  //   if (r.success === false) expect(r.error.issues.length).toBe(1);\n  //   expect(count).toBe(2);\n  // });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/async-refinements.test.ts",
    "content": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"async refine .parse()\", async () => {\n  // throws ZodAsyncError\n  const s1 = z.string().refine(async (_val) => true);\n  expect(() => s1.safeParse(\"asdf\")).toThrow();\n});\n\ntest(\"async refine\", async () => {\n  const s1 = z.string().refine(async (_val) => true);\n  const r1 = await s1.parseAsync(\"asdf\");\n  expect(r1).toEqual(\"asdf\");\n\n  const s2 = z.string().refine(async (_val) => false);\n  const r2 = await s2.safeParseAsync(\"asdf\");\n  expect(r2.success).toBe(false);\n  expect(r2).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"async refine with Promises\", async () => {\n  // expect.assertions(2);\n\n  const schema1 = z.string().refine((_val) => Promise.resolve(true));\n  const v1 = await schema1.parseAsync(\"asdf\");\n  expect(v1).toEqual(\"asdf\");\n\n  const schema2 = z.string().refine((_val) => Promise.resolve(false));\n  await expect(schema2.parseAsync(\"asdf\")).rejects.toBeDefined();\n\n  const schema3 = z.string().refine((_val) => Promise.resolve(true));\n  await expect(schema3.parseAsync(\"asdf\")).resolves.toEqual(\"asdf\");\n  return await expect(schema3.parseAsync(\"qwer\")).resolves.toEqual(\"qwer\");\n});\n\ntest(\"async refine that uses value\", async () => {\n  const schema1 = z.string().refine(async (val) => {\n    return val.length > 5;\n  });\n\n  const r1 = await schema1.safeParseAsync(\"asdf\");\n  expect(r1.success).toBe(false);\n  expect(r1.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]]\n  `);\n\n  const r2 = await schema1.safeParseAsync(\"asdf123\");\n  expect(r2.success).toBe(true);\n  expect(r2.data).toEqual(\"asdf123\");\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/base.test.ts",
    "content": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"test this binding\", () => {\n  const parse = z.string().parse;\n  expect(parse(\"asdf\")).toBe(\"asdf\");\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/bigint.test.ts",
    "content": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\nconst gtFive = z.bigint().gt(BigInt(5));\nconst gteFive = z.bigint().gte(BigInt(5));\nconst ltFive = z.bigint().lt(BigInt(5));\nconst lteFive = z.bigint().lte(BigInt(5));\nconst positive = z.bigint().positive();\nconst negative = z.bigint().negative();\nconst nonnegative = z.bigint().nonnegative();\nconst nonpositive = z.bigint().nonpositive();\nconst multipleOfFive = z.bigint().multipleOf(BigInt(5));\n\ntest(\"passing validations\", () => {\n  z.bigint().parse(BigInt(1));\n  z.bigint().parse(BigInt(0));\n  z.bigint().parse(BigInt(-1));\n  gtFive.parse(BigInt(6));\n  gteFive.parse(BigInt(5));\n  gteFive.parse(BigInt(6));\n  ltFive.parse(BigInt(4));\n  lteFive.parse(BigInt(5));\n  lteFive.parse(BigInt(4));\n  positive.parse(BigInt(3));\n  negative.parse(BigInt(-2));\n  nonnegative.parse(BigInt(0));\n  nonnegative.parse(BigInt(7));\n  nonpositive.parse(BigInt(0));\n  nonpositive.parse(BigInt(-12));\n  multipleOfFive.parse(BigInt(15));\n});\n\ntest(\"failing validations\", () => {\n  expect(() => gtFive.parse(BigInt(5))).toThrow();\n  expect(() => gteFive.parse(BigInt(4))).toThrow();\n  expect(() => ltFive.parse(BigInt(5))).toThrow();\n  expect(() => lteFive.parse(BigInt(6))).toThrow();\n  expect(() => positive.parse(BigInt(0))).toThrow();\n  expect(() => positive.parse(BigInt(-2))).toThrow();\n  expect(() => negative.parse(BigInt(0))).toThrow();\n  expect(() => negative.parse(BigInt(3))).toThrow();\n  expect(() => nonnegative.parse(BigInt(-1))).toThrow();\n  expect(() => nonpositive.parse(BigInt(1))).toThrow();\n  expect(() => multipleOfFive.parse(BigInt(13))).toThrow();\n});\n\ntest(\"min max getters\", () => {\n  expect(z.bigint().min(BigInt(5)).minValue).toEqual(BigInt(5));\n  expect(z.bigint().min(BigInt(5)).min(BigInt(10)).minValue).toEqual(BigInt(10));\n\n  expect(z.bigint().max(BigInt(5)).maxValue).toEqual(BigInt(5));\n  expect(z.bigint().max(BigInt(5)).max(BigInt(1)).maxValue).toEqual(BigInt(1));\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/brand.test.ts",
    "content": "import { expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"branded types\", () => {\n  const mySchema = z\n    .object({\n      name: z.string(),\n    })\n    .brand<\"superschema\">();\n\n  // simple branding\n  type MySchema = z.infer<typeof mySchema>;\n\n  expectTypeOf<MySchema>().toEqualTypeOf<{ name: string } & z.$brand<\"superschema\">>();\n\n  const doStuff = (arg: MySchema) => arg;\n  doStuff(mySchema.parse({ name: \"hello there\" }));\n\n  // inheritance\n  const extendedSchema = mySchema.brand<\"subschema\">();\n  type ExtendedSchema = z.infer<typeof extendedSchema>;\n  expectTypeOf<ExtendedSchema>().toEqualTypeOf<{ name: string } & z.BRAND<\"superschema\"> & z.BRAND<\"subschema\">>();\n\n  doStuff(extendedSchema.parse({ name: \"hello again\" }));\n\n  // number branding\n  const numberSchema = z.number().brand<42>();\n  type NumberSchema = z.infer<typeof numberSchema>;\n  expectTypeOf<NumberSchema>().toEqualTypeOf<number & { [z.$brand]: { 42: true } }>();\n\n  // symbol branding\n  const MyBrand: unique symbol = Symbol(\"hello\");\n  type MyBrand = typeof MyBrand;\n  const symbolBrand = z.number().brand<\"sup\">().brand<typeof MyBrand>();\n  type SymbolBrand = z.infer<typeof symbolBrand>;\n  // number & { [z.BRAND]: { sup: true, [MyBrand]: true } }\n  expectTypeOf<SymbolBrand>().toEqualTypeOf<number & z.BRAND<\"sup\"> & z.BRAND<MyBrand>>();\n\n  // keeping brands out of input types\n  const age = z.number().brand<\"age\">();\n\n  type Age = z.infer<typeof age>;\n  type AgeInput = z.input<typeof age>;\n\n  expectTypeOf<AgeInput>().not.toEqualTypeOf<Age>();\n  expectTypeOf<number>().toEqualTypeOf<AgeInput>();\n  expectTypeOf<number & z.BRAND<\"age\">>().toEqualTypeOf<Age>();\n\n  // @ts-expect-error\n  doStuff({ name: \"hello there!\" });\n});\n\ntest(\"$branded\", () => {\n  const a = z.string().brand<\"a\">();\n\n  expectTypeOf<typeof a>().toEqualTypeOf<z.core.$ZodBranded<z.ZodString, \"a\">>();\n});\n\ntest(\"branded record\", () => {\n  const recordWithBrandedNumberKeys = z.record(z.string().brand(\"SomeBrand\"), z.number());\n  type recordWithBrandedNumberKeys = z.infer<typeof recordWithBrandedNumberKeys>;\n  expectTypeOf<recordWithBrandedNumberKeys>().toEqualTypeOf<Record<string & z.core.$brand<\"SomeBrand\">, number>>();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/catch.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport { z } from \"zod/v4\";\nimport type { util } from \"zod/v4/core\";\n\ntest(\"basic catch\", () => {\n  expect(z.string().catch(\"default\").parse(undefined)).toBe(\"default\");\n});\n\ntest(\"catch fn does not run when parsing succeeds\", () => {\n  let isCalled = false;\n  const cb = () => {\n    isCalled = true;\n    return \"asdf\";\n  };\n  expect(z.string().catch(cb).parse(\"test\")).toBe(\"test\");\n  expect(isCalled).toEqual(false);\n});\n\ntest(\"basic catch async\", async () => {\n  const result = await z.string().catch(\"default\").parseAsync(1243);\n  expect(result).toBe(\"default\");\n});\n\ntest(\"catch replace wrong types\", () => {\n  expect(z.string().catch(\"default\").parse(true)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(true)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(15)).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse([])).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(new Map())).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse(new Set())).toBe(\"default\");\n  expect(z.string().catch(\"default\").parse({})).toBe(\"default\");\n});\n\ntest(\"catch with transform\", () => {\n  const stringWithDefault = z\n    .string()\n    .transform((val) => val.toUpperCase())\n    .catch(\"default\");\n\n  expect(stringWithDefault.parse(undefined)).toBe(\"default\");\n  expect(stringWithDefault.parse(15)).toBe(\"default\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodCatch);\n  expect(stringWithDefault.unwrap()).toBeInstanceOf(z.ZodPipe);\n  expect(stringWithDefault.unwrap().in).toBeInstanceOf(z.ZodString);\n  expect(stringWithDefault.unwrap().out).toBeInstanceOf(z.ZodTransform);\n\n  type inp = z.input<typeof stringWithDefault>;\n  expectTypeOf<inp>().toEqualTypeOf<string | util.Whatever>();\n  type out = z.output<typeof stringWithDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string>();\n});\n\ntest(\"catch on existing optional\", () => {\n  const stringWithDefault = z.string().optional().catch(\"asdf\");\n  expect(stringWithDefault.parse(undefined)).toBe(undefined);\n  expect(stringWithDefault.parse(15)).toBe(\"asdf\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodCatch);\n  expect(stringWithDefault.unwrap()).toBeInstanceOf(z.ZodOptional);\n  expect(stringWithDefault.unwrap().unwrap()).toBeInstanceOf(z.ZodString);\n\n  type inp = z.input<typeof stringWithDefault>;\n  expectTypeOf<inp>().toEqualTypeOf<string | undefined | util.Whatever>();\n  type out = z.output<typeof stringWithDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string | undefined>();\n});\n\ntest(\"optional on catch\", () => {\n  const stringWithDefault = z.string().catch(\"asdf\").optional();\n\n  type inp = z.input<typeof stringWithDefault>;\n  expectTypeOf<inp>().toEqualTypeOf<string | util.Whatever>();\n  type out = z.output<typeof stringWithDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string | undefined>();\n});\n\ntest(\"complex chain example\", () => {\n  const complex = z\n    .string()\n    .catch(\"asdf\")\n    .transform((val) => `${val}!`)\n    .transform((val) => val.toUpperCase())\n    .catch(\"qwer\")\n    .unwrap()\n    .optional()\n    .catch(\"asdfasdf\");\n\n  expect(complex.parse(\"qwer\")).toBe(\"QWER!\");\n  expect(complex.parse(15)).toBe(\"ASDF!\");\n  expect(complex.parse(true)).toBe(\"ASDF!\");\n});\n\ntest(\"removeCatch\", () => {\n  const stringWithRemovedDefault = z.string().catch(\"asdf\").unwrap();\n\n  type out = z.output<typeof stringWithRemovedDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string>();\n});\n\ntest(\"nested\", () => {\n  const inner = z.string().catch(\"asdf\");\n  const outer = z.object({ inner }).catch({\n    inner: \"asdf\",\n  });\n  type input = z.input<typeof outer>;\n  expectTypeOf<input>().toEqualTypeOf<{ inner: string | util.Whatever } | util.Whatever>();\n  type out = z.output<typeof outer>;\n\n  expectTypeOf<out>().toEqualTypeOf<{ inner: string }>();\n  expect(outer.parse(undefined)).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({})).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({ inner: undefined })).toEqual({ inner: \"asdf\" });\n});\n\ntest(\"chained catch\", () => {\n  const stringWithDefault = z.string().catch(\"inner\").catch(\"outer\");\n  const result = stringWithDefault.parse(undefined);\n  expect(result).toEqual(\"inner\");\n  const resultDiff = stringWithDefault.parse(5);\n  expect(resultDiff).toEqual(\"inner\");\n});\n\ntest(\"native enum\", () => {\n  enum Fruits {\n    apple = \"apple\",\n    orange = \"orange\",\n  }\n\n  const schema = z.object({\n    fruit: z.nativeEnum(Fruits).catch(Fruits.apple),\n  });\n\n  expect(schema.parse({})).toEqual({ fruit: Fruits.apple });\n  expect(schema.parse({ fruit: 15 })).toEqual({ fruit: Fruits.apple });\n});\n\ntest(\"enum\", () => {\n  const schema = z.object({\n    fruit: z.enum([\"apple\", \"orange\"]).catch(\"apple\"),\n  });\n\n  expect(schema.parse({})).toEqual({ fruit: \"apple\" });\n  expect(schema.parse({ fruit: true })).toEqual({ fruit: \"apple\" });\n  expect(schema.parse({ fruit: 15 })).toEqual({ fruit: \"apple\" });\n});\n\ntest(\"reported issues with nested usage\", () => {\n  const schema = z.object({\n    string: z.string(),\n    obj: z.object({\n      sub: z.object({\n        lit: z.literal(\"a\"),\n        subCatch: z.number().catch(23),\n      }),\n      midCatch: z.number().catch(42),\n    }),\n    number: z.number().catch(0),\n    bool: z.boolean(),\n  });\n\n  try {\n    schema.parse({\n      string: {},\n      obj: {\n        sub: {\n          lit: \"b\",\n          subCatch: \"24\",\n        },\n        midCatch: 444,\n      },\n      number: \"\",\n      bool: \"yes\",\n    });\n  } catch (error) {\n    const issues = (error as z.ZodError).issues;\n\n    expect(issues.length).toEqual(3);\n    expect(issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"string\",\n          \"message\": \"Invalid input: expected string, received object\",\n          \"path\": [\n            \"string\",\n          ],\n        },\n        {\n          \"code\": \"invalid_value\",\n          \"message\": \"Invalid input: expected \"a\"\",\n          \"path\": [\n            \"obj\",\n            \"sub\",\n            \"lit\",\n          ],\n          \"values\": [\n            \"a\",\n          ],\n        },\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"boolean\",\n          \"message\": \"Invalid input: expected boolean, received string\",\n          \"path\": [\n            \"bool\",\n          ],\n        },\n      ]\n    `);\n    // expect(issues[0].message).toMatch(\"string\");\n    // expect(issues[1].message).toMatch(\"literal\");\n    // expect(issues[2].message).toMatch(\"boolean\");\n  }\n});\n\ntest(\"catch error\", () => {\n  const schema = z.object({\n    age: z.number(),\n    name: z.string().catch((ctx) => {\n      ctx.issues;\n      // issues = ctx.issues;\n\n      return \"John Doe\";\n    }),\n  });\n\n  const result = schema.safeParse({\n    age: null,\n    name: null,\n  });\n\n  expect(result.success).toEqual(false);\n  expect(result.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"age\"\n        ],\n        \"message\": \"Invalid input: expected number, received null\"\n      }\n    ]]\n  `);\n});\n\ntest(\"ctx.input\", () => {\n  const schema = z.string().catch((ctx) => {\n    return String(ctx.input);\n  });\n\n  expect(schema.parse(123)).toEqual(\"123\");\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/coalesce.test.ts",
    "content": "import { expect, test } from \"vitest\";\n\ntest(\"coalesce\", () => {\n  expect(true).toBe(true);\n});\n\n// test(\"nonoptional with default\", () => {\n//   const schema = z.string().optional().coalesce(\"hi\");\n//   expectTypeOf<typeof schema._input>().toEqualTypeOf<string | undefined>();\n//   expectTypeOf<typeof schema._output>().toEqualTypeOf<string>();\n//   expect(schema.parse(undefined)).toBe(\"hi\");\n// });\n\n// test(\"nonoptional in object\", () => {\n//   const schema = z.object({ hi: z.string().optional().nonoptional(\"hi\") });\n\n//   expectTypeOf<typeof schema._input>().toEqualTypeOf<{ hi: string | undefined }>();\n//   expectTypeOf<typeof schema._output>().toEqualTypeOf<{ hi: string }>();\n//   expect(schema.parse(undefined)).toBe(\"hi\");\n// });\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/coerce.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"string coercion\", () => {\n  const schema = z.coerce.string();\n  expect(schema.parse(\"sup\")).toEqual(\"sup\");\n  expect(schema.parse(\"\")).toEqual(\"\");\n  expect(schema.parse(12)).toEqual(\"12\");\n  expect(schema.parse(0)).toEqual(\"0\");\n  expect(schema.parse(-12)).toEqual(\"-12\");\n  expect(schema.parse(3.14)).toEqual(\"3.14\");\n  expect(schema.parse(BigInt(15))).toEqual(\"15\");\n  expect(schema.parse(Number.NaN)).toEqual(\"NaN\");\n  expect(schema.parse(Number.POSITIVE_INFINITY)).toEqual(\"Infinity\");\n  expect(schema.parse(Number.NEGATIVE_INFINITY)).toEqual(\"-Infinity\");\n  expect(schema.parse(true)).toEqual(\"true\");\n  expect(schema.parse(false)).toEqual(\"false\");\n  expect(schema.parse(null)).toEqual(\"null\");\n  expect(schema.parse(undefined)).toEqual(\"undefined\");\n  expect(schema.parse({ hello: \"world!\" })).toEqual(\"[object Object]\");\n  expect(schema.parse([\"item\", \"another_item\"])).toEqual(\"item,another_item\");\n  expect(schema.parse([])).toEqual(\"\");\n  expect(schema.parse(new Date(\"2022-01-01T00:00:00.000Z\"))).toEqual(new Date(\"2022-01-01T00:00:00.000Z\").toString());\n});\n\ntest(\"number coercion\", () => {\n  const schema = z.coerce.number();\n  expect(schema.parse(\"12\")).toEqual(12);\n  expect(schema.parse(\"0\")).toEqual(0);\n  expect(schema.parse(\"-12\")).toEqual(-12);\n  expect(schema.parse(\"3.14\")).toEqual(3.14);\n  expect(schema.parse(\"\")).toEqual(0);\n  expect(() => schema.parse(\"NOT_A_NUMBER\")).toThrow(); // z.ZodError\n  expect(schema.parse(12)).toEqual(12);\n  expect(schema.parse(0)).toEqual(0);\n  expect(schema.parse(-12)).toEqual(-12);\n  expect(schema.parse(3.14)).toEqual(3.14);\n  expect(schema.parse(BigInt(15))).toEqual(15);\n  expect(() => schema.parse(Number.NaN)).toThrow(); // z.ZodError\n  // expect(schema.parse(Number.POSITIVE_INFINITY)).toEqual(Number.POSITIVE_INFINITY);\n  // expect(schema.parse(Number.NEGATIVE_INFINITY)).toEqual(Number.NEGATIVE_INFINITY);\n  expect(schema.parse(true)).toEqual(1);\n  expect(schema.parse(false)).toEqual(0);\n  expect(schema.parse(null)).toEqual(0);\n  expect(() => schema.parse(undefined)).toThrow(); // z.ZodError\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // z.ZodError\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // z.ZodError\n  expect(schema.parse([])).toEqual(0);\n  expect(schema.parse(new Date(1670139203496))).toEqual(1670139203496);\n});\n\ntest(\"boolean coercion\", () => {\n  const schema = z.coerce.boolean();\n  expect(schema.parse(\"true\")).toEqual(true);\n  expect(schema.parse(\"false\")).toEqual(true);\n  expect(schema.parse(\"0\")).toEqual(true);\n  expect(schema.parse(\"1\")).toEqual(true);\n  expect(schema.parse(\"\")).toEqual(false);\n  expect(schema.parse(1)).toEqual(true);\n  expect(schema.parse(0)).toEqual(false);\n  expect(schema.parse(-1)).toEqual(true);\n  expect(schema.parse(3.14)).toEqual(true);\n  expect(schema.parse(BigInt(15))).toEqual(true);\n  expect(schema.parse(Number.NaN)).toEqual(false);\n  expect(schema.parse(Number.POSITIVE_INFINITY)).toEqual(true);\n  expect(schema.parse(Number.NEGATIVE_INFINITY)).toEqual(true);\n  expect(schema.parse(true)).toEqual(true);\n  expect(schema.parse(false)).toEqual(false);\n  expect(schema.parse(null)).toEqual(false);\n  expect(schema.parse(undefined)).toEqual(false);\n  expect(schema.parse({ hello: \"world!\" })).toEqual(true);\n  expect(schema.parse([\"item\", \"another_item\"])).toEqual(true);\n  expect(schema.parse([])).toEqual(true);\n  expect(schema.parse(new Date(1670139203496))).toEqual(true);\n});\n\ntest(\"bigint coercion\", () => {\n  const schema = z.coerce.bigint();\n  expect(schema.parse(\"5\")).toEqual(BigInt(5));\n  expect(schema.parse(\"0\")).toEqual(BigInt(0));\n  expect(schema.parse(\"-5\")).toEqual(BigInt(-5));\n  expect(() => schema.parse(\"3.14\")).toThrow(); // not a z.ZodError!\n  expect(schema.parse(\"\")).toEqual(BigInt(0));\n  expect(() => schema.parse(\"NOT_A_NUMBER\")).toThrow(); // not a z.ZodError!\n  expect(schema.parse(5)).toEqual(BigInt(5));\n  expect(schema.parse(0)).toEqual(BigInt(0));\n  expect(schema.parse(-5)).toEqual(BigInt(-5));\n  expect(() => schema.parse(3.14)).toThrow(); // not a z.ZodError!\n  expect(schema.parse(BigInt(5))).toEqual(BigInt(5));\n  expect(() => schema.parse(Number.NaN)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.POSITIVE_INFINITY)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.NEGATIVE_INFINITY)).toThrow(); // not a z.ZodError!\n  expect(schema.parse(true)).toEqual(BigInt(1));\n  expect(schema.parse(false)).toEqual(BigInt(0));\n  expect(() => schema.parse(null)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(undefined)).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // not a z.ZodError!\n  expect(schema.parse([])).toEqual(BigInt(0));\n  expect(schema.parse(new Date(1670139203496))).toEqual(BigInt(1670139203496));\n});\n\ntest(\"date coercion\", () => {\n  const schema = z.coerce.date();\n  expect(schema.parse(new Date().toDateString())).toBeInstanceOf(Date);\n  expect(schema.parse(new Date().toISOString())).toBeInstanceOf(Date);\n  expect(schema.parse(new Date().toUTCString())).toBeInstanceOf(Date);\n  expect(schema.parse(\"5\")).toBeInstanceOf(Date);\n  expect(schema.parse(\"2000-01-01\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"0\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"-5\")).toBeInstanceOf(Date);\n  // expect(schema.parse(\"3.14\")).toBeInstanceOf(Date);\n  expect(() => schema.parse(\"\")).toThrow(); // z.ZodError\n  expect(() => schema.parse(\"NOT_A_DATE\")).toThrow(); // z.ZodError\n  expect(schema.parse(5)).toBeInstanceOf(Date);\n  expect(schema.parse(0)).toBeInstanceOf(Date);\n  expect(schema.parse(-5)).toBeInstanceOf(Date);\n  expect(schema.parse(3.14)).toBeInstanceOf(Date);\n  expect(() => schema.parse(BigInt(5))).toThrow(); // not a z.ZodError!\n  expect(() => schema.parse(Number.NaN)).toThrow(); // z.ZodError\n  expect(() => schema.parse(Number.POSITIVE_INFINITY)).toThrow(); // z.ZodError\n  expect(() => schema.parse(Number.NEGATIVE_INFINITY)).toThrow(); // z.ZodError\n  expect(schema.parse(true)).toBeInstanceOf(Date);\n  expect(schema.parse(false)).toBeInstanceOf(Date);\n  expect(schema.parse(null)).toBeInstanceOf(Date);\n  expect(() => schema.parse(undefined)).toThrow(); // z.ZodError\n  expect(() => schema.parse({ hello: \"world!\" })).toThrow(); // z.ZodError\n  expect(() => schema.parse([\"item\", \"another_item\"])).toThrow(); // z.ZodError\n  expect(() => schema.parse([])).toThrow(); // z.ZodError\n  expect(schema.parse(new Date())).toBeInstanceOf(Date);\n});\n\n// test(\"template literal coercion\", () => {\n//   const schema = z.coerce\n//     .templateLiteral()\n//     .interpolated(z.number().finite())\n//     .interpolated(\n//       z.enum([\"px\", \"em\", \"rem\", \"vh\", \"vw\", \"vmin\", \"vmax\"]).optional()\n//     );\n//   expect(schema.parse(300)).toEqual(\"300\");\n//   expect(schema.parse(BigInt(300))).toEqual(\"300\");\n//   expect(schema.parse(\"300\")).toEqual(\"300\");\n//   expect(schema.parse(\"300px\")).toEqual(\"300px\");\n//   expect(schema.parse(\"300em\")).toEqual(\"300em\");\n//   expect(schema.parse(\"300rem\")).toEqual(\"300rem\");\n//   expect(schema.parse(\"300vh\")).toEqual(\"300vh\");\n//   expect(schema.parse(\"300vw\")).toEqual(\"300vw\");\n//   expect(schema.parse(\"300vmin\")).toEqual(\"300vmin\");\n//   expect(schema.parse(\"300vmax\")).toEqual(\"300vmax\");\n//   expect(schema.parse([\"300px\"])).toEqual(\"300px\");\n// });\n\ntest(\"override input type\", () => {\n  const a = z.coerce.string<any>();\n  type input = z.input<typeof a>;\n  expectTypeOf<input>().toEqualTypeOf<any>();\n  type output = z.infer<typeof a>;\n  expectTypeOf<output>().toEqualTypeOf<string>();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/continuability.test.ts",
    "content": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"continuability\", () => {\n  /** \n   *  | $ZodGUID\n  | $ZodUUID\n  | $ZodEmail\n  | $ZodURL\n  | $ZodEmoji\n  | $ZodNanoID\n  | $ZodCUID\n  | $ZodCUID2\n  | $ZodULID\n  | $ZodXID\n  | $ZodKSUID\n  | $ZodISODateTime\n  | $ZodISODate\n  | $ZodISOTime\n  | $ZodISODuration\n  | $ZodIPv4\n  | $ZodIPv6\n  | $ZodCIDRv4\n  | $ZodCIDRv6\n  | $ZodBase64\n  | $ZodBase64URL\n  | $ZodE164\n  | $ZodJWT;\n   */\n  expect(\n    z\n      .email()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"email\",\n        \"message\": \"Invalid email address\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^(?!\\\\.)(?!.*\\\\.\\\\.)([A-Za-z0-9_'+\\\\-\\\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\\\-]*\\\\.)+[A-Za-z]{2,}$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .uuid()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"uuid\",\n        \"message\": \"Invalid UUID\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .url()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"url\",\n        \"message\": \"Invalid URL\",\n        \"path\": [],\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .jwt()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"jwt\",\n        \"message\": \"Invalid JWT\",\n        \"path\": [],\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .cidrv4()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"cidrv4\",\n        \"message\": \"Invalid IPv4 range\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\/([0-9]|[1-2][0-9]|3[0-2])$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .cidrv6()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"cidrv6\",\n        \"message\": \"Invalid IPv6 range\",\n        \"path\": [],\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .ipv4()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"ipv4\",\n        \"message\": \"Invalid IPv4 address\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .ipv6()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"ipv6\",\n        \"message\": \"Invalid IPv6 address\",\n        \"path\": [],\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .emoji()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"emoji\",\n        \"message\": \"Invalid emoji\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$/u\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .nanoid()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"nanoid\",\n        \"message\": \"Invalid nanoid\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^[a-zA-Z0-9_-]{21}$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .cuid()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"cuid\",\n        \"message\": \"Invalid cuid\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^[cC][^\\\\s-]{8,}$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .cuid2()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"cuid2\",\n        \"message\": \"Invalid cuid2\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^[0-9a-z]+$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .ulid()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"ulid\",\n        \"message\": \"Invalid ULID\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .xid()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"xid\",\n        \"message\": \"Invalid XID\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^[0-9a-vA-V]{20}$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n  expect(\n    z\n      .ksuid()\n      .refine(() => false)\n      .safeParse(\"invalid_value\").error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"ksuid\",\n        \"message\": \"Invalid KSUID\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^[A-Za-z0-9]{27}$/\",\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [],\n      },\n    ]\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/custom.test.ts",
    "content": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"passing validations\", () => {\n  const example1 = z.custom<number>((x) => typeof x === \"number\");\n  example1.parse(1234);\n  expect(() => example1.parse({})).toThrow();\n});\n\ntest(\"string params\", () => {\n  const example1 = z.custom<number>((x) => typeof x !== \"number\", \"customerr\");\n  const result = example1.safeParse(1234);\n  expect(result.success).toEqual(false);\n  expect(JSON.stringify(result.error).includes(\"customerr\")).toEqual(true);\n});\n\ntest(\"instanceof\", () => {\n  const fn = (value: string) => Uint8Array.from(Buffer.from(value, \"base64\"));\n\n  // Argument of type 'ZodCustom<Uint8Array<ArrayBuffer>, unknown>' is not assignable to parameter of type '$ZodType<any, Uint8Array<ArrayBuffer>>'.\n  z.string().transform(fn).pipe(z.instanceof(Uint8Array));\n});\n\ntest(\"non-continuable by default\", () => {\n  const A = z\n    .custom<string>((val) => typeof val === \"string\")\n    .transform((_) => {\n      throw new Error(\"Invalid input\");\n    });\n  expect(A.safeParse(123).error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]]\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/date.test.ts",
    "content": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\nconst beforeBenchmarkDate = new Date(2022, 10, 4);\nconst benchmarkDate = new Date(2022, 10, 5);\nconst afterBenchmarkDate = new Date(2022, 10, 6);\n\nconst minCheck = z.date().min(benchmarkDate);\nconst maxCheck = z.date().max(benchmarkDate);\n\ntest(\"passing validations\", () => {\n  minCheck.parse(benchmarkDate);\n  minCheck.parse(afterBenchmarkDate);\n\n  maxCheck.parse(benchmarkDate);\n  maxCheck.parse(beforeBenchmarkDate);\n});\n\ntest(\"failing validations\", () => {\n  expect(() => minCheck.parse(beforeBenchmarkDate)).toThrow();\n  expect(() => maxCheck.parse(afterBenchmarkDate)).toThrow();\n});\n\ntest(\"min max getters\", () => {\n  expect(minCheck.minDate).toEqual(benchmarkDate);\n  expect(minCheck.min(afterBenchmarkDate).minDate).toEqual(afterBenchmarkDate);\n\n  expect(maxCheck.maxDate).toEqual(benchmarkDate);\n  expect(maxCheck.max(beforeBenchmarkDate).maxDate).toEqual(beforeBenchmarkDate);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/datetime.test.ts",
    "content": "import { checkSync } from \"recheck\";\nimport { expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"basic datetime parsing\", () => {\n  const datetime = z.string().datetime();\n  datetime.parse(\"1970-01-01T00:00:00.000Z\");\n  datetime.parse(\"2022-10-13T09:52:31.816Z\");\n  datetime.parse(\"2022-10-13T09:52:31.8162314Z\");\n  datetime.parse(\"1970-01-01T00:00:00Z\");\n  datetime.parse(\"2022-10-13T09:52:31Z\");\n  expect(() => datetime.parse(\"\")).toThrow();\n  expect(() => datetime.parse(\"foo\")).toThrow();\n  expect(() => datetime.parse(\"2020-10-14\")).toThrow();\n  expect(() => datetime.parse(\"T18:45:12.123\")).toThrow();\n  expect(() => datetime.parse(\"2020-10-14T17:42:29+00:00\")).toThrow();\n});\n\ntest(\"datetime parsing with precision -1\", () => {\n  const datetimeNoMs = z.string().datetime({ precision: -1, offset: true, local: true });\n  datetimeNoMs.parse(\"1970-01-01T00:00Z\");\n  datetimeNoMs.parse(\"2022-10-13T09:52Z\");\n  datetimeNoMs.parse(\"2022-10-13T09:52+02:00\");\n\n  datetimeNoMs.parse(\"2022-10-13T09:52\");\n  expect(() => datetimeNoMs.parse(\"tuna\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"2022-10-13T09:52+02\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"1970-01-01T00:00:00.000Z\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"1970-01-01T00:00:00.Z\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"2022-10-13T09:52:31.816Z\")).toThrow();\n});\n\ntest(\"datetime parsing with precision 0\", () => {\n  const datetimeNoMs = z.string().datetime({ precision: 0 });\n  datetimeNoMs.parse(\"1970-01-01T00:00:00Z\");\n  datetimeNoMs.parse(\"2022-10-13T09:52:31Z\");\n  expect(() => datetimeNoMs.parse(\"tuna\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"1970-01-01T00:00:00.000Z\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"1970-01-01T00:00:00.Z\")).toThrow();\n  expect(() => datetimeNoMs.parse(\"2022-10-13T09:52:31.816Z\")).toThrow();\n});\n\ntest(\"datetime parsing with precision 3\", () => {\n  const datetime3Ms = z.string().datetime({ precision: 3 });\n  datetime3Ms.parse(\"1970-01-01T00:00:00.000Z\");\n  datetime3Ms.parse(\"2022-10-13T09:52:31.123Z\");\n  expect(() => datetime3Ms.parse(\"tuna\")).toThrow();\n  expect(() => datetime3Ms.parse(\"1970-01-01T00:00:00.1Z\")).toThrow();\n  expect(() => datetime3Ms.parse(\"1970-01-01T00:00:00.12Z\")).toThrow();\n  expect(() => datetime3Ms.parse(\"2022-10-13T09:52:31Z\")).toThrow();\n});\n\ntest(\"datetime parsing with offset\", () => {\n  const datetimeOffset = z.string().datetime({ offset: true });\n  datetimeOffset.parse(\"1970-01-01T00:00:00.000Z\");\n  datetimeOffset.parse(\"2022-10-13T09:52:31.816234134Z\");\n  datetimeOffset.parse(\"1970-01-01T00:00:00Z\");\n  datetimeOffset.parse(\"2022-10-13T09:52:31.4Z\");\n  datetimeOffset.parse(\"2020-10-14T17:42:29+00:00\");\n  datetimeOffset.parse(\"2020-10-14T17:42:29+03:15\");\n  expect(() => datetimeOffset.parse(\"2020-10-14T17:42:29+0315\")).toThrow();\n  expect(() => datetimeOffset.parse(\"2020-10-14T17:42:29+03\")).toThrow();\n  expect(() => datetimeOffset.parse(\"tuna\")).toThrow();\n  expect(() => datetimeOffset.parse(\"2022-10-13T09:52:31.Z\")).toThrow();\n});\n\ntest(\"datetime parsing with offset and precision 0\", () => {\n  const datetimeOffsetNoMs = z.string().datetime({ offset: true, precision: 0 });\n  datetimeOffsetNoMs.parse(\"1970-01-01T00:00:00Z\");\n  datetimeOffsetNoMs.parse(\"2022-10-13T09:52:31Z\");\n  datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29+00:00\");\n  expect(() => datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29+0000\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29+00\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"tuna\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"1970-01-01T00:00:00.000Z\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"1970-01-01T00:00:00.Z\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"2022-10-13T09:52:31.816Z\")).toThrow();\n  expect(() => datetimeOffsetNoMs.parse(\"2020-10-14T17:42:29.124+00:00\")).toThrow();\n});\n\ntest(\"datetime parsing with offset and precision 4\", () => {\n  const datetimeOffset4Ms = z.string().datetime({ offset: true, precision: 4 });\n  datetimeOffset4Ms.parse(\"1970-01-01T00:00:00.1234Z\");\n  datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.1234+00:00\");\n  expect(() => datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.1234+0000\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.1234+00\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"tuna\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"1970-01-01T00:00:00.123Z\")).toThrow();\n  expect(() => datetimeOffset4Ms.parse(\"2020-10-14T17:42:29.124+00:00\")).toThrow();\n});\n\ntest(\"datetime offset normalization\", () => {\n  const a = z.iso.datetime({ offset: true });\n\n  expect(a.safeParse(\"2020-10-14T17:42:29+02\")).toMatchObject({ success: false });\n  expect(a.safeParse(\"2020-10-14T17:42:29+0200\")).toMatchObject({ success: false });\n  a.safeParse(\"2020-10-14T17:42:29+02:00\");\n});\n\ntest(\"datetime parsing with local option\", () => {\n  const a = z.string().datetime({ local: true });\n\n  expect(a.safeParse(\"1970-01-01T00:00\")).toMatchObject({ success: true });\n  expect(a.safeParse(\"1970-01-01T00:00:00\")).toMatchObject({ success: true });\n  expect(a.safeParse(\"2022-10-13T09:52:31.816\")).toMatchObject({ success: true });\n  expect(a.safeParse(\"1970-01-01T00:00:00.000\")).toMatchObject({ success: true });\n  expect(a.safeParse(\"1970-01-01T00\")).toMatchObject({ success: false });\n\n  // Should reject timezone indicators and invalid formats\n\n  expect(() => a.parse(\"2022-10-13T09:52:31+00:00\")).toThrow();\n  expect(() => a.parse(\"2022-10-13 09:52:31\")).toThrow();\n  expect(() => a.parse(\"2022-10-13T24:52:31\")).toThrow();\n  expect(() => a.parse(\"2022-10-13T24:52\")).toThrow();\n  expect(() => a.parse(\"2022-10-13T24:52Z\")).toThrow();\n});\n\ntest(\"datetime parsing with local and offset\", () => {\n  const a = z.string().datetime({ local: true, offset: true });\n\n  // expect(a.parse(\"2022-10-13T12:52\")).toEqual(\"2022-10-13T12:52:00\");\n  a.parse(\"2022-10-13T12:52:00\");\n  a.parse(\"2022-10-13T12:52:00Z\");\n  a.parse(\"2022-10-13T12:52Z\");\n  a.parse(\"2022-10-13T12:52\");\n  a.parse(\"2022-10-13T12:52+02:00\");\n  expect(() => a.parse(\"2022-10-13T12:52:00+02\")).toThrow();\n  // expect(() => a.parse(\"2022-10-13T12:52Z\")).toThrow();\n  // expect(() => a.parse(\"2022-10-13T12:52+02:00\")).toThrow();\n});\n\ntest(\"date parsing\", () => {\n  const date = z.string().date();\n  date.parse(\"1970-01-01\");\n  date.parse(\"2022-01-31\");\n  date.parse(\"2022-03-31\");\n  date.parse(\"2022-04-30\");\n  date.parse(\"2022-05-31\");\n  date.parse(\"2022-06-30\");\n  date.parse(\"2022-07-31\");\n  date.parse(\"2022-08-31\");\n  date.parse(\"2022-09-30\");\n  date.parse(\"2022-10-31\");\n  date.parse(\"2022-11-30\");\n  date.parse(\"2022-12-31\");\n\n  date.parse(\"2000-02-29\");\n  date.parse(\"2400-02-29\");\n  expect(() => date.parse(\"2022-02-29\")).toThrow();\n  expect(() => date.parse(\"2100-02-29\")).toThrow();\n  expect(() => date.parse(\"2200-02-29\")).toThrow();\n  expect(() => date.parse(\"2300-02-29\")).toThrow();\n  expect(() => date.parse(\"2500-02-29\")).toThrow();\n\n  expect(() => date.parse(\"\")).toThrow();\n  expect(() => date.parse(\"foo\")).toThrow();\n  expect(() => date.parse(\"200-01-01\")).toThrow();\n  expect(() => date.parse(\"20000-01-01\")).toThrow();\n  expect(() => date.parse(\"2000-0-01\")).toThrow();\n  expect(() => date.parse(\"2000-011-01\")).toThrow();\n  expect(() => date.parse(\"2000-01-0\")).toThrow();\n  expect(() => date.parse(\"2000-01-011\")).toThrow();\n  expect(() => date.parse(\"2000/01/01\")).toThrow();\n  expect(() => date.parse(\"01-01-2022\")).toThrow();\n  expect(() => date.parse(\"01/01/2022\")).toThrow();\n  expect(() => date.parse(\"2000-01-01 00:00:00Z\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29+00:00\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29Z\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29\")).toThrow();\n  expect(() => date.parse(\"2020-10-14T17:42:29.123Z\")).toThrow();\n\n  expect(() => date.parse(\"2000-00-12\")).toThrow();\n  expect(() => date.parse(\"2000-12-00\")).toThrow();\n  expect(() => date.parse(\"2000-01-32\")).toThrow();\n  expect(() => date.parse(\"2000-13-01\")).toThrow();\n  expect(() => date.parse(\"2000-21-01\")).toThrow();\n\n  expect(() => date.parse(\"2000-02-30\")).toThrow();\n  expect(() => date.parse(\"2000-02-31\")).toThrow();\n  expect(() => date.parse(\"2000-04-31\")).toThrow();\n  expect(() => date.parse(\"2000-06-31\")).toThrow();\n  expect(() => date.parse(\"2000-09-31\")).toThrow();\n  expect(() => date.parse(\"2000-11-31\")).toThrow();\n});\n\ntest(\"time parsing\", () => {\n  const time = z.string().time();\n  time.parse(\"00:00:00\");\n  time.parse(\"23:00:00\");\n  time.parse(\"00:59:00\");\n  time.parse(\"00:00:59\");\n  time.parse(\"23:59:59\");\n  time.parse(\"09:52:31\");\n  time.parse(\"23:59:59.9999999\");\n  time.parse(\"00:00\");\n  expect(() => time.parse(\"\")).toThrow();\n  expect(() => time.parse(\"foo\")).toThrow();\n  expect(() => time.parse(\"00:00:00Z\")).toThrow();\n  expect(() => time.parse(\"0:00:00\")).toThrow();\n  expect(() => time.parse(\"00:0:00\")).toThrow();\n  expect(() => time.parse(\"00:00:0\")).toThrow();\n  expect(() => time.parse(\"00:00:00.000+00:00\")).toThrow();\n  expect(() => time.parse(\"24:00:00\")).toThrow();\n  expect(() => time.parse(\"00:60:00\")).toThrow();\n  expect(() => time.parse(\"00:00:60\")).toThrow();\n  expect(() => time.parse(\"24:60:60\")).toThrow();\n\n  const time2 = z.string().time({ precision: 2 });\n  time2.parse(\"00:00:00.00\");\n  time2.parse(\"09:52:31.12\");\n  time2.parse(\"23:59:59.99\");\n  expect(() => time2.parse(\"\")).toThrow();\n  expect(() => time2.parse(\"foo\")).toThrow();\n  expect(() => time2.parse(\"00:00:00\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.00Z\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.0\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.000\")).toThrow();\n  expect(() => time2.parse(\"00:00:00.00+00:00\")).toThrow();\n\n  const time3 = z.string().time({ precision: z.TimePrecision.Minute });\n  time3.parse(\"00:00\");\n  expect(() => time3.parse(\"00:00:00\")).toThrow();\n});\n\ntest(\"duration\", () => {\n  const duration = z.string().duration();\n\n  const validDurations = [\n    \"P3Y6M4DT12H30M5S\",\n    \"P2Y9M3DT12H31M8.001S\",\n    // \"+P3Y6M4DT12H30M5S\",\n    // \"-PT0.001S\",\n    // \"+PT0.001S\",\n    \"PT0,001S\",\n    \"PT12H30M5S\",\n    // \"-P2M1D\",\n    // \"P-2M-1D\",\n    // \"-P5DT10H\",\n    // \"P-5DT-10H\",\n    \"P1Y\",\n    \"P2MT30M\",\n    \"PT6H\",\n    \"P5W\",\n    // \"P0.5Y\",\n    // \"P0,5Y\",\n    // \"P42YT7.004M\",\n  ];\n\n  const invalidDurations = [\n    \"foo bar\",\n    \"\",\n    \" \",\n    \"P\",\n    \"PT\",\n    \"P1Y2MT\",\n    \"T1H\",\n    \"P0.5Y1D\",\n    \"P0,5Y6M\",\n    \"P1YT\",\n    \"P-2M-1D\",\n    \"P-5DT-10H\",\n    \"P1W2D\",\n    \"-P1D\",\n  ];\n\n  for (const val of validDurations) {\n    const result = duration.safeParse(val);\n    if (!result.success) {\n      throw Error(`Valid duration could not be parsed: ${val}`);\n    }\n  }\n\n  for (const val of invalidDurations) {\n    const result = duration.safeParse(val);\n\n    if (result.success) {\n      throw Error(`Invalid duration was successful parsed: ${val}`);\n    }\n\n    expect(result.error.issues[0].message).toEqual(\"Invalid ISO duration\");\n  }\n});\n\ntest(\"redos checker\", () => {\n  const a = z.iso.datetime();\n  const b = z.string().datetime({ offset: true });\n  const c = z.string().datetime({ local: true });\n  const d = z.string().datetime({ local: true, offset: true, precision: 3 });\n  const e = z.string().date();\n  const f = z.string().time();\n  const g = z.string().duration();\n  for (const schema of [a, b, c, d, e, f, g]) {\n    const result = checkSync(schema._zod.pattern.source, \"\");\n    if (result.status !== \"safe\") throw Error(\"ReDoS issue\");\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/default.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport { z } from \"zod/v4\";\n\ntest(\"basic defaults\", () => {\n  expect(z.string().default(\"default\").parse(undefined)).toBe(\"default\");\n});\n\ntest(\"default with optional\", () => {\n  const schema = z.string().optional().default(\"default\");\n  expect(schema.parse(undefined)).toBe(\"default\");\n  expect(schema.unwrap().parse(undefined)).toBe(undefined);\n});\n\ntest(\"default with transform\", () => {\n  const stringWithDefault = z\n    .string()\n    .transform((val) => val.toUpperCase())\n    .default(\"default\");\n  expect(stringWithDefault.parse(undefined)).toBe(\"default\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodDefault);\n  expect(stringWithDefault.unwrap()).toBeInstanceOf(z.ZodPipe);\n  expect(stringWithDefault.unwrap().in).toBeInstanceOf(z.ZodString);\n  expect(stringWithDefault.unwrap().out).toBeInstanceOf(z.ZodTransform);\n\n  type inp = z.input<typeof stringWithDefault>;\n  expectTypeOf<inp>().toEqualTypeOf<string | undefined>();\n  type out = z.output<typeof stringWithDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string>();\n});\n\ntest(\"default on existing optional\", () => {\n  const stringWithDefault = z.string().optional().default(\"asdf\");\n  expect(stringWithDefault.parse(undefined)).toBe(\"asdf\");\n  expect(stringWithDefault).toBeInstanceOf(z.ZodDefault);\n  expect(stringWithDefault.unwrap()).toBeInstanceOf(z.ZodOptional);\n  expect(stringWithDefault.unwrap().unwrap()).toBeInstanceOf(z.ZodString);\n\n  type inp = z.input<typeof stringWithDefault>;\n  expectTypeOf<inp>().toEqualTypeOf<string | undefined>();\n  type out = z.output<typeof stringWithDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string>();\n});\n\ntest(\"optional on default\", () => {\n  const stringWithDefault = z.string().default(\"asdf\").optional();\n\n  type inp = z.input<typeof stringWithDefault>;\n  expectTypeOf<inp>().toEqualTypeOf<string | undefined>();\n  type out = z.output<typeof stringWithDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string | undefined>();\n\n  expect(stringWithDefault.parse(undefined)).toBe(\"asdf\");\n});\n\n// test(\"complex chain example\", () => {\n//   const complex = z\n//     .string()\n//     .default(\"asdf\")\n//     .transform((val) => val.toUpperCase())\n//     .default(\"qwer\")\n//     .unwrap()\n//     .optional()\n//     .default(\"asdfasdf\");\n\n//   expect(complex.parse(undefined)).toBe(\"asdfasdf\");\n// });\n\ntest(\"removeDefault\", () => {\n  const stringWithRemovedDefault = z.string().default(\"asdf\").removeDefault();\n\n  type out = z.output<typeof stringWithRemovedDefault>;\n  expectTypeOf<out>().toEqualTypeOf<string>();\n});\n\ntest(\"apply default at output\", () => {\n  const schema = z\n    .string()\n    .transform((_) => (Math.random() > 0 ? undefined : _))\n    .default(\"asdf\");\n  expect(schema.parse(\"\")).toEqual(\"asdf\");\n});\n\ntest(\"nested\", () => {\n  const inner = z.string().default(\"asdf\");\n  const outer = z.object({ inner }).default({\n    inner: \"qwer\",\n  });\n  type input = z.input<typeof outer>;\n  expectTypeOf<input>().toEqualTypeOf<{ inner?: string | undefined } | undefined>();\n  type out = z.output<typeof outer>;\n  expectTypeOf<out>().toEqualTypeOf<{ inner: string }>();\n  expect(outer.parse(undefined)).toEqual({ inner: \"qwer\" });\n  expect(outer.parse({})).toEqual({ inner: \"asdf\" });\n  expect(outer.parse({ inner: undefined })).toEqual({ inner: \"asdf\" });\n});\n\ntest(\"chained defaults\", () => {\n  const stringWithDefault = z.string().default(\"inner\").default(\"outer\");\n  const result = stringWithDefault.parse(undefined);\n  expect(result).toEqual(\"outer\");\n});\n\ntest(\"object optionality\", () => {\n  const schema = z.object({\n    hi: z.string().default(\"hi\"),\n  });\n  type schemaInput = z.input<typeof schema>;\n  type schemaOutput = z.output<typeof schema>;\n  expectTypeOf<schemaInput>().toEqualTypeOf<{ hi?: string | undefined }>();\n  expectTypeOf<schemaOutput>().toEqualTypeOf<{ hi: string }>();\n  expect(schema.parse({})).toEqual({\n    hi: \"hi\",\n  });\n});\n\ntest(\"nested prefault/default\", () => {\n  const a = z\n    .string()\n    .default(\"a\")\n    .refine((val) => val.startsWith(\"a\"));\n  const b = z\n    .string()\n    .refine((val) => val.startsWith(\"b\"))\n    .default(\"b\");\n  const c = z\n    .string()\n    .prefault(\"c\")\n    .refine((val) => val.startsWith(\"c\"));\n  const d = z\n    .string()\n    .refine((val) => val.startsWith(\"d\"))\n    .prefault(\"d\");\n\n  const obj = z.object({\n    a,\n    b,\n    c,\n    d,\n  });\n\n  expect(obj.safeParse({ a: \"a1\", b: \"b1\", c: \"c1\", d: \"d1\" })).toMatchInlineSnapshot(`\n    {\n      \"data\": {\n        \"a\": \"a1\",\n        \"b\": \"b1\",\n        \"c\": \"c1\",\n        \"d\": \"d1\",\n      },\n      \"success\": true,\n    }\n  `);\n\n  expect(obj.safeParse({ a: \"f\", b: \"f\", c: \"f\", d: \"f\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"a\"\n        ],\n        \"message\": \"Invalid input\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"b\"\n        ],\n        \"message\": \"Invalid input\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"c\"\n        ],\n        \"message\": \"Invalid input\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"d\"\n        ],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n\n  expect(obj.safeParse({})).toMatchInlineSnapshot(`\n    {\n      \"data\": {\n        \"a\": \"a\",\n        \"b\": \"b\",\n        \"c\": \"c\",\n        \"d\": \"d\",\n      },\n      \"success\": true,\n    }\n  `);\n\n  expect(obj.safeParse({ a: undefined, b: undefined, c: undefined, d: undefined })).toMatchInlineSnapshot(`\n    {\n      \"data\": {\n        \"a\": \"a\",\n        \"b\": \"b\",\n        \"c\": \"c\",\n        \"d\": \"d\",\n      },\n      \"success\": true,\n    }\n  `);\n\n  const obj2 = z.object({\n    a: a.optional(),\n    b: b.optional(),\n    c: c.optional(),\n    d: d.optional(),\n  });\n  expect(obj2.safeParse({ a: undefined, b: undefined, c: undefined, d: undefined })).toMatchInlineSnapshot(`\n    {\n      \"data\": {\n        \"a\": \"a\",\n        \"b\": \"b\",\n        \"c\": \"c\",\n        \"d\": \"d\",\n      },\n      \"success\": true,\n    }\n  `);\n\n  expect(a.parse(undefined)).toBe(\"a\");\n  expect(b.parse(undefined)).toBe(\"b\");\n  expect(c.parse(undefined)).toBe(\"c\");\n  expect(d.parse(undefined)).toBe(\"d\");\n});\n\ntest(\"failing default\", () => {\n  const a = z\n    .string()\n    .default(\"z\")\n    .refine((val) => val.startsWith(\"a\"));\n  const b = z\n    .string()\n    .refine((val) => val.startsWith(\"b\"))\n    .default(\"z\");\n  const c = z\n    .string()\n    .prefault(\"z\")\n    .refine((val) => val.startsWith(\"c\"));\n  const d = z\n    .string()\n    .refine((val) => val.startsWith(\"d\"))\n    .prefault(\"z\");\n\n  const obj = z.object({\n    a,\n    b,\n    c,\n    d,\n  });\n\n  expect(\n    obj.safeParse({\n      a: undefined,\n      b: undefined,\n      c: undefined,\n      d: undefined,\n    }).error!.issues\n  ).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [\n          \"a\",\n        ],\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [\n          \"c\",\n        ],\n      },\n      {\n        \"code\": \"custom\",\n        \"message\": \"Invalid input\",\n        \"path\": [\n          \"d\",\n        ],\n      },\n    ]\n  `);\n});\n\ntest(\"partial should not clobber defaults\", () => {\n  const objWithDefaults = z.object({\n    a: z.string().default(\"defaultA\"),\n    b: z.string().default(\"defaultB\"),\n    c: z.string().default(\"defaultC\"),\n  });\n\n  const objPartialWithOneRequired = objWithDefaults.partial(); //.required({ a: true });\n\n  const test = objPartialWithOneRequired.parse({});\n  expect(test).toMatchInlineSnapshot(`\n    {\n      \"a\": \"defaultA\",\n      \"b\": \"defaultB\",\n      \"c\": \"defaultC\",\n    }\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/description.test.ts",
    "content": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\nconst description = \"a description\";\n\n// test(\"passing `description` to schema should add a description\", () => {\n//   expect(z.string({ description }).description).toEqual(description);\n//   expect(z.number({ description }).description).toEqual(description);\n//   expect(z.boolean({ description }).description).toEqual(description);\n// });\n\ntest(\".describe\", () => {\n  expect(z.string().describe(description).description).toEqual(description);\n  expect(z.number().describe(description).description).toEqual(description);\n  expect(z.boolean().describe(description).description).toEqual(description);\n});\n\ntest(\"adding description with z.globalRegistry\", () => {\n  const schema = z.string();\n  z.core.globalRegistry.add(schema, { description });\n  z.core.globalRegistry.get(schema);\n  expect(schema.description).toEqual(description);\n});\n\n// in Zod 4 descriptions are not inherited\n// test(\"description should carry over to chained schemas\", () => {\n//   const schema = z.string().describe(description);\n//   expect(schema.description).toEqual(description);\n//   expect(schema.optional().description).toEqual(description);\n//   expect(schema.optional().nullable().default(\"default\").description).toEqual(description);\n// });\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/discriminated-unions.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"_values\", () => {\n  expect(z.string()._zod.values).toEqual(undefined);\n  expect(z.enum([\"a\", \"b\"])._zod.values).toEqual(new Set([\"a\", \"b\"]));\n  expect(z.nativeEnum({ a: \"A\", b: \"B\" })._zod.values).toEqual(new Set([\"A\", \"B\"]));\n  expect(z.literal(\"test\")._zod.values).toEqual(new Set([\"test\"]));\n  expect(z.literal(123)._zod.values).toEqual(new Set([123]));\n  expect(z.literal(true)._zod.values).toEqual(new Set([true]));\n  expect(z.literal(BigInt(123))._zod.values).toEqual(new Set([BigInt(123)]));\n  expect(z.undefined()._zod.values).toEqual(new Set([undefined]));\n  expect(z.null()._zod.values).toEqual(new Set([null]));\n\n  const t = z.literal(\"test\");\n  expect(t.optional()._zod.values).toEqual(new Set([\"test\", undefined]));\n  expect(t.nullable()._zod.values).toEqual(new Set([\"test\", null]));\n  expect(t.default(\"test\")._zod.values).toEqual(new Set([\"test\"]));\n  expect(t.catch(\"test\")._zod.values).toEqual(new Set([\"test\"]));\n\n  const pre = z.preprocess((val) => String(val), z.string()).pipe(z.literal(\"test\"));\n  expect(pre._zod.values).toEqual(undefined);\n\n  const post = z.literal(\"test\").transform((_) => Math.random());\n  expect(post._zod.values).toEqual(new Set([\"test\"]));\n\n  // Test that readonly literals pass through their values property\n  expect(z.literal(\"test\").readonly()._zod.values).toEqual(new Set([\"test\"]));\n});\n\ntest(\"valid parse - object\", () => {\n  expect(\n    z\n      .discriminatedUnion(\"type\", [\n        z.object({ type: z.literal(\"a\"), a: z.string() }),\n        z.object({ type: z.literal(\"b\"), b: z.string() }),\n      ])\n      .parse({ type: \"a\", a: \"abc\" })\n  ).toEqual({ type: \"a\", a: \"abc\" });\n});\n\ntest(\"valid - include discriminator key (deprecated)\", () => {\n  expect(\n    z\n      .discriminatedUnion(\"type\", [\n        z.object({ type: z.literal(\"a\"), a: z.string() }),\n        z.object({ type: z.literal(\"b\"), b: z.string() }),\n      ])\n      .parse({ type: \"a\", a: \"abc\" })\n  ).toEqual({ type: \"a\", a: \"abc\" });\n});\n\ntest(\"valid - optional discriminator (object)\", () => {\n  const schema = z.discriminatedUnion(\"type\", [\n    z.object({ type: z.literal(\"a\").optional(), a: z.string() }),\n    z.object({ type: z.literal(\"b\"), b: z.string() }),\n  ]);\n  expect(schema.parse({ type: \"a\", a: \"abc\" })).toEqual({ type: \"a\", a: \"abc\" });\n  expect(schema.parse({ a: \"abc\" })).toEqual({ a: \"abc\" });\n});\n\ntest(\"valid - discriminator value of various primitive types\", () => {\n  const schema = z.discriminatedUnion(\"type\", [\n    z.object({ type: z.literal(\"1\"), val: z.string() }),\n    z.object({ type: z.literal(1), val: z.string() }),\n    z.object({ type: z.literal(BigInt(1)), val: z.string() }),\n    z.object({ type: z.literal(\"true\"), val: z.string() }),\n    z.object({ type: z.literal(true), val: z.string() }),\n    z.object({ type: z.literal(\"null\"), val: z.string() }),\n    z.object({ type: z.null(), val: z.string() }),\n    z.object({ type: z.literal(\"undefined\"), val: z.string() }),\n    z.object({ type: z.undefined(), val: z.string() }),\n  ]);\n\n  expect(schema.parse({ type: \"1\", val: \"val\" })).toEqual({ type: \"1\", val: \"val\" });\n  expect(schema.parse({ type: 1, val: \"val\" })).toEqual({ type: 1, val: \"val\" });\n  expect(schema.parse({ type: BigInt(1), val: \"val\" })).toEqual({\n    type: BigInt(1),\n    val: \"val\",\n  });\n  expect(schema.parse({ type: \"true\", val: \"val\" })).toEqual({\n    type: \"true\",\n    val: \"val\",\n  });\n  expect(schema.parse({ type: true, val: \"val\" })).toEqual({\n    type: true,\n    val: \"val\",\n  });\n  expect(schema.parse({ type: \"null\", val: \"val\" })).toEqual({\n    type: \"null\",\n    val: \"val\",\n  });\n  expect(schema.parse({ type: null, val: \"val\" })).toEqual({\n    type: null,\n    val: \"val\",\n  });\n  expect(schema.parse({ type: \"undefined\", val: \"val\" })).toEqual({\n    type: \"undefined\",\n    val: \"val\",\n  });\n  expect(schema.parse({ type: undefined, val: \"val\" })).toEqual({\n    type: undefined,\n    val: \"val\",\n  });\n\n  const fail = schema.safeParse({\n    type: \"not_a_key\",\n    val: \"val\",\n  });\n  expect(fail.error).toBeInstanceOf(z.ZodError);\n});\n\ntest(\"invalid - null\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"b\"), b: z.string() }),\n    ]).parse(null);\n    throw new Error();\n  } catch (e: any) {\n    // [\n    //   {\n    //     code: z.ZodIssueCode.invalid_type,\n    //     expected: z.ZodParsedType.object,\n    //     input: null,\n    //     message: \"Expected object, received null\",\n    //     received: z.ZodParsedType.null,\n    //     path: [],\n    //   },\n    // ];\n    expect(e.issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"object\",\n          \"message\": \"Invalid input: expected object, received null\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"invalid discriminator value\", () => {\n  const result = z\n    .discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"b\"), b: z.string() }),\n    ])\n    .safeParse({ type: \"x\", a: \"abc\" });\n\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_union\",\n        \"errors\": [],\n        \"note\": \"No matching discriminator\",\n        \"path\": [\n          \"type\"\n        ],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"invalid discriminator value - unionFallback\", () => {\n  const result = z\n    .discriminatedUnion(\n      \"type\",\n      [z.object({ type: z.literal(\"a\"), a: z.string() }), z.object({ type: z.literal(\"b\"), b: z.string() })],\n      { unionFallback: true }\n    )\n    .safeParse({ type: \"x\", a: \"abc\" });\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_union\",\n        \"errors\": [\n          [\n            {\n              \"code\": \"invalid_value\",\n              \"values\": [\n                \"a\"\n              ],\n              \"path\": [\n                \"type\"\n              ],\n              \"message\": \"Invalid input: expected \\\\\"a\\\\\"\"\n            }\n          ],\n          [\n            {\n              \"code\": \"invalid_value\",\n              \"values\": [\n                \"b\"\n              ],\n              \"path\": [\n                \"type\"\n              ],\n              \"message\": \"Invalid input: expected \\\\\"b\\\\\"\"\n            },\n            {\n              \"expected\": \"string\",\n              \"code\": \"invalid_type\",\n              \"path\": [\n                \"b\"\n              ],\n              \"message\": \"Invalid input: expected string, received undefined\"\n            }\n          ]\n        ],\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"valid discriminator value, invalid data\", () => {\n  const result = z\n    .discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ type: z.literal(\"b\"), b: z.string() }),\n    ])\n    .safeParse({ type: \"a\", b: \"abc\" });\n\n  // [\n  //   {\n  //     code: z.ZodIssueCode.invalid_type,\n  //     expected: z.ZodParsedType.string,\n  //     message: \"Required\",\n  //     path: [\"a\"],\n  //     received: z.ZodParsedType.undefined,\n  //   },\n  // ];\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"a\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"wrong schema - missing discriminator\", () => {\n  try {\n    z.discriminatedUnion(\"type\", [\n      z.object({ type: z.literal(\"a\"), a: z.string() }),\n      z.object({ b: z.string() }) as any,\n    ])._zod.propValues;\n    throw new Error();\n  } catch (e: any) {\n    expect(e.message.includes(\"Invalid discriminated union option\")).toBe(true);\n  }\n});\n\n// removed to account for unions of unions\n// test(\"wrong schema - duplicate discriminator values\", () => {\n//   try {\n//     z.discriminatedUnion(\"type\",[\n//       z.object({ type: z.literal(\"a\"), a: z.string() }),\n//       z.object({ type: z.literal(\"a\"), b: z.string() }),\n//     ]);\n//     throw new Error();\n//   } catch (e: any) {\n//     expect(e.message.includes(\"Duplicate discriminator value\")).toEqual(true);\n//   }\n// });\n\ntest(\"async - valid\", async () => {\n  const schema = await z.discriminatedUnion(\"type\", [\n    z.object({\n      type: z.literal(\"a\"),\n      a: z\n        .string()\n        .refine(async () => true)\n        .transform(async (val) => Number(val)),\n    }),\n    z.object({\n      type: z.literal(\"b\"),\n      b: z.string(),\n    }),\n  ]);\n  const data = { type: \"a\", a: \"1\" };\n  const result = await schema.safeParseAsync(data);\n  expect(result.data).toEqual({ type: \"a\", a: 1 });\n});\n\ntest(\"async - invalid\", async () => {\n  // try {\n  const a = z.discriminatedUnion(\"type\", [\n    z.object({\n      type: z.literal(\"a\"),\n      a: z\n        .string()\n        .refine(async () => true)\n        .transform(async (val) => val),\n    }),\n    z.object({\n      type: z.literal(\"b\"),\n      b: z.string(),\n    }),\n  ]);\n  const result = await a.safeParseAsync({ type: \"a\", a: 1 });\n\n  // expect(JSON.parse(e.message)).toEqual([\n  //   {\n  //     code: \"invalid_type\",\n  //     expected: \"string\",\n  //     input: 1,\n  //     received: \"number\",\n  //     path: [\"a\"],\n  //     message: \"Expected string, received number\",\n  //   },\n  // ]);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"a\"\n        ],\n        \"message\": \"Invalid input: expected string, received number\"\n      }\n    ]]\n  `);\n});\n\ntest(\"valid - literals with .default or .pipe\", () => {\n  const schema = z.discriminatedUnion(\"type\", [\n    z.object({\n      type: z.literal(\"foo\").default(\"foo\"),\n      a: z.string(),\n    }),\n    z.object({\n      type: z.literal(\"custom\"),\n      method: z.string(),\n    }),\n    z.object({\n      type: z.literal(\"bar\").transform((val) => val),\n      c: z.string(),\n    }),\n  ]);\n  expect(schema.parse({ type: \"foo\", a: \"foo\" })).toEqual({\n    type: \"foo\",\n    a: \"foo\",\n  });\n});\n\ntest(\"enum and nativeEnum\", () => {\n  enum MyEnum {\n    d = 0,\n    e = \"e\",\n  }\n\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\"),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.enum([\"b\", \"c\"]),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.nativeEnum(MyEnum),\n      // Add other properties specific to this option\n    }),\n  ]);\n\n  type schema = z.infer<typeof schema>;\n  expectTypeOf<schema>().toEqualTypeOf<{ key: \"a\" } | { key: \"b\" | \"c\" } | { key: MyEnum.d | MyEnum.e }>();\n\n  schema.parse({ key: \"a\" });\n  schema.parse({ key: \"b\" });\n  schema.parse({ key: \"c\" });\n  schema.parse({ key: MyEnum.d });\n  schema.parse({ key: MyEnum.e });\n  schema.parse({ key: \"e\" });\n});\n\ntest(\"branded\", () => {\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\"),\n      // Add other properties specific to this option\n    }),\n    z.object({\n      key: z.literal(\"b\").brand<\"asdfasdf\">(),\n      // Add other properties specific to this option\n    }),\n  ]);\n\n  type schema = z.infer<typeof schema>;\n  expectTypeOf<schema>().toEqualTypeOf<{ key: \"a\" } | { key: \"b\" & z.core.$brand<\"asdfasdf\"> }>();\n\n  schema.parse({ key: \"a\" });\n  schema.parse({ key: \"b\" });\n  expect(() => {\n    schema.parse({ key: \"c\" });\n  }).toThrow();\n});\n\ntest(\"optional and nullable\", () => {\n  const schema = z.discriminatedUnion(\"key\", [\n    z.object({\n      key: z.literal(\"a\").optional(),\n      a: z.literal(true),\n    }),\n    z.object({\n      key: z.literal(\"b\").nullable(),\n      b: z.literal(true),\n      // Add other properties specific to this option\n    }),\n  ]);\n\n  type schema = z.infer<typeof schema>;\n  expectTypeOf<schema>().toEqualTypeOf<{ key?: \"a\" | undefined; a: true } | { key: \"b\" | null; b: true }>();\n\n  schema.parse({ key: \"a\", a: true });\n  schema.parse({ key: undefined, a: true });\n  schema.parse({ key: \"b\", b: true });\n  schema.parse({ key: null, b: true });\n  expect(() => {\n    schema.parse({ key: null, a: true });\n  }).toThrow();\n  expect(() => {\n    schema.parse({ key: \"b\", a: true });\n  }).toThrow();\n\n  const value = schema.parse({ key: null, b: true });\n\n  if (!(\"key\" in value)) value.a;\n  if (value.key === undefined) value.a;\n  if (value.key === \"a\") value.a;\n  if (value.key === \"b\") value.b;\n  if (value.key === null) value.b;\n});\n\ntest(\"multiple discriminators\", () => {\n  const FreeConfig = z.object({\n    type: z.literal(\"free\"),\n    min_cents: z.null(),\n  });\n\n  // console.log(FreeConfig.shape.type);\n  const PricedConfig = z.object({\n    type: z.literal(\"fiat-price\"),\n    // min_cents: z.int().nullable(),\n    min_cents: z.null(),\n  });\n\n  const Config = z.discriminatedUnion(\"type\", [FreeConfig, PricedConfig]);\n\n  Config.parse({\n    min_cents: null,\n    type: \"fiat-price\",\n    name: \"Standard\",\n  });\n\n  expect(() => {\n    Config.parse({\n      min_cents: null,\n      type: \"not real\",\n      name: \"Standard\",\n    });\n  }).toThrow();\n});\n\ntest(\"single element union\", () => {\n  const schema = z.object({\n    a: z.literal(\"discKey\"),\n    b: z.enum([\"apple\", \"banana\"]),\n    c: z.object({ id: z.string() }),\n  });\n\n  const input = {\n    a: \"discKey\",\n    b: \"apple\",\n    c: {}, // Invalid, as schema requires `id` property\n  };\n\n  // Validation must fail here, but it doesn't\n\n  const u = z.discriminatedUnion(\"a\", [schema]);\n  const result = u.safeParse(input);\n  expect(result).toMatchObject({ success: false });\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"c\",\n          \"id\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n\n  expect(u.options.length).toEqual(1);\n});\n\ntest(\"nested discriminated unions\", () => {\n  const BaseError = z.object({ status: z.literal(\"failed\"), message: z.string() });\n  const MyErrors = z.discriminatedUnion(\"code\", [\n    BaseError.extend({ code: z.literal(400) }),\n    BaseError.extend({ code: z.literal(401) }),\n    BaseError.extend({ code: z.literal(500) }),\n  ]);\n\n  const MyResult = z.discriminatedUnion(\"status\", [\n    z.object({ status: z.literal(\"success\"), data: z.string() }),\n    MyErrors,\n  ]);\n\n  expect(MyErrors._zod.propValues).toMatchInlineSnapshot(`\n    {\n      \"code\": Set {\n        400,\n        401,\n        500,\n      },\n      \"status\": Set {\n        \"failed\",\n      },\n    }\n  `);\n  expect(MyResult._zod.propValues).toMatchInlineSnapshot(`\n    {\n      \"code\": Set {\n        400,\n        401,\n        500,\n      },\n      \"status\": Set {\n        \"success\",\n        \"failed\",\n      },\n    }\n  `);\n\n  const result = MyResult.parse({ status: \"success\", data: \"hello\" });\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"data\": \"hello\",\n      \"status\": \"success\",\n    }\n  `);\n  const result2 = MyResult.parse({ status: \"failed\", code: 400, message: \"bad request\" });\n  expect(result2).toMatchInlineSnapshot(`\n    {\n      \"code\": 400,\n      \"message\": \"bad request\",\n      \"status\": \"failed\",\n    }\n  `);\n  const result3 = MyResult.parse({ status: \"failed\", code: 401, message: \"unauthorized\" });\n  expect(result3).toMatchInlineSnapshot(`\n    {\n      \"code\": 401,\n      \"message\": \"unauthorized\",\n      \"status\": \"failed\",\n    }\n  `);\n  const result4 = MyResult.parse({ status: \"failed\", code: 500, message: \"internal server error\" });\n  expect(result4).toMatchInlineSnapshot(`\n    {\n      \"code\": 500,\n      \"message\": \"internal server error\",\n      \"status\": \"failed\",\n    }\n  `);\n});\n\ntest(\"readonly literal discriminator\", () => {\n  const discUnion = z.discriminatedUnion(\"type\", [\n    z.object({ type: z.literal(\"a\").readonly(), a: z.string() }),\n    z.object({ type: z.literal(\"b\"), b: z.number() }),\n  ]);\n\n  // Test that both discriminator values are correctly included in propValues\n  const propValues = discUnion._zod.propValues;\n  expect(propValues?.type?.has(\"a\")).toBe(true);\n  expect(propValues?.type?.has(\"b\")).toBe(true);\n\n  // Test that the discriminated union works correctly\n  const result1 = discUnion.parse({ type: \"a\", a: \"hello\" });\n  expect(result1).toEqual({ type: \"a\", a: \"hello\" });\n\n  const result2 = discUnion.parse({ type: \"b\", b: 42 });\n  expect(result2).toEqual({ type: \"b\", b: 42 });\n\n  // Test that invalid discriminator values are rejected\n  expect(() => {\n    discUnion.parse({ type: \"c\", a: \"hello\" });\n  }).toThrow();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/enum.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"enum from string array\", () => {\n  const MyEnum = z.enum([\"Red\", \"Green\", \"Blue\"]);\n  expect(MyEnum.enum.Red).toEqual(\"Red\");\n\n  type MyEnum = z.infer<typeof MyEnum>;\n  expectTypeOf<MyEnum>().toEqualTypeOf<\"Red\" | \"Green\" | \"Blue\">();\n});\n\ntest(\"enum from const object\", () => {\n  const Fruits: { Apple: \"apple\"; Banana: \"banana\" } = {\n    Apple: \"apple\",\n    Banana: \"banana\",\n  };\n  const fruitEnum = z.nativeEnum(Fruits);\n  type fruitEnum = z.infer<typeof fruitEnum>;\n  fruitEnum.parse(\"apple\");\n  fruitEnum.parse(\"banana\");\n  fruitEnum.parse(Fruits.Apple);\n  fruitEnum.parse(Fruits.Banana);\n  expectTypeOf<fruitEnum>().toEqualTypeOf<\"apple\" | \"banana\">();\n});\n\ntest(\"enum from native enum\", () => {\n  enum Fruits {\n    Apple = \"apple\",\n    Banana = \"banana\",\n    Orange = 3,\n  }\n  // @ts-ignore\n  const fruitEnum = z.nativeEnum(Fruits);\n  type fruitEnum = z.infer<typeof fruitEnum>;\n  fruitEnum.parse(\"apple\");\n  fruitEnum.parse(\"banana\");\n  fruitEnum.parse(Fruits.Apple);\n  fruitEnum.parse(Fruits.Banana);\n\n  expect(fruitEnum.safeParse(\"Apple\").success).toEqual(false);\n  expect(fruitEnum.safeParse(\"Cantaloupe\").success).toEqual(false);\n\n  expectTypeOf<fruitEnum>().toMatchTypeOf<Fruits>();\n  expectTypeOf<Fruits>().toMatchTypeOf<fruitEnum>();\n});\n\ntest(\"enum from native enum with numeric keys\", () => {\n  const FruitValues = {\n    Apple: 10,\n    Banana: 20,\n    // @ts-ignore\n  } as const;\n  const fruitEnum = z.nativeEnum(FruitValues);\n  type fruitEnum = z.infer<typeof fruitEnum>;\n  fruitEnum.parse(10);\n  fruitEnum.parse(20);\n  fruitEnum.parse(FruitValues.Apple);\n  fruitEnum.parse(FruitValues.Banana);\n  expectTypeOf<fruitEnum>().toEqualTypeOf<10 | 20>();\n});\n\ntest(\"issue metadata\", () => {\n  const schema = z.enum([\"Red\", \"Green\", \"Blue\"]);\n  const result = schema.safeParse(\"Yellow\");\n  expect(result.error!.issues[0]).toMatchInlineSnapshot(`\n    {\n      \"code\": \"invalid_value\",\n      \"message\": \"Invalid option: expected one of \"Red\"|\"Green\"|\"Blue\"\",\n      \"path\": [],\n      \"values\": [\n        \"Red\",\n        \"Green\",\n        \"Blue\",\n      ],\n    }\n  `);\n});\n\ntest(\"enum from non-const inputs\", () => {\n  const foods = [\"Pasta\", \"Pizza\", \"Tacos\", \"Burgers\", \"Salad\"];\n  const FoodEnum = z.enum(foods);\n\n  expectTypeOf<z.infer<typeof FoodEnum>>().toEqualTypeOf<string>();\n  expect(FoodEnum.safeParse(\"Pasta\").success).toEqual(true);\n  expect(FoodEnum.safeParse(\"Cucumbers\").success).toEqual(false);\n});\n\ntest(\"get options\", () => {\n  expect(z.enum([\"tuna\", \"trout\"]).options).toEqual([\"tuna\", \"trout\"]);\n});\n\ntest(\"readonly enum\", () => {\n  const HTTP_SUCCESS = [\"200\", \"201\"] as const;\n  const arg = z.enum(HTTP_SUCCESS);\n  type arg = z.infer<typeof arg>;\n  expectTypeOf<arg>().toEqualTypeOf<\"200\" | \"201\">();\n\n  arg.parse(\"201\");\n  expect(() => arg.parse(\"202\")).toThrow();\n});\n\ntest(\"error map\", () => {\n  const result = z\n    .enum([\"test\"], { error: (iss) => (iss.input === undefined ? \"REQUIRED\" : undefined) })\n    .safeParse(undefined);\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues[0].message).toEqual(\"REQUIRED\");\n  }\n});\n\ntest(\"type signatures\", () => {\n  const a = z.enum([\"a\", \"b\", \"c\"]);\n  const b = z.enum(a.options);\n  expectTypeOf(a).toEqualTypeOf(b);\n\n  const c = z.enum({ a: 1, b: 2 } as const);\n  expectTypeOf(c.enum).toEqualTypeOf<{\n    readonly a: 1;\n    readonly b: 2;\n  }>();\n\n  enum Fruit {\n    Apple = \"apple\",\n    Banana = \"banana\",\n    Orange = \"orange\",\n  }\n  const d = z.enum(Fruit);\n  expectTypeOf(d.enum).toEqualTypeOf(Fruit);\n\n  const e = z.enum({ a: 1, b: 2 });\n  expectTypeOf(e.enum).toEqualTypeOf<{\n    readonly a: 1;\n    readonly b: 2;\n  }>();\n});\n\ntest(\"extract\", () => {\n  const foods = [\"Pasta\", \"Pizza\", \"Tacos\", \"Burgers\", \"Salad\"] as const;\n  const FoodEnum = z.enum(foods);\n  const ItalianEnum = FoodEnum.extract([\"Pasta\", \"Pizza\"]);\n\n  expect(ItalianEnum.safeParse(\"Pasta\").success).toEqual(true);\n  expect(ItalianEnum.safeParse(\"Tacos\").success).toEqual(false);\n\n  expectTypeOf<z.infer<typeof ItalianEnum>>().toEqualTypeOf<\"Pasta\" | \"Pizza\">();\n});\n\ntest(\"exclude\", () => {\n  const foods = [\"Pasta\", \"Pizza\", \"Tacos\", \"Burgers\", \"Salad\"] as const;\n  const FoodEnum = z.enum(foods);\n  const UnhealthyEnum = FoodEnum.exclude([\"Salad\"]);\n\n  expect(UnhealthyEnum.safeParse(\"Pasta\").success).toEqual(true);\n  expect(UnhealthyEnum.safeParse(\"Salad\").success).toEqual(false);\n  expectTypeOf<z.infer<typeof UnhealthyEnum>>().toEqualTypeOf<\"Pasta\" | \"Pizza\" | \"Tacos\" | \"Burgers\">();\n\n  const EmptyFoodEnum = FoodEnum.exclude(foods);\n  expectTypeOf<typeof EmptyFoodEnum>().toEqualTypeOf<z.ZodEnum<{}>>();\n  expectTypeOf<z.infer<typeof EmptyFoodEnum>>().toEqualTypeOf<never>();\n});\n\ntest(\"error map inheritance\", () => {\n  const foods = [\"Pasta\", \"Pizza\", \"Tacos\", \"Burgers\", \"Salad\"] as const;\n  const FoodEnum = z.enum(foods, { error: () => \"This is not food!\" });\n  const ItalianEnum = FoodEnum.extract([\"Pasta\", \"Pizza\"]);\n\n  const foodsError = FoodEnum.safeParse(\"Cucumbers\");\n  const italianError = ItalianEnum.safeParse(\"Tacos\");\n\n  expect(foodsError.error!.issues[0].message).toEqual(italianError.error!.issues[0].message);\n\n  const UnhealthyEnum = FoodEnum.exclude([\"Salad\"], {\n    error: () => ({ message: \"This is not healthy food!\" }),\n  });\n  const unhealthyError = UnhealthyEnum.safeParse(\"Salad\");\n  if (!unhealthyError.success) {\n    expect(unhealthyError.error.issues[0].message).toEqual(\"This is not healthy food!\");\n  }\n});\n\ntest(\"readonly in ZodEnumDef\", () => {\n  type _a = z.ZodEnum<{ readonly a: \"a\"; readonly b: \"b\" }>;\n  type _b = z.ZodEnum<{ a: \"a\"; b: \"b\" }>;\n});\n\ntest(\"enum error message, invalid enum elementstring\", () => {\n  const result = z.enum([\"Tuna\", \"Trout\"]).safeParse(\"Salmon\");\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_value\",\n        \"values\": [\n          \"Tuna\",\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Invalid option: expected one of \\\\\"Tuna\\\\\"|\\\\\"Trout\\\\\"\"\n      }\n    ]]\n  `);\n});\n\ntest(\"enum error message, invalid type\", () => {\n  const result = z.enum([\"Tuna\", \"Trout\"]).safeParse(12);\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  // expect(result.error!.issues[0].message).toEqual('Invalid input: expected one of \"Tuna\"|\"Trout\"');\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_value\",\n        \"values\": [\n          \"Tuna\",\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Invalid option: expected one of \\\\\"Tuna\\\\\"|\\\\\"Trout\\\\\"\"\n      }\n    ]]\n  `);\n});\n\ntest(\"nativeEnum default error message\", () => {\n  enum Fish {\n    Tuna = \"Tuna\",\n    Trout = \"Trout\",\n  }\n  const result = z.nativeEnum(Fish).safeParse(\"Salmon\");\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  // expect(result.error!.issues[0].message).toEqual('Invalid input: expected one of \"Tuna\"|\"Trout\"');\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_value\",\n        \"values\": [\n          \"Tuna\",\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Invalid option: expected one of \\\\\"Tuna\\\\\"|\\\\\"Trout\\\\\"\"\n      }\n    ]]\n  `);\n});\n\ntest(\"enum with message returns the custom error message\", () => {\n  const schema = z.enum([\"apple\", \"banana\"], {\n    message: \"the value provided is invalid\",\n  });\n\n  const result1 = schema.safeParse(\"berries\");\n  expect(result1.success).toEqual(false);\n  if (!result1.success) {\n    expect(result1.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n\n  const result2 = schema.safeParse(undefined);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n\n  const result3 = schema.safeParse(\"banana\");\n  expect(result3.success).toEqual(true);\n\n  const result4 = schema.safeParse(null);\n  expect(result4.success).toEqual(false);\n  if (!result4.success) {\n    expect(result4.error.issues[0].message).toEqual(\"the value provided is invalid\");\n  }\n});\n\ntest(\"enum with diagonal keys\", () => {\n  const schema_02 = z.enum({\n    A: 1,\n    B: \"A\",\n  });\n\n  expect(schema_02.safeParse(\"A\")).toMatchObject({ success: true });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/error-utils.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ndeclare const iss: z.core.$ZodIssueCode;\n\nconst Test = z.object({\n  f1: z.number(),\n  f2: z.string().optional(),\n  f3: z.string().nullable(),\n  f4: z.array(z.object({ t: z.union([z.string(), z.boolean()]) })),\n});\n// type TestFlattenedErrors = core.inferFlattenedErrors<typeof Test, { message: string; code: number }>;\n// type TestFormErrors = core.inferFlattenedErrors<typeof Test>;\nconst parsed = Test.safeParse({});\n\ntest(\"regular error\", () => {\n  expect(parsed).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"f1\"\n        ],\n        \"message\": \"Invalid input: expected number, received undefined\"\n      },\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"f3\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      },\n      {\n        \"expected\": \"array\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"f4\"\n        ],\n        \"message\": \"Invalid input: expected array, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\".flatten()\", () => {\n  const flattened = parsed.error!.flatten();\n  // flattened.\n  expectTypeOf(flattened).toMatchTypeOf<{\n    formErrors: string[];\n    fieldErrors: {\n      f2?: string[];\n      f1?: string[];\n      f3?: string[];\n      f4?: string[];\n    };\n  }>();\n\n  expect(flattened).toMatchInlineSnapshot(`\n    {\n      \"fieldErrors\": {\n        \"f1\": [\n          \"Invalid input: expected number, received undefined\",\n        ],\n        \"f3\": [\n          \"Invalid input: expected string, received undefined\",\n        ],\n        \"f4\": [\n          \"Invalid input: expected array, received undefined\",\n        ],\n      },\n      \"formErrors\": [],\n    }\n  `);\n});\n\ntest(\"custom .flatten()\", () => {\n  type ErrorType = { message: string; code: number };\n  const flattened = parsed.error!.flatten((iss) => ({ message: iss.message, code: 1234 }));\n  expectTypeOf(flattened).toMatchTypeOf<{\n    formErrors: ErrorType[];\n    fieldErrors: {\n      f2?: ErrorType[];\n      f1?: ErrorType[];\n      f3?: ErrorType[];\n      f4?: ErrorType[];\n    };\n  }>();\n\n  expect(flattened).toMatchInlineSnapshot(`\n    {\n      \"fieldErrors\": {\n        \"f1\": [\n          {\n            \"code\": 1234,\n            \"message\": \"Invalid input: expected number, received undefined\",\n          },\n        ],\n        \"f3\": [\n          {\n            \"code\": 1234,\n            \"message\": \"Invalid input: expected string, received undefined\",\n          },\n        ],\n        \"f4\": [\n          {\n            \"code\": 1234,\n            \"message\": \"Invalid input: expected array, received undefined\",\n          },\n        ],\n      },\n      \"formErrors\": [],\n    }\n  `);\n});\n\ntest(\".format()\", () => {\n  const formatted = parsed.error!.format();\n  expectTypeOf(formatted).toMatchTypeOf<{\n    _errors: string[];\n    f2?: { _errors: string[] };\n    f1?: { _errors: string[] };\n    f3?: { _errors: string[] };\n    f4?: {\n      [x: number]: {\n        _errors: string[];\n        t?: {\n          _errors: string[];\n        };\n      };\n      _errors: string[];\n    };\n  }>();\n\n  expect(formatted).toMatchInlineSnapshot(`\n    {\n      \"_errors\": [],\n      \"f1\": {\n        \"_errors\": [\n          \"Invalid input: expected number, received undefined\",\n        ],\n      },\n      \"f3\": {\n        \"_errors\": [\n          \"Invalid input: expected string, received undefined\",\n        ],\n      },\n      \"f4\": {\n        \"_errors\": [\n          \"Invalid input: expected array, received undefined\",\n        ],\n      },\n    }\n  `);\n});\n\ntest(\"custom .format()\", () => {\n  type ErrorType = { message: string; code: number };\n  const formatted = parsed.error!.format((iss) => ({ message: iss.message, code: 1234 }));\n  expectTypeOf(formatted).toMatchTypeOf<{\n    _errors: ErrorType[];\n    f2?: { _errors: ErrorType[] };\n    f1?: { _errors: ErrorType[] };\n    f3?: { _errors: ErrorType[] };\n    f4?: {\n      [x: number]: {\n        _errors: ErrorType[];\n        t?: {\n          _errors: ErrorType[];\n        };\n      };\n      _errors: ErrorType[];\n    };\n  }>();\n\n  expect(formatted).toMatchInlineSnapshot(`\n    {\n      \"_errors\": [],\n      \"f1\": {\n        \"_errors\": [\n          {\n            \"code\": 1234,\n            \"message\": \"Invalid input: expected number, received undefined\",\n          },\n        ],\n      },\n      \"f3\": {\n        \"_errors\": [\n          {\n            \"code\": 1234,\n            \"message\": \"Invalid input: expected string, received undefined\",\n          },\n        ],\n      },\n      \"f4\": {\n        \"_errors\": [\n          {\n            \"code\": 1234,\n            \"message\": \"Invalid input: expected array, received undefined\",\n          },\n        ],\n      },\n    }\n  `);\n});\n\ntest(\"all errors\", () => {\n  const propertySchema = z.string();\n  const schema = z\n    .object({\n      a: propertySchema,\n      b: propertySchema,\n    })\n    .refine(\n      (val) => {\n        return val.a === val.b;\n      },\n      { message: \"Must be equal\" }\n    );\n\n  const r1 = schema.safeParse({\n    a: \"asdf\",\n    b: \"qwer\",\n  });\n\n  expect(z.core.flattenError(r1.error!)).toEqual({\n    formErrors: [\"Must be equal\"],\n    fieldErrors: {},\n  });\n\n  const r2 = schema.safeParse({\n    a: null,\n    b: null,\n  });\n\n  // const error = _error as z.ZodError;\n  expect(z.core.flattenError(r2.error!)).toMatchInlineSnapshot(`\n    {\n      \"fieldErrors\": {\n        \"a\": [\n          \"Invalid input: expected string, received null\",\n        ],\n        \"b\": [\n          \"Invalid input: expected string, received null\",\n        ],\n      },\n      \"formErrors\": [],\n    }\n  `);\n\n  expect(z.core.flattenError(r2.error!, (iss) => iss.message.toUpperCase())).toMatchInlineSnapshot(`\n    {\n      \"fieldErrors\": {\n        \"a\": [\n          \"INVALID INPUT: EXPECTED STRING, RECEIVED NULL\",\n        ],\n        \"b\": [\n          \"INVALID INPUT: EXPECTED STRING, RECEIVED NULL\",\n        ],\n      },\n      \"formErrors\": [],\n    }\n  `);\n  // Test identity\n\n  expect(z.core.flattenError(r2.error!, (i: z.ZodIssue) => i)).toMatchInlineSnapshot(`\n    {\n      \"fieldErrors\": {\n        \"a\": [\n          {\n            \"code\": \"invalid_type\",\n            \"expected\": \"string\",\n            \"message\": \"Invalid input: expected string, received null\",\n            \"path\": [\n              \"a\",\n            ],\n          },\n        ],\n        \"b\": [\n          {\n            \"code\": \"invalid_type\",\n            \"expected\": \"string\",\n            \"message\": \"Invalid input: expected string, received null\",\n            \"path\": [\n              \"b\",\n            ],\n          },\n        ],\n      },\n      \"formErrors\": [],\n    }\n  `);\n\n  // Test mapping\n  const f1 = z.core.flattenError(r2.error!, (i: z.ZodIssue) => i.message.length);\n  expect(f1).toMatchInlineSnapshot(`\n    {\n      \"fieldErrors\": {\n        \"a\": [\n          45,\n        ],\n        \"b\": [\n          45,\n        ],\n      },\n      \"formErrors\": [],\n    }\n  `);\n  // expect(f1.fieldErrors.a![0]).toEqual(\"Invalid input: expected string\".length);\n  // expect(f1).toMatchObject({\n  //   formErrors: [],\n  //   fieldErrors: {\n  //     a: [\"Invalid input: expected string\".length],\n  //     b: [\"Invalid input: expected string\".length],\n  //   },\n  // });\n});\n\nconst schema = z.strictObject({\n  username: z.string(),\n  favoriteNumbers: z.array(z.number()),\n  nesting: z.object({\n    a: z.string(),\n  }),\n});\nconst result = schema.safeParse({\n  username: 1234,\n  favoriteNumbers: [1234, \"4567\"],\n  nesting: {\n    a: 123,\n  },\n  extra: 1234,\n});\n\ntest(\"z.treeifyError\", () => {\n  expect(z.treeifyError(result.error!)).toMatchInlineSnapshot(`\n    {\n      \"errors\": [\n        \"Unrecognized key: \"extra\"\",\n      ],\n      \"properties\": {\n        \"favoriteNumbers\": {\n          \"errors\": [],\n          \"items\": [\n            ,\n            {\n              \"errors\": [\n                \"Invalid input: expected number, received string\",\n              ],\n            },\n          ],\n        },\n        \"nesting\": {\n          \"errors\": [],\n          \"properties\": {\n            \"a\": {\n              \"errors\": [\n                \"Invalid input: expected string, received number\",\n              ],\n            },\n          },\n        },\n        \"username\": {\n          \"errors\": [\n            \"Invalid input: expected string, received number\",\n          ],\n        },\n      },\n    }\n  `);\n});\n\ntest(\"z.treeifyError 2\", () => {\n  const schema = z.strictObject({\n    name: z.string(),\n    logLevel: z.union([z.string(), z.number()]),\n    env: z.literal([\"production\", \"development\"]),\n  });\n\n  const data = {\n    name: 1000,\n    logLevel: false,\n    extra: 1000,\n  };\n\n  const result = schema.safeParse(data);\n  const err = z.treeifyError(result.error!);\n  expect(err).toMatchInlineSnapshot(`\n    {\n      \"errors\": [\n        \"Unrecognized key: \"extra\"\",\n      ],\n      \"properties\": {\n        \"env\": {\n          \"errors\": [\n            \"Invalid option: expected one of \"production\"|\"development\"\",\n          ],\n        },\n        \"logLevel\": {\n          \"errors\": [\n            \"Invalid input: expected string, received boolean\",\n            \"Invalid input: expected number, received boolean\",\n          ],\n        },\n        \"name\": {\n          \"errors\": [\n            \"Invalid input: expected string, received number\",\n          ],\n        },\n      },\n    }\n  `);\n});\n\ntest(\"z.prettifyError\", () => {\n  expect(z.prettifyError(result.error!)).toMatchInlineSnapshot(`\n    \"✖ Unrecognized key: \"extra\"\n    ✖ Invalid input: expected string, received number\n      → at username\n    ✖ Invalid input: expected number, received string\n      → at favoriteNumbers[1]\n    ✖ Invalid input: expected string, received number\n      → at nesting.a\"\n  `);\n});\n\ntest(\"z.toDotPath\", () => {\n  expect(z.core.toDotPath([\"a\", \"b\", 0, \"c\"])).toMatchInlineSnapshot(`\"a.b[0].c\"`);\n\n  expect(z.core.toDotPath([\"a\", Symbol(\"b\"), 0, \"c\"])).toMatchInlineSnapshot(`\"a[\"Symbol(b)\"][0].c\"`);\n\n  // Test with periods in keys\n  expect(z.core.toDotPath([\"user.name\", \"first.last\"])).toMatchInlineSnapshot(`\"[\"user.name\"][\"first.last\"]\"`);\n\n  // Test with special characters\n  expect(z.core.toDotPath([\"user\", \"$special\", Symbol(\"#symbol\")])).toMatchInlineSnapshot(\n    `\"user.$special[\"Symbol(#symbol)\"]\"`\n  );\n\n  // Test with dots and quotes\n  expect(z.core.toDotPath([\"search\", `query(\"foo.bar\"=\"abc\")`])).toMatchInlineSnapshot(\n    `\"search[\"query(\\\\\"foo.bar\\\\\"=\\\\\"abc\\\\\")\"]\"`\n  );\n\n  // Test with newlines\n  expect(z.core.toDotPath([\"search\", `foo\\nbar`])).toMatchInlineSnapshot(`\"search[\"foo\\\\nbar\"]\"`);\n\n  // Test with empty strings\n  expect(z.core.toDotPath([\"\", \"empty\"])).toMatchInlineSnapshot(`\".empty\"`);\n\n  // Test with array indices\n  expect(z.core.toDotPath([\"items\", 0, 1, 2])).toMatchInlineSnapshot(`\"items[0][1][2]\"`);\n\n  // Test with mixed path elements\n  expect(z.core.toDotPath([\"users\", \"user.config\", 0, \"settings.theme\"])).toMatchInlineSnapshot(\n    `\"users[\"user.config\"][0][\"settings.theme\"]\"`\n  );\n\n  // Test with square brackets in keys\n  expect(z.core.toDotPath([\"data[0]\", \"value\"])).toMatchInlineSnapshot(`\"[\"data[0]\"].value\"`);\n\n  // Test with empty path\n  expect(z.core.toDotPath([])).toMatchInlineSnapshot(`\"\"`);\n});\n\ntest(\"inheritance\", () => {\n  const e1 = new z.ZodError([]);\n  expect(e1).toBeInstanceOf(z.core.$ZodError);\n  expect(e1).toBeInstanceOf(z.ZodError);\n  // expect(e1).not.toBeInstanceOf(Error);\n\n  const e2 = new z.ZodRealError([]);\n  expect(e2).toBeInstanceOf(z.ZodError);\n  expect(e2).toBeInstanceOf(z.ZodRealError);\n  expect(e2).toBeInstanceOf(Error);\n});\n\ntest(\"disc union treeify/format\", () => {\n  const schema = z.discriminatedUnion(\n    \"foo\",\n    [\n      z.object({\n        foo: z.literal(\"x\"),\n        x: z.string(),\n      }),\n      z.object({\n        foo: z.literal(\"y\"),\n        y: z.string(),\n      }),\n    ],\n    {\n      error: \"Invalid discriminator\",\n    }\n  );\n\n  const error = schema.safeParse({ foo: \"invalid\" }).error;\n  expect(z.treeifyError(error!)).toMatchInlineSnapshot(`\n    {\n      \"errors\": [],\n      \"properties\": {\n        \"foo\": {\n          \"errors\": [\n            \"Invalid discriminator\",\n          ],\n        },\n      },\n    }\n  `);\n  expect(z.prettifyError(error!)).toMatchInlineSnapshot(`\n    \"✖ Invalid discriminator\n      → at foo\"\n  `);\n  expect(z.formatError(error!)).toMatchInlineSnapshot(`\n    {\n      \"_errors\": [],\n      \"foo\": {\n        \"_errors\": [\n          \"Invalid discriminator\",\n        ],\n      },\n    }\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/error.test.ts",
    "content": "import { inspect } from \"node:util\";\nimport { expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"error creation\", () => {\n  const err1 = new z.ZodError([]);\n\n  err1.issues.push({\n    code: \"invalid_type\",\n    expected: \"object\",\n    path: [],\n    message: \"\",\n    input: \"adf\",\n  });\n  err1.isEmpty;\n\n  const err2 = new z.ZodError(err1.issues);\n  const err3 = new z.ZodError([]);\n  err3.addIssues(err1.issues);\n  err3.addIssue(err1.issues[0]);\n  err1.message;\n  err2.message;\n  err3.message;\n});\n\ntest(\"do not allow error and message together\", () => {\n  expect(() =>\n    z.string().refine((_) => true, {\n      message: \"override\",\n      error: (iss) => (iss.input === undefined ? \"asdf\" : null),\n    })\n  ).toThrow();\n});\n\nconst errorMap: z.ZodErrorMap = (issue) => {\n  if (issue.code === \"invalid_type\") {\n    if (issue.expected === \"string\") {\n      return { message: \"bad type!\" };\n    }\n  }\n  if (issue.code === \"custom\") {\n    return { message: `less-than-${issue.params?.minimum}` };\n  }\n  return undefined;\n};\n\ntest(\"type error with custom error map\", () => {\n  const result = z.string().safeParse(234, { error: errorMap });\n  expect(result.success).toBe(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"bad type!\"\n      }\n    ]]\n  `);\n});\n\ntest(\"refinement fail with params\", () => {\n  const result = z\n    .number()\n    .refine((val) => val >= 3, {\n      params: { minimum: 3 },\n    })\n    .safeParse(2, { error: errorMap });\n  expect(result.success).toBe(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"params\": {\n          \"minimum\": 3\n        },\n        \"message\": \"less-than-3\"\n      }\n    ]]\n  `);\n});\n\ntest(\"hard coded error  with custom errormap\", () => {\n  const result = z\n    .string()\n    .refine((val) => val.length > 12, {\n      params: { minimum: 13 },\n      message: \"override\",\n    })\n    .safeParse(\"asdf\", { error: () => \"contextual\" });\n\n  expect(result.success).toBe(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"params\": {\n          \"minimum\": 13\n        },\n        \"message\": \"override\"\n      }\n    ]]\n  `);\n});\n\ntest(\"default error message\", () => {\n  const result = z\n    .number()\n    .refine((x) => x > 3)\n    .safeParse(2);\n\n  expect(result.success).toBe(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]]\n  `);\n});\n\ntest(\"override error in refine\", () => {\n  const result = z\n    .number()\n    .refine((x) => x > 3, \"override\")\n    .safeParse(2);\n  expect(result.success).toBe(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"override\"\n      }\n    ]]\n  `);\n});\n\ntest(\"override error in refinement\", () => {\n  const result = z\n    .number()\n    .refine((x) => x > 3, {\n      message: \"override\",\n    })\n    .safeParse(2);\n  expect(result.success).toBe(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"override\"\n      }\n    ]]\n  `);\n});\n\ntest(\"array minimum\", () => {\n  let result = z.array(z.string()).min(3, \"tooshort\").safeParse([\"asdf\", \"qwer\"]);\n  expect(result.success).toBe(false);\n  expect(result.error!.issues[0].code).toEqual(\"too_small\");\n  expect(result.error!.issues[0].message).toEqual(\"tooshort\");\n\n  result = z.array(z.string()).min(3).safeParse([\"asdf\", \"qwer\"]);\n  expect(result.success).toBe(false);\n  expect(result.error!.issues[0].code).toEqual(\"too_small\");\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"array\",\n        \"code\": \"too_small\",\n        \"minimum\": 3,\n        \"inclusive\": true,\n        \"path\": [],\n        \"message\": \"Too small: expected array to have >=3 items\"\n      }\n    ]]\n  `);\n});\n\ntest(\"literal bigint default error message\", () => {\n  const result = z.literal(BigInt(12)).safeParse(BigInt(13));\n  expect(result.success).toBe(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_value\",\n        \"values\": [\n          \"12\"\n        ],\n        \"path\": [],\n        \"message\": \"Invalid input: expected 12n\"\n      }\n    ]]\n  `);\n});\n\ntest(\"custom path in custom error map\", () => {\n  const schema = z.object({\n    items: z.array(z.string()).refine((data) => data.length > 3, {\n      path: [\"items-too-few\"],\n    }),\n  });\n\n  const errorMap: z.ZodErrorMap = (issue) => {\n    expect((issue.path ?? []).length).toBe(2);\n    return { message: \"doesnt matter\" };\n  };\n  const result = schema.safeParse({ items: [\"first\"] }, { error: errorMap });\n  expect(result.success).toBe(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"items\",\n          \"items-too-few\"\n        ],\n        \"message\": \"doesnt matter\"\n      }\n    ]]\n  `);\n});\n\n// test(\"error metadata from value\", () => {\n//   const dynamicRefine = z.string().refine(\n//     (val) => val === val.toUpperCase(),\n//     (val) => ({ params: { val } })\n//   );\n\n//   const result = dynamicRefine.safeParse(\"asdf\");\n//   expect(result.success).toEqual(false);\n//   if (!result.success) {\n//     const sub = result.error.issues[0];\n//     expect(result.error.issues[0].code).toEqual(\"custom\");\n//     if (sub.code === \"custom\") {\n//       expect(sub.params?.val).toEqual(\"asdf\");\n//     }\n//   }\n// });\n\n// test(\"don't call refine after validation failed\", () => {\n//   const asdf = z\n//     .union([\n//       z.number(),\n//       z.string().transform(z.number(), (val) => {\n//         return parseFloat(val);\n//       }),\n//     ])\n//     .refine((v) => v >= 1);\n\n//   expect(() => asdf.safeParse(\"foo\")).not.toThrow();\n// });\n\ntest(\"root level formatting\", () => {\n  const schema = z.string().email();\n  const result = schema.safeParse(\"asdfsdf\");\n  expect(result.success).toBe(false);\n\n  expect(result.error!.format()).toMatchInlineSnapshot(`\n    {\n      \"_errors\": [\n        \"Invalid email address\",\n      ],\n    }\n  `);\n});\n\ntest(\"custom path\", () => {\n  const schema = z\n    .object({\n      password: z.string(),\n      confirm: z.string(),\n    })\n    .refine((val) => val.confirm === val.password, { path: [\"confirm\"] });\n\n  const result = schema.safeParse({\n    password: \"peanuts\",\n    confirm: \"qeanuts\",\n  });\n\n  expect(result.success).toBe(false);\n  const error = result.error!.format();\n  expect(error._errors).toEqual([]);\n  expect(error.password?._errors).toEqual(undefined);\n  expect(error.confirm?._errors).toEqual([\"Invalid input\"]);\n});\n\ntest(\"custom path\", () => {\n  const schema = z\n    .object({\n      password: z.string().min(6),\n      confirm: z.string().min(6),\n    })\n    .refine((val) => val.confirm === val.password);\n\n  const result = schema.safeParse({\n    password: \"qwer\",\n    confirm: \"asdf\",\n  });\n\n  expect(result.success).toBe(false);\n  expect(result.error!.issues.length).toEqual(3);\n});\n\nconst schema = z.object({\n  inner: z.object({\n    name: z\n      .string()\n      .refine((val) => val.length > 5)\n      .array()\n      .refine((val) => val.length <= 1),\n  }),\n});\n\ntest(\"no abort early on refinements\", () => {\n  const invalidItem = {\n    inner: { name: [\"aasd\", \"asdfasdfasfd\"] },\n  };\n\n  const result1 = schema.safeParse(invalidItem);\n  expect(result1.success).toBe(false);\n  expect(result1.error!.issues.length).toEqual(2);\n});\n\ntest(\"detect issue with input fallback\", () => {\n  const schema = z\n    .string()\n    .transform((val) => val.length)\n    .refine(() => false, { message: \"always fails\" })\n    .refine(\n      (val) => {\n        if (typeof val !== \"number\") throw new Error();\n        return (val ^ 2) > 10;\n      } // should be number but it's a string\n    );\n  expect(() => schema.parse(\"hello\")).toThrow(z.ZodError);\n});\n\ntest(\"formatting\", () => {\n  const invalidItem = {\n    inner: { name: [\"aasd\", \"asdfasdfasfd\"] },\n  };\n  const invalidArray = {\n    inner: { name: [\"asdfasdf\", \"asdfasdfasfd\"] },\n  };\n  const result1 = schema.safeParse(invalidItem);\n  const result2 = schema.safeParse(invalidArray);\n\n  expect(result1.success).toBe(false);\n  expect(result2.success).toBe(false);\n  const error1 = result1.error!.format();\n  expect(error1._errors).toEqual([]);\n  expect(error1.inner?._errors).toEqual([]);\n  expect(error1.inner?.name?.[1]).toEqual(undefined);\n\n  type FormattedError = z.inferFormattedError<typeof schema>;\n  const error2: FormattedError = result2.error!.format();\n  expect(error2._errors).toEqual([]);\n  expect(error2.inner?._errors).toEqual([]);\n  expect(error2.inner?.name?._errors).toEqual([\"Invalid input\"]);\n  expect(error2.inner?.name?.[0]).toEqual(undefined);\n  expect(error2.inner?.name?.[1]).toEqual(undefined);\n  expect(error2.inner?.name?.[2]).toEqual(undefined);\n\n  // test custom mapper\n  type FormattedErrorWithNumber = z.inferFormattedError<typeof schema, number>;\n  const errorWithNumber: FormattedErrorWithNumber = result2.error!.format(() => 5);\n  expect(errorWithNumber._errors).toEqual([]);\n  expect(errorWithNumber.inner?._errors).toEqual([]);\n  expect(errorWithNumber.inner?.name?._errors).toEqual([5]);\n});\n\ntest(\"formatting with nullable and optional fields\", () => {\n  const nameSchema = z.string().refine((val) => val.length > 5);\n  const schema = z.object({\n    nullableObject: z.object({ name: nameSchema }).nullable(),\n    nullableArray: z.array(nameSchema).nullable(),\n    nullableTuple: z.tuple([nameSchema, nameSchema, z.number()]).nullable(),\n    optionalObject: z.object({ name: nameSchema }).optional(),\n    optionalArray: z.array(nameSchema).optional(),\n    optionalTuple: z.tuple([nameSchema, nameSchema, z.number()]).optional(),\n  });\n  const invalidItem = {\n    nullableObject: { name: \"abcd\" },\n    nullableArray: [\"abcd\"],\n    nullableTuple: [\"abcd\", \"abcd\", 1],\n    optionalObject: { name: \"abcd\" },\n    optionalArray: [\"abcd\"],\n    optionalTuple: [\"abcd\", \"abcd\", 1],\n  };\n  const result = schema.safeParse(invalidItem);\n  expect(result.success).toBe(false);\n  const error: z.inferFormattedError<typeof schema> = result.error!.format();\n  expect(error._errors).toEqual([]);\n  expect(error.nullableObject?._errors).toEqual([]);\n  expect(error.nullableObject?.name?._errors).toEqual([\"Invalid input\"]);\n  expect(error.nullableArray?._errors).toEqual([]);\n  expect(error.nullableArray?.[0]?._errors).toEqual([\"Invalid input\"]);\n  expect(error.nullableTuple?._errors).toEqual([]);\n  expect(error.nullableTuple?.[0]?._errors).toEqual([\"Invalid input\"]);\n  expect(error.nullableTuple?.[1]?._errors).toEqual([\"Invalid input\"]);\n  expect(error.optionalObject?._errors).toEqual([]);\n  expect(error.optionalObject?.name?._errors).toEqual([\"Invalid input\"]);\n  expect(error.optionalArray?._errors).toEqual([]);\n  expect(error.optionalArray?.[0]?._errors).toEqual([\"Invalid input\"]);\n  expect(error.optionalTuple?._errors).toEqual([]);\n  expect(error.optionalTuple?.[0]?._errors).toEqual([\"Invalid input\"]);\n  expect(error.optionalTuple?.[1]?._errors).toEqual([\"Invalid input\"]);\n\n  expect(error).toMatchInlineSnapshot(`\n    {\n      \"_errors\": [],\n      \"nullableArray\": {\n        \"0\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n        \"_errors\": [],\n      },\n      \"nullableObject\": {\n        \"_errors\": [],\n        \"name\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n      },\n      \"nullableTuple\": {\n        \"0\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n        \"1\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n        \"_errors\": [],\n      },\n      \"optionalArray\": {\n        \"0\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n        \"_errors\": [],\n      },\n      \"optionalObject\": {\n        \"_errors\": [],\n        \"name\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n      },\n      \"optionalTuple\": {\n        \"0\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n        \"1\": {\n          \"_errors\": [\n            \"Invalid input\",\n          ],\n        },\n        \"_errors\": [],\n      },\n    }\n  `);\n});\n\ntest(\"inferFlattenedErrors\", () => {\n  const schemaWithTransform = z.object({ foo: z.string() }).transform((o) => ({ bar: o.foo }));\n\n  const result = schemaWithTransform.safeParse({});\n\n  expect(result.success).toBe(false);\n  type ValidationErrors = z.inferFlattenedErrors<typeof schemaWithTransform>;\n  const error: ValidationErrors = result.error!.flatten();\n  expect(error).toMatchInlineSnapshot(`\n    {\n      \"fieldErrors\": {\n        \"foo\": [\n          \"Invalid input: expected string, received undefined\",\n        ],\n      },\n      \"formErrors\": [],\n    }\n  `);\n});\n\nconst stringWithCustomError = z.string({\n  error: () => \"bound\",\n});\n\ntest(\"schema-bound error map\", () => {\n  const result = stringWithCustomError.safeParse(1234);\n  expect(result.success).toBe(false);\n  expect(result.error!.issues[0].message).toEqual(\"bound\");\n});\n\ntest(\"bound error map overrides contextual\", () => {\n  // support contextual override\n  const result = stringWithCustomError.safeParse(undefined, {\n    error: () => ({ message: \"override\" }),\n  });\n  expect(result.success).toBe(false);\n  expect(result.error!.issues[0].message).toEqual(\"bound\");\n});\n\ntest(\"z.config customError \", () => {\n  // support overrideErrorMap\n\n  z.config({ customError: () => ({ message: \"override\" }) });\n  const result = stringWithCustomError.min(10).safeParse(\"tooshort\");\n  expect(result.success).toBe(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"too_small\",\n        \"minimum\": 10,\n        \"inclusive\": true,\n        \"path\": [],\n        \"message\": \"override\"\n      }\n    ]]\n  `);\n  expect(result.error!.issues[0].message).toEqual(\"override\");\n  z.config({ customError: undefined });\n});\n\n// test(\"invalid and required\", () => {\n//   const str = z.string({\n//     invalid_type_error: \"Invalid name\",\n//     required_error: \"Name is required\",\n//   });\n//   const result1 = str.safeParse(1234);\n//   expect(result1.success).toBe(false);\n//   if (!result1.success) {\n//     expect(result1.error.issues[0].message).toEqual(\"Invalid name\");\n//   }\n//   const result2 = str.safeParse(undefined);\n//   expect(result2.success).toBe(false);\n//   if (!result2.success) {\n//     expect(result2.error.issues[0].message).toEqual(\"Name is required\");\n//   }\n// });\n\n// test(\"Fallback to default required error\", () => {\n//   const str = z.string({\n//     invalid_type_error: \"Invalid name\",\n//     // required_error: \"Name is required\",\n//   });\n\n//   const result2 = str.safeParse(undefined);\n//   expect(result2.success).toBe(false);\n//   if (!result2.success) {\n//     expect(result2.error.issues[0].message).toEqual(\"Required\");\n//   }\n// });\n\n// test(\"invalid and required and errorMap\", () => {\n//   expect(() => {\n//     return z.string({\n//       invalid_type_error: \"Invalid name\",\n//       required_error: \"Name is required\",\n//       errorMap: () => ({ message: \"override\" }),\n//     });\n//   }).toThrow();\n// });\n\n// test(\"strict error message\", () => {\n//   const errorMsg = \"Invalid object\";\n//   const obj = z.object({ x: z.string() }).strict(errorMsg);\n//   const result = obj.safeParse({ x: \"a\", y: \"b\" });\n//   expect(result.success).toBe(false);\n//   if (!result.success) {\n//     expect(result.error.issues[0].message).toEqual(errorMsg);\n//   }\n// });\n\ntest(\"empty string error message\", () => {\n  const schema = z.string().max(1, { message: \"\" });\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toBe(false);\n  expect(result.error!.issues[0].message).toEqual(\"\");\n});\n\ntest(\"dont short circuit on continuable errors\", () => {\n  const user = z\n    .object({\n      password: z.string().min(6),\n      confirm: z.string(),\n    })\n    .refine((data) => data.password === data.confirm, {\n      message: \"Passwords don't match\",\n      path: [\"confirm\"],\n    });\n  const result = user.safeParse({ password: \"asdf\", confirm: \"qwer\" });\n  expect(result.success).toBe(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"too_small\",\n        \"minimum\": 6,\n        \"inclusive\": true,\n        \"path\": [\n          \"password\"\n        ],\n        \"message\": \"Too small: expected string to have >=6 characters\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"confirm\"\n        ],\n        \"message\": \"Passwords don't match\"\n      }\n    ]]\n  `);\n  // expect(result.error!.issues.length).toEqual(2);\n});\n\ntest(\"string error params\", () => {\n  const a = z.string(\"Bad!\");\n  expect(a.safeParse(123).error!.issues[0].message).toBe(\"Bad!\");\n\n  const b = z.string().min(5, \"Too short!\");\n  expect(b.safeParse(\"abc\").error!.issues[0].message).toBe(\"Too short!\");\n\n  const c = z.uuid(\"Bad UUID!\");\n  expect(c.safeParse(\"not-a-uuid\").error!.issues[0].message).toBe(\"Bad UUID!\");\n\n  const d = z.string().datetime({ message: \"Bad date!\" });\n  expect(d.safeParse(\"not-a-date\").error!.issues[0].message).toBe(\"Bad date!\");\n\n  const e = z.array(z.string(), \"Bad array!\");\n  expect(e.safeParse(\"not-an-array\").error!.issues[0].message).toBe(\"Bad array!\");\n\n  const f = z.array(z.string()).min(5, \"Too few items!\");\n  expect(f.safeParse([\"a\", \"b\"]).error!.issues[0].message).toBe(\"Too few items!\");\n\n  const g = z.set(z.string(), \"Bad set!\");\n  expect(g.safeParse(\"not-a-set\").error!.issues[0].message).toBe(\"Bad set!\");\n\n  const h = z.array(z.string(), \"Bad array!\");\n  expect(h.safeParse(123).error!.issues[0].message).toBe(\"Bad array!\");\n\n  const i = z.set(z.string(), \"Bad set!\");\n  expect(i.safeParse(123).error!.issues[0].message).toBe(\"Bad set!\");\n\n  const j = z.array(z.string(), \"Bad array!\");\n  expect(j.safeParse(null).error!.issues[0].message).toBe(\"Bad array!\");\n});\n\ntest(\"error inheritance\", () => {\n  const e1 = z.string().safeParse(123).error!;\n  expect(e1).toBeInstanceOf(z.core.$ZodError);\n  expect(e1).toBeInstanceOf(z.ZodError);\n  expect(e1).toBeInstanceOf(z.ZodRealError);\n  // expect(e1).not.toBeInstanceOf(Error);\n\n  try {\n    z.string().parse(123);\n  } catch (e2) {\n    expect(e1).toBeInstanceOf(z.core.$ZodError);\n    expect(e2).toBeInstanceOf(z.ZodError);\n    expect(e2).toBeInstanceOf(z.ZodRealError);\n    // expect(e2).toBeInstanceOf(Error);\n  }\n});\n\ntest(\"error serialization\", () => {\n  try {\n    z.string().parse(123);\n  } catch (e) {\n    expect(e).toMatchInlineSnapshot(`\n      [ZodError: [\n        {\n          \"expected\": \"string\",\n          \"code\": \"invalid_type\",\n          \"path\": [],\n          \"message\": \"Invalid input: expected string, received number\"\n        }\n      ]]\n    `);\n    expect(inspect(e).split(\"\\n\").slice(0, 8).join(\"\\n\")).toMatchInlineSnapshot(`\n      \"ZodError: [\n        {\n          \"expected\": \"string\",\n          \"code\": \"invalid_type\",\n          \"path\": [],\n          \"message\": \"Invalid input: expected string, received number\"\n        }\n      ]\"\n    `);\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/file.test.ts",
    "content": "// @ts-ignore\nimport { File as WebFile } from \"@web-std/file\";\n\nimport { afterEach, beforeEach, expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\nconst minCheck = z.file().min(5);\nconst maxCheck = z.file().max(8);\nconst mimeCheck = z.file().mime([\"text/plain\", \"application/json\"]);\n\nconst originalFile = global.File;\nbeforeEach(async () => {\n  if (!globalThis.File) globalThis.File = WebFile;\n});\nafterEach(() => {\n  if (globalThis.File !== originalFile) {\n    globalThis.File = originalFile;\n  }\n});\n\ntest(\"passing validations\", () => {\n  minCheck.safeParse(new File([\"12345\"], \"test.txt\"));\n  maxCheck.safeParse(new File([\"12345678\"], \"test.txt\"));\n  mimeCheck.safeParse(new File([\"\"], \"test.csv\", { type: \"text/plain\" }));\n  expect(() => mimeCheck.parse(new File([\"\"], \"test.txt\"))).toThrow();\n  expect(() => mimeCheck.parse(new File([\"\"], \"test.txt\", { type: \"text/csv\" }))).toThrow();\n});\n\ntest(\"failing validations\", () => {\n  expect(minCheck.safeParse(new File([\"1234\"], \"test.txt\"))).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"origin\": \"file\",\n        \"code\": \"too_small\",\n        \"minimum\": 5,\n        \"path\": [],\n        \"message\": \"Too small: expected file to have >5 bytes\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(maxCheck.safeParse(new File([\"123456789\"], \"test.txt\"))).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"origin\": \"file\",\n        \"code\": \"too_big\",\n        \"maximum\": 8,\n        \"path\": [],\n        \"message\": \"Too big: expected file to have <8 bytes\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(mimeCheck.safeParse(new File([\"\"], \"test.csv\"))).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_value\",\n        \"values\": [\n          \"text/plain\",\n          \"application/json\"\n        ],\n        \"path\": [],\n        \"message\": \"Invalid option: expected one of \\\\\"text/plain\\\\\"|\\\\\"application/json\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(mimeCheck.safeParse(new File([\"\"], \"test.csv\", { type: \"text/csv\" }))).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_value\",\n        \"values\": [\n          \"text/plain\",\n          \"application/json\"\n        ],\n        \"path\": [],\n        \"message\": \"Invalid option: expected one of \\\\\"text/plain\\\\\"|\\\\\"application/json\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/firstparty.test.ts",
    "content": "import { expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\nimport type * as core from \"zod/v4/core\";\n\ntest(\"first party switch\", () => {\n  const myType = z.string() as core.$ZodTypes;\n  const def = myType._zod.def;\n  switch (def.type) {\n    case \"string\":\n      break;\n    case \"number\":\n      break;\n    case \"bigint\":\n      break;\n    case \"boolean\":\n      break;\n    case \"date\":\n      break;\n    case \"symbol\":\n      break;\n    case \"undefined\":\n      break;\n    case \"null\":\n      break;\n    case \"any\":\n      break;\n    case \"unknown\":\n      break;\n    case \"never\":\n      break;\n    case \"void\":\n      break;\n    case \"array\":\n      break;\n    case \"object\":\n      break;\n    case \"union\":\n      break;\n    case \"intersection\":\n      break;\n    case \"tuple\":\n      break;\n    case \"record\":\n      break;\n    case \"map\":\n      break;\n    case \"set\":\n      break;\n    case \"literal\":\n      break;\n    case \"enum\":\n      break;\n    case \"promise\":\n      break;\n    case \"optional\":\n      break;\n    case \"nonoptional\":\n      break;\n    case \"nullable\":\n      break;\n    case \"default\":\n      break;\n    case \"prefault\":\n      break;\n    case \"template_literal\":\n      break;\n    case \"custom\":\n      break;\n    case \"transform\":\n      break;\n    case \"readonly\":\n      break;\n    case \"nan\":\n      break;\n    case \"pipe\":\n      break;\n    case \"success\":\n      break;\n    case \"catch\":\n      break;\n    case \"file\":\n      break;\n    case \"lazy\":\n      break;\n    default:\n      expectTypeOf(def).toEqualTypeOf<never>();\n  }\n});\n\ntest(\"$ZodSchemaTypes\", () => {\n  const type = \"string\" as core.$ZodTypeDef[\"type\"];\n  switch (type) {\n    case \"string\":\n      break;\n    case \"number\":\n      break;\n    case \"int\":\n      break;\n    case \"bigint\":\n      break;\n    case \"boolean\":\n      break;\n    case \"date\":\n      break;\n    case \"symbol\":\n      break;\n    case \"undefined\":\n      break;\n    case \"null\":\n      break;\n    case \"any\":\n      break;\n    case \"unknown\":\n      break;\n    case \"never\":\n      break;\n    case \"void\":\n      break;\n    case \"array\":\n      break;\n    case \"object\":\n      break;\n    case \"union\":\n      break;\n    case \"intersection\":\n      break;\n    case \"tuple\":\n      break;\n    case \"record\":\n      break;\n    case \"map\":\n      break;\n    case \"set\":\n      break;\n    case \"literal\":\n      break;\n    case \"enum\":\n      break;\n    case \"promise\":\n      break;\n    case \"optional\":\n      break;\n    case \"nonoptional\":\n      break;\n    case \"nullable\":\n      break;\n    case \"default\":\n      break;\n    case \"prefault\":\n      break;\n    case \"template_literal\":\n      break;\n    case \"custom\":\n      break;\n    case \"transform\":\n      break;\n    case \"readonly\":\n      break;\n    case \"nan\":\n      break;\n    case \"pipe\":\n      break;\n    case \"success\":\n      break;\n    case \"catch\":\n      break;\n    case \"file\":\n      break;\n    case \"lazy\":\n      break;\n\n    default:\n      expectTypeOf(type).toEqualTypeOf<never>();\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/function.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst args1 = z.tuple([z.string()]);\nconst returns1 = z.number();\nconst func1 = z.function({\n  input: args1,\n\n  output: returns1,\n});\n\ntest(\"function parsing\", () => {\n  const parsed = func1.implement((arg: any) => arg.length);\n  const result = parsed(\"asdf\");\n  expect(result).toBe(4);\n});\n\ntest(\"parsed function fail 1\", () => {\n  // @ts-expect-error\n  const parsed = func1.implement((x: string) => x);\n  expect(() => parsed(\"asdf\")).toThrow();\n});\n\ntest(\"parsed function fail 2\", () => {\n  // @ts-expect-error\n  const parsed = func1.implement((x: string) => x);\n  expect(() => parsed(13 as any)).toThrow();\n});\n\ntest(\"function inference 1\", () => {\n  type func1 = (typeof func1)[\"_input\"];\n  expectTypeOf<func1>().toEqualTypeOf<(k: string) => number>();\n});\n\n// test(\"method parsing\", () => {\n//   const methodObject = z.object({\n//     property: z.number(),\n//     method: z\n//       .function()\n//       .input(z.tuple([z.string()]))\n//       .output(z.number()),\n//   });\n//   const methodInstance = {\n//     property: 3,\n//     method: function (s: string) {\n//       return s.length + this.property;\n//     },\n//   };\n//   const parsed = methodObject.parse(methodInstance);\n//   expect(parsed.method(\"length=8\")).toBe(11); // 8 length + 3 property\n// });\n\n// test(\"async method parsing\", async () => {\n//   const methodObject = z.object({\n//     property: z.number(),\n//     method: z.function().input(z.string()).output(z.promise(z.number())),\n//   });\n//   const methodInstance = {\n//     property: 3,\n//     method: async function (s: string) {\n//       return s.length + this.property;\n//     },\n//   };\n//   const parsed = methodObject.parse(methodInstance);\n//   expect(await parsed.method(\"length=8\")).toBe(11); // 8 length + 3 property\n// });\n\ntest(\"args method\", () => {\n  const t1 = z.function();\n  type t1 = (typeof t1)[\"_input\"];\n  expectTypeOf<t1>().toEqualTypeOf<(...args_1: never[]) => unknown>();\n  t1._input;\n\n  const t2args = z.tuple([z.string()], z.unknown());\n\n  const t2 = t1.input(t2args);\n  type t2 = (typeof t2)[\"_input\"];\n  expectTypeOf<t2>().toEqualTypeOf<(arg: string, ...args_1: unknown[]) => unknown>();\n\n  const t3 = t2.output(z.boolean());\n  type t3 = (typeof t3)[\"_input\"];\n  expectTypeOf<t3>().toEqualTypeOf<(arg: string, ...args_1: unknown[]) => boolean>();\n});\n\n// test(\"custom args\", () => {\n//   const fn = z.function().implement((_a: string, _b: number) => {\n//     return new Date();\n//   });\n\n//   expectTypeOf(fn).toEqualTypeOf<(a: string, b: number) => Date>();\n// });\n\nconst args2 = z.tuple([\n  z.object({\n    f1: z.number(),\n    f2: z.string().nullable(),\n    f3: z.array(z.boolean().optional()).optional(),\n  }),\n]);\nconst returns2 = z.union([z.string(), z.number()]);\n\nconst func2 = z.function({\n  input: args2,\n  output: returns2,\n});\n\ntest(\"function inference 2\", () => {\n  type func2 = (typeof func2)[\"_input\"];\n\n  expectTypeOf<func2>().toEqualTypeOf<\n    (arg: {\n      f3?: (boolean | undefined)[] | undefined;\n      f1: number;\n      f2: string | null;\n    }) => string | number\n  >();\n});\n\ntest(\"valid function run\", () => {\n  const validFunc2Instance = func2.implement((_x) => {\n    _x.f2;\n    _x.f3![0];\n    return \"adf\" as any;\n  });\n\n  validFunc2Instance({\n    f1: 21,\n    f2: \"asdf\",\n    f3: [true, false],\n  });\n});\n\ntest(\"input validation error\", () => {\n  const schema = z.function({\n    input: z.tuple([z.string()]),\n    output: z.void(),\n  });\n  const fn = schema.implement(() => 1234 as any);\n\n  // @ts-expect-error\n  const checker = () => fn();\n\n  try {\n    checker();\n  } catch (e: any) {\n    expect(e.issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"string\",\n          \"message\": \"Invalid input: expected string, received undefined\",\n          \"path\": [\n            0,\n          ],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"array inputs\", () => {\n  const a = z.function({\n    input: [\n      z.object({\n        name: z.string(),\n        age: z.number().int(),\n      }),\n    ],\n    output: z.string(),\n  });\n\n  a.implement((args) => {\n    return `${args.age}`;\n  });\n\n  const b = z.function({\n    input: [\n      z.object({\n        name: z.string(),\n        age: z.number().int(),\n      }),\n    ],\n  });\n  b.implement((args) => {\n    return `${args.age}`;\n  });\n});\n\ntest(\"output validation error\", () => {\n  const schema = z.function({\n    input: z.tuple([]),\n    output: z.string(),\n  });\n  const fn = schema.implement(() => 1234 as any);\n  try {\n    fn();\n  } catch (e: any) {\n    expect(e.issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"string\",\n          \"message\": \"Invalid input: expected string, received number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"function with async refinements\", async () => {\n  const schema = z\n    .function()\n    .input([z.string().refine(async (val) => val.length > 10)])\n    .output(z.promise(z.number().refine(async (val) => val > 10)));\n\n  const func = schema.implementAsync(async (val) => {\n    return val.length;\n  });\n  const results = [];\n  try {\n    await func(\"asdfasdf\");\n    results.push(\"success\");\n  } catch (_) {\n    results.push(\"fail\");\n  }\n  try {\n    await func(\"asdflkjasdflkjsf\");\n    results.push(\"success\");\n  } catch (_) {\n    results.push(\"fail\");\n  }\n\n  expect(results).toEqual([\"fail\", \"success\"]);\n});\n\ntest(\"non async function with async refinements should fail\", async () => {\n  const func = z\n    .function()\n    .input([z.string().refine(async (val) => val.length > 10)])\n    .output(z.number().refine(async (val) => val > 10))\n    .implement((val) => {\n      return val.length;\n    });\n\n  const results = [];\n  try {\n    await func(\"asdasdfasdffasdf\");\n    results.push(\"success\");\n  } catch (_) {\n    results.push(\"fail\");\n  }\n\n  expect(results).toEqual([\"fail\"]);\n});\n\ntest(\"extra parameters with rest\", () => {\n  const maxLength5 = z\n    .function()\n    .input([z.string()], z.unknown())\n    .output(z.boolean())\n    .implement((str, _arg, _qewr) => {\n      return str.length <= 5;\n    });\n\n  const filteredList = [\"apple\", \"orange\", \"pear\", \"banana\", \"strawberry\"].filter(maxLength5);\n  expect(filteredList.length).toEqual(2);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/generics.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nfunction nest<TData extends z.ZodType>(schema: TData) {\n  return z.object({\n    nested: schema,\n  });\n}\n\ntest(\"generics\", () => {\n  const a = nest(z.object({ a: z.string() }));\n  type a = z.infer<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<{ nested: { a: string } }>();\n\n  const b = nest(z.object({ a: z.string().optional() }));\n  type b = z.infer<typeof b>;\n  expectTypeOf<b>().toEqualTypeOf<{ nested: { a?: string | undefined } }>();\n});\n\ntest(\"generics with optional\", () => {\n  async function stripOuter<TData extends z.ZodType>(schema: TData, data: unknown) {\n    return z\n      .object({\n        nested: schema.optional(),\n      })\n      .transform((data) => {\n        return data.nested;\n      })\n      .parse({ nested: data });\n  }\n\n  const result = stripOuter(z.object({ a: z.string() }), { a: \"asdf\" });\n  expectTypeOf<typeof result>().toEqualTypeOf<Promise<{ a: string } | undefined>>();\n});\n\n// test(\"assignability\", () => {\n//   const createSchemaAndParse = <K extends string, VS extends z.ZodString>(key: K, valueSchema: VS, data: unknown) => {\n//     const schema = z.object({\n//       [key]: valueSchema,\n//     });\n//     // return { [key]: valueSchema };\n//     const parsed = schema.parse(data);\n//     return parsed;\n//     // const inferred: z.infer<z.ZodObject<{ [k in K]: VS }>> = parsed;\n//     // return inferred;\n//   };\n//   const parsed = createSchemaAndParse(\"foo\", z.string(), { foo: \"\" });\n//   expectTypeOf<typeof parsed>().toEqualTypeOf<{ foo: string }>();\n// });\n\ntest(\"nested no undefined\", () => {\n  const inner = z.string().or(z.array(z.string()));\n  const outer = z.object({ inner });\n  type outerSchema = z.infer<typeof outer>;\n  expectTypeOf<outerSchema>().toEqualTypeOf<{ inner: string | string[] }>();\n\n  expect(outer.safeParse({ inner: undefined }).success).toEqual(false);\n});\n\ntest(\"generic on output type\", () => {\n  const createV4Schema = <Output>(opts: {\n    schema: z.ZodType<Output>;\n  }) => {\n    return opts.schema;\n  };\n\n  createV4Schema({\n    schema: z.object({\n      name: z.string(),\n    }),\n  })?._zod?.output?.name;\n});\n",
    "symbols": [
      {
        "name": "nest",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/generics.test.ts",
        "startLine": 4,
        "endLine": 8
      },
      {
        "name": "stripOuter",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/generics.test.ts",
        "startLine": 21,
        "endLine": 30
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/index.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\nimport type { util } from \"zod/v4/core\";\n\ntest(\"z.boolean\", () => {\n  const a = z.boolean();\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, false)).toEqual(false);\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"true\")).toThrow();\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<boolean>();\n});\n\ntest(\"z.bigint\", () => {\n  const a = z.bigint();\n  expect(z.parse(a, BigInt(123))).toEqual(BigInt(123));\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n});\n\ntest(\"z.symbol\", () => {\n  const a = z.symbol();\n  const sym = Symbol();\n  expect(z.parse(a, sym)).toEqual(sym);\n  expect(() => z.parse(a, \"symbol\")).toThrow();\n});\n\ntest(\"z.date\", () => {\n  const a = z.date();\n  const date = new Date();\n  expect(z.parse(a, date)).toEqual(date);\n  expect(() => z.parse(a, \"date\")).toThrow();\n});\n\ntest(\"z.coerce.string\", () => {\n  const a = z.coerce.string();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n  expect(z.parse(a, true)).toEqual(\"true\");\n  expect(z.parse(a, null)).toEqual(\"null\");\n  expect(z.parse(a, undefined)).toEqual(\"undefined\");\n});\n\ntest(\"z.coerce.number\", () => {\n  const a = z.coerce.number();\n  expect(z.parse(a, \"123\")).toEqual(123);\n  expect(z.parse(a, \"123.45\")).toEqual(123.45);\n  expect(z.parse(a, true)).toEqual(1);\n  expect(z.parse(a, false)).toEqual(0);\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.coerce.boolean\", () => {\n  const a = z.coerce.boolean();\n  // test booleans\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, false)).toEqual(false);\n  expect(z.parse(a, \"true\")).toEqual(true);\n  expect(z.parse(a, \"false\")).toEqual(true);\n  expect(z.parse(a, 1)).toEqual(true);\n  expect(z.parse(a, 0)).toEqual(false);\n  expect(z.parse(a, {})).toEqual(true);\n  expect(z.parse(a, [])).toEqual(true);\n  expect(z.parse(a, undefined)).toEqual(false);\n  expect(z.parse(a, null)).toEqual(false);\n  expect(z.parse(a, \"\")).toEqual(false);\n});\n\ntest(\"z.coerce.bigint\", () => {\n  const a = z.coerce.bigint();\n  expect(z.parse(a, \"123\")).toEqual(BigInt(123));\n  expect(z.parse(a, 123)).toEqual(BigInt(123));\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.coerce.date\", () => {\n  const a = z.coerce.date();\n  const date = new Date();\n  expect(z.parse(a, date.toISOString())).toEqual(date);\n  expect(z.parse(a, date.getTime())).toEqual(date);\n  expect(() => z.parse(a, \"invalid date\")).toThrow();\n});\n\ntest(\"z.iso.datetime\", () => {\n  const d1 = \"2021-01-01T00:00:00Z\";\n  const d2 = \"2021-01-01T00:00:00.123Z\";\n  const d3 = \"2021-01-01T00:00:00\";\n  const d4 = \"2021-01-01T00:00:00+07:00\";\n  const d5 = \"bad data\";\n\n  // local: false, offset: false, precision: null\n  const a = z.iso.datetime();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(true);\n  expect(z.safeParse(a, d3).success).toEqual(false);\n  expect(z.safeParse(a, d4).success).toEqual(false);\n  expect(z.safeParse(a, d5).success).toEqual(false);\n\n  const b = z.iso.datetime({ local: true });\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(true);\n  expect(z.safeParse(b, d3).success).toEqual(true);\n  expect(z.safeParse(b, d4).success).toEqual(false);\n  expect(z.safeParse(b, d5).success).toEqual(false);\n\n  const c = z.iso.datetime({ offset: true });\n  expect(z.safeParse(c, d1).success).toEqual(true);\n  expect(z.safeParse(c, d2).success).toEqual(true);\n  expect(z.safeParse(c, d3).success).toEqual(false);\n  expect(z.safeParse(c, d4).success).toEqual(true);\n  expect(z.safeParse(c, d5).success).toEqual(false);\n\n  const d = z.iso.datetime({ precision: 3 });\n  expect(z.safeParse(d, d1).success).toEqual(false);\n  expect(z.safeParse(d, d2).success).toEqual(true);\n  expect(z.safeParse(d, d3).success).toEqual(false);\n  expect(z.safeParse(d, d4).success).toEqual(false);\n  expect(z.safeParse(d, d5).success).toEqual(false);\n});\n\ntest(\"z.iso.date\", () => {\n  const d1 = \"2021-01-01\";\n  const d2 = \"bad data\";\n\n  const a = z.iso.date();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(false);\n\n  const b = z.string().check(z.iso.date());\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(false);\n});\n\ntest(\"z.iso.time\", () => {\n  const d1 = \"00:00:00\";\n  const d2 = \"00:00:00.123\";\n  const d3 = \"bad data\";\n\n  const a = z.iso.time();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(true);\n  expect(z.safeParse(a, d3).success).toEqual(false);\n\n  const b = z.iso.time({ precision: 3 });\n  expect(z.safeParse(b, d1).success).toEqual(false);\n  expect(z.safeParse(b, d2).success).toEqual(true);\n  expect(z.safeParse(b, d3).success).toEqual(false);\n\n  const c = z.string().check(z.iso.time());\n  expect(z.safeParse(c, d1).success).toEqual(true);\n  expect(z.safeParse(c, d2).success).toEqual(true);\n  expect(z.safeParse(c, d3).success).toEqual(false);\n});\n\ntest(\"z.iso.duration\", () => {\n  const d1 = \"P3Y6M4DT12H30M5S\";\n  const d2 = \"bad data\";\n\n  const a = z.iso.duration();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(false);\n\n  const b = z.string().check(z.iso.duration());\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(false);\n});\n\ntest(\"z.undefined\", () => {\n  const a = z.undefined();\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, \"undefined\")).toThrow();\n});\n\ntest(\"z.null\", () => {\n  const a = z.null();\n  expect(z.parse(a, null)).toEqual(null);\n  expect(() => z.parse(a, \"null\")).toThrow();\n});\n\ntest(\"z.any\", () => {\n  const a = z.any();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  z.parse(a, {});\n  z.parse(a, []);\n  z.parse(a, Symbol());\n  z.parse(a, new Date());\n});\n\ntest(\"z.unknown\", () => {\n  const a = z.unknown();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  z.parse(a, {});\n  z.parse(a, []);\n  z.parse(a, Symbol());\n  z.parse(a, new Date());\n});\n\ntest(\"z.never\", () => {\n  const a = z.never();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.void\", () => {\n  const a = z.void();\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, null)).toThrow();\n});\n\ntest(\"z.array\", () => {\n  const a = z.array(z.string());\n  expect(z.parse(a, [\"hello\", \"world\"])).toEqual([\"hello\", \"world\"]);\n  expect(() => z.parse(a, [123])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.union\", () => {\n  const a = z.union([z.string(), z.number()]);\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(() => z.parse(a, true)).toThrow();\n});\n\ntest(\"z.intersection\", () => {\n  const a = z.intersection(z.object({ a: z.string() }), z.object({ b: z.number() }));\n  expect(z.parse(a, { a: \"hello\", b: 123 })).toEqual({ a: \"hello\", b: 123 });\n  expect(() => z.parse(a, { a: \"hello\" })).toThrow();\n  expect(() => z.parse(a, { b: 123 })).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.tuple\", () => {\n  const a = z.tuple([z.string(), z.number()]);\n  expect(z.parse(a, [\"hello\", 123])).toEqual([\"hello\", 123]);\n  expect(() => z.parse(a, [\"hello\", \"world\"])).toThrow();\n  expect(() => z.parse(a, [123, 456])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  // tuple with rest\n  const b = z.tuple([z.string(), z.number(), z.optional(z.string())], z.boolean());\n  type b = z.output<typeof b>;\n\n  expectTypeOf<b>().toEqualTypeOf<[string, number, string?, ...boolean[]]>();\n  const datas = [\n    [\"hello\", 123],\n    [\"hello\", 123, \"world\"],\n    [\"hello\", 123, \"world\", true],\n    [\"hello\", 123, \"world\", true, false, true],\n  ];\n  for (const data of datas) {\n    expect(z.parse(b, data)).toEqual(data);\n  }\n\n  expect(() => z.parse(b, [\"hello\", 123, 123])).toThrow();\n  expect(() => z.parse(b, [\"hello\", 123, \"world\", 123])).toThrow();\n\n  // tuple with readonly args\n  const cArgs = [z.string(), z.number(), z.optional(z.string())] as const;\n  const c = z.tuple(cArgs, z.boolean());\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<[string, number, string?, ...boolean[]]>();\n  // type c = z.output<typeof c>;\n});\n\ntest(\"z.record\", () => {\n  // record schema with enum keys\n  const a = z.record(z.string(), z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Record<string, string>>();\n\n  const b = z.record(z.union([z.string(), z.number(), z.symbol()]), z.string());\n  type b = z.output<typeof b>;\n  expectTypeOf<b>().toEqualTypeOf<Record<string | number | symbol, string>>();\n  expect(z.parse(b, { a: \"hello\", 1: \"world\", [Symbol.for(\"asdf\")]: \"symbol\" })).toEqual({\n    a: \"hello\",\n    1: \"world\",\n    [Symbol.for(\"asdf\")]: \"symbol\",\n  });\n\n  // enum keys\n  const c = z.record(z.enum([\"a\", \"b\", \"c\"]), z.string());\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<Record<\"a\" | \"b\" | \"c\", string>>();\n  expect(z.parse(c, { a: \"hello\", b: \"world\", c: \"world\" })).toEqual({\n    a: \"hello\",\n    b: \"world\",\n    c: \"world\",\n  });\n  // missing keys\n  expect(() => z.parse(c, { a: \"hello\", b: \"world\" })).toThrow();\n  // extra keys\n  expect(() => z.parse(c, { a: \"hello\", b: \"world\", c: \"world\", d: \"world\" })).toThrow();\n\n  // partial enum\n  const d = z.record(z.enum([\"a\", \"b\"]).or(z.never()), z.string());\n  type d = z.output<typeof d>;\n  expectTypeOf<d>().toEqualTypeOf<Record<\"a\" | \"b\", string>>();\n});\n\ntest(\"z.map\", () => {\n  const a = z.map(z.string(), z.number());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Map<string, number>>();\n  expect(z.parse(a, new Map([[\"hello\", 123]]))).toEqual(new Map([[\"hello\", 123]]));\n  expect(() => z.parse(a, new Map([[\"hello\", \"world\"]]))).toThrow();\n  expect(() => z.parse(a, new Map([[1243, \"world\"]]))).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  const r1 = z.safeParse(a, new Map([[123, 123]]));\n  expect(r1.error?.issues[0].code).toEqual(\"invalid_type\");\n  expect(r1.error?.issues[0].path).toEqual([123]);\n\n  const r2: any = z.safeParse(a, new Map([[BigInt(123), 123]]));\n  expect(r2.error!.issues[0].code).toEqual(\"invalid_key\");\n  expect(r2.error!.issues[0].path).toEqual([]);\n\n  const r3: any = z.safeParse(a, new Map([[\"hello\", \"world\"]]));\n  expect(r3.error!.issues[0].code).toEqual(\"invalid_type\");\n  expect(r3.error!.issues[0].path).toEqual([\"hello\"]);\n});\n\ntest(\"z.map invalid_element\", () => {\n  const a = z.map(z.bigint(), z.number());\n  const r1 = z.safeParse(a, new Map([[BigInt(123), BigInt(123)]]));\n\n  expect(r1.error!.issues[0].code).toEqual(\"invalid_element\");\n  expect(r1.error!.issues[0].path).toEqual([]);\n});\n\ntest(\"z.map async\", async () => {\n  const a = z.map(z.string().check(z.refine(async () => true)), z.number().check(z.refine(async () => true)));\n  const d1 = new Map([[\"hello\", 123]]);\n  expect(await z.parseAsync(a, d1)).toEqual(d1);\n\n  await expect(z.parseAsync(a, new Map([[123, 123]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, new Map([[\"hi\", \"world\"]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, new Map([[1243, \"world\"]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, \"hello\")).rejects.toThrow();\n\n  const r = await z.safeParseAsync(a, new Map([[123, 123]]));\n  expect(r.success).toEqual(false);\n  expect(r.error!.issues[0].code).toEqual(\"invalid_type\");\n  expect(r.error!.issues[0].path).toEqual([123]);\n});\n\ntest(\"z.set\", () => {\n  const a = z.set(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Set<string>>();\n  expect(z.parse(a, new Set([\"hello\", \"world\"]))).toEqual(new Set([\"hello\", \"world\"]));\n  expect(() => z.parse(a, new Set([123]))).toThrow();\n  expect(() => z.parse(a, [\"hello\", \"world\"])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  const b = z.set(z.number());\n  expect(z.parse(b, new Set([1, 2, 3]))).toEqual(new Set([1, 2, 3]));\n  expect(() => z.parse(b, new Set([\"hello\"]))).toThrow();\n  expect(() => z.parse(b, [1, 2, 3])).toThrow();\n  expect(() => z.parse(b, 123)).toThrow();\n});\n\ntest(\"z.enum\", () => {\n  const a = z.enum([\"A\", \"B\", \"C\"]);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<\"A\" | \"B\" | \"C\">();\n  expect(z.parse(a, \"A\")).toEqual(\"A\");\n  expect(z.parse(a, \"B\")).toEqual(\"B\");\n  expect(z.parse(a, \"C\")).toEqual(\"C\");\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  expect(a.enum.A).toEqual(\"A\");\n  expect(a.enum.B).toEqual(\"B\");\n  expect(a.enum.C).toEqual(\"C\");\n  expect((a.enum as any).D).toEqual(undefined);\n});\n\ntest(\"z.enum - native\", () => {\n  enum NativeEnum {\n    A = \"A\",\n    B = \"B\",\n    C = \"C\",\n  }\n  const a = z.enum(NativeEnum);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<NativeEnum>();\n  expect(z.parse(a, NativeEnum.A)).toEqual(NativeEnum.A);\n  expect(z.parse(a, NativeEnum.B)).toEqual(NativeEnum.B);\n  expect(z.parse(a, NativeEnum.C)).toEqual(NativeEnum.C);\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // test a.enum\n  a;\n  expect(a.enum.A).toEqual(NativeEnum.A);\n  expect(a.enum.B).toEqual(NativeEnum.B);\n  expect(a.enum.C).toEqual(NativeEnum.C);\n});\n\ntest(\"z.nativeEnum\", () => {\n  enum NativeEnum {\n    A = \"A\",\n    B = \"B\",\n    C = \"C\",\n  }\n  const a = z.nativeEnum(NativeEnum);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<NativeEnum>();\n  expect(z.parse(a, NativeEnum.A)).toEqual(NativeEnum.A);\n  expect(z.parse(a, NativeEnum.B)).toEqual(NativeEnum.B);\n  expect(z.parse(a, NativeEnum.C)).toEqual(NativeEnum.C);\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // test a.enum\n  a;\n  expect(a.enum.A).toEqual(NativeEnum.A);\n  expect(a.enum.B).toEqual(NativeEnum.B);\n  expect(a.enum.C).toEqual(NativeEnum.C);\n});\n\ntest(\"z.literal\", () => {\n  const a = z.literal(\"hello\");\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<\"hello\">();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, \"world\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.file\", () => {\n  const a = z.file();\n  const file = new File([\"content\"], \"filename.txt\", { type: \"text/plain\" });\n  expect(z.parse(a, file)).toEqual(file);\n  expect(() => z.parse(a, \"file\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.transform\", () => {\n  const a = z.pipe(\n    z.string(),\n    z.transform((val) => val.toUpperCase())\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"HELLO\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.transform async\", async () => {\n  const a = z.pipe(\n    z.string(),\n    z.transform(async (val) => val.toUpperCase())\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(await z.parseAsync(a, \"hello\")).toEqual(\"HELLO\");\n  await expect(() => z.parseAsync(a, 123)).rejects.toThrow();\n});\n\ntest(\"z.preprocess\", () => {\n  const a = z.pipe(\n    z.transform((val) => String(val).toUpperCase()),\n    z.string()\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n  expect(z.parse(a, true)).toEqual(\"TRUE\");\n  expect(z.parse(a, BigInt(1234))).toEqual(\"1234\");\n  // expect(() => z.parse(a, Symbol(\"asdf\"))).toThrow();\n});\n\n// test(\"z.preprocess async\", () => {\n//   const a = z.preprocess(async (val) => String(val), z.string());\n//   type a = z.output<typeof a>;\n//   expectTypeOf<a>().toEqualTypeOf<string>();\n//   expect(z.parse(a, 123)).toEqual(\"123\");\n//   expect(z.parse(a, true)).toEqual(\"true\");\n//   expect(() => z.parse(a, {})).toThrow();\n// });\n\ntest(\"z.optional\", () => {\n  const a = z.optional(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string | undefined>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.nullable\", () => {\n  const a = z.nullable(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string | null>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, null)).toEqual(null);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.default\", () => {\n  const a = z._default(z.string(), \"default\");\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, undefined)).toEqual(\"default\");\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n\n  const b = z._default(z.string(), () => \"default\");\n  expect(z.parse(b, undefined)).toEqual(\"default\");\n  expect(z.parse(b, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(b, 123)).toThrow();\n});\n\ntest(\"z.catch\", () => {\n  const a = z.catch(z.string(), \"default\");\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(\"default\");\n\n  const b = z.catch(z.string(), () => \"default\");\n  expect(z.parse(b, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(b, 123)).toEqual(\"default\");\n\n  const c = z.catch(z.string(), (ctx) => {\n    return `${ctx.error.issues.length}issues`;\n  });\n  expect(z.parse(c, 1234)).toEqual(\"1issues\");\n});\n\ntest(\"z.nan\", () => {\n  const a = z.nan();\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<number>();\n  expect(z.parse(a, Number.NaN)).toEqual(Number.NaN);\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"NaN\")).toThrow();\n});\n\ntest(\"z.pipe\", () => {\n  const a = z.pipe(\n    z.pipe(\n      z.string(),\n      z.transform((val) => val.length)\n    ),\n    z.number()\n  );\n  type a_in = z.input<typeof a>;\n  expectTypeOf<a_in>().toEqualTypeOf<string>();\n  type a_out = z.output<typeof a>;\n  expectTypeOf<a_out>().toEqualTypeOf<number>();\n\n  expect(z.parse(a, \"123\")).toEqual(3);\n  expect(z.parse(a, \"hello\")).toEqual(5);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.readonly\", () => {\n  const a = z.readonly(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Readonly<string>>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.templateLiteral\", () => {\n  const a = z.templateLiteral([z.string(), z.number()]);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<`${string}${number}`>();\n  expect(z.parse(a, \"hello123\")).toEqual(\"hello123\");\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // multipart\n  const b = z.templateLiteral([z.string(), z.number(), z.string()]);\n  type b = z.output<typeof b>;\n  expectTypeOf<b>().toEqualTypeOf<`${string}${number}${string}`>();\n  expect(z.parse(b, \"hello123world\")).toEqual(\"hello123world\");\n  expect(z.parse(b, \"123\")).toEqual(\"123\");\n  expect(() => z.parse(b, \"hello\")).toThrow();\n  expect(() => z.parse(b, 123)).toThrow();\n\n  // include boolean\n  const c = z.templateLiteral([z.string(), z.boolean()]);\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<`${string}${boolean}`>();\n  expect(z.parse(c, \"hellotrue\")).toEqual(\"hellotrue\");\n  expect(z.parse(c, \"hellofalse\")).toEqual(\"hellofalse\");\n  expect(() => z.parse(c, \"hello\")).toThrow();\n  expect(() => z.parse(c, 123)).toThrow();\n\n  // include literal prefix\n  const d = z.templateLiteral([z.literal(\"hello\"), z.number()]);\n  type d = z.output<typeof d>;\n  expectTypeOf<d>().toEqualTypeOf<`hello${number}`>();\n  expect(z.parse(d, \"hello123\")).toEqual(\"hello123\");\n  expect(() => z.parse(d, 123)).toThrow();\n  expect(() => z.parse(d, \"world123\")).toThrow();\n\n  // include literal union\n  const e = z.templateLiteral([z.literal([\"aa\", \"bb\"]), z.number()]);\n  type e = z.output<typeof e>;\n  expectTypeOf<e>().toEqualTypeOf<`aa${number}` | `bb${number}`>();\n  expect(z.parse(e, \"aa123\")).toEqual(\"aa123\");\n  expect(z.parse(e, \"bb123\")).toEqual(\"bb123\");\n  expect(() => z.parse(e, \"cc123\")).toThrow();\n  expect(() => z.parse(e, 123)).toThrow();\n});\n\n// this returns both a schema and a check\ntest(\"z.custom schema\", () => {\n  const a = z.custom((val) => {\n    return typeof val === \"string\";\n  });\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.custom check\", () => {\n  // @ts-expect-error Inference not possible, use z.refine()\n  z.date().check(z.custom((val) => val.getTime() > 0));\n});\n\ntest(\"z.check\", () => {\n  // this is a more flexible version of z.custom that accepts an arbitrary _parse logic\n  // the function should return base.$ZodResult\n  const a = z.any().check(\n    z.check<string>((ctx) => {\n      if (typeof ctx.value === \"string\") return;\n      ctx.issues.push({\n        code: \"custom\",\n        origin: \"custom\",\n        message: \"Expected a string\",\n        input: ctx.value,\n      });\n    })\n  );\n  expect(z.safeParse(a, \"hello\")).toMatchObject({\n    success: true,\n    data: \"hello\",\n  });\n  expect(z.safeParse(a, 123)).toMatchObject({\n    success: false,\n    error: { issues: [{ code: \"custom\", message: \"Expected a string\" }] },\n  });\n});\n\ntest(\"z.instanceof\", () => {\n  class A {}\n\n  const a = z.instanceof(A);\n  expect(z.parse(a, new A())).toBeInstanceOf(A);\n  expect(() => z.parse(a, {})).toThrow();\n});\n\ntest(\"z.refine\", () => {\n  const a = z.number().check(\n    z.refine((val) => val > 3),\n    z.refine((val) => val < 10)\n  );\n  expect(z.parse(a, 5)).toEqual(5);\n  expect(() => z.parse(a, 2)).toThrow();\n  expect(() => z.parse(a, 11)).toThrow();\n  expect(() => z.parse(a, \"hi\")).toThrow();\n});\n\n// test(\"z.superRefine\", () => {\n//   const a = z.number([\n//     z.superRefine((val, ctx) => {\n//       if (val < 3) {\n//         return ctx.addIssue({\n//           code: \"custom\",\n//           origin: \"custom\",\n//           message: \"Too small\",\n//           input: val,\n//         });\n//       }\n//       if (val > 10) {\n//         return ctx.addIssue(\"Too big\");\n//       }\n//     }),\n//   ]);\n\n//   expect(z.parse(a, 5)).toEqual(5);\n//   expect(() => z.parse(a, 2)).toThrow();\n//   expect(() => z.parse(a, 11)).toThrow();\n//   expect(() => z.parse(a, \"hi\")).toThrow();\n// });\n\ntest(\"z.transform\", () => {\n  const a = z.transform((val: number) => {\n    return `${val}`;\n  });\n  type a_in = z.input<typeof a>;\n  expectTypeOf<a_in>().toEqualTypeOf<number>();\n  type a_out = z.output<typeof a>;\n  expectTypeOf<a_out>().toEqualTypeOf<string>();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n});\n\ntest(\"z.$brand()\", () => {\n  const a = z.string().brand<\"my-brand\">();\n  type a = z.output<typeof a>;\n  const branded = (_: a) => {};\n  // @ts-expect-error\n  branded(\"asdf\");\n});\n\ntest(\"z.lazy\", () => {\n  const a = z.lazy(() => z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\n// schema that validates JSON-like data\ntest(\"z.json\", () => {\n  const a = z.json();\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<util.JSONType>();\n\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, {})).toEqual({});\n  expect(z.parse(a, { a: \"hello\" })).toEqual({ a: \"hello\" });\n  expect(z.parse(a, [1, 2, 3])).toEqual([1, 2, 3]);\n  expect(z.parse(a, [{ a: \"hello\" }])).toEqual([{ a: \"hello\" }]);\n\n  // fail cases\n  expect(() => z.parse(a, new Date())).toThrow();\n  expect(() => z.parse(a, Symbol())).toThrow();\n  expect(() => z.parse(a, { a: new Date() })).toThrow();\n  expect(() => z.parse(a, undefined)).toThrow();\n  expect(() => z.parse(a, { a: undefined })).toThrow();\n});\n\n// promise\ntest(\"z.promise\", async () => {\n  const a = z.promise(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n\n  expect(await z.safeParseAsync(a, Promise.resolve(\"hello\"))).toMatchObject({\n    success: true,\n    data: \"hello\",\n  });\n  expect(await z.safeParseAsync(a, Promise.resolve(123))).toMatchObject({\n    success: false,\n  });\n\n  const b = z.string();\n  expect(() => z.parse(b, Promise.resolve(\"hello\"))).toThrow();\n});\n// test(\"type assertions\", () => {\n//   const schema = z.pipe(\n//     z.string(),\n//     z.transform((val) => val.length)\n//   );\n//   schema.assertInput<string>();\n//   // @ts-expect-error\n//   schema.assertInput<number>();\n\n//   schema.assertOutput<number>();\n//   // @ts-expect-error\n//   schema.assertOutput<string>();\n// });\n\ntest(\"isPlainObject\", () => {\n  expect(z.core.util.isPlainObject({})).toEqual(true);\n  expect(z.core.util.isPlainObject(Object.create(null))).toEqual(true);\n  expect(z.core.util.isPlainObject([])).toEqual(false);\n  expect(z.core.util.isPlainObject(new Date())).toEqual(false);\n  expect(z.core.util.isPlainObject(null)).toEqual(false);\n  expect(z.core.util.isPlainObject(undefined)).toEqual(false);\n  expect(z.core.util.isPlainObject(\"string\")).toEqual(false);\n  expect(z.core.util.isPlainObject(123)).toEqual(false);\n  expect(z.core.util.isPlainObject(Symbol())).toEqual(false);\n});\n\ntest(\"def typing\", () => {\n  z.string().def.type satisfies \"string\";\n  z.number().def.type satisfies \"number\";\n  z.bigint().def.type satisfies \"bigint\";\n  z.boolean().def.type satisfies \"boolean\";\n  z.date().def.type satisfies \"date\";\n  z.symbol().def.type satisfies \"symbol\";\n  z.undefined().def.type satisfies \"undefined\";\n  z.string().nullable().def.type satisfies \"nullable\";\n  z.null().def.type satisfies \"null\";\n  z.any().def.type satisfies \"any\";\n  z.unknown().def.type satisfies \"unknown\";\n  z.never().def.type satisfies \"never\";\n  z.void().def.type satisfies \"void\";\n  z.array(z.string()).def.type satisfies \"array\";\n  z.object({ key: z.string() }).def.type satisfies \"object\";\n  z.union([z.string(), z.number()]).def.type satisfies \"union\";\n  z.intersection(z.string(), z.number()).def.type satisfies \"intersection\";\n  z.tuple([z.string(), z.number()]).def.type satisfies \"tuple\";\n  z.record(z.string(), z.number()).def.type satisfies \"record\";\n  z.map(z.string(), z.number()).def.type satisfies \"map\";\n  z.set(z.string()).def.type satisfies \"set\";\n  z.literal(\"example\").def.type satisfies \"literal\";\n  z.enum([\"a\", \"b\", \"c\"]).def.type satisfies \"enum\";\n  z.promise(z.string()).def.type satisfies \"promise\";\n  z.lazy(() => z.string()).def.type satisfies \"lazy\";\n  z.string().optional().def.type satisfies \"optional\";\n  z.string().default(\"default\").def.type satisfies \"default\";\n  z.templateLiteral([z.literal(\"a\"), z.literal(\"b\")]).def.type satisfies \"template_literal\";\n  z.custom<string>((val) => typeof val === \"string\").def.type satisfies \"custom\";\n  z.transform((val) => val as string).def.type satisfies \"transform\";\n  z.string().optional().nonoptional().def.type satisfies \"nonoptional\";\n  z.object({ key: z.string() }).readonly().def.type satisfies \"readonly\";\n  z.nan().def.type satisfies \"nan\";\n  z.unknown().pipe(z.number()).def.type satisfies \"pipe\";\n  z.success(z.string()).def.type satisfies \"success\";\n  z.string().catch(\"fallback\").def.type satisfies \"catch\";\n  z.file().def.type satisfies \"file\";\n});\n",
    "symbols": [
      {
        "name": "A",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/index.test.ts",
        "startLine": 657,
        "endLine": 657
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/instanceof.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"instanceof\", async () => {\n  class Test {}\n  class Subtest extends Test {}\n  abstract class AbstractBar {\n    constructor(public val: string) {}\n  }\n  class Bar extends AbstractBar {}\n\n  const TestSchema = z.instanceof(Test);\n  const SubtestSchema = z.instanceof(Subtest);\n  const AbstractSchema = z.instanceof(AbstractBar);\n  const BarSchema = z.instanceof(Bar);\n\n  TestSchema.parse(new Test());\n  TestSchema.parse(new Subtest());\n  SubtestSchema.parse(new Subtest());\n  AbstractSchema.parse(new Bar(\"asdf\"));\n  const bar = BarSchema.parse(new Bar(\"asdf\"));\n  expect(bar.val).toEqual(\"asdf\");\n\n  await expect(() => SubtestSchema.parse(new Test())).toThrow();\n  await expect(() => TestSchema.parse(12)).toThrow();\n\n  expectTypeOf<Test>().toEqualTypeOf<z.infer<typeof TestSchema>>();\n});\n\ntest(\"instanceof fatal\", () => {\n  const schema = z.instanceof(Date).refine((d) => d.toString());\n  const res = schema.safeParse(null);\n  expect(res.success).toBe(false);\n});\n",
    "symbols": [
      {
        "name": "Test",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/instanceof.test.ts",
        "startLine": 5,
        "endLine": 5
      },
      {
        "name": "Subtest",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/instanceof.test.ts",
        "startLine": 6,
        "endLine": 6
      },
      {
        "name": "AbstractBar",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/instanceof.test.ts",
        "startLine": 7,
        "endLine": 9
      },
      {
        "name": "Bar",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/instanceof.test.ts",
        "startLine": 10,
        "endLine": 10
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/intersection.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport type { util } from \"zod/v4/core\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"object intersection\", () => {\n  const A = z.object({ a: z.string() });\n  const B = z.object({ b: z.string() });\n\n  const C = z.intersection(A, B); // BaseC.merge(HasID);\n  type C = z.infer<typeof C>;\n  expectTypeOf<C>().toEqualTypeOf<{ a: string } & { b: string }>();\n  const data = { a: \"foo\", b: \"foo\" };\n  expect(C.parse(data)).toEqual(data);\n  expect(() => C.parse({ a: \"foo\" })).toThrow();\n});\n\ntest(\"object intersection: loose\", () => {\n  const A = z.looseObject({ a: z.string() });\n  const B = z.object({ b: z.string() });\n\n  const C = z.intersection(A, B); // BaseC.merge(HasID);\n  type C = z.infer<typeof C>;\n  expectTypeOf<C>().toEqualTypeOf<{ a: string; [x: string]: unknown } & { b: string }>();\n  const data = { a: \"foo\", b: \"foo\", c: \"extra\" };\n  expect(C.parse(data)).toEqual(data);\n  expect(() => C.parse({ a: \"foo\" })).toThrow();\n});\n\ntest(\"object intersection: strict\", () => {\n  const A = z.strictObject({ a: z.string() });\n  const B = z.object({ b: z.string() });\n\n  const C = z.intersection(A, B); // BaseC.merge(HasID);\n  type C = z.infer<typeof C>;\n  expectTypeOf<C>().toEqualTypeOf<{ a: string } & { b: string }>();\n  const data = { a: \"foo\", b: \"foo\", c: \"extra\" };\n\n  const result = C.safeParse(data);\n  expect(result.success).toEqual(false);\n});\n\ntest(\"deep intersection\", () => {\n  const Animal = z.object({\n    properties: z.object({\n      is_animal: z.boolean(),\n    }),\n  });\n  const Cat = z.intersection(\n    z.object({\n      properties: z.object({\n        jumped: z.boolean(),\n      }),\n    }),\n    Animal\n  );\n\n  type Cat = util.Flatten<z.infer<typeof Cat>>;\n  expectTypeOf<Cat>().toEqualTypeOf<{ properties: { is_animal: boolean } & { jumped: boolean } }>();\n  const a = Cat.safeParse({ properties: { is_animal: true, jumped: true } });\n  expect(a.data!.properties).toEqual({ is_animal: true, jumped: true });\n});\n\ntest(\"deep intersection of arrays\", async () => {\n  const Author = z.object({\n    posts: z.array(\n      z.object({\n        post_id: z.number(),\n      })\n    ),\n  });\n  const Registry = z.intersection(\n    Author,\n    z.object({\n      posts: z.array(\n        z.object({\n          title: z.string(),\n        })\n      ),\n    })\n  );\n\n  const posts = [\n    { post_id: 1, title: \"Novels\" },\n    { post_id: 2, title: \"Fairy tales\" },\n  ];\n  const cat = Registry.parse({ posts });\n  expect(cat.posts).toEqual(posts);\n  const asyncCat = await Registry.parseAsync({ posts });\n  expect(asyncCat.posts).toEqual(posts);\n});\n\ntest(\"invalid intersection types\", async () => {\n  const numberIntersection = z.intersection(\n    z.number(),\n    z.number().transform((x) => x + 1)\n  );\n\n  expect(() => {\n    numberIntersection.parse(1234);\n  }).toThrowErrorMatchingInlineSnapshot(`[Error: Unmergable intersection. Error path: []]`);\n});\n\ntest(\"invalid array merge (incompatible lengths)\", async () => {\n  const stringArrInt = z.intersection(\n    z.string().array(),\n    z\n      .string()\n      .array()\n      .transform((val) => [...val, \"asdf\"])\n  );\n\n  expect(() => stringArrInt.safeParse([\"asdf\", \"qwer\"])).toThrowErrorMatchingInlineSnapshot(\n    `[Error: Unmergable intersection. Error path: []]`\n  );\n});\n\ntest(\"invalid array merge (incompatible elements)\", async () => {\n  const stringArrInt = z.intersection(\n    z.string().array(),\n    z\n      .string()\n      .array()\n      .transform((val) => [...val.slice(0, -1), \"asdf\"])\n  );\n\n  expect(() => stringArrInt.safeParse([\"asdf\", \"qwer\"])).toThrowErrorMatchingInlineSnapshot(\n    `[Error: Unmergable intersection. Error path: [1]]`\n  );\n});\n\ntest(\"invalid object merge\", async () => {\n  const Cat = z.object({\n    phrase: z.string().transform((val) => `${val} Meow`),\n  });\n  const Dog = z.object({\n    phrase: z.string().transform((val) => `${val} Woof`),\n  });\n  const CatDog = z.intersection(Cat, Dog);\n\n  expect(() => CatDog.parse({ phrase: \"Hello, my name is CatDog.\" })).toThrowErrorMatchingInlineSnapshot(\n    `[Error: Unmergable intersection. Error path: [\"phrase\"]]`\n  );\n});\n\ntest(\"invalid deep merge of object and array combination\", async () => {\n  const University = z.object({\n    students: z.array(\n      z.object({\n        name: z.string().transform((val) => `Student name: ${val}`),\n      })\n    ),\n  });\n  const Registry = z.intersection(\n    University,\n    z.object({\n      students: z.array(\n        z.object({\n          name: z.string(),\n          surname: z.string(),\n        })\n      ),\n    })\n  );\n\n  const students = [{ name: \"John\", surname: \"Doe\" }];\n\n  expect(() => Registry.parse({ students })).toThrowErrorMatchingInlineSnapshot(\n    `[Error: Unmergable intersection. Error path: [\"students\",0,\"name\"]]`\n  );\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/json.test.ts",
    "content": "import { test } from \"vitest\";\n// import * as z from \"zod/v4\";\n\ntest(() => {});\n// test(\"overload types\", () => {\n//   const schema = z.string().json();\n//   util.assertEqual<typeof schema, z.ZodString>(true);\n//   const schema2 = z.string().json(z.number());\n//   util.assertEqual<typeof schema2, z.ZodPipe<z.ZodTransform<any, string>, z.ZodNumber>>(true);\n//   const r2 = schema2.parse(\"12\");\n//   util.assertEqual<number, typeof r2>(true);\n// });\n// test(\"parse string to json\", async () => {\n//   const Env = z.object({\n//     myJsonConfig: z.string().jsonString(z.object({ foo: z.number() })),\n//     someOtherValue: z.string(),\n//   });\n\n//   expect(\n//     Env.parse({\n//       myJsonConfig: '{ \"foo\": 123 }',\n//       someOtherValue: \"abc\",\n//     })\n//   ).toEqual({\n//     myJsonConfig: { foo: 123 },\n//     someOtherValue: \"abc\",\n//   });\n\n//   const invalidValues = Env.safeParse({\n//     myJsonConfig: '{\"foo\": \"not a number!\"}',\n//     someOtherValue: null,\n//   });\n//   expect(JSON.parse(JSON.stringify(invalidValues))).toEqual({\n//     success: false,\n//     error: {\n//       name: \"ZodError\",\n//       issues: [\n//         {\n//           code: \"invalid_type\",\n//           expected: \"number\",\n//           input: \"not a number!\",\n//           received: \"string\",\n//           path: [\"myJsonConfig\", \"foo\"],\n//           message: \"Expected number, received string\",\n//         },\n//         {\n//           code: \"invalid_type\",\n//           expected: \"string\",\n//           input: null,\n//           received: \"null\",\n//           path: [\"someOtherValue\"],\n//           message: \"Expected string, received null\",\n//         },\n//       ],\n//     },\n//   });\n\n//   const invalidJsonSyntax = Env.safeParse({\n//     myJsonConfig: \"This is not valid json\",\n//     someOtherValue: null,\n//   });\n//   expect(JSON.parse(JSON.stringify(invalidJsonSyntax))).toMatchObject({\n//     success: false,\n//     error: {\n//       name: \"ZodError\",\n//       issues: [\n//         {\n//           code: \"invalid_string\",\n//           input: {\n//             _def: {\n//               catchall: {\n//                 _def: {\n//                   typeName: \"ZodNever\",\n//                 },\n//               },\n//               typeName: \"ZodObject\",\n//               unknownKeys: \"strip\",\n//             },\n//           },\n//           validation: \"json\",\n//           message: \"Invalid json\",\n//           path: [\"myJsonConfig\"],\n//         },\n//         {\n//           code: \"invalid_type\",\n//           expected: \"string\",\n//           input: null,\n//           received: \"null\",\n//           path: [\"someOtherValue\"],\n//           message: \"Expected string, received null\",\n//         },\n//       ],\n//     },\n//   });\n// });\n\n// test(\"no argument\", () => {\n//   const schema = z.string().json();\n//   util.assertEqual<typeof schema, z.ZodString>(true);\n//   z.string().json().parse(`{}`);\n//   z.string().json().parse(`null`);\n//   z.string().json().parse(`12`);\n//   z.string().json().parse(`{ \"test\": \"test\"}`);\n//   expect(() => z.string().json().parse(`asdf`)).toThrow();\n//   expect(() => z.string().json().parse(`{ \"test\": undefined }`)).toThrow();\n//   expect(() => z.string().json().parse(`{ \"test\": 12n }`)).toThrow();\n//   expect(() => z.string().json().parse(`{ test: \"test\" }`)).toThrow();\n// });\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/lazy.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"opt passthrough\", () => {\n  const object = z.object({\n    a: z.lazy(() => z.string()),\n    b: z.lazy(() => z.string().optional()),\n    c: z.lazy(() => z.string().default(\"default\")),\n  });\n\n  type ObjectTypeIn = z.input<typeof object>;\n  expectTypeOf<ObjectTypeIn>().toEqualTypeOf<{\n    a: string;\n    b?: string | undefined;\n    c?: string | undefined;\n  }>();\n\n  type ObjectTypeOut = z.output<typeof object>;\n  expectTypeOf<ObjectTypeOut>().toEqualTypeOf<{\n    a: string;\n    b?: string | undefined;\n    c: string;\n  }>();\n\n  const result = object.parse(\n    {\n      a: \"hello\",\n      b: undefined,\n    },\n    { jitless: true }\n  );\n  expect(result).toEqual({\n    a: \"hello\",\n    // b: undefined,\n    c: \"default\",\n  });\n\n  expect(z.lazy(() => z.string())._zod.optin).toEqual(undefined);\n  expect(z.lazy(() => z.string())._zod.optout).toEqual(undefined);\n\n  expect(z.lazy(() => z.string().optional())._zod.optin).toEqual(\"optional\");\n  expect(z.lazy(() => z.string().optional())._zod.optout).toEqual(\"optional\");\n\n  expect(z.lazy(() => z.string().default(\"asdf\"))._zod.optin).toEqual(\"optional\");\n  expect(z.lazy(() => z.string().default(\"asdf\"))._zod.optout).toEqual(undefined);\n});\n\n//////////////   LAZY   //////////////\n\ntest(\"schema getter\", () => {\n  z.lazy(() => z.string()).parse(\"asdf\");\n});\n\ntest(\"lazy proxy\", () => {\n  const schema = z.lazy(() => z.string())._zod.innerType.min(6);\n  schema.parse(\"123456\");\n  expect(schema.safeParse(\"12345\").success).toBe(false);\n});\n\ninterface Category {\n  name: string;\n  subcategories: Category[];\n}\n\nconst testCategory: Category = {\n  name: \"I\",\n  subcategories: [\n    {\n      name: \"A\",\n      subcategories: [\n        {\n          name: \"1\",\n          subcategories: [\n            {\n              name: \"a\",\n              subcategories: [],\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\ntest(\"recursion with z.lazy\", () => {\n  const Category: z.ZodType<Category> = z.lazy(() =>\n    z.object({\n      name: z.string(),\n      subcategories: z.array(Category),\n    })\n  );\n  Category.parse(testCategory);\n});\n\ntype LinkedList = null | { value: number; next: LinkedList };\n\nconst linkedListExample = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null,\n      },\n    },\n  },\n};\n\ntest(\"recursive union wit z.lazy\", () => {\n  const LinkedListSchema: z.ZodType<LinkedList> = z.lazy(() =>\n    z.union([\n      z.null(),\n      z.object({\n        value: z.number(),\n        next: LinkedListSchema,\n      }),\n    ])\n  );\n  LinkedListSchema.parse(linkedListExample);\n});\n\ninterface A {\n  val: number;\n  b: B;\n}\n\ninterface B {\n  val: number;\n  a?: A | undefined;\n}\n\ntest(\"mutual recursion with lazy\", () => {\n  const Alazy: z.ZodType<A> = z.lazy(() =>\n    z.object({\n      val: z.number(),\n      b: Blazy,\n    })\n  );\n\n  const Blazy: z.ZodType<B> = z.lazy(() =>\n    z.object({\n      val: z.number(),\n      a: Alazy.optional(),\n    })\n  );\n\n  const testData = {\n    val: 1,\n    b: {\n      val: 5,\n      a: {\n        val: 3,\n        b: {\n          val: 4,\n          a: {\n            val: 2,\n            b: {\n              val: 1,\n            },\n          },\n        },\n      },\n    },\n  };\n\n  Alazy.parse(testData);\n  Blazy.parse(testData.b);\n\n  expect(() => Alazy.parse({ val: \"asdf\" })).toThrow();\n});\n\n// TODO\ntest(\"mutual recursion with cyclical data\", () => {\n  const a: any = { val: 1 };\n  const b: any = { val: 2 };\n  a.b = b;\n  b.a = a;\n});\n\ntest(\"complicated self-recursion\", () => {\n  const Category = z.object({\n    name: z.string(),\n    age: z.optional(z.number()),\n    get nullself() {\n      return Category.nullable();\n    },\n    get optself() {\n      return Category.optional();\n    },\n    get self() {\n      return Category;\n    },\n    get subcategories() {\n      return z.array(Category);\n    },\n    nested: z.object({\n      get sub() {\n        return Category;\n      },\n    }),\n  });\n\n  type _Category = z.output<typeof Category>;\n});\n\ntest(\"lazy initialization\", () => {\n  const a: any = z.lazy(() => a).optional();\n  const b: any = z.lazy(() => b).nullable();\n  const c: any = z.lazy(() => c).default({} as any);\n  const d: any = z.lazy(() => d).prefault({} as any);\n  const e: any = z.lazy(() => e).nonoptional();\n  const f: any = z.lazy(() => f).catch({} as any);\n  const g: any = z.lazy(() => z.object({ g })).readonly();\n\n  const baseCategorySchema = z.object({\n    name: z.string(),\n  });\n  type Category = z.infer<typeof baseCategorySchema> & {\n    subcategories: Category[];\n  };\n  const categorySchema: z.ZodType<Category> = baseCategorySchema.extend({\n    subcategories: z.lazy(() => categorySchema.array()),\n  });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/literal.test.ts",
    "content": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\nconst literalTuna = z.literal(\"tuna\");\nconst literalTunaCustomMessage = z.literal(\"tuna\", {\n  message: \"That's not a tuna\",\n});\nconst literalFortyTwo = z.literal(42);\nconst literalTrue = z.literal(true);\n\ntest(\"passing validations\", () => {\n  literalTuna.parse(\"tuna\");\n  literalFortyTwo.parse(42);\n  literalTrue.parse(true);\n});\n\ntest(\"failing validations\", () => {\n  expect(() => literalTuna.parse(\"shark\")).toThrow();\n  expect(() => literalFortyTwo.parse(43)).toThrow();\n  expect(() => literalTrue.parse(false)).toThrow();\n});\n\ntest(\"invalid_literal should have `input` field with data\", () => {\n  const data = \"shark\";\n  const result = literalTuna.safeParse(data);\n\n  const issue = result.error!.issues[0];\n  expect(issue.code).toBe(\"invalid_value\");\n  expect(issue).toMatchInlineSnapshot(`\n    {\n      \"code\": \"invalid_value\",\n      \"message\": \"Invalid input: expected \"tuna\"\",\n      \"path\": [],\n      \"values\": [\n        \"tuna\",\n      ],\n    }\n  `);\n});\n\ntest(\"invalid_literal should return default message\", () => {\n  const data = \"shark\";\n  const result = literalTuna.safeParse(data);\n\n  const issue = result.error!.issues[0];\n  expect(issue.message).toEqual(`Invalid input: expected \\\"tuna\\\"`);\n});\n\ntest(\"invalid_literal should return custom message\", () => {\n  const data = \"shark\";\n  const result = literalTunaCustomMessage.safeParse(data);\n\n  const issue = result.error!.issues[0];\n  expect(issue.message).toEqual(`That's not a tuna`);\n});\n\ntest(\"literal default error message\", () => {\n  const result = z.literal(\"Tuna\").safeParse(\"Trout\");\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_value\",\n        \"values\": [\n          \"Tuna\"\n        ],\n        \"path\": [],\n        \"message\": \"Invalid input: expected \\\\\"Tuna\\\\\"\"\n      }\n    ]]\n  `);\n});\n\ntest(\"literal bigint default error message\", () => {\n  const result = z.literal(BigInt(12)).safeParse(BigInt(13));\n  expect(result.success).toBe(false);\n\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error!.issues[0].message).toEqual(`Invalid input: expected 12n`);\n});\n\ntest(\".value getter\", () => {\n  expect(z.literal(\"tuna\").value).toEqual(\"tuna\");\n  expect(() => z.literal([1, 2, 3]).value).toThrow();\n});\n\ntest(\"readonly\", () => {\n  const a = [\"asdf\"] as const;\n  z.literal(a);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/map.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst stringMap = z.map(z.string(), z.string());\ntype stringMap = z.infer<typeof stringMap>;\n\ntest(\"type inference\", () => {\n  expectTypeOf<stringMap>().toEqualTypeOf<Map<string, string>>();\n});\n\ntest(\"valid parse\", () => {\n  const result = stringMap.safeParse(\n    new Map([\n      [\"first\", \"foo\"],\n      [\"second\", \"bar\"],\n    ])\n  );\n  expect(result.success).toEqual(true);\n  expect(result.data).toMatchInlineSnapshot(`\n    Map {\n      \"first\" => \"foo\",\n      \"second\" => \"bar\",\n    }\n  `);\n});\n\ntest(\"valid parse async\", async () => {\n  const asyncMap = z.map(\n    z.string().refine(async () => false, \"bad key\"),\n    z.string().refine(async () => false, \"bad value\")\n  );\n  const result = await asyncMap.safeParseAsync(new Map([[\"first\", \"foo\"]]));\n  expect(result.success).toEqual(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"first\"\n        ],\n        \"message\": \"bad key\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"first\"\n        ],\n        \"message\": \"bad value\"\n      }\n    ]]\n  `);\n});\n\ntest(\"throws when a Set is given\", () => {\n  const result = stringMap.safeParse(new Set([]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(1);\n    expect(result.error.issues[0].code).toEqual(\"invalid_type\");\n  }\n});\n\ntest(\"throws when the given map has invalid key and invalid input\", () => {\n  const result = stringMap.safeParse(new Map([[42, Symbol()]]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error).toMatchInlineSnapshot(`\n      [ZodError: [\n        {\n          \"expected\": \"string\",\n          \"code\": \"invalid_type\",\n          \"path\": [\n            42\n          ],\n          \"message\": \"Invalid input: expected string, received number\"\n        },\n        {\n          \"expected\": \"string\",\n          \"code\": \"invalid_type\",\n          \"path\": [\n            42\n          ],\n          \"message\": \"Invalid input: expected string, received symbol\"\n        }\n      ]]\n    `);\n  }\n});\n\ntest(\"throws when the given map has multiple invalid entries\", () => {\n  // const result = stringMap.safeParse(new Map([[42, Symbol()]]));\n\n  const result = stringMap.safeParse(\n    new Map([\n      [1, \"foo\"],\n      [\"bar\", 2],\n    ] as [any, any][]) as Map<any, any>\n  );\n\n  // const result = stringMap.safeParse(new Map([[42, Symbol()]]));\n  expect(result.success).toEqual(false);\n  if (result.success === false) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error.issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"string\",\n          \"message\": \"Invalid input: expected string, received number\",\n          \"path\": [\n            1,\n          ],\n        },\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"string\",\n          \"message\": \"Invalid input: expected string, received number\",\n          \"path\": [\n            \"bar\",\n          ],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"dirty\", async () => {\n  const map = z.map(\n    z.string().refine((val) => val === val.toUpperCase(), {\n      message: \"Keys must be uppercase\",\n    }),\n    z.string()\n  );\n  const result = await map.spa(\n    new Map([\n      [\"first\", \"foo\"],\n      [\"second\", \"bar\"],\n    ])\n  );\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues.length).toEqual(2);\n    expect(result.error).toMatchInlineSnapshot(`\n      [ZodError: [\n        {\n          \"code\": \"custom\",\n          \"path\": [\n            \"first\"\n          ],\n          \"message\": \"Keys must be uppercase\"\n        },\n        {\n          \"code\": \"custom\",\n          \"path\": [\n            \"second\"\n          ],\n          \"message\": \"Keys must be uppercase\"\n        }\n      ]]\n    `);\n  }\n});\n\ntest(\"map with object keys\", () => {\n  const map = z.map(\n    z.object({\n      name: z.string(),\n      age: z.number(),\n    }),\n    z.string()\n  );\n  const data = new Map([\n    [{ name: \"John\", age: 30 }, \"foo\"],\n    [{ name: \"Jane\", age: 25 }, \"bar\"],\n  ]);\n  const result = map.safeParse(data);\n  expect(result.success).toEqual(true);\n  expect(result.data!).toEqual(data);\n\n  const badData = new Map([[\"bad\", \"foo\"]]);\n  const badResult = map.safeParse(badData);\n  expect(badResult.success).toEqual(false);\n  expect(badResult.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"object\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"bad\"\n        ],\n        \"message\": \"Invalid input: expected object, received string\"\n      }\n    ]]\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/nan.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\nconst schema = z.nan();\n\ntest(\"passing validations\", () => {\n  schema.parse(Number.NaN);\n  schema.parse(Number(\"Not a number\"));\n  expectTypeOf<typeof schema._output>().toEqualTypeOf<number>();\n});\n\ntest(\"failing validations\", () => {\n  expect(() => schema.parse(5)).toThrow();\n  expect(() => schema.parse(\"John\")).toThrow();\n  expect(() => schema.parse(true)).toThrow();\n  expect(() => schema.parse(null)).toThrow();\n  expect(() => schema.parse(undefined)).toThrow();\n  expect(() => schema.parse({})).toThrow();\n  expect(() => schema.parse([])).toThrow();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/nested-refine.test.ts",
    "content": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"nested refinements\", () => {\n  const zodSchema = z\n    .object({\n      password: z.string().min(1),\n      nested: z\n        .object({\n          confirm: z\n            .string()\n            .min(1)\n            .refine((value) => value.length > 2, {\n              message: \"Confirm length should be > 2\",\n            }),\n        })\n        .refine(\n          (data) => {\n            return data.confirm === \"bar\";\n          },\n          {\n            path: [\"confirm\"],\n            error: 'Value must be \"bar\"',\n          }\n        ),\n    })\n    .refine(\n      (data) => {\n        return data.nested.confirm === data.password;\n      },\n      {\n        path: [\"nested\", \"confirm\"],\n        error: \"Password and confirm must match\",\n      }\n    );\n\n  const DATA = {\n    password: \"bar\",\n    nested: { confirm: \"\" },\n  };\n  expect(zodSchema.safeParse(DATA)).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"too_small\",\n        \"minimum\": 1,\n        \"inclusive\": true,\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Too small: expected string to have >=1 characters\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Confirm length should be > 2\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Value must be \\\\\"bar\\\\\"\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Password and confirm must match\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n\n  expect(zodSchema.safeParse(DATA, { jitless: true })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"too_small\",\n        \"minimum\": 1,\n        \"inclusive\": true,\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Too small: expected string to have >=1 characters\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Confirm length should be > 2\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Value must be \\\\\"bar\\\\\"\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"nested\",\n          \"confirm\"\n        ],\n        \"message\": \"Password and confirm must match\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n\n  expect(zodSchema[\"~standard\"].validate(DATA)).toMatchInlineSnapshot(`\n    {\n      \"issues\": [\n        {\n          \"code\": \"too_small\",\n          \"inclusive\": true,\n          \"message\": \"Too small: expected string to have >=1 characters\",\n          \"minimum\": 1,\n          \"origin\": \"string\",\n          \"path\": [\n            \"nested\",\n            \"confirm\",\n          ],\n        },\n        {\n          \"code\": \"custom\",\n          \"message\": \"Confirm length should be > 2\",\n          \"path\": [\n            \"nested\",\n            \"confirm\",\n          ],\n        },\n        {\n          \"code\": \"custom\",\n          \"message\": \"Value must be \"bar\"\",\n          \"path\": [\n            \"nested\",\n            \"confirm\",\n          ],\n        },\n        {\n          \"code\": \"custom\",\n          \"message\": \"Password and confirm must match\",\n          \"path\": [\n            \"nested\",\n            \"confirm\",\n          ],\n        },\n      ],\n    }\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/nonoptional.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport { z } from \"zod/v4\";\n\ntest(\"nonoptional\", () => {\n  const schema = z.string().nonoptional();\n  expectTypeOf<typeof schema._input>().toEqualTypeOf<string>();\n  expectTypeOf<typeof schema._output>().toEqualTypeOf<string>();\n\n  const result = schema.safeParse(undefined);\n  expect(result.success).toBe(false);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"nonoptional with default\", () => {\n  const schema = z.string().optional().nonoptional();\n  expectTypeOf<typeof schema._input>().toEqualTypeOf<string>();\n  expectTypeOf<typeof schema._output>().toEqualTypeOf<string>();\n\n  const result = schema.safeParse(undefined);\n  expect(result.success).toBe(false);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"nonoptional\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected nonoptional, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"nonoptional in object\", () => {\n  const schema = z.object({ hi: z.string().optional().nonoptional() });\n\n  expectTypeOf<typeof schema._input>().toEqualTypeOf<{ hi: string }>();\n  expectTypeOf<typeof schema._output>().toEqualTypeOf<{ hi: string }>();\n  const r1 = schema.safeParse({ hi: \"asdf\" });\n  expect(r1.success).toEqual(true);\n\n  const r2 = schema.safeParse({ hi: undefined });\n  // expect(schema.safeParse({ hi: undefined }).success).toEqual(false);\n  expect(r2.success).toEqual(false);\n  expect(r2.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"nonoptional\",\n        \"path\": [\n          \"hi\"\n        ],\n        \"message\": \"Invalid input: expected nonoptional, received undefined\"\n      }\n    ]]\n  `);\n\n  const r3 = schema.safeParse({});\n  expect(r3.success).toEqual(false);\n  expect(r3.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"nonoptional\",\n        \"path\": [\n          \"hi\"\n        ],\n        \"message\": \"Invalid input: expected nonoptional, received undefined\"\n      }\n    ]]\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/nullable.test.ts",
    "content": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\".nullable()\", () => {\n  const nullable = z.string().nullable();\n  expect(nullable.parse(null)).toBe(null);\n  expect(nullable.parse(\"asdf\")).toBe(\"asdf\");\n  expect(() => nullable.parse(123)).toThrow();\n});\n\ntest(\".nullable unwrap\", () => {\n  const schema = z.string().nullable();\n  expect(schema).toBeInstanceOf(z.ZodNullable);\n  expect(schema.unwrap()).toBeInstanceOf(z.ZodString);\n});\n\ntest(\"z.null\", () => {\n  const n = z.null();\n  expect(n.parse(null)).toBe(null);\n  expect(() => n.parse(\"asdf\")).toThrow();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/number.test.ts",
    "content": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"z.number() basic validation\", () => {\n  const schema = z.number();\n  expect(schema.parse(1234)).toEqual(1234);\n});\n\ntest(\"NaN validation\", () => {\n  const schema = z.number();\n  expect(() => schema.parse(Number.NaN)).toThrow();\n});\n\ntest(\"Infinity validation\", () => {\n  const schema = z.number();\n  expect(schema.safeParse(Number.POSITIVE_INFINITY)).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"received\": \"Infinity\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected number, received number\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse(Number.NEGATIVE_INFINITY)).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"received\": \"Infinity\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected number, received number\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\".gt() validation\", () => {\n  const schema = z.number().gt(0).gt(5);\n  expect(schema.parse(6)).toEqual(6);\n  expect(() => schema.parse(5)).toThrow();\n});\n\ntest(\".gte() validation\", () => {\n  const schema = z.number().gt(0).gte(1).gte(5);\n  expect(schema.parse(5)).toEqual(5);\n  expect(() => schema.parse(4)).toThrow();\n});\n\ntest(\".min() validation\", () => {\n  const schema = z.number().min(0).min(5);\n  expect(schema.parse(5)).toEqual(5);\n  expect(() => schema.parse(4)).toThrow();\n});\n\ntest(\".lt() validation\", () => {\n  const schema = z.number().lte(10).lt(5);\n  expect(schema.parse(4)).toEqual(4);\n  expect(() => schema.parse(5)).toThrow();\n});\n\ntest(\".lte() validation\", () => {\n  const schema = z.number().lte(10).lte(5);\n  expect(schema.parse(5)).toEqual(5);\n  expect(() => schema.parse(6)).toThrow();\n});\n\ntest(\".max() validation\", () => {\n  const schema = z.number().max(10).max(5);\n  expect(schema.parse(5)).toEqual(5);\n  expect(() => schema.parse(6)).toThrow();\n});\n\ntest(\".int() validation\", () => {\n  const schema = z.number().int();\n  expect(schema.parse(4)).toEqual(4);\n  expect(() => schema.parse(3.14)).toThrow();\n});\n\ntest(\".positive() validation\", () => {\n  const schema = z.number().positive();\n  expect(schema.parse(1)).toEqual(1);\n  expect(() => schema.parse(0)).toThrow();\n  expect(() => schema.parse(-1)).toThrow();\n});\n\ntest(\".negative() validation\", () => {\n  const schema = z.number().negative();\n  expect(schema.parse(-1)).toEqual(-1);\n  expect(() => schema.parse(0)).toThrow();\n  expect(() => schema.parse(1)).toThrow();\n});\n\ntest(\".nonpositive() validation\", () => {\n  const schema = z.number().nonpositive();\n  expect(schema.parse(0)).toEqual(0);\n  expect(schema.parse(-1)).toEqual(-1);\n  expect(() => schema.parse(1)).toThrow();\n});\n\ntest(\".nonnegative() validation\", () => {\n  const schema = z.number().nonnegative();\n  expect(schema.parse(0)).toEqual(0);\n  expect(schema.parse(1)).toEqual(1);\n  expect(() => schema.parse(-1)).toThrow();\n});\n\ntest(\".multipleOf() with positive divisor\", () => {\n  const schema = z.number().multipleOf(5);\n  expect(schema.parse(15)).toEqual(15);\n  expect(schema.parse(-15)).toEqual(-15);\n  expect(() => schema.parse(7.5)).toThrow();\n  expect(() => schema.parse(-7.5)).toThrow();\n});\n\ntest(\".multipleOf() with negative divisor\", () => {\n  const schema = z.number().multipleOf(-5);\n  expect(schema.parse(-15)).toEqual(-15);\n  expect(schema.parse(15)).toEqual(15);\n  expect(() => schema.parse(-7.5)).toThrow();\n  expect(() => schema.parse(7.5)).toThrow();\n});\n\ntest(\".step() validation\", () => {\n  const schemaPointOne = z.number().step(0.1);\n  const schemaPointZeroZeroZeroOne = z.number().step(0.0001);\n  const schemaSixPointFour = z.number().step(6.4);\n\n  expect(schemaPointOne.parse(6)).toEqual(6);\n  expect(schemaPointOne.parse(6.1)).toEqual(6.1);\n  expect(schemaSixPointFour.parse(12.8)).toEqual(12.8);\n  expect(schemaPointZeroZeroZeroOne.parse(3.01)).toEqual(3.01);\n  expect(() => schemaPointOne.parse(6.11)).toThrow();\n  expect(() => schemaPointOne.parse(6.1000000001)).toThrow();\n  expect(() => schemaSixPointFour.parse(6.41)).toThrow();\n});\n\ntest(\".finite() validation\", () => {\n  const schema = z.number().finite();\n  expect(schema.parse(123)).toEqual(123);\n  expect(schema.safeParse(Number.POSITIVE_INFINITY)).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"received\": \"Infinity\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected number, received number\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse(Number.NEGATIVE_INFINITY)).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"received\": \"Infinity\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected number, received number\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\".safe() validation\", () => {\n  const schema = z.number().safe();\n  expect(schema.parse(Number.MIN_SAFE_INTEGER)).toEqual(Number.MIN_SAFE_INTEGER);\n  expect(schema.parse(Number.MAX_SAFE_INTEGER)).toEqual(Number.MAX_SAFE_INTEGER);\n  expect(() => schema.parse(Number.MIN_SAFE_INTEGER - 1)).toThrow();\n  expect(() => schema.parse(Number.MAX_SAFE_INTEGER + 1)).toThrow();\n});\n\ntest(\"min value getters\", () => {\n  expect(z.number().minValue).toBeNull;\n  expect(z.number().lt(5).minValue).toBeNull;\n  expect(z.number().lte(5).minValue).toBeNull;\n  expect(z.number().max(5).minValue).toBeNull;\n  expect(z.number().negative().minValue).toBeNull;\n  expect(z.number().nonpositive().minValue).toBeNull;\n  expect(z.number().int().minValue).toBeNull;\n  expect(z.number().multipleOf(5).minValue).toBeNull;\n  expect(z.number().finite().minValue).toBeNull;\n  expect(z.number().gt(5).minValue).toEqual(5);\n  expect(z.number().gte(5).minValue).toEqual(5);\n  expect(z.number().min(5).minValue).toEqual(5);\n  expect(z.number().min(5).min(10).minValue).toEqual(10);\n  expect(z.number().positive().minValue).toEqual(0);\n  expect(z.number().nonnegative().minValue).toEqual(0);\n  expect(z.number().safe().minValue).toEqual(Number.MIN_SAFE_INTEGER);\n});\n\ntest(\"max value getters\", () => {\n  expect(z.number().maxValue).toBeNull;\n  expect(z.number().gt(5).maxValue).toBeNull;\n  expect(z.number().gte(5).maxValue).toBeNull;\n  expect(z.number().min(5).maxValue).toBeNull;\n  expect(z.number().positive().maxValue).toBeNull;\n  expect(z.number().nonnegative().maxValue).toBeNull;\n  expect(z.number().int().minValue).toBeNull;\n  expect(z.number().multipleOf(5).minValue).toBeNull;\n  expect(z.number().finite().minValue).toBeNull;\n  expect(z.number().lt(5).maxValue).toEqual(5);\n  expect(z.number().lte(5).maxValue).toEqual(5);\n  expect(z.number().max(5).maxValue).toEqual(5);\n  expect(z.number().max(5).max(1).maxValue).toEqual(1);\n  expect(z.number().negative().maxValue).toEqual(0);\n  expect(z.number().nonpositive().maxValue).toEqual(0);\n  expect(z.number().safe().maxValue).toEqual(Number.MAX_SAFE_INTEGER);\n});\n\ntest(\"int getter\", () => {\n  expect(z.number().isInt).toEqual(false);\n  expect(z.number().int().isInt).toEqual(true);\n  expect(z.number().safe().isInt).toEqual(true);\n  expect(z.number().multipleOf(5).isInt).toEqual(true);\n});\n\n/** In Zod 4, number schemas don't accept infinite values. */\ntest(\"finite getter\", () => {\n  expect(z.number().isFinite).toEqual(true);\n});\n\ntest(\"string format methods\", () => {\n  const a = z.int32().min(5);\n  expect(a.parse(6)).toEqual(6);\n  expect(() => a.parse(1)).toThrow();\n});\n\ntest(\"error customization\", () => {\n  z.number().gte(5, { error: (iss) => \"Min: \" + iss.minimum.valueOf() });\n  z.number().lte(5, { error: (iss) => \"Max: \" + iss.maximum.valueOf() });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/object.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\nimport * as core from \"zod/v4/core\";\n\nconst Test = z.object({\n  f1: z.number(),\n  f2: z.string().optional(),\n  f3: z.string().nullable(),\n  f4: z.array(z.object({ t: z.union([z.string(), z.boolean()]) })),\n});\n\ntest(\"object type inference\", () => {\n  type TestType = {\n    f1: number;\n    f2?: string | undefined;\n    f3: string | null;\n    f4: { t: string | boolean }[];\n  };\n\n  expectTypeOf<z.TypeOf<typeof Test>>().toEqualTypeOf<TestType>();\n});\n\ntest(\"unknown throw\", () => {\n  const asdf: unknown = 35;\n  expect(() => Test.parse(asdf)).toThrow();\n});\n\ntest(\"shape() should return schema of particular key\", () => {\n  const f1Schema = Test.shape.f1;\n  const f2Schema = Test.shape.f2;\n  const f3Schema = Test.shape.f3;\n  const f4Schema = Test.shape.f4;\n\n  expect(f1Schema).toBeInstanceOf(z.ZodNumber);\n  expect(f2Schema).toBeInstanceOf(z.ZodOptional);\n  expect(f3Schema).toBeInstanceOf(z.ZodNullable);\n  expect(f4Schema).toBeInstanceOf(z.ZodArray);\n});\n\ntest(\"correct parsing\", () => {\n  Test.parse({\n    f1: 12,\n    f2: \"string\",\n    f3: \"string\",\n    f4: [\n      {\n        t: \"string\",\n      },\n    ],\n  });\n\n  Test.parse({\n    f1: 12,\n    f3: null,\n    f4: [\n      {\n        t: false,\n      },\n    ],\n  });\n});\n\ntest(\"nonstrict by default\", () => {\n  z.object({ points: z.number() }).parse({\n    points: 2314,\n    unknown: \"asdf\",\n  });\n});\n\ntest(\"parse optional keys \", () => {\n  const schema = z.object({\n    a: z.string().optional(),\n  });\n  expect(schema.parse({ a: \"asdf\" })).toEqual({ a: \"asdf\" });\n});\n\ntest(\"empty object\", () => {\n  const schema = z.object({});\n  expect(schema.parse({})).toEqual({});\n  expect(schema.parse({ name: \"asdf\" })).toEqual({});\n  expect(schema.safeParse(null).success).toEqual(false);\n  expect(schema.safeParse(\"asdf\").success).toEqual(false);\n  expectTypeOf<z.output<typeof schema>>().toEqualTypeOf<Record<string, never>>();\n});\n\nconst data = {\n  points: 2314,\n  unknown: \"asdf\",\n};\n\ntest(\"strip by default\", () => {\n  const val = z.object({ points: z.number() }).parse(data);\n  expect(val).toEqual({ points: 2314 });\n});\n\ntest(\"unknownkeys override\", () => {\n  const val = z.object({ points: z.number() }).strict().passthrough().strip().passthrough().parse(data);\n\n  expect(val).toEqual(data);\n});\n\ntest(\"passthrough unknown\", () => {\n  const val = z.object({ points: z.number() }).passthrough().parse(data);\n\n  expect(val).toEqual(data);\n});\n\ntest(\"strip unknown\", () => {\n  const val = z.object({ points: z.number() }).strip().parse(data);\n\n  expect(val).toEqual({ points: 2314 });\n});\n\ntest(\"strict\", () => {\n  const val = z.object({ points: z.number() }).strict().safeParse(data);\n\n  expect(val.success).toEqual(false);\n});\n\ntest(\"catchall inference\", () => {\n  const o1 = z\n    .object({\n      first: z.string(),\n    })\n    .catchall(z.number());\n\n  const d1 = o1.parse({ first: \"asdf\", num: 1243 });\n  // expectTypeOf<(typeof d1)[\"asdf\"]>().toEqualTypeOf<number>();\n  expectTypeOf<(typeof d1)[\"first\"]>().toEqualTypeOf<string>();\n});\n\ntest(\"catchall overrides strict\", () => {\n  const o1 = z.object({ first: z.string().optional() }).strict().catchall(z.number());\n\n  // should run fine\n  // setting a catchall overrides the unknownKeys behavior\n  o1.parse({\n    asdf: 1234,\n  });\n\n  // should only run catchall validation\n  // against unknown keys\n  o1.parse({\n    first: \"asdf\",\n    asdf: 1234,\n  });\n});\n\ntest(\"catchall overrides strict\", () => {\n  const o1 = z\n    .object({\n      first: z.string(),\n    })\n    .strict()\n    .catchall(z.number());\n\n  // should run fine\n  // setting a catchall overrides the unknownKeys behavior\n  o1.parse({\n    first: \"asdf\",\n    asdf: 1234,\n  });\n});\n\ntest(\"optional keys are unset\", async () => {\n  const SNamedEntity = z.object({\n    id: z.string(),\n    set: z.string().optional(),\n    unset: z.string().optional(),\n  });\n  const result = await SNamedEntity.parse({\n    id: \"asdf\",\n    set: undefined,\n  });\n  expect(Object.keys(result)).toEqual([\"id\", \"set\"]);\n});\n\ntest(\"catchall parsing\", async () => {\n  const result = z.object({ name: z.string() }).catchall(z.number()).parse({ name: \"Foo\", validExtraKey: 61 });\n\n  expect(result).toEqual({ name: \"Foo\", validExtraKey: 61 });\n\n  const result2 = z\n    .object({ name: z.string() })\n    .catchall(z.number())\n    .safeParse({ name: \"Foo\", validExtraKey: 61, invalid: \"asdf\" });\n\n  expect(result2.success).toEqual(false);\n});\n\ntest(\"nonexistent keys\", async () => {\n  const Schema = z.union([z.object({ a: z.string() }), z.object({ b: z.number() })]);\n  const obj = { a: \"A\" };\n  const result = await Schema.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21\n  expect(result.success).toBe(true);\n});\n\ntest(\"test async union\", async () => {\n  const Schema2 = z.union([\n    z.object({\n      ty: z.string(),\n    }),\n    z.object({\n      ty: z.number(),\n    }),\n  ]);\n\n  const obj = { ty: \"A\" };\n  const result = await Schema2.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21\n  expect(result.success).toEqual(true);\n});\n\ntest(\"test inferred merged type\", async () => {\n  const asdf = z.object({ a: z.string() }).merge(z.object({ a: z.number() }));\n  type asdf = z.infer<typeof asdf>;\n\n  expectTypeOf<asdf>().toEqualTypeOf<{ a: number }>();\n});\n\ntest(\"inferred type with Record shape\", () => {\n  type A = z.ZodObject<Record<string, z.ZodType<string, number>>>;\n  expectTypeOf<z.infer<A>>().toEqualTypeOf<Record<string, string>>();\n  expectTypeOf<z.input<A>>().toEqualTypeOf<Record<string, number>>();\n\n  type B = z.ZodObject;\n  expectTypeOf<z.infer<B>>().toEqualTypeOf<Record<string, unknown>>();\n  expectTypeOf<z.input<B>>().toEqualTypeOf<Record<string, unknown>>();\n});\n\ntest(\"inferred merged object type with optional properties\", async () => {\n  const Merged = z\n    .object({ a: z.string(), b: z.string().optional() })\n    .merge(z.object({ a: z.string().optional(), b: z.string() }));\n  type Merged = z.infer<typeof Merged>;\n  expectTypeOf<Merged>().toEqualTypeOf<{ a?: string; b: string }>();\n  expectTypeOf<Merged>().toEqualTypeOf<{ a?: string; b: string }>();\n});\n\ntest(\"inferred unioned object type with optional properties\", async () => {\n  const Unioned = z.union([\n    z.object({ a: z.string(), b: z.string().optional() }),\n    z.object({ a: z.string().optional(), b: z.string() }),\n  ]);\n  type Unioned = z.infer<typeof Unioned>;\n  expectTypeOf<Unioned>().toEqualTypeOf<{ a: string; b?: string } | { a?: string; b: string }>();\n});\n\ntest(\"inferred enum type\", async () => {\n  const Enum = z.object({ a: z.string(), b: z.string().optional() }).keyof();\n\n  expect(Enum.enum).toEqual({\n    a: \"a\",\n    b: \"b\",\n  });\n\n  expect(Enum._zod.def.entries).toEqual({\n    a: \"a\",\n    b: \"b\",\n  });\n  type Enum = z.infer<typeof Enum>;\n  expectTypeOf<Enum>().toEqualTypeOf<\"a\" | \"b\">();\n});\n\ntest(\"inferred partial object type with optional properties\", async () => {\n  const Partial = z.object({ a: z.string(), b: z.string().optional() }).partial();\n  type Partial = z.infer<typeof Partial>;\n  expectTypeOf<Partial>().toEqualTypeOf<{ a?: string; b?: string }>();\n});\n\ntest(\"inferred picked object type with optional properties\", async () => {\n  const Picked = z.object({ a: z.string(), b: z.string().optional() }).pick({ b: true });\n  type Picked = z.infer<typeof Picked>;\n  expectTypeOf<Picked>().toEqualTypeOf<{ b?: string }>();\n});\n\ntest(\"inferred type for unknown/any keys\", () => {\n  const myType = z.object({\n    anyOptional: z.any().optional(),\n    anyRequired: z.any(),\n    unknownOptional: z.unknown().optional(),\n    unknownRequired: z.unknown(),\n  });\n  type myType = z.infer<typeof myType>;\n  expectTypeOf<myType>().toEqualTypeOf<{\n    anyOptional?: any;\n    anyRequired: any;\n    unknownOptional?: unknown;\n    unknownRequired: unknown;\n  }>();\n});\n\ntest(\"strictObject\", async () => {\n  const strictObj = z.strictObject({\n    name: z.string(),\n  });\n\n  const syncResult = strictObj.safeParse({ name: \"asdf\", unexpected: 13 });\n  expect(syncResult.success).toEqual(false);\n\n  const asyncResult = await strictObj.spa({ name: \"asdf\", unexpected: 13 });\n  expect(asyncResult.success).toEqual(false);\n});\n\ntest(\"object with refine\", async () => {\n  const schema = z\n    .object({\n      a: z.string().default(\"foo\"),\n      b: z.number(),\n    })\n    .refine(() => true);\n  expect(schema.parse({ b: 5 })).toEqual({ b: 5, a: \"foo\" });\n  const result = await schema.parseAsync({ b: 5 });\n  expect(result).toEqual({ b: 5, a: \"foo\" });\n});\n\ntest(\"intersection of object with date\", async () => {\n  const schema = z.object({\n    a: z.date(),\n  });\n  expect(z.intersection(schema, schema).parse({ a: new Date(1637353595983) })).toEqual({\n    a: new Date(1637353595983),\n  });\n  const result = await schema.parseAsync({ a: new Date(1637353595983) });\n  expect(result).toEqual({ a: new Date(1637353595983) });\n});\n\ntest(\"intersection of object with refine with date\", async () => {\n  const schema = z\n    .object({\n      a: z.date(),\n    })\n    .refine(() => true);\n  expect(z.intersection(schema, schema).parse({ a: new Date(1637353595983) })).toEqual({\n    a: new Date(1637353595983),\n  });\n  const result = await schema.parseAsync({ a: new Date(1637353595983) });\n  expect(result).toEqual({ a: new Date(1637353595983) });\n});\n\ntest(\"constructor key\", () => {\n  const person = z\n    .object({\n      name: z.string(),\n    })\n    .strict();\n\n  expect(() =>\n    person.parse({\n      name: \"bob dylan\",\n      constructor: 61,\n    })\n  ).toThrow();\n});\n\ntest(\"constructor key\", () => {\n  const Example = z.object({\n    prop: z.string(),\n    opt: z.number().optional(),\n    arr: z.string().array(),\n  });\n\n  type Example = z.infer<typeof Example>;\n  expectTypeOf<keyof Example>().toEqualTypeOf<\"prop\" | \"opt\" | \"arr\">();\n});\n\ntest(\"catchall\", () => {\n  const a = z.object({});\n  expect(a._zod.def.catchall).toBeUndefined();\n\n  const b = z.strictObject({});\n  expect(b._zod.def.catchall).toBeInstanceOf(core.$ZodNever);\n\n  const c = z.looseObject({});\n  expect(c._zod.def.catchall).toBeInstanceOf(core.$ZodUnknown);\n\n  const d = z.object({}).catchall(z.number());\n  expect(d._zod.def.catchall).toBeInstanceOf(core.$ZodNumber);\n});\n\ntest(\"unknownkeys merging\", () => {\n  // This one is \"strict\"\n  const a = z.looseObject({\n    a: z.string(),\n  });\n\n  const b = z.strictObject({ b: z.string() });\n\n  // incoming object overrides\n  const c = a.merge(b);\n  expect(c._zod.def.catchall).toBeInstanceOf(core.$ZodNever);\n});\n\nconst personToExtend = z.object({\n  firstName: z.string(),\n  lastName: z.string(),\n});\n\ntest(\"extend() should return schema with new key\", () => {\n  const PersonWithNickname = personToExtend.extend({ nickName: z.string() });\n  type PersonWithNickname = z.infer<typeof PersonWithNickname>;\n\n  const expected = { firstName: \"f\", nickName: \"n\", lastName: \"l\" };\n  const actual = PersonWithNickname.parse(expected);\n\n  expect(actual).toEqual(expected);\n  expectTypeOf<keyof PersonWithNickname>().toEqualTypeOf<\"firstName\" | \"lastName\" | \"nickName\">();\n  expectTypeOf<PersonWithNickname>().toEqualTypeOf<{ firstName: string; lastName: string; nickName: string }>();\n});\n\ntest(\"extend() should have power to override existing key\", () => {\n  const PersonWithNumberAsLastName = personToExtend.extend({\n    lastName: z.number(),\n  });\n  type PersonWithNumberAsLastName = z.infer<typeof PersonWithNumberAsLastName>;\n\n  const expected = { firstName: \"f\", lastName: 42 };\n  const actual = PersonWithNumberAsLastName.parse(expected);\n\n  expect(actual).toEqual(expected);\n  expectTypeOf<PersonWithNumberAsLastName>().toEqualTypeOf<{ firstName: string; lastName: number }>();\n});\n\ntest(\"passthrough index signature\", () => {\n  const a = z.object({ a: z.string() });\n  type a = z.infer<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<{ a: string }>();\n  const b = a.passthrough();\n  type b = z.infer<typeof b>;\n  expectTypeOf<b>().toEqualTypeOf<{ a: string; [k: string]: unknown }>();\n});\n\n// test(\"xor\", () => {\n//   type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n//   type XOR<T, U> = T extends object ? (U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : U) : T;\n\n//   type A = { name: string; a: number };\n//   type B = { name: string; b: number };\n//   type C = XOR<A, B>;\n//   type Outer = { data: C };\n//   const Outer = z.object({\n//     data: z.union([z.object({ name: z.string(), a: z.number() }), z.object({ name: z.string(), b: z.number() })]),\n//   }) satisfies z.ZodType<Outer, any>;\n// });\n\ntest(\"assignability\", () => {\n  z.object({ a: z.string() }) satisfies z.ZodObject<{ a: z.ZodString }>;\n  z.object({ a: z.string() }).catchall(z.number()) satisfies z.ZodObject<{ a: z.ZodString }>;\n  z.object({ a: z.string() }).strict() satisfies z.ZodObject;\n  z.object({}) satisfies z.ZodObject;\n\n  z.looseObject({ name: z.string() }) satisfies z.ZodObject<\n    {\n      name: z.ZodString;\n    },\n    z.core.$loose\n  >;\n  z.looseObject({ name: z.string() }) satisfies z.ZodObject<{\n    name: z.ZodString;\n  }>;\n  z.strictObject({ name: z.string() }) satisfies z.ZodObject<\n    {\n      name: z.ZodString;\n    },\n    z.core.$loose\n  >;\n  z.strictObject({ name: z.string() }) satisfies z.ZodObject<\n    {\n      name: z.ZodString;\n    },\n    z.core.$strict\n  >;\n  z.object({ name: z.string() }) satisfies z.ZodObject<{\n    name: z.ZodString;\n  }>;\n  z.object({\n    a: z.string(),\n    b: z.number(),\n    c: z.boolean(),\n  }) satisfies z.core.$ZodObject;\n});\n\ntest(\"null prototype\", () => {\n  const schema = z.object({ a: z.string() });\n  const obj = Object.create(null);\n  obj.a = \"foo\";\n  expect(schema.parse(obj)).toEqual({ a: \"foo\" });\n});\n\ntest(\"empty objects\", () => {\n  const A = z.looseObject({});\n  type Ain = z.input<typeof A>;\n  expectTypeOf<Ain>().toEqualTypeOf<Record<string, unknown>>();\n  type Aout = z.output<typeof A>;\n  expectTypeOf<Aout>().toEqualTypeOf<Record<string, unknown>>();\n\n  const B = z.object({});\n  type Bout = z.output<typeof B>;\n  expectTypeOf<Bout>().toEqualTypeOf<Record<string, never>>();\n  type Bin = z.input<typeof B>;\n  expectTypeOf<Bin>().toEqualTypeOf<Record<string, never>>();\n\n  const C = z.strictObject({});\n  type Cout = z.output<typeof C>;\n  expectTypeOf<Cout>().toEqualTypeOf<Record<string, never>>();\n  type Cin = z.input<typeof C>;\n  expectTypeOf<Cin>().toEqualTypeOf<Record<string, never>>();\n});\n\ntest(\"preserve key order\", () => {\n  const schema = z.object({\n    a: z.string().optional(),\n    b: z.string(),\n  });\n  const r1 = schema.safeParse({ a: \"asdf\", b: \"qwer\" });\n  const r2 = schema.safeParse({ a: \"asdf\", b: \"qwer\" }, { jitless: true });\n\n  expect(Object.keys(r1.data!)).toMatchInlineSnapshot(`\n    [\n      \"a\",\n      \"b\",\n    ]\n  `);\n  expect(Object.keys(r1.data!)).toEqual(Object.keys(r2.data!));\n});\n\ntest(\"empty shape\", () => {\n  const a = z.object({});\n\n  a.parse({});\n  a.parse({}, { jitless: true });\n  a.parse(Object.create(null));\n  a.parse(Object.create(null), { jitless: true });\n\n  expect(() => a.parse([])).toThrow();\n  expect(() => a.parse([], { jitless: true })).toThrow();\n});\n\ntest(\"zodtype assignability\", () => {\n  // Does not error\n  z.object({ hello: z.string().optional() }) satisfies z.ZodType<{ hello?: string | undefined }>;\n  z.object({ hello: z.string() }) satisfies z.ZodType<{ hello?: string | undefined }>;\n  // @ts-expect-error\n  z.object({}) satisfies z.ZodType<{ hello: string | undefined }>;\n  // @ts-expect-error\n  z.object({ hello: z.string().optional() }) satisfies z.ZodType<{ hello: string | undefined }>;\n  // @ts-expect-error\n  z.object({ hello: z.string().optional() }) satisfies z.ZodType<{ hello: string }>;\n  // @ts-expect-error\n  z.object({ hello: z.number() }) satisfies z.ZodType<{ hello?: string | undefined }>;\n});\n\ntest(\"index signature in shape\", () => {\n  function makeZodObj<const T extends string>(key: T) {\n    return z.looseObject({\n      [key]: z.string(),\n    });\n  }\n\n  const schema = makeZodObj(\"foo\");\n  type schema = z.infer<typeof schema>;\n\n  expectTypeOf<schema>().toEqualTypeOf<Record<string, string>>();\n});\n",
    "symbols": [
      {
        "name": "makeZodObj",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/object.test.ts",
        "startLine": 553,
        "endLine": 557
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/optional.test.ts",
    "content": "// @ts-ignore TS6133\nimport { expect, expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\".optional()\", () => {\n  const schema = z.string().optional();\n  expect(schema.parse(\"adsf\")).toEqual(\"adsf\");\n  expect(schema.parse(undefined)).toEqual(undefined);\n  expect(schema.safeParse(null).success).toEqual(false);\n\n  expectTypeOf<typeof schema._output>().toEqualTypeOf<string | undefined>();\n});\n\ntest(\"unwrap\", () => {\n  const unwrapped = z.string().optional().unwrap();\n  expect(unwrapped).toBeInstanceOf(z.ZodString);\n});\n\ntest(\"optionality\", () => {\n  const a = z.string();\n  expect(a._zod.optin).toEqual(undefined);\n  expect(a._zod.optout).toEqual(undefined);\n\n  const b = z.string().optional();\n  expect(b._zod.optin).toEqual(\"optional\");\n  expect(b._zod.optout).toEqual(\"optional\");\n\n  const c = z.string().default(\"asdf\");\n  expect(c._zod.optin).toEqual(\"optional\");\n  expect(c._zod.optout).toEqual(undefined);\n\n  const d = z.string().optional().nullable();\n  expect(d._zod.optin).toEqual(\"optional\");\n  expect(d._zod.optout).toEqual(\"optional\");\n\n  const e = z.string().default(\"asdf\").nullable();\n  expect(e._zod.optin).toEqual(\"optional\");\n  expect(e._zod.optout).toEqual(undefined);\n\n  // z.undefined should NOT be optional\n  const f = z.undefined();\n  expect(f._zod.optin).toEqual(\"optional\");\n  expect(f._zod.optout).toEqual(\"optional\");\n  expectTypeOf<typeof f._zod.optin>().toEqualTypeOf<\"optional\" | undefined>();\n  expectTypeOf<typeof f._zod.optout>().toEqualTypeOf<\"optional\" | undefined>();\n\n  // z.union should be optional if any of the types are optional\n  const g = z.union([z.string(), z.undefined()]);\n  expect(g._zod.optin).toEqual(\"optional\");\n  expect(g._zod.optout).toEqual(\"optional\");\n  expectTypeOf<typeof g._zod.optin>().toEqualTypeOf<\"optional\" | undefined>();\n  expectTypeOf<typeof g._zod.optout>().toEqualTypeOf<\"optional\" | undefined>();\n\n  const h = z.union([z.string(), z.optional(z.string())]);\n  expect(h._zod.optin).toEqual(\"optional\");\n  expect(h._zod.optout).toEqual(\"optional\");\n  expectTypeOf<typeof h._zod.optin>().toEqualTypeOf<\"optional\">();\n  expectTypeOf<typeof h._zod.optout>().toEqualTypeOf<\"optional\">();\n});\n\ntest(\"pipe optionality\", () => {\n  z.string().optional()._zod.optin;\n  const a = z.string().optional().pipe(z.string());\n  expect(a._zod.optin).toEqual(\"optional\");\n  expect(a._zod.optout).toEqual(undefined);\n  expectTypeOf<typeof a._zod.optin>().toEqualTypeOf<\"optional\">();\n  expectTypeOf<typeof a._zod.optout>().toEqualTypeOf<\"optional\" | undefined>();\n\n  const b = z\n    .string()\n    .transform((val) => (Math.random() ? val : undefined))\n    .pipe(z.string().optional());\n  expect(b._zod.optin).toEqual(undefined);\n  expect(b._zod.optout).toEqual(\"optional\");\n  expectTypeOf<typeof b._zod.optin>().toEqualTypeOf<\"optional\" | undefined>();\n  expectTypeOf<typeof b._zod.optout>().toEqualTypeOf<\"optional\">();\n\n  const c = z.string().default(\"asdf\").pipe(z.string());\n  expect(c._zod.optin).toEqual(\"optional\");\n  expect(c._zod.optout).toEqual(undefined);\n\n  const d = z\n    .string()\n    .transform((val) => (Math.random() ? val : undefined))\n    .pipe(z.string().default(\"asdf\"));\n  expect(d._zod.optin).toEqual(undefined);\n  expect(d._zod.optout).toEqual(undefined);\n});\n\ntest(\"pipe optionality inside objects\", () => {\n  const schema = z.object({\n    a: z.string().optional(),\n    b: z.string().optional().pipe(z.string()),\n    c: z.string().default(\"asdf\").pipe(z.string()),\n    d: z\n      .string()\n      .transform((val) => (Math.random() ? val : undefined))\n      .pipe(z.string().optional()),\n    e: z\n      .string()\n      .transform((val) => (Math.random() ? val : undefined))\n      .pipe(z.string().default(\"asdf\")),\n  });\n\n  type SchemaIn = z.input<typeof schema>;\n  expectTypeOf<SchemaIn>().toEqualTypeOf<{\n    a?: string | undefined;\n    b?: string | undefined;\n    c?: string | undefined;\n    d: string;\n    e: string;\n  }>();\n\n  type SchemaOut = z.output<typeof schema>;\n  expectTypeOf<SchemaOut>().toEqualTypeOf<{\n    a?: string | undefined;\n    b: string;\n    c: string;\n    d?: string | undefined;\n    e: string;\n  }>();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/partial.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst nested = z.object({\n  name: z.string(),\n  age: z.number(),\n  outer: z.object({\n    inner: z.string(),\n  }),\n  array: z.array(z.object({ asdf: z.string() })),\n});\n\ntest(\"shallow inference\", () => {\n  const shallow = nested.partial();\n  type shallow = z.infer<typeof shallow>;\n\n  expectTypeOf<shallow>().toEqualTypeOf<{\n    name?: string | undefined;\n    age?: number | undefined;\n    outer?: { inner: string } | undefined;\n    array?: { asdf: string }[] | undefined;\n  }>();\n});\n\ntest(\"shallow partial parse\", () => {\n  const shallow = nested.partial();\n  shallow.parse({});\n  shallow.parse({\n    name: \"asdf\",\n    age: 23143,\n  });\n});\n\ntest(\"required\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    nullableField: z.number().nullable(),\n    nullishField: z.string().nullish(),\n  });\n\n  const requiredObject = object.required();\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodNonOptional);\n  expect(requiredObject.shape.name.unwrap()).toBeInstanceOf(z.ZodString);\n  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNonOptional);\n  expect(requiredObject.shape.age.unwrap()).toBeInstanceOf(z.ZodOptional);\n  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodNonOptional);\n  expect(requiredObject.shape.field.unwrap()).toBeInstanceOf(z.ZodDefault);\n  expect(requiredObject.shape.nullableField).toBeInstanceOf(z.ZodNonOptional);\n  expect(requiredObject.shape.nullableField.unwrap()).toBeInstanceOf(z.ZodNullable);\n  expect(requiredObject.shape.nullishField).toBeInstanceOf(z.ZodNonOptional);\n  expect(requiredObject.shape.nullishField.unwrap()).toBeInstanceOf(z.ZodOptional);\n  expect(requiredObject.shape.nullishField.unwrap().unwrap()).toBeInstanceOf(z.ZodNullable);\n});\n\ntest(\"required inference\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    nullableField: z.number().nullable(),\n    nullishField: z.string().nullish(),\n  });\n\n  const requiredObject = object.required();\n\n  type required = z.infer<typeof requiredObject>;\n  type expected = {\n    name: string;\n    age: number;\n    field: string;\n    nullableField: number | null;\n    nullishField: string | null;\n  };\n  expectTypeOf<expected>().toEqualTypeOf<required>();\n});\n\ntest(\"required with mask\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string().optional(),\n  });\n\n  const requiredObject = object.required({ age: true });\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);\n  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNonOptional);\n  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);\n});\n\ntest(\"required with mask -- ignore falsy values\", () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string().optional(),\n  });\n\n  // @ts-expect-error\n  const requiredObject = object.required({ age: true, country: false });\n  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);\n  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNonOptional);\n  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(requiredObject.shape.country).toBeInstanceOf(z.ZodOptional);\n});\n\ntest(\"partial with mask\", async () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string(),\n  });\n\n  const masked = object.partial({ age: true, field: true, name: true }).strict();\n\n  expect(masked.shape.name).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.age).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.field).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.country).toBeInstanceOf(z.ZodString);\n\n  masked.parse({ country: \"US\" });\n  await masked.parseAsync({ country: \"US\" });\n});\n\ntest(\"partial with mask -- ignore falsy values\", async () => {\n  const object = z.object({\n    name: z.string(),\n    age: z.number().optional(),\n    field: z.string().optional().default(\"asdf\"),\n    country: z.string(),\n  });\n\n  // @ts-expect-error\n  const masked = object.partial({ name: true, country: false }).strict();\n\n  expect(masked.shape.name).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.age).toBeInstanceOf(z.ZodOptional);\n  expect(masked.shape.field).toBeInstanceOf(z.ZodDefault);\n  expect(masked.shape.country).toBeInstanceOf(z.ZodString);\n\n  masked.parse({ country: \"US\" });\n  await masked.parseAsync({ country: \"US\" });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/pickomit.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst fish = z.object({\n  name: z.string(),\n  age: z.number(),\n  nested: z.object({}),\n});\n\ntest(\"pick type inference\", () => {\n  const nameonlyFish = fish.pick({ name: true });\n  type nameonlyFish = z.infer<typeof nameonlyFish>;\n  expectTypeOf<nameonlyFish>().toEqualTypeOf<{ name: string }>();\n});\n\ntest(\"pick parse - success\", () => {\n  const nameonlyFish = fish.pick({ name: true });\n  nameonlyFish.parse({ name: \"bob\" });\n\n  // @ts-expect-error checking runtime picks `name` only.\n  const anotherNameonlyFish = fish.pick({ name: true, age: false });\n  anotherNameonlyFish.parse({ name: \"bob\" });\n});\n\ntest(\"pick parse - fail\", () => {\n  fish.pick({ name: true }).parse({ name: \"12\" } as any);\n  fish.pick({ name: true }).parse({ name: \"bob\", age: 12 } as any);\n  fish.pick({ age: true }).parse({ age: 12 } as any);\n\n  const nameonlyFish = fish.pick({ name: true }).strict();\n  const bad1 = () => nameonlyFish.parse({ name: 12 } as any);\n  const bad2 = () => nameonlyFish.parse({ name: \"bob\", age: 12 } as any);\n  const bad3 = () => nameonlyFish.parse({ age: 12 } as any);\n\n  // @ts-expect-error checking runtime picks `name` only.\n  const anotherNameonlyFish = fish.pick({ name: true, age: false }).strict();\n  const bad4 = () => anotherNameonlyFish.parse({ name: \"bob\", age: 12 } as any);\n\n  expect(bad1).toThrow();\n  expect(bad2).toThrow();\n  expect(bad3).toThrow();\n  expect(bad4).toThrow();\n});\n\ntest(\"pick - remove optional\", () => {\n  const schema = z.object({ a: z.string(), b: z.string().optional() });\n  expect(\"a\" in schema._zod.def.shape).toEqual(true);\n  expect(\"b\" in schema._zod.def.shape!).toEqual(true);\n  const picked = schema.pick({ a: true });\n  expect(\"a\" in picked._zod.def.shape).toEqual(true);\n  expect(\"b\" in picked._zod.def.shape!).toEqual(false);\n});\n\ntest(\"omit type inference\", () => {\n  const nonameFish = fish.omit({ name: true });\n  type nonameFish = z.infer<typeof nonameFish>;\n\n  expectTypeOf<nonameFish>().toEqualTypeOf<{ age: number; nested: Record<string, never> }>();\n});\n\ntest(\"omit parse - success\", () => {\n  const nonameFish = fish.omit({ name: true });\n  nonameFish.parse({ age: 12, nested: {} });\n\n  // @ts-expect-error checking runtime omits `name` only.\n  const anotherNonameFish = fish.omit({ name: true, age: false });\n  anotherNonameFish.parse({ age: 12, nested: {} });\n});\n\ntest(\"omit parse - fail\", () => {\n  const nonameFish = fish.omit({ name: true });\n  const bad1 = () => nonameFish.parse({ name: 12 } as any);\n  const bad2 = () => nonameFish.parse({ age: 12 } as any);\n  const bad3 = () => nonameFish.parse({} as any);\n\n  // @ts-expect-error checking runtime omits `name` only.\n  const anotherNonameFish = fish.omit({ name: true, age: false });\n  const bad4 = () => anotherNonameFish.parse({ nested: {} } as any);\n\n  expect(bad1).toThrow();\n  expect(bad2).toThrow();\n  expect(bad3).toThrow();\n  expect(bad4).toThrow();\n});\n\ntest(\"omit - remove optional\", () => {\n  const schema = z.object({ a: z.string(), b: z.string().optional() });\n  expect(\"a\" in schema._zod.def.shape).toEqual(true);\n  const omitted = schema.omit({ a: true });\n  expect(\"a\" in omitted._zod.def.shape).toEqual(false);\n});\n\ntest(\"nonstrict inference\", () => {\n  const laxfish = fish.pick({ name: true }).catchall(z.any());\n  type laxfish = z.infer<typeof laxfish>;\n  expectTypeOf<laxfish>().toEqualTypeOf<{ name: string; [k: string]: any }>();\n});\n\ntest(\"nonstrict parsing - pass\", () => {\n  const laxfish = fish.passthrough().pick({ name: true });\n  laxfish.parse({ name: \"asdf\", whatever: \"asdf\" });\n  laxfish.parse({ name: \"asdf\", age: 12, nested: {} });\n});\n\ntest(\"nonstrict parsing - fail\", () => {\n  const laxfish = fish.passthrough().pick({ name: true });\n  const bad = () => laxfish.parse({ whatever: \"asdf\" } as any);\n  expect(bad).toThrow();\n});\n\ntest(\"pick/omit/required/partial - do not allow unknown keys\", () => {\n  const schema = z.object({\n    name: z.string(),\n    age: z.number(),\n  });\n\n  expect(() => schema.pick({ name: true, asdf: true })).toThrow();\n\n  // @ts-expect-error\n  expect(() => schema.pick({ $unknown: true })).toThrow();\n  // @ts-expect-error\n  expect(() => schema.omit({ $unknown: true })).toThrow();\n  // @ts-expect-error\n  expect(() => schema.required({ $unknown: true })).toThrow();\n  // @ts-expect-error\n  expect(() => schema.partial({ $unknown: true })).toThrow();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/pipe.test.ts",
    "content": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"string to number pipe\", () => {\n  const schema = z.string().transform(Number).pipe(z.number());\n  expect(schema.parse(\"1234\")).toEqual(1234);\n});\n\ntest(\"string to number pipe async\", async () => {\n  const schema = z\n    .string()\n    .transform(async (val) => Number(val))\n    .pipe(z.number());\n  expect(await schema.parseAsync(\"1234\")).toEqual(1234);\n});\n\ntest(\"string with default fallback\", () => {\n  const stringWithDefault = z\n    .pipe(\n      z.transform((v) => (v === \"none\" ? undefined : v)),\n      z.string()\n    )\n    .catch(\"default\");\n\n  expect(stringWithDefault.parse(\"ok\")).toBe(\"ok\");\n  expect(stringWithDefault.parse(undefined)).toBe(\"default\");\n  expect(stringWithDefault.parse(\"none\")).toBe(\"default\");\n  expect(stringWithDefault.parse(15)).toBe(\"default\");\n});\n\ntest(\"continue on non-fatal errors\", () => {\n  const schema = z\n    .string()\n    .refine((c) => c === \"1234\", \"A\")\n    .transform((val) => Number(val))\n    .refine((c) => c === 1234, \"B\");\n\n  schema.parse(\"1234\");\n\n  expect(schema.safeParse(\"4321\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"A\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"B\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"break on fatal errors\", () => {\n  const schema = z\n    .string()\n    .refine((c) => c === \"1234\", { message: \"A\", abort: true })\n    .transform((val) => Number(val))\n    .refine((c) => c === 1234, \"B\");\n\n  schema.parse(\"1234\");\n\n  expect(schema.safeParse(\"4321\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"A\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/prefault.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport { z } from \"zod/v4\";\n\ntest(\"basic prefault\", () => {\n  const a = z.prefault(z.string().trim(), \"  default  \");\n  expect(a).toBeInstanceOf(z.ZodPrefault);\n  expect(a.parse(\"  asdf  \")).toEqual(\"asdf\");\n  expect(a.parse(undefined)).toEqual(\"default\");\n\n  type inp = z.input<typeof a>;\n  expectTypeOf<inp>().toEqualTypeOf<string | undefined>();\n  type out = z.output<typeof a>;\n  expectTypeOf<out>().toEqualTypeOf<string>();\n});\n\ntest(\"prefault inside object\", () => {\n  // test optinality\n  const a = z.object({\n    name: z.string().optional(),\n    age: z.number().default(1234),\n    email: z.string().prefault(\"1234\"),\n  });\n\n  type inp = z.input<typeof a>;\n  expectTypeOf<inp>().toEqualTypeOf<{\n    name?: string | undefined;\n    age?: number | undefined;\n    email?: string | undefined;\n  }>();\n\n  type out = z.output<typeof a>;\n  expectTypeOf<out>().toEqualTypeOf<{\n    name?: string | undefined;\n    age: number;\n    email: string;\n  }>();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/preprocess.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"preprocess\", () => {\n  const schema = z.preprocess((data) => [data], z.string().array());\n  const value = schema.parse(\"asdf\");\n  expect(value).toEqual([\"asdf\"]);\n  expectTypeOf<(typeof schema)[\"_input\"]>().toEqualTypeOf<unknown>();\n});\n\ntest(\"async preprocess\", async () => {\n  const schema = z.preprocess(async (data) => {\n    return [data];\n  }, z.string().array());\n  const value = await schema.safeParseAsync(\"asdf\");\n  expect(value.data).toEqual([\"asdf\"]);\n  expect(value).toMatchInlineSnapshot(`\n    {\n      \"data\": [\n        \"asdf\",\n      ],\n      \"success\": true,\n    }\n  `);\n});\n\ntest(\"ctx.addIssue accepts string\", () => {\n  const schema = z.preprocess((_, ctx) => {\n    ctx.addIssue(\"bad stuff\");\n  }, z.string());\n  const result = schema.safeParse(\"asdf\");\n  expect(result.error!.issues).toHaveLength(1);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"message\": \"bad stuff\",\n        \"code\": \"custom\",\n        \"path\": []\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"preprocess ctx.addIssue with parse\", () => {\n  const a = z.preprocess((data, ctx) => {\n    ctx.addIssue({\n      input: data,\n      code: \"custom\",\n      message: `${data} is not one of our allowed strings`,\n    });\n    return data;\n  }, z.string());\n\n  const result = a.safeParse(\"asdf\");\n\n  // expect(result.error!.toJSON()).toContain(\"not one of our allowed strings\");\n\n  expect(result.error!.issues).toHaveLength(1);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"message\": \"asdf is not one of our allowed strings\",\n        \"path\": []\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"preprocess ctx.addIssue non-fatal by default\", () => {\n  const schema = z.preprocess((data, ctx) => {\n    ctx.addIssue({\n      code: \"custom\",\n      message: `custom error`,\n    });\n    return data;\n  }, z.string());\n  const result = schema.safeParse(1234);\n\n  expect(result.error!.issues).toHaveLength(2);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"message\": \"custom error\",\n        \"path\": []\n      },\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected string, received number\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"preprocess ctx.addIssue fatal true\", () => {\n  const schema = z.preprocess((data, ctx) => {\n    ctx.addIssue({\n      input: data,\n      code: \"custom\",\n      origin: \"custom\",\n      message: `custom error`,\n      fatal: true,\n    });\n    return data;\n  }, z.string());\n\n  const result = schema.safeParse(1234);\n\n  expect(result.error!.issues).toHaveLength(1);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"origin\": \"custom\",\n        \"message\": \"custom error\",\n        \"fatal\": true,\n        \"path\": []\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"async preprocess ctx.addIssue with parseAsync\", async () => {\n  const schema = z.preprocess(async (data, ctx) => {\n    ctx.addIssue({\n      input: data,\n      code: \"custom\",\n      message: `${data} is not one of our allowed strings`,\n    });\n    return data;\n  }, z.string());\n\n  const result = await schema.safeParseAsync(\"asdf\");\n\n  expect(result.error!.issues).toHaveLength(1);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"message\": \"asdf is not one of our allowed strings\",\n        \"path\": []\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"z.NEVER in preprocess\", () => {\n  const foo = z.preprocess((val, ctx) => {\n    if (!val) {\n      ctx.addIssue({ input: val, code: \"custom\", message: \"bad\" });\n      return z.NEVER;\n    }\n    return val;\n  }, z.number());\n\n  type foo = z.infer<typeof foo>;\n  expectTypeOf<foo>().toEqualTypeOf<number>();\n  const result = foo.safeParse(undefined);\n\n  expect(result.error!.issues).toHaveLength(2);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"message\": \"bad\",\n        \"path\": []\n      },\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected number, received object\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"preprocess as the second property of object\", () => {\n  const schema = z.object({\n    nonEmptyStr: z.string().min(1),\n    positiveNum: z.preprocess((v) => Number(v), z.number().positive()),\n  });\n  const result = schema.safeParse({\n    nonEmptyStr: \"\",\n    positiveNum: \"\",\n  });\n\n  expect(result.error!.issues).toHaveLength(2);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"too_small\",\n        \"minimum\": 1,\n        \"inclusive\": true,\n        \"path\": [\n          \"nonEmptyStr\"\n        ],\n        \"message\": \"Too small: expected string to have >=1 characters\"\n      },\n      {\n        \"origin\": \"number\",\n        \"code\": \"too_small\",\n        \"minimum\": 0,\n        \"inclusive\": false,\n        \"path\": [\n          \"positiveNum\"\n        ],\n        \"message\": \"Too small: expected number to be >0\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"preprocess validates with sibling errors\", () => {\n  const schema = z.object({\n    missing: z.string().refine(() => false),\n    preprocess: z.preprocess((data: any) => data?.trim(), z.string().regex(/ asdf/)),\n  });\n\n  const result = schema.safeParse({ preprocess: \" asdf\" });\n\n  expect(result.error!.issues).toHaveLength(2);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"missing\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      },\n      {\n        \"origin\": \"string\",\n        \"code\": \"invalid_format\",\n        \"format\": \"regex\",\n        \"pattern\": \"/ asdf/\",\n        \"path\": [\n          \"preprocess\"\n        ],\n        \"message\": \"Invalid string: must match pattern / asdf/\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"perform transform with non-fatal issues\", () => {\n  const A = z\n    .string()\n    .refine((_) => false)\n    .min(4)\n    .transform((val) => val.length)\n    .pipe(z.number())\n    .refine((_) => false);\n  expect(A.safeParse(\"asdfasdf\").error!.issues).toHaveLength(2);\n  expect(A.safeParse(\"asdfasdf\").error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]]\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/primitive.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst literalStringSchema = z.literal(\"asdf\");\nconst literalNumberSchema = z.literal(12);\nconst literalBooleanSchema = z.literal(true);\nconst literalBigIntSchema = z.literal(BigInt(42));\n\nconst stringSchema = z.string();\nconst numberSchema = z.number();\nconst bigintSchema = z.bigint();\nconst booleanSchema = z.boolean();\nconst dateSchema = z.date();\nconst symbolSchema = z.symbol();\nconst nullSchema = z.null();\nconst undefinedSchema = z.undefined();\nconst stringSchemaOptional = z.string().optional();\nconst stringSchemaNullable = z.string().nullable();\nconst numberSchemaOptional = z.number().optional();\nconst numberSchemaNullable = z.number().nullable();\nconst bigintSchemaOptional = z.bigint().optional();\nconst bigintSchemaNullable = z.bigint().nullable();\nconst booleanSchemaOptional = z.boolean().optional();\nconst booleanSchemaNullable = z.boolean().nullable();\nconst dateSchemaOptional = z.date().optional();\nconst dateSchemaNullable = z.date().nullable();\nconst symbolSchemaOptional = z.symbol().optional();\nconst symbolSchemaNullable = z.symbol().nullable();\n\ntest(\"literal string schema\", () => {\n  expect(literalStringSchema.parse(\"asdf\")).toBe(\"asdf\");\n  expect(() => literalStringSchema.parse(\"not_asdf\")).toThrow();\n  expect(() => literalStringSchema.parse(123)).toThrow();\n  expect(() => literalStringSchema.parse(true)).toThrow();\n  expect(() => literalStringSchema.parse({})).toThrow();\n});\n\ntest(\"literal number schema\", () => {\n  expect(literalNumberSchema.parse(12)).toBe(12);\n  expect(() => literalNumberSchema.parse(13)).toThrow();\n  expect(() => literalNumberSchema.parse(\"foo\")).toThrow();\n  expect(() => literalNumberSchema.parse(true)).toThrow();\n  expect(() => literalNumberSchema.parse({})).toThrow();\n});\n\ntest(\"literal boolean schema\", () => {\n  expect(literalBooleanSchema.parse(true)).toBe(true);\n  expect(() => literalBooleanSchema.parse(false)).toThrow();\n  expect(() => literalBooleanSchema.parse(\"asdf\")).toThrow();\n  expect(() => literalBooleanSchema.parse(123)).toThrow();\n  expect(() => literalBooleanSchema.parse({})).toThrow();\n});\n\ntest(\"literal bigint schema\", () => {\n  expect(literalBigIntSchema.parse(BigInt(42))).toBe(BigInt(42));\n  expect(() => literalBigIntSchema.parse(BigInt(43))).toThrow();\n  expect(() => literalBigIntSchema.parse(\"asdf\")).toThrow();\n  expect(() => literalBigIntSchema.parse(123)).toThrow();\n  expect(() => literalBigIntSchema.parse({})).toThrow();\n});\n\ntest(\"string schema\", () => {\n  stringSchema.parse(\"foo\");\n  expect(() => stringSchema.parse(Math.random())).toThrow();\n  expect(() => stringSchema.parse(true)).toThrow();\n  expect(() => stringSchema.parse(undefined)).toThrow();\n  expect(() => stringSchema.parse(null)).toThrow();\n});\n\ntest(\"number schema\", () => {\n  numberSchema.parse(Math.random());\n  expect(() => numberSchema.parse(\"foo\")).toThrow();\n  expect(() => numberSchema.parse(BigInt(17))).toThrow();\n  expect(() => numberSchema.parse(true)).toThrow();\n  expect(() => numberSchema.parse(undefined)).toThrow();\n  expect(() => numberSchema.parse(null)).toThrow();\n});\n\ntest(\"bigint schema\", () => {\n  bigintSchema.parse(BigInt(17));\n  expect(() => bigintSchema.parse(\"foo\")).toThrow();\n  expect(() => bigintSchema.parse(Math.random())).toThrow();\n  expect(() => bigintSchema.parse(true)).toThrow();\n  expect(() => bigintSchema.parse(undefined)).toThrow();\n  expect(() => bigintSchema.parse(null)).toThrow();\n});\n\ntest(\"boolean schema\", () => {\n  booleanSchema.parse(true);\n  expect(() => booleanSchema.parse(\"foo\")).toThrow();\n  expect(() => booleanSchema.parse(Math.random())).toThrow();\n  expect(() => booleanSchema.parse(undefined)).toThrow();\n  expect(() => booleanSchema.parse(null)).toThrow();\n});\n\ntest(\"date schema\", async () => {\n  dateSchema.parse(new Date());\n  expect(() => dateSchema.parse(\"foo\")).toThrow();\n  expect(() => dateSchema.parse(Math.random())).toThrow();\n  expect(() => dateSchema.parse(true)).toThrow();\n  expect(() => dateSchema.parse(undefined)).toThrow();\n  expect(() => dateSchema.parse(null)).toThrow();\n  expect(await dateSchema.safeParseAsync(new Date(\"invalid\"))).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"date\",\n        \"code\": \"invalid_type\",\n        \"received\": \"Invalid Date\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected date, received Date\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"symbol schema\", () => {\n  symbolSchema.parse(Symbol(\"foo\"));\n  expect(() => symbolSchema.parse(\"foo\")).toThrow();\n  expect(() => symbolSchema.parse(Math.random())).toThrow();\n  expect(() => symbolSchema.parse(true)).toThrow();\n  expect(() => symbolSchema.parse(new Date())).toThrow();\n  expect(() => symbolSchema.parse(undefined)).toThrow();\n  expect(() => symbolSchema.parse(null)).toThrow();\n});\n\ntest(\"undefined schema\", () => {\n  undefinedSchema.parse(undefined);\n  expect(() => undefinedSchema.parse(\"foo\")).toThrow();\n  expect(() => undefinedSchema.parse(Math.random())).toThrow();\n  expect(() => undefinedSchema.parse(true)).toThrow();\n  expect(() => undefinedSchema.parse(null)).toThrow();\n});\n\ntest(\"null schema\", () => {\n  nullSchema.parse(null);\n  expect(() => nullSchema.parse(\"foo\")).toThrow();\n  expect(() => nullSchema.parse(Math.random())).toThrow();\n  expect(() => nullSchema.parse(true)).toThrow();\n  expect(() => nullSchema.parse(undefined)).toThrow();\n});\n\ntest(\"primitive inference\", () => {\n  expectTypeOf<z.TypeOf<typeof literalStringSchema>>().toEqualTypeOf<\"asdf\">();\n  expectTypeOf<z.TypeOf<typeof literalNumberSchema>>().toEqualTypeOf<12>();\n  expectTypeOf<z.TypeOf<typeof literalBooleanSchema>>().toEqualTypeOf<true>();\n  expectTypeOf<z.TypeOf<typeof literalBigIntSchema>>().toEqualTypeOf<bigint>();\n  expectTypeOf<z.TypeOf<typeof stringSchema>>().toEqualTypeOf<string>();\n  expectTypeOf<z.TypeOf<typeof numberSchema>>().toEqualTypeOf<number>();\n  expectTypeOf<z.TypeOf<typeof bigintSchema>>().toEqualTypeOf<bigint>();\n  expectTypeOf<z.TypeOf<typeof booleanSchema>>().toEqualTypeOf<boolean>();\n  expectTypeOf<z.TypeOf<typeof dateSchema>>().toEqualTypeOf<Date>();\n  expectTypeOf<z.TypeOf<typeof symbolSchema>>().toEqualTypeOf<symbol>();\n  expectTypeOf<z.TypeOf<typeof nullSchema>>().toEqualTypeOf<null>();\n  expectTypeOf<z.TypeOf<typeof undefinedSchema>>().toEqualTypeOf<undefined>();\n  expectTypeOf<z.TypeOf<typeof stringSchemaOptional>>().toEqualTypeOf<string | undefined>();\n  expectTypeOf<z.TypeOf<typeof stringSchemaNullable>>().toEqualTypeOf<string | null>();\n  expectTypeOf<z.TypeOf<typeof numberSchemaOptional>>().toEqualTypeOf<number | undefined>();\n  expectTypeOf<z.TypeOf<typeof numberSchemaNullable>>().toEqualTypeOf<number | null>();\n  expectTypeOf<z.TypeOf<typeof bigintSchemaOptional>>().toEqualTypeOf<bigint | undefined>();\n  expectTypeOf<z.TypeOf<typeof bigintSchemaNullable>>().toEqualTypeOf<bigint | null>();\n  expectTypeOf<z.TypeOf<typeof booleanSchemaOptional>>().toEqualTypeOf<boolean | undefined>();\n  expectTypeOf<z.TypeOf<typeof booleanSchemaNullable>>().toEqualTypeOf<boolean | null>();\n  expectTypeOf<z.TypeOf<typeof dateSchemaOptional>>().toEqualTypeOf<Date | undefined>();\n  expectTypeOf<z.TypeOf<typeof dateSchemaNullable>>().toEqualTypeOf<Date | null>();\n  expectTypeOf<z.TypeOf<typeof symbolSchemaOptional>>().toEqualTypeOf<symbol | undefined>();\n  expectTypeOf<z.TypeOf<typeof symbolSchemaNullable>>().toEqualTypeOf<symbol | null>();\n});\n\ntest(\"get literal values\", () => {\n  expect(literalStringSchema.values).toEqual(new Set([\"asdf\"]));\n  expect(literalStringSchema._zod.def.values).toEqual([\"asdf\"]);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/promise.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst promSchema = z.promise(\n  z.object({\n    name: z.string(),\n    age: z.number(),\n  })\n);\n\ntest(\"promise inference\", () => {\n  type promSchemaType = z.infer<typeof promSchema>;\n  expectTypeOf<promSchemaType>().toEqualTypeOf<{ name: string; age: number }>();\n});\n\ntest(\"promise parsing success\", async () => {\n  // expect(() => promSchema.parse(Promise.resolve({ name: \"Bobby\", age: 10 }))).toThrow();\n  const pr = promSchema.parseAsync(Promise.resolve({ name: \"Bobby\", age: 10 }));\n  expect(pr).toBeInstanceOf(Promise);\n  const result = await pr;\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"age\": 10,\n      \"name\": \"Bobby\",\n    }\n  `);\n});\n\ntest(\"promise parsing fail\", async () => {\n  const bad = await promSchema.safeParseAsync(Promise.resolve({ name: \"Bobby\", age: \"10\" }));\n  expect(bad.success).toBe(false);\n  expect(bad.error).toBeInstanceOf(z.ZodError);\n});\n\ntest(\"promise parsing fail 2\", async () => {\n  const result = await promSchema.safeParseAsync(Promise.resolve({ name: \"Bobby\", age: \"10\" }));\n  expect(result.success).toBe(false);\n  expect(result.error).toBeInstanceOf(z.ZodError);\n});\n\ntest(\"promise parsing fail\", () => {\n  const bad = () => promSchema.parse({ then: () => {}, catch: {} });\n  expect(bad).toThrow();\n});\n\ntest(\"sync promise parsing\", () => {\n  expect(() => z.promise(z.string()).parse(Promise.resolve(\"asfd\"))).toThrow();\n});\n\nconst asyncFunction = z.function({\n  input: z.tuple([]),\n  output: promSchema,\n});\n\ntest(\"async function pass\", async () => {\n  const validatedFunction = asyncFunction.implementAsync(async () => {\n    return { name: \"jimmy\", age: 14 };\n  });\n  await expect(validatedFunction()).resolves.toEqual({\n    name: \"jimmy\",\n    age: 14,\n  });\n});\n\ntest(\"async function fail\", async () => {\n  const validatedFunction = asyncFunction.implementAsync(() => {\n    return Promise.resolve(\"asdf\" as any);\n  });\n  await expect(validatedFunction()).rejects.toBeInstanceOf(z.core.$ZodError);\n});\n\ntest(\"async promise parsing\", () => {\n  const res = z.promise(z.number()).parseAsync(Promise.resolve(12));\n  expect(res).toBeInstanceOf(Promise);\n});\n\ntest(\"resolves\", () => {\n  const foo = z.literal(\"foo\");\n  const res = z.promise(foo);\n  expect(res.unwrap()).toEqual(foo);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/prototypes.test.ts",
    "content": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ndeclare module \"zod/v4\" {\n  interface ZodType {\n    /** @deprecated */\n    _classic(): string;\n  }\n}\n\ntest(\"prototype extension\", () => {\n  z.ZodType.prototype._classic = function () {\n    return \"_classic\";\n  };\n\n  // should pass\n  const result = z.string()._classic();\n  expect(result).toBe(\"_classic\");\n  // expectTypeOf<typeof result>().toEqualTypeOf<string>();\n\n  // clean up\n  z.ZodType.prototype._classic = undefined;\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/readonly.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nenum testEnum {\n  A = 0,\n  B = 1,\n}\n\ntest(\"flat inference\", () => {\n  const readonlyString = z.string().readonly();\n  const readonlyNumber = z.number().readonly();\n  const readonlyNaN = z.nan().readonly();\n  const readonlyBigInt = z.bigint().readonly();\n  const readonlyBoolean = z.boolean().readonly();\n  const readonlyDate = z.date().readonly();\n  const readonlyUndefined = z.undefined().readonly();\n  const readonlyNull = z.null().readonly();\n  const readonlyAny = z.any().readonly();\n  const readonlyUnknown = z.unknown().readonly();\n  const readonlyVoid = z.void().readonly();\n  const readonlyStringArray = z.array(z.string()).readonly();\n  const readonlyTuple = z.tuple([z.string(), z.number()]).readonly();\n  const readonlyMap = z.map(z.string(), z.date()).readonly();\n  const readonlySet = z.set(z.string()).readonly();\n  const readonlyStringRecord = z.record(z.string(), z.string()).readonly();\n  const readonlyNumberRecord = z.record(z.string(), z.number()).readonly();\n  const readonlyObject = z.object({ a: z.string(), 1: z.number() }).readonly();\n  const readonlyEnum = z.nativeEnum(testEnum).readonly();\n  const readonlyPromise = z.promise(z.string()).readonly();\n\n  expectTypeOf<typeof readonlyString._output>().toEqualTypeOf<string>();\n  expectTypeOf<typeof readonlyNumber._output>().toEqualTypeOf<number>();\n  expectTypeOf<typeof readonlyNaN._output>().toEqualTypeOf<number>();\n  expectTypeOf<typeof readonlyBigInt._output>().toEqualTypeOf<bigint>();\n  expectTypeOf<typeof readonlyBoolean._output>().toEqualTypeOf<boolean>();\n  expectTypeOf<typeof readonlyDate._output>().toEqualTypeOf<Date>();\n  expectTypeOf<typeof readonlyUndefined._output>().toEqualTypeOf<undefined>();\n  expectTypeOf<typeof readonlyNull._output>().toEqualTypeOf<null>();\n  expectTypeOf<typeof readonlyAny._output>().toEqualTypeOf<any>();\n  expectTypeOf<typeof readonlyUnknown._output>().toEqualTypeOf<Readonly<unknown>>();\n  expectTypeOf<typeof readonlyVoid._output>().toEqualTypeOf<void>();\n  expectTypeOf<typeof readonlyStringArray._output>().toEqualTypeOf<readonly string[]>();\n  expectTypeOf<typeof readonlyTuple._output>().toEqualTypeOf<readonly [string, number]>();\n  expectTypeOf<typeof readonlyMap._output>().toEqualTypeOf<ReadonlyMap<string, Date>>();\n  expectTypeOf<typeof readonlySet._output>().toEqualTypeOf<ReadonlySet<string>>();\n  expectTypeOf<typeof readonlyStringRecord._output>().toEqualTypeOf<Readonly<Record<string, string>>>();\n  expectTypeOf<typeof readonlyNumberRecord._output>().toEqualTypeOf<Readonly<Record<string, number>>>();\n  expectTypeOf<typeof readonlyObject._output>().toEqualTypeOf<{ readonly a: string; readonly 1: number }>();\n  expectTypeOf<typeof readonlyEnum._output>().toEqualTypeOf<Readonly<testEnum>>();\n  expectTypeOf<typeof readonlyPromise._output>().toEqualTypeOf<string>();\n});\n\n// test(\"deep inference\", () => {\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[0]>>().toEqualTypeOf<string>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[1]>>().toEqualTypeOf<number>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[2]>>().toEqualTypeOf<number>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[3]>>().toEqualTypeOf<bigint>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[4]>>().toEqualTypeOf<boolean>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[5]>>().toEqualTypeOf<Date>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[6]>>().toEqualTypeOf<undefined>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[7]>>().toEqualTypeOf<null>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[8]>>().toEqualTypeOf<any>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[9]>\n//   >().toEqualTypeOf<Readonly<unknown>>();\n//   expectTypeOf<z.infer<(typeof deepReadonlySchemas_0)[10]>>().toEqualTypeOf<void>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[11]>\n//   >().toEqualTypeOf<(args_0: string, args_1: number, ...args_2: unknown[]) => unknown>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[12]>\n//   >().toEqualTypeOf<readonly string[]>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[13]>\n//   >().toEqualTypeOf<readonly [string, number]>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[14]>\n//   >().toEqualTypeOf<ReadonlyMap<string, Date>>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[15]>\n//   >().toEqualTypeOf<ReadonlySet<Promise<string>>>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[16]>\n//   >().toEqualTypeOf<Readonly<Record<string, string>>>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[17]>\n//   >().toEqualTypeOf<Readonly<Record<string, number>>>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[18]>\n//   >().toEqualTypeOf<{ readonly a: string; readonly 1: number }>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[19]>\n//   >().toEqualTypeOf<Readonly<testEnum>>();\n//   expectTypeOf<\n//     z.infer<(typeof deepReadonlySchemas_0)[20]>\n//   >().toEqualTypeOf<Promise<string>>();\n\n//   expectTypeOf<\n//     z.infer<typeof crazyDeepReadonlySchema>\n//   >().toEqualTypeOf<ReadonlyMap<\n//     ReadonlySet<readonly [string, number]>,\n//     {\n//       readonly a: {\n//         readonly [x: string]: readonly any[];\n//       };\n//       readonly b: {\n//         readonly c: {\n//           readonly d: {\n//             readonly e: {\n//               readonly f: {\n//                 readonly g?: {};\n//               };\n//             };\n//           };\n//         };\n//       };\n//     }\n//   >>();\n// });\n\ntest(\"object freezing\", async () => {\n  expect(Object.isFrozen(z.array(z.string()).readonly().parse([\"a\"]))).toBe(true);\n  expect(Object.isFrozen(z.tuple([z.string(), z.number()]).readonly().parse([\"a\", 1]))).toBe(true);\n  expect(\n    Object.isFrozen(\n      z\n        .map(z.string(), z.date())\n        .readonly()\n        .parse(new Map([[\"a\", new Date()]]))\n    )\n  ).toBe(true);\n\n  expect(Object.isFrozen(z.record(z.string(), z.string()).readonly().parse({ a: \"b\" }))).toBe(true);\n  expect(Object.isFrozen(z.record(z.string(), z.number()).readonly().parse({ a: 1 }))).toBe(true);\n  expect(Object.isFrozen(z.object({ a: z.string(), 1: z.number() }).readonly().parse({ a: \"b\", 1: 2 }))).toBe(true);\n  expect(\n    Object.isFrozen(\n      await z\n        .set(z.promise(z.string()))\n        .readonly()\n        .parseAsync(new Set([Promise.resolve(\"a\")]))\n    )\n  ).toBe(true);\n  expect(Object.isFrozen(await z.promise(z.string()).readonly().parseAsync(Promise.resolve(\"a\")))).toBe(true);\n});\n\ntest(\"async object freezing\", async () => {\n  expect(Object.isFrozen(await z.array(z.string()).readonly().parseAsync([\"a\"]))).toBe(true);\n  expect(Object.isFrozen(await z.tuple([z.string(), z.number()]).readonly().parseAsync([\"a\", 1]))).toBe(true);\n  expect(\n    Object.isFrozen(\n      await z\n        .map(z.string(), z.date())\n        .readonly()\n        .parseAsync(new Map([[\"a\", new Date()]]))\n    )\n  ).toBe(true);\n  expect(\n    Object.isFrozen(\n      await z\n        .set(z.promise(z.string()))\n        .readonly()\n        .parseAsync(new Set([Promise.resolve(\"a\")]))\n    )\n  ).toBe(true);\n  expect(Object.isFrozen(await z.record(z.string(), z.string()).readonly().parseAsync({ a: \"b\" }))).toBe(true);\n  expect(Object.isFrozen(await z.record(z.string(), z.number()).readonly().parseAsync({ a: 1 }))).toBe(true);\n  expect(\n    Object.isFrozen(await z.object({ a: z.string(), 1: z.number() }).readonly().parseAsync({ a: \"b\", 1: 2 }))\n  ).toBe(true);\n  expect(Object.isFrozen(await z.promise(z.string()).readonly().parseAsync(Promise.resolve(\"a\")))).toBe(true);\n});\n\ntest(\"readonly inference\", () => {\n  const readonlyStringArray = z.string().array().readonly();\n  const readonlyStringTuple = z.tuple([z.string()]).readonly();\n  const deepReadonly = z.object({ a: z.string() }).readonly();\n\n  type readonlyStringArray = z.infer<typeof readonlyStringArray>;\n  type readonlyStringTuple = z.infer<typeof readonlyStringTuple>;\n  type deepReadonly = z.infer<typeof deepReadonly>;\n\n  expectTypeOf<readonlyStringArray>().toEqualTypeOf<readonly string[]>();\n  expectTypeOf<readonlyStringTuple>().toEqualTypeOf<readonly [string]>();\n  expectTypeOf<deepReadonly>().toEqualTypeOf<{ readonly a: string }>();\n});\n\ntest(\"readonly parse\", () => {\n  const schema = z.array(z.string()).readonly();\n  const readonlyArray = [\"a\", \"b\", \"c\"] as const;\n  const mutableArray = [\"a\", \"b\", \"c\"];\n  const result1 = schema.parse(readonlyArray);\n  const result2 = schema.parse(mutableArray);\n  expect(result1).toEqual(readonlyArray);\n  expect(result2).toEqual(mutableArray);\n});\n\ntest(\"readonly parse with tuples\", () => {\n  const schema = z.tuple([z.string(), z.number()]).readonly();\n  schema.parse([\"a\", 1]);\n});\n\ntest(\"readonly and the get method\", () => {\n  const readonlyString = z.string().readonly();\n  const readonlyNumber1 = z.number().readonly();\n  const readonlyNumber2 = z.number().readonly();\n  const readonlyBigInt = z.bigint().readonly();\n  const readonlyBoolean = z.boolean().readonly();\n  const readonlyDate = z.date().readonly();\n  const readonlyUndefined = z.undefined().readonly();\n  const readonlyNull = z.null().readonly();\n  const readonlyAny = z.any().readonly();\n  const readonlyUnknown = z.unknown().readonly();\n  const readonlyVoid = z.void().readonly();\n  // const readonlyFunction = z.function(z.tuple([z.string(), z.number()]), z.unknown()).readonly();\n  const readonlyStringArray = z.string().array().readonly();\n  const readonlyTuple = z.tuple([z.string(), z.number()]).readonly();\n\n  expectTypeOf<z.infer<typeof readonlyString>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof readonlyNumber1>>().toEqualTypeOf<number>();\n  expectTypeOf<z.infer<typeof readonlyNumber2>>().toEqualTypeOf<number>();\n  expectTypeOf<z.infer<typeof readonlyBigInt>>().toEqualTypeOf<bigint>();\n  expectTypeOf<z.infer<typeof readonlyBoolean>>().toEqualTypeOf<boolean>();\n  expectTypeOf<z.infer<typeof readonlyDate>>().toEqualTypeOf<Date>();\n  expectTypeOf<z.infer<typeof readonlyUndefined>>().toEqualTypeOf<undefined>();\n  expectTypeOf<z.infer<typeof readonlyNull>>().toEqualTypeOf<null>();\n  expectTypeOf<z.infer<typeof readonlyAny>>().toEqualTypeOf<any>();\n  expectTypeOf<z.infer<typeof readonlyUnknown>>().toEqualTypeOf<Readonly<unknown>>();\n  expectTypeOf<z.infer<typeof readonlyVoid>>().toEqualTypeOf<void>();\n  // expectTypeOf<z.infer<typeof readonlyFunction>>().toEqualTypeOf<\n  //   (args_0: string, args_1: number, ...args_2: unknown[]) => unknown\n  // >();\n  expectTypeOf<z.infer<typeof readonlyStringArray>>().toEqualTypeOf<readonly string[]>();\n  expectTypeOf<z.infer<typeof readonlyTuple>>().toEqualTypeOf<readonly [string, number]>();\n\n  expect(readonlyString.parse(\"asdf\")).toEqual(\"asdf\");\n  expect(readonlyNumber1.parse(1234)).toEqual(1234);\n  expect(readonlyNumber2.parse(1234)).toEqual(1234);\n  const bigIntVal = BigInt(1);\n  expect(readonlyBigInt.parse(bigIntVal)).toEqual(bigIntVal);\n  expect(readonlyBoolean.parse(true)).toEqual(true);\n  const dateVal = new Date();\n  expect(readonlyDate.parse(dateVal)).toEqual(dateVal);\n  expect(readonlyUndefined.parse(undefined)).toEqual(undefined);\n  expect(readonlyNull.parse(null)).toEqual(null);\n  expect(readonlyAny.parse(\"whatever\")).toEqual(\"whatever\");\n  expect(readonlyUnknown.parse(\"whatever\")).toEqual(\"whatever\");\n  expect(readonlyVoid.parse(undefined)).toEqual(undefined);\n  // expect(readonlyFunction.parse(() => void 0)).toEqual(() => void 0);\n  expect(readonlyStringArray.parse([\"asdf\"])).toEqual([\"asdf\"]);\n  expect(readonlyTuple.parse([\"asdf\", 1234])).toEqual([\"asdf\", 1234]);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/record.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"type inference\", () => {\n  const booleanRecord = z.record(z.string(), z.boolean());\n  type booleanRecord = typeof booleanRecord._output;\n\n  const recordWithEnumKeys = z.record(z.enum([\"Tuna\", \"Salmon\"]), z.string());\n  type recordWithEnumKeys = z.infer<typeof recordWithEnumKeys>;\n\n  const recordWithLiteralKey = z.record(z.literal([\"Tuna\", \"Salmon\"]), z.string());\n  type recordWithLiteralKey = z.infer<typeof recordWithLiteralKey>;\n\n  const recordWithLiteralUnionKeys = z.record(z.union([z.literal(\"Tuna\"), z.literal(\"Salmon\")]), z.string());\n  type recordWithLiteralUnionKeys = z.infer<typeof recordWithLiteralUnionKeys>;\n\n  expectTypeOf<booleanRecord>().toEqualTypeOf<Record<string, boolean>>();\n  expectTypeOf<recordWithEnumKeys>().toEqualTypeOf<Record<\"Tuna\" | \"Salmon\", string>>();\n  expectTypeOf<recordWithLiteralKey>().toEqualTypeOf<Record<\"Tuna\" | \"Salmon\", string>>();\n  expectTypeOf<recordWithLiteralUnionKeys>().toEqualTypeOf<Record<\"Tuna\" | \"Salmon\", string>>();\n});\n\ntest(\"enum exhaustiveness\", () => {\n  const schema = z.record(z.enum([\"Tuna\", \"Salmon\"]), z.string());\n  expect(\n    schema.parse({\n      Tuna: \"asdf\",\n      Salmon: \"asdf\",\n    })\n  ).toEqual({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  expect(schema.safeParse({ Tuna: \"asdf\", Salmon: \"asdf\", Trout: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"unrecognized_keys\",\n        \"keys\": [\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Unrecognized key: \\\\\"Trout\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse({ Tuna: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"Salmon\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"literal exhaustiveness\", () => {\n  const schema = z.record(z.literal([\"Tuna\", \"Salmon\"]), z.string());\n  schema.parse({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  expect(schema.safeParse({ Tuna: \"asdf\", Salmon: \"asdf\", Trout: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"unrecognized_keys\",\n        \"keys\": [\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Unrecognized key: \\\\\"Trout\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse({ Tuna: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"Salmon\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"pipe exhaustiveness\", () => {\n  const schema = z.record(z.enum([\"Tuna\", \"Salmon\"]).pipe(z.any()), z.string());\n  expect(schema.parse({ Tuna: \"asdf\", Salmon: \"asdf\" })).toEqual({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  expect(schema.safeParse({ Tuna: \"asdf\", Salmon: \"asdf\", Trout: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"unrecognized_keys\",\n        \"keys\": [\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Unrecognized key: \\\\\"Trout\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse({ Tuna: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"Salmon\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"union exhaustiveness\", () => {\n  const schema = z.record(z.union([z.literal(\"Tuna\"), z.literal(\"Salmon\")]), z.string());\n  expect(schema.parse({ Tuna: \"asdf\", Salmon: \"asdf\" })).toEqual({\n    Tuna: \"asdf\",\n    Salmon: \"asdf\",\n  });\n\n  expect(schema.safeParse({ Tuna: \"asdf\", Salmon: \"asdf\", Trout: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"unrecognized_keys\",\n        \"keys\": [\n          \"Trout\"\n        ],\n        \"path\": [],\n        \"message\": \"Unrecognized key: \\\\\"Trout\\\\\"\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse({ Tuna: \"asdf\" })).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"Salmon\"\n        ],\n        \"message\": \"Invalid input: expected string, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"string record parse - pass\", () => {\n  const schema = z.record(z.string(), z.boolean());\n  schema.parse({\n    k1: true,\n    k2: false,\n    1234: false,\n  });\n\n  expect(schema.safeParse({ asdf: 1234 }).success).toEqual(false);\n  expect(schema.safeParse(\"asdf\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"record\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected record, received string\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"key and value getters\", () => {\n  const rec = z.record(z.string(), z.number());\n\n  rec.keyType.parse(\"asdf\");\n  rec.valueType.parse(1234);\n});\n\ntest(\"is not vulnerable to prototype pollution\", async () => {\n  const rec = z.record(\n    z.string(),\n    z.object({\n      a: z.string(),\n    })\n  );\n\n  const data = JSON.parse(`\n    {\n      \"__proto__\": {\n        \"a\": \"evil\"\n      },\n      \"b\": {\n        \"a\": \"good\"\n      }\n    }\n  `);\n\n  const obj1 = rec.parse(data);\n  expect(obj1.a).toBeUndefined();\n\n  const obj2 = rec.safeParse(data);\n  expect(obj2.success).toBe(true);\n  if (obj2.success) {\n    expect(obj2.data.a).toBeUndefined();\n  }\n\n  const obj3 = await rec.parseAsync(data);\n  expect(obj3.a).toBeUndefined();\n\n  const obj4 = await rec.safeParseAsync(data);\n  expect(obj4.success).toBe(true);\n  if (obj4.success) {\n    expect(obj4.data.a).toBeUndefined();\n  }\n});\n\ntest(\"dont remove undefined values\", () => {\n  const result1 = z.record(z.string(), z.any()).parse({ foo: undefined });\n\n  expect(result1).toEqual({\n    foo: undefined,\n  });\n});\n\ntest(\"allow undefined values\", () => {\n  const schema = z.record(z.string(), z.undefined());\n\n  expect(\n    Object.keys(\n      schema.parse({\n        _test: undefined,\n      })\n    )\n  ).toEqual([\"_test\"]);\n});\n\ntest(\"async parsing\", async () => {\n  const schema = z\n    .record(\n      z.string(),\n      z\n        .string()\n        .optional()\n        .refine(async () => true)\n    )\n    .refine(async () => true);\n\n  const data = {\n    foo: \"bar\",\n    baz: \"qux\",\n  };\n  const result = await schema.safeParseAsync(data);\n  expect(result.data).toEqual(data);\n});\n\ntest(\"async parsing\", async () => {\n  const schema = z\n    .record(\n      z.string(),\n      z\n        .string()\n        .optional()\n        .refine(async () => false)\n    )\n    .refine(async () => false);\n\n  const data = {\n    foo: \"bar\",\n    baz: \"qux\",\n  };\n  const result = await schema.safeParseAsync(data);\n  expect(result.success).toEqual(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"foo\"\n        ],\n        \"message\": \"Invalid input\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [\n          \"baz\"\n        ],\n        \"message\": \"Invalid input\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]]\n  `);\n});\n\ntest(\"partial record\", () => {\n  const schema = z.partialRecord(z.string(), z.string());\n  type schema = z.infer<typeof schema>;\n  expectTypeOf<schema>().toEqualTypeOf<Partial<Record<string, string>>>();\n\n  const Keys = z.enum([\"id\", \"name\", \"email\"]).or(z.never());\n  const Person = z.partialRecord(Keys, z.string());\n  expectTypeOf<z.infer<typeof Person>>().toEqualTypeOf<Partial<Record<\"id\" | \"name\" | \"email\", string>>>();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/recursive-types.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport { z } from \"zod/v4\";\n\ntest(\"recursion with z.lazy\", () => {\n  const data = {\n    name: \"I\",\n    subcategories: [\n      {\n        name: \"A\",\n        subcategories: [\n          {\n            name: \"1\",\n            subcategories: [\n              {\n                name: \"a\",\n                subcategories: [],\n              },\n            ],\n          },\n        ],\n      },\n    ],\n  };\n\n  const Category = z.object({\n    name: z.string(),\n    get subcategories() {\n      return z.array(Category).optional().nullable();\n    },\n  });\n  type Category = z.infer<typeof Category>;\n  interface _Category {\n    name: string;\n    subcategories?: _Category[] | undefined | null;\n  }\n  expectTypeOf<Category>().toEqualTypeOf<_Category>();\n  Category.parse(data);\n});\n\ntest(\"recursion involving union type\", () => {\n  const data = {\n    value: 1,\n    next: {\n      value: 2,\n      next: {\n        value: 3,\n        next: {\n          value: 4,\n          next: null,\n        },\n      },\n    },\n  };\n\n  const LL = z.object({\n    value: z.number(),\n    get next() {\n      return LL.nullable();\n    },\n  });\n  type LL = z.infer<typeof LL>;\n  type _LL = {\n    value: number;\n    next: _LL | null;\n  };\n  expectTypeOf<LL>().toEqualTypeOf<_LL>();\n\n  LL.parse(data);\n});\n\ntest(\"mutual recursion - native\", () => {\n  const Alazy = z.object({\n    val: z.number(),\n    get b() {\n      return Blazy;\n    },\n  });\n\n  const Blazy = z.object({\n    val: z.number(),\n    get a() {\n      return Alazy.optional();\n    },\n  });\n  const testData = {\n    val: 1,\n    b: {\n      val: 5,\n      a: {\n        val: 3,\n        b: {\n          val: 4,\n          a: {\n            val: 2,\n            b: {\n              val: 1,\n            },\n          },\n        },\n      },\n    },\n  };\n\n  type Alazy = z.infer<typeof Alazy>;\n  type Blazy = z.infer<typeof Blazy>;\n  interface _Alazy {\n    val: number;\n    b: _Blazy;\n  }\n  interface _Blazy {\n    val: number;\n    a?: _Alazy | undefined;\n  }\n  expectTypeOf<Alazy>().toEqualTypeOf<_Alazy>();\n  expectTypeOf<Blazy>().toEqualTypeOf<_Blazy>();\n  Alazy.parse(testData);\n  Blazy.parse(testData.b);\n\n  expect(() => Alazy.parse({ val: \"asdf\" })).toThrow();\n});\n\ntest(\"pick and omit with getter\", () => {\n  const Category = z.strictObject({\n    name: z.string(),\n    get subcategories() {\n      return z.array(Category);\n    },\n  });\n\n  type Category = z.infer<typeof Category>;\n\n  interface _Category {\n    name: string;\n    subcategories: _Category[];\n  }\n  expectTypeOf<Category>().toEqualTypeOf<_Category>();\n\n  const PickedCategory = Category.pick({ name: true });\n  const OmittedCategory = Category.omit({ subcategories: true });\n\n  const picked = { name: \"test\" };\n  const omitted = { name: \"test\" };\n\n  PickedCategory.parse(picked);\n  OmittedCategory.parse(omitted);\n\n  expect(() => PickedCategory.parse({ name: \"test\", subcategories: [] })).toThrow();\n  expect(() => OmittedCategory.parse({ name: \"test\", subcategories: [] })).toThrow();\n});\n\ntest(\"deferred self-recursion\", () => {\n  const Feature = z.object({\n    title: z.string(),\n    get features(): z.ZodOptional<z.ZodArray<typeof Feature>> {\n      return z.optional(z.array(Feature)); //.optional();\n    },\n  });\n  // type Feature = z.infer<typeof Feature>;\n\n  const Output = z.object({\n    id: z.int(), //.nonnegative(),\n    name: z.string(),\n    get features(): z.ZodArray<typeof Feature> {\n      return Feature.array();\n    },\n  });\n  type Output = z.output<typeof Output>;\n\n  type _Feature = {\n    title: string;\n    features?: _Feature[] | undefined;\n  };\n\n  type _Output = {\n    id: number;\n    name: string;\n    features: _Feature[];\n  };\n\n  // expectTypeOf<Feature>().toEqualTypeOf<_Feature>();\n  expectTypeOf<Output>().toEqualTypeOf<_Output>();\n});\n\ntest(\"deferred mutual recursion\", () => {\n  const Slot = z.object({\n    slotCode: z.string(),\n\n    get blocks() {\n      return z.array(Block);\n    },\n  });\n  type Slot = z.infer<typeof Slot>;\n\n  const Block = z.object({\n    blockCode: z.string(),\n    get slots() {\n      return z.array(Slot).optional();\n    },\n  });\n  type Block = z.infer<typeof Block>;\n\n  const Page = z.object({\n    slots: z.array(Slot),\n  });\n  type Page = z.infer<typeof Page>;\n\n  type _Slot = {\n    slotCode: string;\n    blocks: _Block[];\n  };\n  type _Block = {\n    blockCode: string;\n    slots?: _Slot[] | undefined;\n  };\n  type _Page = {\n    slots: _Slot[];\n  };\n  expectTypeOf<Slot>().toEqualTypeOf<_Slot>();\n  expectTypeOf<Block>().toEqualTypeOf<_Block>();\n  expectTypeOf<Page>().toEqualTypeOf<_Page>();\n});\n\ntest(\"mutual recursion with meta\", () => {\n  const A = z\n    .object({\n      name: z.string(),\n      get b() {\n        return B;\n      },\n    })\n    .readonly()\n    .meta({ id: \"A\" })\n    .optional();\n\n  const B = z\n    .object({\n      name: z.string(),\n      get a() {\n        return A;\n      },\n    })\n    .readonly()\n    .meta({ id: \"B\" });\n\n  type A = z.infer<typeof A>;\n  type B = z.infer<typeof B>;\n\n  type _A =\n    | Readonly<{\n        name: string;\n        b: _B;\n      }>\n    | undefined;\n  // | undefined;\n  type _B = Readonly<{\n    name: string;\n    a?: _A;\n  }>;\n  expectTypeOf<A>().toEqualTypeOf<_A>();\n  expectTypeOf<B>().toEqualTypeOf<_B>();\n});\n\ntest(\"recursion compatibility\", () => {\n  // array\n  const A = z.object({\n    get array() {\n      return A.array();\n    },\n    get optional() {\n      return A.optional();\n    },\n    get nullable() {\n      return A.nullable();\n    },\n    get nonoptional() {\n      return A.nonoptional();\n    },\n    get readonly() {\n      return A.readonly();\n    },\n    get describe() {\n      return A.describe(\"A recursive type\");\n    },\n    get meta() {\n      return A.meta({ description: \"A recursive type\" });\n    },\n    get pipe() {\n      return A.pipe(z.any());\n    },\n    get strict() {\n      return A.strict();\n    },\n    get tuple() {\n      return z.tuple([A, A]);\n    },\n    get object() {\n      return z\n        .object({\n          subcategories: A,\n        })\n        .strict()\n        .loose();\n    },\n    get union() {\n      return z.union([A, A]);\n    },\n    get intersection() {\n      return z.intersection(A, A);\n    },\n    get record() {\n      return z.record(z.string(), A);\n    },\n    get map() {\n      return z.map(z.string(), A);\n    },\n    get set() {\n      return z.set(A);\n    },\n    get lazy() {\n      return z.lazy(() => A);\n    },\n    get promise() {\n      return z.promise(A);\n    },\n  });\n});\n\n// biome-ignore lint: sadf\nexport type RecursiveA = z.ZodUnion<\n  [\n    z.ZodObject<{\n      a: z.ZodDefault<RecursiveA>;\n      b: z.ZodPrefault<RecursiveA>;\n      c: z.ZodNonOptional<RecursiveA>;\n      d: z.ZodOptional<RecursiveA>;\n      e: z.ZodNullable<RecursiveA>;\n      g: z.ZodReadonly<RecursiveA>;\n      h: z.ZodPipe<RecursiveA, z.ZodString>;\n      i: z.ZodArray<RecursiveA>;\n      j: z.ZodSet<RecursiveA>;\n      k: z.ZodMap<RecursiveA, RecursiveA>;\n      l: z.ZodRecord<z.ZodString, RecursiveA>;\n      m: z.ZodUnion<[RecursiveA, RecursiveA]>;\n      n: z.ZodIntersection<RecursiveA, RecursiveA>;\n      o: z.ZodLazy<RecursiveA>;\n      p: z.ZodPromise<RecursiveA>;\n      q: z.ZodCatch<RecursiveA>;\n      r: z.ZodSuccess<RecursiveA>;\n      s: z.ZodTransform<RecursiveA, string>;\n      t: z.ZodTuple<[RecursiveA, RecursiveA]>;\n      u: z.ZodObject<{\n        a: RecursiveA;\n      }>;\n    }>,\n  ]\n>;\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/refine.test.ts",
    "content": "import { describe, expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ndescribe(\"basic refinement functionality\", () => {\n  test(\"should create a new schema instance when refining\", () => {\n    const obj1 = z.object({\n      first: z.string(),\n      second: z.string(),\n    });\n    const obj2 = obj1.partial().strict();\n    const obj3 = obj2.refine((data) => data.first || data.second, \"Either first or second should be filled in.\");\n\n    expect(obj1 === (obj2 as any)).toEqual(false);\n    expect(obj2 === (obj3 as any)).toEqual(false);\n  });\n\n  test(\"should validate according to refinement logic\", () => {\n    const schema = z\n      .object({\n        first: z.string(),\n        second: z.string(),\n      })\n      .partial()\n      .strict()\n      .refine((data) => data.first || data.second, \"Either first or second should be filled in.\");\n\n    // Should fail on empty object\n    expect(() => schema.parse({})).toThrow();\n\n    // Should pass with first property\n    expect(schema.parse({ first: \"a\" })).toEqual({ first: \"a\" });\n\n    // Should pass with second property\n    expect(schema.parse({ second: \"a\" })).toEqual({ second: \"a\" });\n\n    // Should pass with both properties\n    expect(schema.parse({ first: \"a\", second: \"a\" })).toEqual({ first: \"a\", second: \"a\" });\n  });\n\n  test(\"should validate strict mode correctly\", () => {\n    const schema = z\n      .object({\n        first: z.string(),\n        second: z.string(),\n      })\n      .partial()\n      .strict();\n\n    // Should throw on extra properties\n    expect(() => schema.parse({ third: \"adsf\" })).toThrow();\n  });\n});\n\ndescribe(\"refinement with custom error messages\", () => {\n  test(\"should use custom error message when validation fails\", () => {\n    const validationSchema = z\n      .object({\n        email: z.string().email(),\n        password: z.string(),\n        confirmPassword: z.string(),\n      })\n      .refine((data) => data.password === data.confirmPassword, \"Both password and confirmation must match\");\n\n    const result = validationSchema.safeParse({\n      email: \"aaaa@gmail.com\",\n      password: \"aaaaaaaa\",\n      confirmPassword: \"bbbbbbbb\",\n    });\n\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues[0].message).toEqual(\"Both password and confirmation must match\");\n    }\n  });\n});\n\ndescribe(\"async refinements\", () => {\n  test(\"should support async refinement functions\", async () => {\n    const validationSchema = z\n      .object({\n        email: z.string().email(),\n        password: z.string(),\n        confirmPassword: z.string(),\n      })\n      .refine(\n        (data) => Promise.resolve().then(() => data.password === data.confirmPassword),\n        \"Both password and confirmation must match\"\n      );\n\n    // Should pass with matching passwords\n    const validData = {\n      email: \"aaaa@gmail.com\",\n      password: \"password\",\n      confirmPassword: \"password\",\n    };\n\n    await expect(validationSchema.parseAsync(validData)).resolves.toEqual(validData);\n\n    // Should fail with non-matching passwords\n    await expect(\n      validationSchema.parseAsync({\n        email: \"aaaa@gmail.com\",\n        password: \"password\",\n        confirmPassword: \"different\",\n      })\n    ).rejects.toThrow();\n  });\n});\n\ndescribe(\"early termination options\", () => {\n  test(\"should abort early with continue: false\", () => {\n    const schema = z\n      .string()\n      .superRefine((val, ctx) => {\n        if (val.length < 2) {\n          ctx.addIssue({\n            code: \"custom\",\n            message: \"BAD\",\n            continue: false,\n          });\n        }\n      })\n      .refine((_) => false);\n\n    const result = schema.safeParse(\"\");\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues.length).toEqual(1);\n      expect(result.error.issues[0].message).toEqual(\"BAD\");\n    }\n  });\n\n  test(\"should abort early with fatal: true\", () => {\n    const schema = z\n      .string()\n      .superRefine((val, ctx) => {\n        if (val.length < 2) {\n          ctx.addIssue({\n            code: \"custom\",\n            fatal: true,\n            message: \"BAD\",\n          });\n        }\n      })\n      .refine((_) => false);\n\n    const result = schema.safeParse(\"\");\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues.length).toEqual(1);\n      expect(result.error.issues[0].message).toEqual(\"BAD\");\n    }\n  });\n\n  test(\"should abort early with abort flag\", () => {\n    const schema = z\n      .string()\n      .refine((_) => false, { abort: true })\n      .refine((_) => false);\n\n    const result = schema.safeParse(\"\");\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues.length).toEqual(1);\n    }\n  });\n});\n\ndescribe(\"custom error paths\", () => {\n  test(\"should use custom path in error message\", async () => {\n    const result = await z\n      .object({ password: z.string(), confirm: z.string() })\n      .refine((data) => data.confirm === data.password, { path: [\"confirm\"] })\n      .safeParse({ password: \"asdf\", confirm: \"qewr\" });\n\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues[0].path).toEqual([\"confirm\"]);\n    }\n  });\n});\n\ndescribe(\"superRefine functionality\", () => {\n  test(\"should support multiple validation rules\", () => {\n    const Strings = z.array(z.string()).superRefine((val, ctx) => {\n      if (val.length > 3) {\n        ctx.addIssue({\n          input: val,\n          code: \"too_big\",\n          origin: \"array\",\n          maximum: 3,\n          inclusive: true,\n          exact: true,\n          message: \"Too many items 😡\",\n        });\n      }\n\n      if (val.length !== new Set(val).size) {\n        ctx.addIssue({\n          input: val,\n          code: \"custom\",\n          message: `No duplicates allowed.`,\n        });\n      }\n    });\n\n    // Should fail with too many items and duplicates\n    const result = Strings.safeParse([\"asfd\", \"asfd\", \"asfd\", \"asfd\"]);\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues.length).toEqual(2);\n      expect(result.error.issues[0].message).toEqual(\"Too many items 😡\");\n      expect(result.error.issues[1].message).toEqual(\"No duplicates allowed.\");\n    }\n\n    // Should pass with valid input\n    const validArray = [\"asfd\", \"qwer\"];\n    expect(Strings.parse(validArray)).toEqual(validArray);\n  });\n\n  test(\"should support async superRefine\", async () => {\n    const Strings = z.array(z.string()).superRefine(async (val, ctx) => {\n      if (val.length > 3) {\n        ctx.addIssue({\n          input: val,\n          code: \"too_big\",\n          origin: \"array\",\n          maximum: 3,\n          inclusive: true,\n          message: \"Too many items 😡\",\n        });\n      }\n\n      if (val.length !== new Set(val).size) {\n        ctx.addIssue({\n          input: val,\n          code: \"custom\",\n          message: `No duplicates allowed.`,\n        });\n      }\n    });\n\n    // Should fail with too many items and duplicates\n    const result = await Strings.safeParseAsync([\"asfd\", \"asfd\", \"asfd\", \"asfd\"]);\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues.length).toEqual(2);\n    }\n\n    // Should pass with valid input\n    const validArray = [\"asfd\", \"qwer\"];\n    await expect(Strings.parseAsync(validArray)).resolves.toEqual(validArray);\n  });\n\n  test(\"should accept string as shorthand for custom error message\", () => {\n    const schema = z.string().superRefine((_, ctx) => {\n      ctx.addIssue(\"bad stuff\");\n    });\n\n    const result = schema.safeParse(\"asdf\");\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues).toHaveLength(1);\n      expect(result.error.issues[0].message).toEqual(\"bad stuff\");\n    }\n  });\n\n  test(\"should respect fatal flag in superRefine\", () => {\n    const schema = z\n      .string()\n      .superRefine((val, ctx) => {\n        if (val === \"\") {\n          ctx.addIssue({\n            input: val,\n            code: \"custom\",\n            message: \"foo\",\n            fatal: true,\n          });\n        }\n      })\n      .superRefine((val, ctx) => {\n        if (val !== \" \") {\n          ctx.addIssue({\n            input: val,\n            code: \"custom\",\n            message: \"bar\",\n          });\n        }\n      });\n\n    const result = schema.safeParse(\"\");\n    expect(result.success).toEqual(false);\n    if (!result.success) {\n      expect(result.error.issues.length).toEqual(1);\n      expect(result.error.issues[0].message).toEqual(\"foo\");\n    }\n  });\n});\n\ndescribe(\"chained refinements\", () => {\n  test(\"should collect all validation errors when appropriate\", () => {\n    const objectSchema = z\n      .object({\n        length: z.number(),\n        size: z.number(),\n      })\n      .refine(({ length }) => length > 5, {\n        path: [\"length\"],\n        message: \"length greater than 5\",\n      })\n      .refine(({ size }) => size > 7, {\n        path: [\"size\"],\n        message: \"size greater than 7\",\n      });\n\n    // Should fail with one error\n    const r1 = objectSchema.safeParse({\n      length: 4,\n      size: 9,\n    });\n    expect(r1.success).toEqual(false);\n    if (!r1.success) {\n      expect(r1.error.issues.length).toEqual(1);\n      expect(r1.error.issues[0].path).toEqual([\"length\"]);\n    }\n\n    // Should fail with two errors\n    const r2 = objectSchema.safeParse({\n      length: 4,\n      size: 3,\n    });\n    expect(r2.success).toEqual(false);\n    if (!r2.success) {\n      expect(r2.error.issues.length).toEqual(2);\n    }\n\n    // Should pass with valid input\n    const validData = {\n      length: 6,\n      size: 8,\n    };\n    expect(objectSchema.parse(validData)).toEqual(validData);\n  });\n});\n\n// Commented tests can be uncommented once type-checking issues are resolved\n/*\ndescribe(\"type refinement\", () => {\n  test(\"refinement type guard\", () => {\n    const validationSchema = z.object({\n      a: z.string().refine((s): s is \"a\" => s === \"a\"),\n    });\n    type Input = z.input<typeof validationSchema>;\n    type Schema = z.infer<typeof validationSchema>;\n\n    expectTypeOf<Input[\"a\"]>().not.toEqualTypeOf<\"a\">();\n    expectTypeOf<Input[\"a\"]>().toEqualTypeOf<string>();\n\n    expectTypeOf<Schema[\"a\"]>().toEqualTypeOf<\"a\">();\n    expectTypeOf<Schema[\"a\"]>().not.toEqualTypeOf<string>();\n  });\n\n  test(\"superRefine - type narrowing\", () => {\n    type NarrowType = { type: string; age: number };\n    const schema = z\n      .object({\n        type: z.string(),\n        age: z.number(),\n      })\n      .nullable()\n      .superRefine((arg, ctx): arg is NarrowType => {\n        if (!arg) {\n          // still need to make a call to ctx.addIssue\n          ctx.addIssue({\n            input: arg,\n            code: \"custom\",\n            message: \"cannot be null\",\n            fatal: true,\n          });\n          return false;\n        }\n        return true;\n      });\n\n    expectTypeOf<z.infer<typeof schema>>().toEqualTypeOf<NarrowType>();\n\n    expect(schema.safeParse({ type: \"test\", age: 0 }).success).toEqual(true);\n    expect(schema.safeParse(null).success).toEqual(false);\n  });\n\n  test(\"chained mixed refining types\", () => {\n    type firstRefinement = { first: string; second: number; third: true };\n    type secondRefinement = { first: \"bob\"; second: number; third: true };\n    type thirdRefinement = { first: \"bob\"; second: 33; third: true };\n    const schema = z\n      .object({\n        first: z.string(),\n        second: z.number(),\n        third: z.boolean(),\n      })\n      .nullable()\n      .refine((arg): arg is firstRefinement => !!arg?.third)\n      .superRefine((arg, ctx): arg is secondRefinement => {\n        expectTypeOf<typeof arg>().toEqualTypeOf<firstRefinement>();\n        if (arg.first !== \"bob\") {\n          ctx.addIssue({\n            input: arg,\n            code: \"custom\",\n            message: \"`first` property must be `bob`\",\n          });\n          return false;\n        }\n        return true;\n      })\n      .refine((arg): arg is thirdRefinement => {\n        expectTypeOf<typeof arg>().toEqualTypeOf<secondRefinement>();\n        return arg.second === 33;\n      });\n\n    expectTypeOf<z.infer<typeof schema>>().toEqualTypeOf<thirdRefinement>();\n  });\n});\n*/\n\ntest(\"when\", () => {\n  const schema = z\n    .strictObject({\n      password: z.string().min(8),\n      confirmPassword: z.string(),\n      other: z.string(),\n    })\n    .refine(\n      (data) => {\n        console.log(\"running check...\");\n        console.log(data);\n        console.log(data.password);\n        return data.password === data.confirmPassword;\n      },\n      {\n        message: \"Passwords do not match\",\n        path: [\"confirmPassword\"],\n        when(payload) {\n          if (payload.value === undefined) return false;\n          if (payload.value === null) return false;\n          // no issues with confirmPassword or password\n          return payload.issues.every((iss) => iss.path?.[0] !== \"confirmPassword\" && iss.path?.[0] !== \"password\");\n        },\n      }\n    );\n\n  expect(schema.safeParse(undefined)).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"object\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected object, received undefined\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(schema.safeParse(null)).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"expected\": \"object\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected object, received null\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(\n    schema.safeParse({\n      password: \"asdf\",\n      confirmPassword: \"asdfg\",\n      other: \"qwer\",\n    })\n  ).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"too_small\",\n        \"minimum\": 8,\n        \"inclusive\": true,\n        \"path\": [\n          \"password\"\n        ],\n        \"message\": \"Too small: expected string to have >=8 characters\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n\n  expect(\n    schema.safeParse({\n      password: \"asdf\",\n      confirmPassword: \"asdfg\",\n      other: 1234,\n    })\n  ).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"too_small\",\n        \"minimum\": 8,\n        \"inclusive\": true,\n        \"path\": [\n          \"password\"\n        ],\n        \"message\": \"Too small: expected string to have >=8 characters\"\n      },\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          \"other\"\n        ],\n        \"message\": \"Invalid input: expected string, received number\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/registries.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"globalRegistry\", () => {\n  const reg = z.registry();\n\n  const a = z.string();\n  reg.add(a);\n  expect(reg.has(a)).toEqual(true);\n\n  reg.remove(a);\n  expect(reg.has(a)).toEqual(false);\n\n  a.register(z.globalRegistry, { field: \"sup\" });\n  expect(z.globalRegistry.has(a)).toEqual(true);\n  expect(z.globalRegistry.get(a)).toEqual({ field: \"sup\" });\n\n  z.globalRegistry.remove(a);\n  expect(z.globalRegistry.has(a)).toEqual(false);\n});\n\ntest(\"z.registry\", () => {\n  const fieldRegistry = z.registry<{ name: string; description: string }>();\n\n  const a = z.string();\n  fieldRegistry.add(a, { name: \"hello\", description: \"world\" });\n  const a_meta = fieldRegistry.get(a);\n  expect(a_meta).toEqual({ name: \"hello\", description: \"world\" });\n\n  fieldRegistry.remove(a);\n  expect(fieldRegistry.has(a)).toEqual(false);\n  expect(fieldRegistry.get(a)).toEqual(undefined);\n});\n\ntest(\"z.registry no metadata\", () => {\n  const fieldRegistry = z.registry();\n\n  const a = z.string();\n  fieldRegistry.add(a);\n  fieldRegistry.add(z.number());\n  expect(fieldRegistry.get(a)).toEqual(undefined);\n  expect(fieldRegistry.has(a)).toEqual(true);\n});\n\ntest(\"z.registry with schema constraints\", () => {\n  const fieldRegistry = z.registry<{ name: string; description: string }, z.ZodString>();\n\n  const a = z.string();\n  fieldRegistry.add(a, { name: \"hello\", description: \"world\" });\n  // @ts-expect-error\n  fieldRegistry.add(z.number(), { name: \"test\" });\n  // @ts-expect-error\n  z.number().register(fieldRegistry, { name: \"test\", description: \"test\" });\n});\n\n// test(\"z.namedRegistry\", () => {\n//   const namedReg = z\n//     .namedRegistry<{ name: string; description: string }>()\n//     .add(z.string(), { name: \"hello\", description: \"world\" })\n//     .add(z.number(), { name: \"number\", description: \"number\" });\n\n//   expect(namedReg.get(\"hello\")).toEqual({\n//     name: \"hello\",\n//     description: \"world\",\n//   });\n//   expect(namedReg.has(\"hello\")).toEqual(true);\n//   expect(namedReg.get(\"number\")).toEqual({\n//     name: \"number\",\n//     description: \"number\",\n//   });\n\n//   // @ts-expect-error\n//   namedReg.get(\"world\");\n//   // @ts-expect-error\n//   expect(namedReg.get(\"world\")).toEqual(undefined);\n\n//   const hello = namedReg.get(\"hello\");\n//   expect(hello).toEqual({ name: \"hello\", description: \"world\" });\n//   expectTypeOf<typeof hello>().toEqualTypeOf<{\n//     name: \"hello\";\n//     description: \"world\";\n//   }>();\n//   expectTypeOf<typeof namedReg.items>().toEqualTypeOf<{\n//     hello: { name: \"hello\"; description: \"world\" };\n//     number: { name: \"number\"; description: \"number\" };\n//   }>();\n// });\n\ntest(\"output type in registry meta\", () => {\n  const reg = z.registry<{ out: z.$output }>();\n  const a = z.string();\n  reg.add(a, { out: \"asdf\" });\n  // @ts-expect-error\n  reg.add(a, 1234);\n  expectTypeOf(reg.get(a)).toEqualTypeOf<{ out: string } | undefined>();\n});\n\ntest(\"output type in registry meta - objects and arrays\", () => {\n  const reg = z.registry<{ name: string; examples: z.$output[] }>();\n  const a = z.string();\n  reg.add(a, { name: \"hello\", examples: [\"world\"] });\n\n  // @ts-expect-error\n  reg.add(a, { name: \"hello\", examples: \"world\" });\n  expectTypeOf(reg.get(a)).toEqualTypeOf<{ name: string; examples: string[] } | undefined>();\n});\n\ntest(\"input type in registry meta\", () => {\n  const reg = z.registry<{ in: z.$input }>();\n  const a = z.pipe(z.number(), z.transform(String));\n  reg.add(a, { in: 1234 });\n  // @ts-expect-error\n  reg.add(a, \"1234\");\n  expectTypeOf(reg.get(a)).toEqualTypeOf<{ in: number } | undefined>();\n});\n\ntest(\"input type in registry meta - objects and arrays\", () => {\n  const reg = z.registry<{ name: string; examples: z.$input[] }>();\n  const a = z.pipe(z.number(), z.transform(String));\n  reg.add(a, { name: \"hello\", examples: [1234] });\n\n  // @ts-expect-error\n  reg.add(a, { name: \"hello\", examples: \"world\" });\n  expectTypeOf(reg.get(a)).toEqualTypeOf<{ name: string; examples: number[] } | undefined>();\n});\n\ntest(\".meta method\", () => {\n  const a1 = z.string();\n  const a2 = a1.meta({ name: \"hello\" });\n\n  expect(a1.meta()).toEqual(undefined);\n  expect(a2.meta()).toEqual({ name: \"hello\" });\n  expect(a1 === a2).toEqual(false);\n});\n\ntest(\".meta metadata does not bubble up\", () => {\n  const a1 = z.string().meta({ name: \"hello\" });\n  const a2 = a1.optional();\n\n  expect(a1.meta()).toEqual({ name: \"hello\" });\n  expect(a2.meta()).toEqual(undefined);\n});\n\ntest(\".describe\", () => {\n  const a1 = z.string();\n  const a2 = a1.describe(\"Hello\");\n\n  expect(a1.description).toEqual(undefined);\n  expect(a2.description).toEqual(\"Hello\");\n});\n\ntest(\"inherit across clone\", () => {\n  const A = z.string().meta({ a: true });\n  expect(A.meta()).toEqual({ a: true });\n  const B = A.meta({ b: true });\n  expect(B.meta()).toEqual({ a: true, b: true });\n  const C = B.describe(\"hello\");\n  expect(C.meta()).toEqual({ a: true, b: true, description: \"hello\" });\n});\n\ntest(\"loose examples\", () => {\n  z.string().register(z.globalRegistry, {\n    examples: [\"example\"],\n  });\n});\n\ntest(\"function meta witout replacement\", () => {\n  const myReg = z.registry<{\n    defaulter: (arg: string, test: boolean) => number;\n  }>();\n\n  const mySchema = z.date();\n  myReg.add(mySchema, {\n    defaulter: (arg, _test) => {\n      return arg.length;\n    },\n  });\n\n  expect(myReg.get(mySchema)!.defaulter(\"hello\", true)).toEqual(5);\n});\n\ntest(\"function meta with replacement\", () => {\n  const myReg = z.registry<{\n    defaulter: (arg: z.$input, test: boolean) => z.$output;\n  }>();\n\n  const mySchema = z.string().transform((val) => val.length);\n  myReg.add(mySchema, {\n    defaulter: (arg, _test) => {\n      return arg.length;\n    },\n  });\n\n  expect(myReg.get(mySchema)!.defaulter(\"hello\", true)).toEqual(5);\n});\n\ntest(\"test .clear()\", () => {\n  const reg = z.registry();\n  const a = z.string();\n  reg.add(a);\n  expect(reg.has(a)).toEqual(true);\n  reg.clear();\n  expect(reg.has(a)).toEqual(false);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/set.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst stringSet = z.set(z.string());\ntype stringSet = z.infer<typeof stringSet>;\n\nconst minTwo = z.set(z.string()).min(2);\nconst maxTwo = z.set(z.string()).max(2);\nconst justTwo = z.set(z.string()).size(2);\nconst nonEmpty = z.set(z.string()).nonempty();\nconst nonEmptyMax = z.set(z.string()).nonempty().max(2);\n\ntest(\"type inference\", () => {\n  expectTypeOf<stringSet>().toEqualTypeOf<Set<string>>();\n});\n\ntest(\"valid parse\", () => {\n  const result = stringSet.safeParse(new Set([\"first\", \"second\"]));\n  expect(result.success).toEqual(true);\n  expect(result.data!.has(\"first\")).toEqual(true);\n  expect(result.data!.has(\"second\")).toEqual(true);\n  expect(result.data!.has(\"third\")).toEqual(false);\n\n  expect(() => {\n    minTwo.parse(new Set([\"a\", \"b\"]));\n    minTwo.parse(new Set([\"a\", \"b\", \"c\"]));\n    maxTwo.parse(new Set([\"a\", \"b\"]));\n    maxTwo.parse(new Set([\"a\"]));\n    justTwo.parse(new Set([\"a\", \"b\"]));\n    nonEmpty.parse(new Set([\"a\"]));\n    nonEmptyMax.parse(new Set([\"a\"]));\n  }).not.toThrow();\n});\n\ntest(\"valid parse async\", async () => {\n  const result = await stringSet.spa(new Set([\"first\", \"second\"]));\n  expect(result.success).toEqual(true);\n  expect(result.data!.has(\"first\")).toEqual(true);\n  expect(result.data!.has(\"second\")).toEqual(true);\n  expect(result.data!.has(\"third\")).toEqual(false);\n\n  const asyncResult = await stringSet.safeParse(new Set([\"first\", \"second\"]));\n  expect(asyncResult.success).toEqual(true);\n  expect(asyncResult.data!.has(\"first\")).toEqual(true);\n  expect(asyncResult.data!.has(\"second\")).toEqual(true);\n  expect(asyncResult.data!.has(\"third\")).toEqual(false);\n});\n\ntest(\"valid parse: size-related methods\", () => {\n  expect(() => {\n    minTwo.parse(new Set([\"a\", \"b\"]));\n    minTwo.parse(new Set([\"a\", \"b\", \"c\"]));\n    maxTwo.parse(new Set([\"a\", \"b\"]));\n    maxTwo.parse(new Set([\"a\"]));\n    justTwo.parse(new Set([\"a\", \"b\"]));\n    nonEmpty.parse(new Set([\"a\"]));\n    nonEmptyMax.parse(new Set([\"a\"]));\n  }).not.toThrow();\n\n  const sizeZeroResult = stringSet.parse(new Set());\n  expect(sizeZeroResult.size).toBe(0);\n\n  const sizeTwoResult = minTwo.parse(new Set([\"a\", \"b\"]));\n  expect(sizeTwoResult.size).toBe(2);\n});\n\ntest(\"failing when parsing empty set in nonempty \", () => {\n  const result = nonEmpty.safeParse(new Set());\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error!.issues[0].code).toEqual(\"too_small\");\n});\n\ntest(\"failing when set is smaller than min() \", () => {\n  const result = minTwo.safeParse(new Set([\"just_one\"]));\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error!.issues[0].code).toEqual(\"too_small\");\n});\n\ntest(\"failing when set is bigger than max() \", () => {\n  const result = maxTwo.safeParse(new Set([\"one\", \"two\", \"three\"]));\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error!.issues[0].code).toEqual(\"too_big\");\n});\n\ntest(\"doesn’t throw when an empty set is given\", () => {\n  const result = stringSet.safeParse(new Set([]));\n  expect(result.success).toEqual(true);\n});\n\ntest(\"throws when a Map is given\", () => {\n  const result = stringSet.safeParse(new Map([]));\n  expect(result.success).toEqual(false);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"set\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected set, received Map\"\n      }\n    ]]\n  `);\n});\n\ntest(\"throws when the given set has invalid input\", () => {\n  const result = stringSet.safeParse(new Set([Symbol()]));\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected string, received symbol\"\n      }\n    ]]\n  `);\n});\n\ntest(\"throws when the given set has multiple invalid entries\", () => {\n  const result = stringSet.safeParse(new Set([1, 2] as any[]));\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(2);\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected string, received number\"\n      },\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected string, received number\"\n      }\n    ]]\n  `);\n});\n\ntest(\"min/max\", async () => {\n  const schema = z.set(z.string()).min(4).max(5);\n\n  const r1 = schema.safeParse(new Set([\"a\", \"b\", \"c\", \"d\"]));\n  expect(r1.success).toEqual(true);\n\n  const r2 = schema.safeParse(new Set([\"a\", \"b\", \"c\"]));\n  expect(r2.success).toEqual(false);\n  expect(r2.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"too_small\",\n        \"message\": \"Too small: expected set to have >4 items\",\n        \"minimum\": 4,\n        \"origin\": \"set\",\n        \"path\": [],\n      },\n    ]\n  `);\n\n  const r3 = schema.safeParse(new Set([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]));\n  expect(r3.success).toEqual(false);\n  expect(r3.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"too_big\",\n        \"maximum\": 5,\n        \"message\": \"Too big: expected set to have <5 items\",\n        \"origin\": \"set\",\n        \"path\": [],\n      },\n    ]\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/standard-schema.test.ts",
    "content": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"length checks\", async () => {\n  const schema = z.string();\n  const result = await schema[\"~standard\"].validate(12);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"issues\": [\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"string\",\n          \"message\": \"Invalid input: expected string, received number\",\n          \"path\": [],\n        },\n      ],\n    }\n  `);\n});\n\ntest(\"length checks\", async () => {\n  const schema = z.string();\n  const result = await schema[\"~standard\"].validate(\"asdf\");\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"value\": \"asdf\",\n    }\n  `);\n});\n\ntest(\"length checks\", async () => {\n  const schema = z.string().refine(async (val) => val.length > 5);\n  const result = await schema[\"~standard\"].validate(12);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"issues\": [\n        {\n          \"code\": \"invalid_type\",\n          \"expected\": \"string\",\n          \"message\": \"Invalid input: expected string, received number\",\n          \"path\": [],\n        },\n      ],\n    }\n  `);\n});\n\ntest(\"length checks\", async () => {\n  const schema = z.string().refine(async (val) => val.length > 5);\n  const result = await schema[\"~standard\"].validate(\"234134134\");\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"value\": \"234134134\",\n    }\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/string-formats.test.ts",
    "content": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"string format methods\", () => {\n  const a = z.email().min(10);\n  const b = z.email().max(10);\n  const c = z.email().length(10);\n  const d = z.email().uppercase();\n  const e = z.email().lowercase();\n\n  // Positive and negative cases for `a`\n  expect(a.safeParse(\"longemail@example.com\").success).toBe(true); // Positive\n  expect(a.safeParse(\"ort@e.co\").success).toBe(false); // Negative\n\n  // Positive and negative cases for `b`\n  expect(b.safeParse(\"sho@e.co\").success).toBe(true); // Positive\n  expect(b.safeParse(\"longemail@example.com\").success).toBe(false); // Negative\n\n  // Positive and negative cases for `c`\n  expect(c.safeParse(\"56780@e.co\").success).toBe(true); // Positive\n  expect(c.safeParse(\"shoasdfasdfrt@e.co\").success).toBe(false); // Negative\n\n  // Positive and negative cases for `d`\n  expect(d.safeParse(\"EMAIL@EXAMPLE.COM\").success).toBe(true); // Positive\n  expect(d.safeParse(\"email@example.com\").success).toBe(false); // Negative\n\n  // Positive and negative cases for `e`\n  expect(e.safeParse(\"email@example.com\").success).toBe(true); // Positive\n  expect(e.safeParse(\"EMAIL@EXAMPLE.COM\").success).toBe(false); // Negative\n});\n\ntest(\"z.stringFormat\", () => {\n  const ccRegex = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\n\n  const a = z\n    .stringFormat(\"creditCard\", (val) => ccRegex.test(val), {\n      error: `Invalid credit card number`,\n    })\n    .refine((_) => false, \"Also bad\");\n\n  expect(a.safeParse(\"asdf\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"creditCard\",\n        \"path\": [],\n        \"message\": \"Invalid credit card number\"\n      },\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Also bad\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(a.safeParse(\"1234-5678-9012-3456\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Also bad\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(a.def.pattern).toMatchInlineSnapshot(`undefined`);\n\n  const b = z\n    .stringFormat(\"creditCard\", ccRegex, {\n      abort: true,\n      error: `Invalid credit card number`,\n    })\n    .refine((_) => false, \"Also bad\");\n\n  expect(b.safeParse(\"asdf\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"creditCard\",\n        \"path\": [],\n        \"message\": \"Invalid credit card number\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(b.safeParse(\"1234-5678-9012-3456\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Also bad\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(b.def.pattern).toMatchInlineSnapshot(\n    `/\\\\^\\\\(\\\\?:\\\\\\\\d\\\\{14,19\\\\}\\\\|\\\\\\\\d\\\\{4\\\\}\\\\(\\\\?: \\\\\\\\d\\\\{3,6\\\\}\\\\)\\\\{2,4\\\\}\\\\|\\\\\\\\d\\\\{4\\\\}\\\\(\\\\?:-\\\\\\\\d\\\\{3,6\\\\}\\\\)\\\\{2,4\\\\}\\\\)\\\\$/u`\n  );\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/string.test.ts",
    "content": "import { randomBytes } from \"node:crypto\";\nimport { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\nconst minFive = z.string().min(5, \"min5\");\nconst maxFive = z.string().max(5, \"max5\");\nconst justFive = z.string().length(5);\nconst nonempty = z.string().min(1, \"nonempty\");\nconst includes = z.string().includes(\"includes\");\nconst includesFromIndex2 = z.string().includes(\"includes\", { position: 2 });\nconst startsWith = z.string().startsWith(\"startsWith\");\nconst endsWith = z.string().endsWith(\"endsWith\");\n\ntest(\"length checks\", () => {\n  minFive.parse(\"12345\");\n  minFive.parse(\"123456\");\n  maxFive.parse(\"12345\");\n  maxFive.parse(\"1234\");\n  nonempty.parse(\"1\");\n  justFive.parse(\"12345\");\n\n  expect(() => minFive.parse(\"1234\")).toThrow();\n  expect(() => maxFive.parse(\"123456\")).toThrow();\n  expect(() => nonempty.parse(\"\")).toThrow();\n  expect(() => justFive.parse(\"1234\")).toThrow();\n  expect(() => justFive.parse(\"123456\")).toThrow();\n});\n\ntest(\"includes\", () => {\n  includes.parse(\"XincludesXX\");\n  includesFromIndex2.parse(\"XXXincludesXX\");\n\n  expect(() => includes.parse(\"XincludeXX\")).toThrow();\n  expect(() => includesFromIndex2.parse(\"XincludesXX\")).toThrow();\n});\n\ntest(\"startswith/endswith\", () => {\n  startsWith.parse(\"startsWithX\");\n  endsWith.parse(\"XendsWith\");\n\n  expect(() => startsWith.parse(\"x\")).toThrow();\n  expect(() => endsWith.parse(\"x\")).toThrow();\n});\n\ntest(\"email validations\", () => {\n  const validEmails = [\n    `email@domain.com`,\n    `firstname.lastname@domain.com`,\n    `email@subdomain.domain.com`,\n    `firstname+lastname@domain.com`,\n    `1234567890@domain.com`,\n    `email@domain-one.com`,\n    `_______@domain.com`,\n    `email@domain.name`,\n    `email@domain.co.jp`,\n    `firstname-lastname@domain.com`,\n    `very.common@example.com`,\n    `disposable.style.email.with+symbol@example.com`,\n    `other.email-with-hyphen@example.com`,\n    `fully-qualified-domain@example.com`,\n    `user.name+tag+sorting@example.com`,\n    `x@example.com`,\n    `mojojojo@asdf.example.com`,\n    `example-indeed@strange-example.com`,\n    `example@s.example`,\n    `user-@example.org`,\n    `user@my-example.com`,\n    `a@b.cd`,\n    `work+user@mail.com`,\n    `tom@test.te-st.com`,\n    `something@subdomain.domain-with-hyphens.tld`,\n    `common'name@domain.com`,\n    `francois@etu.inp-n7.fr`,\n  ];\n  const invalidEmails = [\n    // no \"printable characters\"\n    // `user%example.com@example.org`,\n    // `mailhost!username@example.org`,\n    // `test/test@test.com`,\n\n    // double @\n    `francois@@etu.inp-n7.fr`,\n    // do not support quotes\n    `\"email\"@domain.com`,\n    `\"e asdf sadf ?<>ail\"@domain.com`,\n    `\" \"@example.org`,\n    `\"john..doe\"@example.org`,\n    `\"very.(),:;<>[]\\\".VERY.\\\"very@\\\\ \\\"very\\\".unusual\"@strange.example.com`,\n    // do not support comma\n    `a,b@domain.com`,\n\n    // do not support IPv4\n    `email@123.123.123.123`,\n    `email@[123.123.123.123]`,\n    `postmaster@123.123.123.123`,\n    `user@[68.185.127.196]`,\n    `ipv4@[85.129.96.247]`,\n    `valid@[79.208.229.53]`,\n    `valid@[255.255.255.255]`,\n    `valid@[255.0.55.2]`,\n    `valid@[255.0.55.2]`,\n\n    // do not support ipv6\n    `hgrebert0@[IPv6:4dc8:ac7:ce79:8878:1290:6098:5c50:1f25]`,\n    `bshapiro4@[IPv6:3669:c709:e981:4884:59a3:75d1:166b:9ae]`,\n    `jsmith@[IPv6:2001:db8::1]`,\n    `postmaster@[IPv6:2001:0db8:85a3:0000:0000:8a2e:0370:7334]`,\n    `postmaster@[IPv6:2001:0db8:85a3:0000:0000:8a2e:0370:192.168.1.1]`,\n\n    // microsoft test cases\n    `plainaddress`,\n    `#@%^%#$@#$@#.com`,\n    `@domain.com`,\n    `Joe Smith &lt;email@domain.com&gt;`,\n    `email.domain.com`,\n    `email@domain@domain.com`,\n    `.email@domain.com`,\n    `email.@domain.com`,\n    `email..email@domain.com`,\n    `あいうえお@domain.com`,\n    `email@domain.com (Joe Smith)`,\n    `email@domain`,\n    `email@-domain.com`,\n    `email@111.222.333.44444`,\n    `email@domain..com`,\n    `Abc.example.com`,\n    `A@b@c@example.com`,\n    `colin..hacks@domain.com`,\n    `a\"b(c)d,e:f;g<h>i[j\\k]l@example.com`,\n    `just\"not\"right@example.com`,\n    `this is\"not\\allowed@example.com`,\n    `this\\ still\\\"not\\\\allowed@example.com`,\n\n    // random\n    `i_like_underscore@but_its_not_allowed_in_this_part.example.com`,\n    `QA[icon]CHOCOLATE[icon]@test.com`,\n    `invalid@-start.com`,\n    `invalid@end.com-`,\n    `a.b@c.d`,\n    `invalid@[1.1.1.-1]`,\n    `invalid@[68.185.127.196.55]`,\n    `temp@[192.168.1]`,\n    `temp@[9.18.122.]`,\n    `double..point@test.com`,\n    `asdad@test..com`,\n    `asdad@hghg...sd...au`,\n    `asdad@hghg........au`,\n    `invalid@[256.2.2.48]`,\n    `invalid@[256.2.2.48]`,\n    `invalid@[999.465.265.1]`,\n    `jkibbey4@[IPv6:82c4:19a8::70a9:2aac:557::ea69:d985:28d]`,\n    `mlivesay3@[9952:143f:b4df:2179:49a1:5e82:b92e:6b6]`,\n    `gbacher0@[IPv6:bc37:4d3f:5048:2e26:37cc:248e:df8e:2f7f:af]`,\n    `invalid@[IPv6:5348:4ed3:5d38:67fb:e9b:acd2:c13:192.168.256.1]`,\n    `test@.com`,\n    `aaaaaaaaaaaaaaalongemailthatcausesregexDoSvulnerability@test.c`,\n  ];\n  const emailSchema = z.string().email();\n\n  expect(\n    validEmails.every((email) => {\n      return emailSchema.safeParse(email).success;\n    })\n  ).toBe(true);\n  expect(\n    invalidEmails.every((email) => {\n      return emailSchema.safeParse(email).success === false;\n    })\n  ).toBe(true);\n});\n\ntest(\"base64 validations\", () => {\n  const validBase64Strings = [\n    \"SGVsbG8gV29ybGQ=\", // \"Hello World\"\n    \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw==\", // \"This is an encoded string\"\n    \"TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcms=\", // \"Many hands make light work\"\n    \"UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // \"Patience is the key to success\"\n    \"QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // \"Base64 encoding is fun\"\n    \"MTIzNDU2Nzg5MA==\", // \"1234567890\"\n    \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=\", // \"abcdefghijklmnopqrstuvwxyz\"\n    \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo=\", // \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"ISIkJSMmJyonKCk=\", // \"!\\\"#$%&'()*\"\n    \"\", // Empty string is technically a valid base64\n  ];\n\n  for (const str of validBase64Strings) {\n    expect(str + z.string().base64().safeParse(str).success).toBe(`${str}true`);\n  }\n\n  const invalidBase64Strings = [\n    \"12345\", // Not padded correctly, not a multiple of 4 characters\n    \"SGVsbG8gV29ybGQ\", // Missing padding\n    \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw\", // Missing padding\n    \"!UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // Invalid character '!'\n    \"?QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // Invalid character '?'\n    \".MTIzND2Nzg5MC4=\", // Invalid character '.'\n    \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo\", // Missing padding\n  ];\n\n  for (const str of invalidBase64Strings) {\n    expect(str + z.string().base64().safeParse(str).success).toBe(`${str}false`);\n  }\n});\n\ntest(\"base64url validations\", () => {\n  const base64url = z.string().base64url();\n\n  const validBase64URLStrings = [\n    \"SGVsbG8gV29ybGQ\", // \"Hello World\"\n\n    \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw\", // \"This is an encoded string\"\n\n    \"TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcms\", // \"Many hands make light work\"\n\n    \"UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // \"Patience is the key to success\"\n    \"QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg\", // \"Base64 encoding is fun\"\n\n    \"MTIzNDU2Nzg5MA\", // \"1234567890\"\n\n    \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo\", // \"abcdefghijklmnopqrstuvwxyz\"\n\n    \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo\", // \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    \"ISIkJSMmJyonKCk\", // \"!\\\"#$%&'()*\"\n\n    \"\", // Empty string is technically valid base64url\n    \"w7_Dv8O-w74K\", // ÿÿþþ\n    \"123456\",\n  ];\n\n  for (const str of validBase64URLStrings) {\n    expect(str + base64url.safeParse(str).success).toBe(`${str}true`);\n  }\n\n  const invalidBase64URLStrings = [\n    \"w7/Dv8O+w74K\", // Has + and / characters (is base64)\n    \"12345\", // Invalid length (not a multiple of 4 characters when adding allowed number of padding characters)\n    \"12345===\", // Not padded correctly\n    \"!UGF0aWVuY2UgaXMgdGhlIGtleSB0byBzdWNjZXNz\", // Invalid character '!'\n    \"?QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // Invalid character '?'\n    \".MTIzND2Nzg5MC4=\", // Invalid character '.'\n\n    // disallow valid padding\n    \"SGVsbG8gV29ybGQ=\", // \"Hello World\" with padding\n    \"VGhpcyBpcyBhbiBlbmNvZGVkIHN0cmluZw==\", // \"This is an encoded string\" with padding\n    \"TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcms=\", // \"Many hands make light work\" with padding\n    \"QmFzZTY0IGVuY29kaW5nIGlzIGZ1bg==\", // \"Base64 encoding is fun\" with padding\n    \"MTIzNDU2Nzg5MA==\", // \"1234567890\" with padding\n    \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo=\", // \"abcdefghijklmnopqrstuvwxyz with padding\"\n    \"QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVo=\", // \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" with padding\n    \"ISIkJSMmJyonKCk=\", // \"!\\\"#$%&'()*\" with padding\n  ];\n\n  for (const str of invalidBase64URLStrings) {\n    expect(str + base64url.safeParse(str).success).toBe(`${str}false`);\n  }\n});\n\ntest(\"big base64 and base64url\", () => {\n  const bigbase64 = randomBytes(1024 * 1024 * 10).toString(\"base64\");\n  z.base64().parse(bigbase64);\n  const bigbase64url = randomBytes(1024 * 1024 * 10).toString(\"base64url\");\n  z.base64url().parse(bigbase64url);\n});\n\nfunction makeJwt(header: object, payload: object) {\n  const headerBase64 = Buffer.from(JSON.stringify(header)).toString(\"base64url\");\n  const payloadBase64 = Buffer.from(JSON.stringify(payload)).toString(\"base64url\");\n  const signature = \"signature\"; // Placeholder for the signature\n  return `${headerBase64}.${payloadBase64}.${signature}`;\n}\n\ntest(\"jwt token\", () => {\n  const jwt = z.string().jwt();\n  expect(() => jwt.parse(\"invalid\")).toThrow();\n  expect(() => jwt.parse(\"invalid.invalid\")).toThrow();\n  expect(() => jwt.parse(\"invalid.invalid.invalid\")).toThrow();\n\n  // Valid JWTs\n  const es256jwt = z.string().jwt({ alg: \"ES256\" });\n  const d1 = makeJwt({ typ: \"JWT\", alg: \"ES256\" }, {});\n  jwt.parse(d1);\n  es256jwt.parse(d1);\n\n  // Invalid header\n  const d2 = makeJwt({}, {});\n  expect(() => jwt.parse(d2)).toThrow();\n\n  // Wrong algorithm\n  const d3 = makeJwt({ typ: \"JWT\", alg: \"RS256\" }, {});\n  expect(() => es256jwt.parse(d3)).toThrow();\n\n  // missing typ is fine\n  const d4 = makeJwt({ alg: \"HS256\" }, {});\n  jwt.parse(d4);\n\n  // type isn't JWT\n  const d5 = makeJwt({ typ: \"SUP\", alg: \"HS256\" }, { foo: \"bar\" });\n  expect(() => jwt.parse(d5)).toThrow();\n});\n\ntest(\"url validations\", () => {\n  const url = z.string().url();\n  url.parse(\"http://google.com\");\n  url.parse(\"https://google.com/asdf?asdf=ljk3lk4&asdf=234#asdf\");\n  url.parse(\"https://anonymous:flabada@developer.mozilla.org/en-US/docs/Web/API/URL/password\");\n  url.parse(\"https://localhost\");\n  url.parse(\"https://my.local\");\n  url.parse(\"http://aslkfjdalsdfkjaf\");\n  url.parse(\"http://localhost\");\n\n  url.parse(\"c:\");\n\n  expect(() => url.parse(\"asdf\")).toThrow();\n  expect(() => url.parse(\"https:/\")).toThrow();\n  expect(() => url.parse(\"asdfj@lkjsdf.com\")).toThrow();\n  expect(() => url.parse(\"https://\")).toThrow();\n});\n\ntest(\"httpurl\", () => {\n  const httpUrl = z.url({\n    protocol: /^https?$/,\n    hostname: z.regexes.domain,\n    // /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$/\n  });\n\n  httpUrl.parse(\"https://example.com\");\n  httpUrl.parse(\"http://example.com\");\n  // ports\n  httpUrl.parse(\"https://example.com:8080\");\n  httpUrl.parse(\"http://example.com:8080\");\n  // subdomains\n  httpUrl.parse(\"https://sub.example.com\");\n  httpUrl.parse(\"http://sub.example.com\");\n  // paths\n  httpUrl.parse(\"https://example.com/path/to/resource\");\n  httpUrl.parse(\"http://example.com/path/to/resource\");\n  // query parameters\n  httpUrl.parse(\"https://example.com/path?query=param\");\n  httpUrl.parse(\"http://example.com/path?query=param\");\n  // fragment identifiers\n  httpUrl.parse(\"https://example.com/path#fragment\");\n  httpUrl.parse(\"http://example.com/path#fragment\");\n  // fails\n  expect(() => httpUrl.parse(\"ftp://example.com\")).toThrow();\n  expect(() => httpUrl.parse(\"shttp://example.com\")).toThrow();\n  expect(() => httpUrl.parse(\"httpz://example.com\")).toThrow();\n  expect(() => httpUrl.parse(\"http://\")).toThrow();\n  expect(() => httpUrl.parse(\"http://localhost\")).toThrow();\n  expect(() => httpUrl.parse(\"http://-asdf.com\")).toThrow();\n  expect(() =>\n    httpUrl.parse(\n      \"http://asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf.com\"\n    )\n  ).toThrow();\n  expect(() => httpUrl.parse(\"http://asdf.c\")).toThrow();\n  expect(() => httpUrl.parse(\"mailto:asdf@lckj.com\")).toThrow();\n});\n\ntest(\"url error overrides\", () => {\n  try {\n    z.string().url().parse(\"https\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"Invalid URL\");\n  }\n  try {\n    z.string().url(\"badurl\").parse(\"https\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"badurl\");\n  }\n  try {\n    z.string().url({ message: \"badurl\" }).parse(\"https\");\n  } catch (err) {\n    expect((err as z.ZodError).issues[0].message).toEqual(\"badurl\");\n  }\n});\n\ntest(\"emoji validations\", () => {\n  const emoji = z.string().emoji();\n\n  emoji.parse(\"👋👋👋👋\");\n  emoji.parse(\"🍺👩‍🚀🫡\");\n  emoji.parse(\"💚💙💜💛❤️\");\n  emoji.parse(\"🐛🗝🐏🍡🎦🚢🏨💫🎌☘🗡😹🔒🎬➡️🍹🗂🚨⚜🕑〽️🚦🌊🍴💍🍌💰😳🌺🍃\");\n  emoji.parse(\"🇹🇷🤽🏿‍♂️\");\n  emoji.parse(\n    \"😀😁😂🤣😃😄😅😆😉😊😋😎😍😘🥰😗😙😚☺️☺🙂🤗🤩🤔🤨😐😑😶🙄😏😣😥😮🤐😯😪😫😴😌😛😜😝🤤😒😓😔😕🙃🤑😲☹️☹🙁😖😞😟😤😢😭😦😧😨😩🤯😬😰😱🥵🥶😳🤪😵😡😠🤬😷🤒🤕🤢🤮🤧😇🤠🥳🥴🥺🤥🤫🤭🧐🤓😈👿🤡👹👺💀☠️☠👻👽👾🤖💩😺😸😹😻😼😽🙀😿😾🙈🙉🙊🏻🏼🏽🏾🏿👶👶🏻👶🏼👶🏽👶🏾👶🏿🧒🧒🏻🧒🏼🧒🏽🧒🏾🧒🏿👦👦🏻👦🏼👦🏽👦🏾👦🏿👧👧🏻👧🏼👧🏽👧🏾👧🏿🧑🧑🏻🧑🏼🧑🏽🧑🏾🧑🏿👨👨🏻👨🏼👨🏽👨🏾👨🏿👩👩🏻👩🏼👩🏽👩🏾👩🏿🧓🧓🏻🧓🏼🧓🏽🧓🏾🧓🏿👴👴🏻👴🏼👴🏽👴🏾👴🏿👵👵🏻👵🏼👵🏽👵🏾👵🏿👨‍⚕️👨‍⚕👨🏻‍⚕️👨🏻‍⚕👨🏼‍⚕️👨🏼‍⚕👨🏽‍⚕️👨🏽‍⚕👨🏾‍⚕️👨🏾‍⚕👨🏿‍⚕️👨🏿‍⚕👩‍⚕️👩‍⚕👩🏻‍⚕️👩🏻‍⚕👩🏼‍⚕️👩🏼‍⚕👩🏽‍⚕️👩🏽‍⚕👩🏾‍⚕️👩🏾‍⚕👩🏿‍⚕️👩🏿‍⚕👨‍🎓👨🏻‍🎓👨🏼‍🎓👨🏽‍🎓👨🏾‍🎓👨🏿‍🎓👩‍🎓👩🏻‍🎓👩🏼‍🎓👩🏽‍🎓👩🏾‍🎓👩🏿‍🎓👨‍🏫👨🏻‍🏫👨🏼‍🏫👨🏽‍🏫👨🏾‍🏫👨🏿‍🏫👩‍🏫👩🏻‍🏫👩🏼‍🏫👩🏽‍🏫👩🏾‍🏫👩🏿‍🏫👨‍⚖️👨‍⚖👨🏻‍⚖️👨🏻‍⚖👨🏼‍⚖️👨🏼‍⚖👨🏽‍⚖️👨🏽‍⚖👨🏾‍⚖️👨🏾‍⚖👨🏿‍⚖️👨🏿‍⚖👩‍⚖️👩‍⚖👩🏻‍⚖️👩🏻‍⚖👩🏼‍⚖️👩🏼‍⚖👩🏽‍⚖️👩🏽‍⚖👩🏾‍⚖️👩🏾‍⚖👩🏿‍⚖️👩🏿‍⚖👨‍🌾👨🏻‍🌾👨🏼‍🌾👨🏽‍🌾👨🏾‍🌾👨🏿‍🌾👩‍🌾👩🏻‍🌾👩🏼‍🌾👩🏽‍🌾👩🏾‍🌾👩🏿‍🌾👨‍🍳👨🏻‍🍳👨🏼‍🍳👨🏽‍🍳👨🏾‍🍳👨🏿‍🍳👩‍🍳👩🏻‍🍳👩🏼‍🍳👩🏽‍🍳👩🏾‍🍳👩🏿‍🍳👨‍🔧👨🏻‍🔧👨🏼‍🔧👨🏽‍🔧👨🏾‍🔧👨🏿‍🔧👩‍🔧👩🏻‍🔧👩🏼‍🔧👩🏽‍🔧👩🏾‍🔧👩🏿‍🔧👨‍🏭👨🏻‍🏭👨🏼‍🏭👨🏽‍🏭👨🏾‍🏭👨🏿‍🏭👩‍🏭👩🏻‍🏭👩🏼‍🏭👩🏽‍🏭👩🏾‍🏭👩🏿‍🏭👨‍💼👨🏻‍💼👨🏼‍💼👨🏽‍💼👨🏾‍💼👨🏿‍💼👩‍💼👩🏻‍💼👩🏼‍💼👩🏽‍💼👩🏾‍💼👩🏿‍💼👨‍🔬👨🏻‍🔬👨🏼‍🔬👨🏽‍🔬👨🏾‍🔬👨🏿‍🔬👩‍🔬👩🏻‍🔬👩🏼‍🔬👩🏽‍🔬👩🏾‍🔬👩🏿‍🔬👨‍💻👨🏻‍💻👨🏼‍💻👨🏽‍💻👨🏾‍💻👨🏿‍💻👩‍💻👩🏻‍💻👩🏼‍💻👩🏽‍💻👩🏾‍💻👩🏿‍💻👨‍🎤👨🏻‍🎤👨🏼‍🎤👨🏽‍🎤👨🏾‍🎤👨🏿‍🎤👩‍🎤👩🏻‍🎤👩🏼‍🎤👩🏽‍🎤👩🏾‍🎤👩🏿‍🎤👨‍🎨👨🏻‍🎨👨🏼‍🎨👨🏽‍🎨👨🏾‍🎨👨🏿‍🎨👩‍🎨👩🏻‍🎨👩🏼‍🎨👩🏽‍🎨👩🏾‍🎨👩🏿‍🎨👨‍✈️👨‍✈👨🏻‍✈️👨🏻‍✈👨🏼‍✈️👨🏼‍✈👨🏽‍✈️👨🏽‍✈👨🏾‍✈️👨🏾‍✈👨🏿‍✈️👨🏿‍✈👩‍✈️👩‍✈👩🏻‍✈️👩🏻‍✈👩🏼‍✈️👩🏼‍✈👩🏽‍✈️👩🏽‍✈👩🏾‍✈️👩🏾‍✈👩🏿‍✈️👩🏿‍✈👨‍🚀👨🏻‍🚀👨🏼‍🚀👨🏽‍🚀👨🏾‍🚀👨🏿‍🚀👩‍🚀👩🏻‍🚀👩🏼‍🚀👩🏽‍🚀👩🏾‍🚀👩🏿‍🚀👨‍🚒👨🏻‍🚒👨🏼‍🚒👨🏽‍🚒👨🏾‍🚒👨🏿‍🚒👩‍🚒👩🏻‍🚒👩🏼‍🚒👩🏽‍🚒👩🏾‍🚒👩🏿‍🚒👮👮🏻👮🏼👮🏽👮🏾👮🏿👮‍♂️👮‍♂👮🏻‍♂️👮🏻‍♂👮🏼‍♂️👮🏼‍♂👮🏽‍♂️👮🏽‍♂👮🏾‍♂️👮🏾‍♂👮🏿‍♂️👮🏿‍♂👮‍♀️👮‍♀👮🏻‍♀️👮🏻‍♀👮🏼‍♀️👮🏼‍♀👮🏽‍♀️👮🏽‍♀👮🏾‍♀️👮🏾‍♀👮🏿‍♀️👮🏿‍♀🕵️🕵🕵🏻🕵🏼🕵🏽🕵🏾🕵🏿🕵️‍♂️🕵‍♂️🕵️‍♂🕵‍♂🕵🏻‍♂️🕵🏻‍♂🕵🏼‍♂️🕵🏼‍♂🕵🏽‍♂️🕵🏽‍♂🕵🏾‍♂️🕵🏾‍♂🕵🏿‍♂️🕵🏿‍♂🕵️‍♀️🕵‍♀️🕵️‍♀🕵‍♀🕵🏻‍♀️🕵🏻‍♀🕵🏼‍♀️🕵🏼‍♀🕵🏽‍♀️🕵🏽‍♀🕵🏾‍♀️🕵🏾‍♀🕵🏿‍♀️🕵🏿‍♀💂💂🏻💂🏼💂🏽💂🏾💂🏿💂‍♂️💂‍♂💂🏻‍♂️💂🏻‍♂💂🏼‍♂️💂🏼‍♂💂🏽‍♂️💂🏽‍♂💂🏾‍♂️💂🏾‍♂💂🏿‍♂️💂🏿‍♂💂‍♀️💂‍♀💂🏻‍♀️💂🏻‍♀💂🏼‍♀️💂🏼‍♀💂🏽‍♀️💂🏽‍♀💂🏾‍♀️💂🏾‍♀💂🏿‍♀️💂🏿‍♀👷👷🏻👷🏼👷🏽👷🏾👷🏿👷‍♂️👷‍♂👷🏻‍♂️👷🏻‍♂👷🏼‍♂️👷🏼‍♂👷🏽‍♂️👷🏽‍♂👷🏾‍♂️👷🏾‍♂👷🏿‍♂️👷🏿‍♂👷‍♀️👷‍♀👷🏻‍♀️👷🏻‍♀👷🏼‍♀️👷🏼‍♀👷🏽‍♀️👷🏽‍♀👷🏾‍♀️👷🏾‍♀👷🏿‍♀️👷🏿‍♀🤴🤴🏻🤴🏼🤴🏽🤴🏾🤴🏿👸👸🏻👸🏼👸🏽👸🏾👸🏿👳👳🏻👳🏼👳🏽👳🏾👳🏿👳‍♂️👳‍♂👳🏻‍♂️👳🏻‍♂👳🏼‍♂️👳🏼‍♂👳🏽‍♂️👳🏽‍♂👳🏾‍♂️👳🏾‍♂👳🏿‍♂️👳🏿‍♂👳‍♀️👳‍♀👳🏻‍♀️👳🏻‍♀👳🏼‍♀️👳🏼‍♀👳🏽‍♀️👳🏽‍♀👳🏾‍♀️👳🏾‍♀👳🏿‍♀️👳🏿‍♀👲👲🏻👲🏼👲🏽👲🏾👲🏿🧕🧕🏻🧕🏼🧕🏽🧕🏾🧕🏿🧔🧔🏻🧔🏼🧔🏽🧔🏾🧔🏿👱👱🏻👱🏼👱🏽👱🏾👱🏿👱‍♂️👱‍♂👱🏻‍♂️👱🏻‍♂👱🏼‍♂️👱🏼‍♂👱🏽‍♂️👱🏽‍♂👱🏾‍♂️👱🏾‍♂👱🏿‍♂️👱🏿‍♂👱‍♀️👱‍♀👱🏻‍♀️👱🏻‍♀👱🏼‍♀️👱🏼‍♀👱🏽‍♀️👱🏽‍♀👱🏾‍♀️👱🏾‍♀👱🏿‍♀️👱🏿‍♀👨‍🦰👨🏻‍🦰👨🏼‍🦰👨🏽‍🦰👨🏾‍🦰👨🏿‍🦰👩‍🦰👩🏻‍🦰👩🏼‍🦰👩🏽‍🦰👩🏾‍🦰👩🏿‍🦰👨‍🦱👨🏻‍🦱👨🏼‍🦱👨🏽‍🦱👨🏾‍🦱👨🏿‍🦱👩‍🦱👩🏻‍🦱👩🏼‍🦱👩🏽‍🦱👩🏾‍🦱👩🏿‍🦱👨‍🦲👨🏻‍🦲👨🏼‍🦲👨🏽‍🦲👨🏾‍🦲👨🏿‍🦲👩‍🦲👩🏻‍🦲👩🏼‍🦲👩🏽‍🦲👩🏾‍🦲👩🏿‍🦲👨‍🦳👨🏻‍🦳👨🏼‍🦳👨🏽‍🦳👨🏾‍🦳👨🏿‍🦳👩‍🦳👩🏻‍🦳👩🏼‍🦳👩🏽‍🦳👩🏾‍🦳👩🏿‍🦳🤵🤵🏻🤵🏼🤵🏽🤵🏾🤵🏿👰👰🏻👰🏼👰🏽👰🏾👰🏿🤰🤰🏻🤰🏼🤰🏽🤰🏾🤰🏿🤱🤱🏻🤱🏼🤱🏽🤱🏾🤱🏿👼👼🏻👼🏼👼🏽👼🏾👼🏿🎅🎅🏻🎅🏼🎅🏽🎅🏾🎅🏿🤶🤶🏻🤶🏼🤶🏽🤶🏾🤶🏿🦸🦸🏻🦸🏼🦸🏽🦸🏾🦸🏿🦸‍♀️🦸‍♀🦸🏻‍♀️🦸🏻‍♀🦸🏼‍♀️🦸🏼‍♀🦸🏽‍♀️🦸🏽‍♀🦸🏾‍♀️🦸🏾‍♀🦸🏿‍♀️🦸🏿‍♀🦸‍♂️🦸‍♂🦸🏻‍♂️🦸🏻‍♂🦸🏼‍♂️🦸🏼‍♂🦸🏽‍♂️🦸🏽‍♂🦸🏾‍♂️🦸🏾‍♂🦸🏿‍♂️🦸🏿‍♂🦹🦹🏻🦹🏼🦹🏽🦹🏾🦹🏿🦹‍♀️🦹‍♀🦹🏻‍♀️🦹🏻‍♀🦹🏼‍♀️🦹🏼‍♀🦹🏽‍♀️🦹🏽‍♀🦹🏾‍♀️🦹🏾‍♀🦹🏿‍♀️🦹🏿‍♀🦹‍♂️🦹‍♂🦹🏻‍♂️🦹🏻‍♂🦹🏼‍♂️🦹🏼‍♂🦹🏽‍♂️🦹🏽‍♂🦹🏾‍♂️🦹🏾‍♂🦹🏿‍♂️🦹🏿‍♂🧙🧙🏻🧙🏼🧙🏽🧙🏾🧙🏿🧙‍♀️🧙‍♀🧙🏻‍♀️🧙🏻‍♀🧙🏼‍♀️🧙🏼‍♀🧙🏽‍♀️🧙🏽‍♀🧙🏾‍♀️🧙🏾‍♀🧙🏿‍♀️🧙🏿‍♀🧙‍♂️🧙‍♂🧙🏻‍♂️🧙🏻‍♂🧙🏼‍♂️🧙🏼‍♂🧙🏽‍♂️🧙🏽‍♂🧙🏾‍♂️🧙🏾‍♂🧙🏿‍♂️🧙🏿‍♂🧚🧚🏻🧚🏼🧚🏽🧚🏾🧚🏿🧚‍♀️🧚‍♀🧚🏻‍♀️🧚🏻‍♀🧚🏼‍♀️🧚🏼‍♀🧚🏽‍♀️🧚🏽‍♀🧚🏾‍♀️🧚🏾‍♀🧚🏿‍♀️🧚🏿‍♀🧚‍♂️🧚‍♂🧚🏻‍♂️🧚🏻‍♂🧚🏼‍♂️🧚🏼‍♂🧚🏽‍♂️🧚🏽‍♂🧚🏾‍♂️🧚🏾‍♂🧚🏿‍♂️🧚🏿‍♂🧛🧛🏻🧛🏼🧛🏽🧛🏾🧛🏿🧛‍♀️🧛‍♀🧛🏻‍♀️🧛🏻‍♀🧛🏼‍♀️🧛🏼‍♀🧛🏽‍♀️🧛🏽‍♀🧛🏾‍♀️🧛🏾‍♀🧛🏿‍♀️🧛🏿‍♀🧛‍♂️🧛‍♂🧛🏻‍♂️🧛🏻‍♂🧛🏼‍♂️🧛🏼‍♂🧛🏽‍♂️🧛🏽‍♂🧛🏾‍♂️🧛🏾‍♂🧛🏿‍♂️🧛🏿‍♂🧜🧜🏻🧜🏼🧜🏽🧜🏾🧜🏿🧜‍♀️🧜‍♀🧜🏻‍♀️🧜🏻‍♀🧜🏼‍♀️🧜🏼‍♀🧜🏽‍♀️🧜🏽‍♀🧜🏾‍♀️🧜🏾‍♀🧜🏿‍♀️🧜🏿‍♀🧜‍♂️🧜‍♂🧜🏻‍♂️🧜🏻‍♂🧜🏼‍♂️🧜🏼‍♂🧜🏽‍♂️🧜🏽‍♂🧜🏾‍♂️🧜🏾‍♂🧜🏿‍♂️🧜🏿‍♂🧝🧝🏻🧝🏼🧝🏽🧝🏾🧝🏿🧝‍♀️🧝‍♀🧝🏻‍♀️🧝🏻‍♀🧝🏼‍♀️🧝🏼‍♀🧝🏽‍♀️🧝🏽‍♀🧝🏾‍♀️🧝🏾‍♀🧝🏿‍♀️🧝🏿‍♀🧝‍♂️🧝‍♂🧝🏻‍♂️🧝🏻‍♂🧝🏼‍♂️🧝🏼‍♂🧝🏽‍♂️🧝🏽‍♂🧝🏾‍♂️🧝🏾‍♂🧝🏿‍♂️🧝🏿‍♂🧞🧞‍♀️🧞‍♀🧞‍♂️🧞‍♂🧟🧟‍♀️🧟‍♀🧟‍♂️🧟‍♂🙍🙍🏻🙍🏼🙍🏽🙍🏾🙍🏿🙍‍♂️🙍‍♂🙍🏻‍♂️🙍🏻‍♂🙍🏼‍♂️🙍🏼‍♂🙍🏽‍♂️🙍🏽‍♂🙍🏾‍♂️🙍🏾‍♂🙍🏿‍♂️🙍🏿‍♂🙍‍♀️🙍‍♀🙍🏻‍♀️🙍🏻‍♀🙍🏼‍♀️🙍🏼‍♀🙍🏽‍♀️🙍🏽‍♀🙍🏾‍♀️🙍🏾‍♀🙍🏿‍♀️🙍🏿‍♀🙎🙎🏻🙎🏼🙎🏽🙎🏾🙎🏿🙎‍♂️🙎‍♂🙎🏻‍♂️🙎🏻‍♂🙎🏼‍♂️🙎🏼‍♂🙎🏽‍♂️🙎🏽‍♂🙎🏾‍♂️🙎🏾‍♂🙎🏿‍♂️🙎🏿‍♂🙎‍♀️🙎‍♀🙎🏻‍♀️🙎🏻‍♀🙎🏼‍♀️🙎🏼‍♀🙎🏽‍♀️🙎🏽‍♀🙎🏾‍♀️🙎🏾‍♀🙎🏿‍♀️🙎🏿‍♀🙅🙅🏻🙅🏼🙅🏽🙅🏾🙅🏿🙅‍♂️🙅‍♂🙅🏻‍♂️🙅🏻‍♂🙅🏼‍♂️🙅🏼‍♂🙅🏽‍♂️🙅🏽‍♂🙅🏾‍♂️🙅🏾‍♂🙅🏿‍♂️🙅🏿‍♂🙅‍♀️🙅‍♀🙅🏻‍♀️🙅🏻‍♀🙅🏼‍♀️🙅🏼‍♀🙅🏽‍♀️🙅🏽‍♀🙅🏾‍♀️🙅🏾‍♀🙅🏿‍♀️🙅🏿‍♀🙆🙆🏻🙆🏼🙆🏽🙆🏾🙆🏿🙆‍♂️🙆‍♂🙆🏻‍♂️🙆🏻‍♂🙆🏼‍♂️🙆🏼‍♂🙆🏽‍♂️🙆🏽‍♂🙆🏾‍♂️🙆🏾‍♂🙆🏿‍♂️🙆🏿‍♂🙆‍♀️🙆‍♀🙆🏻‍♀️🙆🏻‍♀🙆🏼‍♀️🙆🏼‍♀🙆🏽‍♀️🙆🏽‍♀🙆🏾‍♀️🙆🏾‍♀🙆🏿‍♀️🙆🏿‍♀💁💁🏻💁🏼💁🏽💁🏾💁🏿💁‍♂️💁‍♂💁🏻‍♂️💁🏻‍♂💁🏼‍♂️💁🏼‍♂💁🏽‍♂️💁🏽‍♂💁🏾‍♂️💁🏾‍♂💁🏿‍♂️💁🏿‍♂💁‍♀️💁‍♀💁🏻‍♀️💁🏻‍♀💁🏼‍♀️💁🏼‍♀💁🏽‍♀️💁🏽‍♀💁🏾‍♀️💁🏾‍♀💁🏿‍♀️💁🏿‍♀🙋🙋🏻🙋🏼🙋🏽🙋🏾🙋🏿🙋‍♂️🙋‍♂🙋🏻‍♂️🙋🏻‍♂🙋🏼‍♂️🙋🏼‍♂🙋🏽‍♂️🙋🏽‍♂🙋🏾‍♂️🙋🏾‍♂🙋🏿‍♂️🙋🏿‍♂🙋‍♀️🙋‍♀🙋🏻‍♀️🙋🏻‍♀🙋🏼‍♀️🙋🏼‍♀🙋🏽‍♀️🙋🏽‍♀🙋🏾‍♀️🙋🏾‍♀🙋🏿‍♀️🙋🏿‍♀🙇🙇🏻🙇🏼🙇🏽🙇🏾🙇🏿🙇‍♂️🙇‍♂🙇🏻‍♂️🙇🏻‍♂🙇🏼‍♂️🙇🏼‍♂🙇🏽‍♂️🙇🏽‍♂🙇🏾‍♂️🙇🏾‍♂🙇🏿‍♂️🙇🏿‍♂🙇‍♀️🙇‍♀🙇🏻‍♀️🙇🏻‍♀🙇🏼‍♀️🙇🏼‍♀🙇🏽‍♀️🙇🏽‍♀🙇🏾‍♀️🙇🏾‍♀🙇🏿‍♀️🙇🏿‍♀🤦🤦🏻🤦🏼🤦🏽🤦🏾🤦🏿🤦‍♂️🤦‍♂🤦🏻‍♂️🤦🏻‍♂🤦🏼‍♂️🤦🏼‍♂🤦🏽‍♂️🤦🏽‍♂🤦🏾‍♂️🤦🏾‍♂🤦🏿‍♂️🤦🏿‍♂🤦‍♀️🤦‍♀🤦🏻‍♀️🤦🏻‍♀🤦🏼‍♀️🤦🏼‍♀🤦🏽‍♀️🤦🏽‍♀🤦🏾‍♀️🤦🏾‍♀🤦🏿‍♀️🤦🏿‍♀🤷🤷🏻🤷🏼🤷🏽🤷🏾🤷🏿🤷‍♂️🤷‍♂🤷🏻‍♂️🤷🏻‍♂🤷🏼‍♂️🤷🏼‍♂🤷🏽‍♂️🤷🏽‍♂🤷🏾‍♂️🤷🏾‍♂🤷🏿‍♂️🤷🏿‍♂🤷‍♀️🤷‍♀🤷🏻‍♀️🤷🏻‍♀🤷🏼‍♀️🤷🏼‍♀🤷🏽‍♀️🤷🏽‍♀🤷🏾‍♀️🤷🏾‍♀🤷🏿‍♀️🤷🏿‍♀💆💆🏻💆🏼💆🏽💆🏾💆🏿💆‍♂️💆‍♂💆🏻‍♂️💆🏻‍♂💆🏼‍♂️💆🏼‍♂💆🏽‍♂️💆🏽‍♂💆🏾‍♂️💆🏾‍♂💆🏿‍♂️💆🏿‍♂💆‍♀️💆‍♀💆🏻‍♀️💆🏻‍♀💆🏼‍♀️💆🏼‍♀💆🏽‍♀️💆🏽‍♀💆🏾‍♀️💆🏾‍♀💆🏿‍♀️💆🏿‍♀💇💇🏻💇🏼💇🏽💇🏾💇🏿💇‍♂️💇‍♂💇🏻‍♂️💇🏻‍♂💇🏼‍♂️💇🏼‍♂💇🏽‍♂️💇🏽‍♂💇🏾‍♂️💇🏾‍♂💇🏿‍♂️💇🏿‍♂💇‍♀️💇‍♀💇🏻‍♀️💇🏻‍♀💇🏼‍♀️💇🏼‍♀💇🏽‍♀️💇🏽‍♀💇🏾‍♀️💇🏾‍♀💇🏿‍♀️💇🏿‍♀🚶🚶🏻🚶🏼🚶🏽🚶🏾🚶🏿🚶‍♂️🚶‍♂🚶🏻‍♂️🚶🏻‍♂🚶🏼‍♂️🚶🏼‍♂🚶🏽‍♂️🚶🏽‍♂🚶🏾‍♂️🚶🏾‍♂🚶🏿‍♂️🚶🏿‍♂🚶‍♀️🚶‍♀🚶🏻‍♀️🚶🏻‍♀🚶🏼‍♀️🚶🏼‍♀🚶🏽‍♀️🚶🏽‍♀🚶🏾‍♀️🚶🏾‍♀🚶🏿‍♀️🚶🏿‍♀🏃🏃🏻🏃🏼🏃🏽🏃🏾🏃🏿🏃‍♂️🏃‍♂🏃🏻‍♂️🏃🏻‍♂🏃🏼‍♂️🏃🏼‍♂🏃🏽‍♂️🏃🏽‍♂🏃🏾‍♂️🏃🏾‍♂🏃🏿‍♂️🏃🏿‍♂🏃‍♀️🏃‍♀🏃🏻‍♀️🏃🏻‍♀🏃🏼‍♀️🏃🏼‍♀🏃🏽‍♀️🏃🏽‍♀🏃🏾‍♀️🏃🏾‍♀🏃🏿‍♀️🏃🏿‍♀💃💃🏻💃🏼💃🏽💃🏾💃🏿🕺🕺🏻🕺🏼🕺🏽🕺🏾🕺🏿👯👯‍♂️👯‍♂👯‍♀️👯‍♀🧖🧖🏻🧖🏼🧖🏽🧖🏾🧖🏿🧖‍♀️🧖‍♀🧖🏻‍♀️🧖🏻‍♀🧖🏼‍♀️🧖🏼‍♀🧖🏽‍♀️🧖🏽‍♀🧖🏾‍♀️🧖🏾‍♀🧖🏿‍♀️🧖🏿‍♀🧖‍♂️🧖‍♂🧖🏻‍♂️🧖🏻‍♂🧖🏼‍♂️🧖🏼‍♂🧖🏽‍♂️🧖🏽‍♂🧖🏾‍♂️🧖🏾‍♂🧖🏿‍♂️🧖🏿‍♂🧗🧗🏻🧗🏼🧗🏽🧗🏾🧗🏿🧗‍♀️🧗‍♀🧗🏻‍♀️🧗🏻‍♀🧗🏼‍♀️🧗🏼‍♀🧗🏽‍♀️🧗🏽‍♀🧗🏾‍♀️🧗🏾‍♀🧗🏿‍♀️🧗🏿‍♀🧗‍♂️🧗‍♂🧗🏻‍♂️🧗🏻‍♂🧗🏼‍♂️🧗🏼‍♂🧗🏽‍♂️🧗🏽‍♂🧗🏾‍♂️🧗🏾‍♂🧗🏿‍♂️🧗🏿‍♂🧘🧘🏻🧘🏼🧘🏽🧘🏾🧘🏿🧘‍♀️🧘‍♀🧘🏻‍♀️🧘🏻‍♀🧘🏼‍♀️🧘🏼‍♀🧘🏽‍♀️🧘🏽‍♀🧘🏾‍♀️🧘🏾‍♀🧘🏿‍♀️🧘🏿‍♀🧘‍♂️🧘‍♂🧘🏻‍♂️🧘🏻‍♂🧘🏼‍♂️🧘🏼‍♂🧘🏽‍♂️🧘🏽‍♂🧘🏾‍♂️🧘🏾‍♂🧘🏿‍♂️🧘🏿‍♂🛀🛀🏻🛀🏼🛀🏽🛀🏾🛀🏿🛌🛌🏻🛌🏼🛌🏽🛌🏾🛌🏿🕴️🕴🕴🏻🕴🏼🕴🏽🕴🏾🕴🏿🗣️🗣👤👥🤺🏇🏇🏻🏇🏼🏇🏽🏇🏾🏇🏿⛷️⛷🏂🏂🏻🏂🏼🏂🏽🏂🏾🏂🏿🏌️🏌🏌🏻🏌🏼🏌🏽🏌🏾🏌🏿🏌️‍♂️🏌‍♂️🏌️‍♂🏌‍♂🏌🏻‍♂️🏌🏻‍♂🏌🏼‍♂️🏌🏼‍♂🏌🏽‍♂️🏌🏽‍♂🏌🏾‍♂️🏌🏾‍♂🏌🏿‍♂️🏌🏿‍♂🏌️‍♀️🏌‍♀️🏌️‍♀🏌‍♀🏌🏻‍♀️🏌🏻‍♀🏌🏼‍♀️🏌🏼‍♀🏌🏽‍♀️🏌🏽‍♀🏌🏾‍♀️🏌🏾‍♀🏌🏿‍♀️🏌🏿‍♀🏄🏄🏻🏄🏼🏄🏽🏄🏾🏄🏿🏄‍♂️🏄‍♂🏄🏻‍♂️🏄🏻‍♂🏄🏼‍♂️🏄🏼‍♂🏄🏽‍♂️🏄🏽‍♂🏄🏾‍♂️🏄🏾‍♂🏄🏿‍♂️🏄🏿‍♂🏄‍♀️🏄‍♀🏄🏻‍♀️🏄🏻‍♀🏄🏼‍♀️🏄🏼‍♀🏄🏽‍♀️🏄🏽‍♀🏄🏾‍♀️🏄🏾‍♀🏄🏿‍♀️🏄🏿‍♀🚣🚣🏻🚣🏼🚣🏽🚣🏾🚣🏿🚣‍♂️🚣‍♂🚣🏻‍♂️🚣🏻‍♂🚣🏼‍♂️🚣🏼‍♂🚣🏽‍♂️🚣🏽‍♂🚣🏾‍♂️🚣🏾‍♂🚣🏿‍♂️🚣🏿‍♂🚣‍♀️🚣‍♀🚣🏻‍♀️🚣🏻‍♀🚣🏼‍♀️🚣🏼‍♀🚣🏽‍♀️🚣🏽‍♀🚣🏾‍♀️🚣🏾‍♀🚣🏿‍♀️🚣🏿‍♀🏊🏊🏻🏊🏼🏊🏽🏊🏾🏊🏿🏊‍♂️🏊‍♂🏊🏻‍♂️🏊🏻‍♂🏊🏼‍♂️🏊🏼‍♂🏊🏽‍♂️🏊🏽‍♂🏊🏾‍♂️🏊🏾‍♂🏊🏿‍♂️🏊🏿‍♂🏊‍♀️🏊‍♀🏊🏻‍♀️🏊🏻‍♀🏊🏼‍♀️🏊🏼‍♀🏊🏽‍♀️🏊🏽‍♀🏊🏾‍♀️🏊🏾‍♀🏊🏿‍♀️🏊🏿‍♀⛹️⛹⛹🏻⛹🏼⛹🏽⛹🏾⛹🏿⛹️‍♂️⛹‍♂️⛹️‍♂⛹‍♂⛹🏻‍♂️⛹🏻‍♂⛹🏼‍♂️⛹🏼‍♂⛹🏽‍♂️⛹🏽‍♂⛹🏾‍♂️⛹🏾‍♂⛹🏿‍♂️⛹🏿‍♂⛹️‍♀️⛹‍♀️⛹️‍♀⛹‍♀⛹🏻‍♀️⛹🏻‍♀⛹🏼‍♀️⛹🏼‍♀⛹🏽‍♀️⛹🏽‍♀⛹🏾‍♀️⛹🏾‍♀⛹🏿‍♀️⛹🏿‍♀🏋️🏋🏋🏻🏋🏼🏋🏽🏋🏾🏋🏿🏋️‍♂️🏋‍♂️🏋️‍♂🏋‍♂🏋🏻‍♂️🏋🏻‍♂🏋🏼‍♂️🏋🏼‍♂🏋🏽‍♂️🏋🏽‍♂🏋🏾‍♂️🏋🏾‍♂🏋🏿‍♂️🏋🏿‍♂🏋️‍♀️🏋‍♀️🏋️‍♀🏋‍♀🏋🏻‍♀️🏋🏻‍♀🏋🏼‍♀️🏋🏼‍♀🏋🏽‍♀️🏋🏽‍♀🏋🏾‍♀️🏋🏾‍♀🏋🏿‍♀️🏋🏿‍♀🚴🚴🏻🚴🏼🚴🏽🚴🏾🚴🏿🚴‍♂️🚴‍♂🚴🏻‍♂️🚴🏻‍♂🚴🏼‍♂️🚴🏼‍♂🚴🏽‍♂️🚴🏽‍♂🚴🏾‍♂️🚴🏾‍♂🚴🏿‍♂️🚴🏿‍♂🚴‍♀️🚴‍♀🚴🏻‍♀️🚴🏻‍♀🚴🏼‍♀️🚴🏼‍♀🚴🏽‍♀️🚴🏽‍♀🚴🏾‍♀️🚴🏾‍♀🚴🏿‍♀️🚴🏿‍♀🚵🚵🏻🚵🏼🚵🏽🚵🏾🚵🏿🚵‍♂️🚵‍♂🚵🏻‍♂️🚵🏻‍♂🚵🏼‍♂️🚵🏼‍♂🚵🏽‍♂️🚵🏽‍♂🚵🏾‍♂️🚵🏾‍♂🚵🏿‍♂️🚵🏿‍♂🚵‍♀️🚵‍♀🚵🏻‍♀️🚵🏻‍♀🚵🏼‍♀️🚵🏼‍♀🚵🏽‍♀️🚵🏽‍♀🚵🏾‍♀️🚵🏾‍♀🚵🏿‍♀️🚵🏿‍♀🏎️🏎🏍️🏍🤸🤸🏻🤸🏼🤸🏽🤸🏾🤸🏿🤸‍♂️🤸‍♂🤸🏻‍♂️🤸🏻‍♂🤸🏼‍♂️🤸🏼‍♂🤸🏽‍♂️🤸🏽‍♂🤸🏾‍♂️🤸🏾‍♂🤸🏿‍♂️🤸🏿‍♂🤸‍♀️🤸‍♀🤸🏻‍♀️🤸🏻‍♀🤸🏼‍♀️🤸🏼‍♀🤸🏽‍♀️🤸🏽‍♀🤸🏾‍♀️🤸🏾‍♀🤸🏿‍♀️🤸🏿‍♀🤼🤼‍♂️🤼‍♂🤼‍♀️🤼‍♀🤽🤽🏻🤽🏼🤽🏽🤽🏾🤽🏿🤽‍♂️🤽‍♂🤽🏻‍♂️🤽🏻‍♂🤽🏼‍♂️🤽🏼‍♂🤽🏽‍♂️🤽🏽‍♂🤽🏾‍♂️🤽🏾‍♂🤽🏿‍♂️🤽🏿‍♂🤽‍♀️🤽‍♀🤽🏻‍♀️🤽🏻‍♀🤽🏼‍♀️🤽🏼‍♀🤽🏽‍♀️🤽🏽‍♀🤽🏾‍♀️🤽🏾‍♀🤽🏿‍♀️🤽🏿‍♀🤾🤾🏻🤾🏼🤾🏽🤾🏾🤾🏿🤾‍♂️🤾‍♂🤾🏻‍♂️🤾🏻‍♂🤾🏼‍♂️🤾🏼‍♂🤾🏽‍♂️🤾🏽‍♂🤾🏾‍♂️🤾🏾‍♂🤾🏿‍♂️🤾🏿‍♂🤾‍♀️🤾‍♀🤾🏻‍♀️🤾🏻‍♀🤾🏼‍♀️🤾🏼‍♀🤾🏽‍♀️🤾🏽‍♀🤾🏾‍♀️🤾🏾‍♀🤾🏿‍♀️🤾🏿‍♀🤹🤹🏻🤹🏼🤹🏽🤹🏾🤹🏿🤹‍♂️🤹‍♂🤹🏻‍♂️🤹🏻‍♂🤹🏼‍♂️🤹🏼‍♂🤹🏽‍♂️🤹🏽‍♂🤹🏾‍♂️🤹🏾‍♂🤹🏿‍♂️🤹🏿‍♂🤹‍♀️🤹‍♀🤹🏻‍♀️🤹🏻‍♀🤹🏼‍♀️🤹🏼‍♀🤹🏽‍♀️🤹🏽‍♀🤹🏾‍♀️🤹🏾‍♀🤹🏿‍♀️🤹🏿‍♀👫👬👭💏👩‍❤️‍💋‍👨👩‍❤‍💋‍👨👨‍❤️‍💋‍👨👨‍❤‍💋‍👨👩‍❤️‍💋‍👩👩‍❤‍💋‍👩💑👩‍❤️‍👨👩‍❤‍👨👨‍❤️‍👨👨‍❤‍👨👩‍❤️‍👩👩‍❤‍👩👪👨‍👩‍👦👨‍👩‍👧👨‍👩‍👧‍👦👨‍👩‍👦‍👦👨‍👩‍👧‍👧👨‍👨‍👦👨‍👨‍👧👨‍👨‍👧‍👦👨‍👨‍👦‍👦👨‍👨‍👧‍👧👩‍👩‍👦👩‍👩‍👧👩‍👩‍👧‍👦👩‍👩‍👦‍👦👩‍👩‍👧‍👧👨‍👦👨‍👦‍👦👨‍👧👨‍👧‍👦👨‍👧‍👧👩‍👦👩‍👦‍👦👩‍👧👩‍👧‍👦👩‍👧‍👧🤳🤳🏻🤳🏼🤳🏽🤳🏾🤳🏿💪💪🏻💪🏼💪🏽💪🏾💪🏿🦵🦵🏻🦵🏼🦵🏽🦵🏾🦵🏿🦶🦶🏻🦶🏼🦶🏽🦶🏾🦶🏿👈👈🏻👈🏼👈🏽👈🏾👈🏿👉👉🏻👉🏼👉🏽👉🏾👉🏿☝️☝☝🏻☝🏼☝🏽☝🏾☝🏿👆👆🏻👆🏼👆🏽👆🏾👆🏿🖕🖕🏻🖕🏼🖕🏽🖕🏾🖕🏿👇👇🏻👇🏼👇🏽👇🏾👇🏿✌️✌✌🏻✌🏼✌🏽✌🏾✌🏿🤞🤞🏻🤞🏼🤞🏽🤞🏾🤞🏿🖖🖖🏻🖖🏼🖖🏽🖖🏾🖖🏿🤘🤘🏻🤘🏼🤘🏽🤘🏾🤘🏿🤙🤙🏻🤙🏼🤙🏽🤙🏾🤙🏿🖐️🖐🖐🏻🖐🏼🖐🏽🖐🏾🖐🏿✋✋🏻✋🏼✋🏽✋🏾✋🏿👌👌🏻👌🏼👌🏽👌🏾👌🏿👍👍🏻👍🏼👍🏽👍🏾👍🏿👎👎🏻👎🏼👎🏽👎🏾👎🏿✊✊🏻✊🏼✊🏽✊🏾✊🏿👊👊🏻👊🏼👊🏽👊🏾👊🏿🤛🤛🏻🤛🏼🤛🏽🤛🏾🤛🏿🤜🤜🏻🤜🏼🤜🏽🤜🏾🤜🏿🤚🤚🏻🤚🏼🤚🏽🤚🏾🤚🏿👋👋🏻👋🏼👋🏽👋🏾👋🏿🤟🤟🏻🤟🏼🤟🏽🤟🏾🤟🏿✍️✍✍🏻✍🏼✍🏽✍🏾✍🏿👏👏🏻👏🏼👏🏽👏🏾👏🏿👐👐🏻👐🏼👐🏽👐🏾👐🏿🙌🙌🏻🙌🏼🙌🏽🙌🏾🙌🏿🤲🤲🏻🤲🏼🤲🏽🤲🏾🤲🏿🙏🙏🏻🙏🏼🙏🏽🙏🏾🙏🏿🤝💅💅🏻💅🏼💅🏽💅🏾💅🏿👂👂🏻👂🏼👂🏽👂🏾👂🏿👃👃🏻👃🏼👃🏽👃🏾👃🏿🦰🦱🦲🦳👣👀👁️👁👁️‍🗨️👁‍🗨️👁️‍🗨👁‍🗨🧠🦴🦷👅👄💋💘❤️❤💓💔💕💖💗💙💚💛🧡💜🖤💝💞💟❣️❣💌💤💢💣💥💦💨💫💬🗨️🗨🗯️🗯💭🕳️🕳👓🕶️🕶🥽🥼👔👕👖🧣🧤🧥🧦👗👘👙👚👛👜👝🛍️🛍🎒👞👟🥾🥿👠👡👢👑👒🎩🎓🧢⛑️⛑📿💄💍💎🐵🐒🦍🐶🐕🐩🐺🦊🦝🐱🐈🦁🐯🐅🐆🐴🐎🦄🦓🦌🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🦙🦒🐘🦏🦛🐭🐁🐀🐹🐰🐇🐿️🐿🦔🦇🐻🐨🐼🦘🦡🐾🦃🐔🐓🐣🐤🐥🐦🐧🕊️🕊🦅🦆🦢🦉🦚🦜🐸🐊🐢🦎🐍🐲🐉🦕🦖🐳🐋🐬🐟🐠🐡🦈🐙🐚🦀🦞🦐🦑🐌🦋🐛🐜🐝🐞🦗🕷️🕷🕸️🕸🦂🦟🦠💐🌸💮🏵️🏵🌹🥀🌺🌻🌼🌷🌱🌲🌳🌴🌵🌾🌿☘️☘🍀🍁🍂🍃🍇🍈🍉🍊🍋🍌🍍🥭🍎🍏🍐🍑🍒🍓🥝🍅🥥🥑🍆🥔🥕🌽🌶️🌶🥒🥬🥦🍄🥜🌰🍞🥐🥖🥨🥯🥞🧀🍖🍗🥩🥓🍔🍟🍕🌭🥪🌮🌯🥙🥚🍳🥘🍲🥣🥗🍿🧂🥫🍱🍘🍙🍚🍛🍜🍝🍠🍢🍣🍤🍥🥮🍡🥟🥠🥡🍦🍧🍨🍩🍪🎂🍰🧁🥧🍫🍬🍭🍮🍯🍼🥛☕🍵🍶🍾🍷🍸🍹🍺🍻🥂🥃🥤🥢🍽️🍽🍴🥄🔪🏺🌍🌎🌏🌐🗺️🗺🗾🧭🏔️🏔⛰️⛰🌋🗻🏕️🏕🏖️🏖🏜️🏜🏝️🏝🏞️🏞🏟️🏟🏛️🏛🏗️🏗🧱🏘️🏘🏚️🏚🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪🕌🕍⛩️⛩🕋⛲⛺🌁🌃🏙️🏙🌄🌅🌆🌇🌉♨️♨🌌🎠🎡🎢💈🎪🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🚚🚛🚜🚲🛴🛹🛵🚏🛣️🛣🛤️🛤🛢️🛢⛽🚨🚥🚦🛑🚧⚓⛵🛶🚤🛳️🛳⛴️⛴🛥️🛥🚢✈️✈🛩️🛩🛫🛬💺🚁🚟🚠🚡🛰️🛰🚀🛸🛎️🛎🧳⌛⏳⌚⏰⏱️⏱⏲️⏲🕰️🕰🕛🕧🕐🕜🕑🕝🕒🕞🕓🕟🕔🕠🕕🕡🕖🕢🕗🕣🕘🕤🕙🕥🕚🕦🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌡️🌡☀️☀🌝🌞⭐🌟🌠☁️☁⛅⛈️⛈🌤️🌤🌥️🌥🌦️🌦🌧️🌧🌨️🌨🌩️🌩🌪️🌪🌫️🌫🌬️🌬🌀🌈🌂☂️☂☔⛱️⛱⚡❄️❄☃️☃⛄☄️☄🔥💧🌊🎃🎄🎆🎇🧨✨🎈🎉🎊🎋🎍🎎🎏🎐🎑🧧🎀🎁🎗️🎗🎟️🎟🎫🎖️🎖🏆🏅🥇🥈🥉⚽⚾🥎🏀🏐🏈🏉🎾🥏🎳🏏🏑🏒🥍🏓🏸🥊🥋🥅⛳⛸️⛸🎣🎽🎿🛷🥌🎯🎱🔮🧿🎮🕹️🕹🎰🎲🧩🧸♠️♠♥️♥♦️♦♣️♣♟️♟🃏🀄🎴🎭🖼️🖼🎨🧵🧶🔇🔈🔉🔊📢📣📯🔔🔕🎼🎵🎶🎙️🎙🎚️🎚🎛️🎛🎤🎧📻🎷🎸🎹🎺🎻🥁📱📲☎️☎📞📟📠🔋🔌💻🖥️🖥🖨️🖨⌨️⌨🖱️🖱🖲️🖲💽💾💿📀🧮🎥🎞️🎞📽️📽🎬📺📷📸📹📼🔍🔎🕯️🕯💡🔦🏮📔📕📖📗📘📙📚📓📒📃📜📄📰🗞️🗞📑🔖🏷️🏷💰💴💵💶💷💸💳🧾💹💱💲✉️✉📧📨📩📤📥📦📫📪📬📭📮🗳️🗳✏️✏✒️✒🖋️🖋🖊️🖊🖌️🖌🖍️🖍📝💼📁📂🗂️🗂📅📆🗒️🗒🗓️🗓📇📈📉📊📋📌📍📎🖇️🖇📏📐✂️✂🗃️🗃🗄️🗄🗑️🗑🔒🔓🔏🔐🔑🗝️🗝🔨⛏️⛏⚒️⚒🛠️🛠🗡️🗡⚔️⚔🔫🏹🛡️🛡🔧🔩⚙️⚙🗜️🗜⚖️⚖🔗⛓️⛓🧰🧲⚗️⚗🧪🧫🧬🔬🔭📡💉💊🚪🛏️🛏🛋️🛋🚽🚿🛁🧴🧷🧹🧺🧻🧼🧽🧯🛒🚬⚰️⚰⚱️⚱🗿🏧🚮🚰♿🚹🚺🚻🚼🚾🛂🛃🛄🛅⚠️⚠🚸⛔🚫🚳🚭🚯🚱🚷📵🔞☢️☢☣️☣⬆️⬆↗️↗➡️➡↘️↘⬇️⬇↙️↙⬅️⬅↖️↖↕️↕↔️↔↩️↩↪️↪⤴️⤴⤵️⤵🔃🔄🔙🔚🔛🔜🔝🛐⚛️⚛🕉️🕉✡️✡☸️☸☯️☯✝️✝☦️☦☪️☪☮️☮🕎🔯♈♉♊♋♌♍♎♏♐♑♒♓⛎🔀🔁🔂▶️▶⏩⏭️⏭⏯️⏯◀️◀⏪⏮️⏮🔼⏫🔽⏬⏸️⏸⏹️⏹⏺️⏺⏏️⏏🎦🔅🔆📶📳📴♀️♀♂️♂⚕️⚕♾️♾♻️♻⚜️⚜🔱📛🔰⭕✅☑️☑✔️✔✖️✖❌❎➕➖➗➰➿〽️〽✳️✳✴️✴❇️❇‼️‼⁉️⁉❓❔❕❗〰️〰©️©®️®™️™#️⃣#⃣*️⃣*⃣0️⃣0⃣1️⃣1⃣2️⃣2⃣3️⃣3⃣4️⃣4⃣5️⃣5⃣6️⃣6⃣7️⃣7⃣8️⃣8⃣9️⃣9⃣🔟💯🔠🔡🔢🔣🔤🅰️🅰🆎🅱️🅱🆑🆒🆓ℹ️ℹ🆔Ⓜ️Ⓜ🆕🆖🅾️🅾🆗🅿️🅿🆘🆙🆚🈁🈂️🈂🈷️🈷🈶🈯🉐🈹🈚🈲🉑🈸🈴🈳㊗️㊗㊙️㊙🈺🈵▪️▪▫️▫◻️◻◼️◼◽◾⬛⬜🔶🔷🔸🔹🔺🔻💠🔘🔲🔳⚪⚫🔴🔵🏁🚩🎌🏴🏳️🏳🏳️‍🌈🏳‍🌈🏴‍☠️🏴‍☠🇦🇨🇦🇩🇦🇪🇦🇫🇦🇬🇦🇮🇦🇱🇦🇲🇦🇴🇦🇶🇦🇷🇦🇸🇦🇹🇦🇺🇦🇼🇦🇽🇦🇿🇧🇦🇧🇧🇧🇩🇧🇪🇧🇫🇧🇬🇧🇭🇧🇮🇧🇯🇧🇱🇧🇲🇧🇳🇧🇴🇧🇶🇧🇷🇧🇸🇧🇹🇧🇻🇧🇼🇧🇾🇧🇿🇨🇦🇨🇨🇨🇩🇨🇫🇨🇬🇨🇭🇨🇮🇨🇰🇨🇱🇨🇲🇨🇳🇨🇴🇨🇵🇨🇷🇨🇺🇨🇻🇨🇼🇨🇽🇨🇾🇨🇿🇩🇪🇩🇬🇩🇯🇩🇰🇩🇲🇩🇴🇩🇿🇪🇦🇪🇨🇪🇪🇪🇬🇪🇭🇪🇷🇪🇸🇪🇹🇪🇺🇫🇮🇫🇯🇫🇰🇫🇲🇫🇴🇫🇷🇬🇦🇬🇧🇬🇩🇬🇪🇬🇫🇬🇬🇬🇭🇬🇮🇬🇱🇬🇲🇬🇳🇬🇵🇬🇶🇬🇷🇬🇸🇬🇹🇬🇺🇬🇼🇬🇾🇭🇰🇭🇲🇭🇳🇭🇷🇭🇹🇭🇺🇮🇨🇮🇩🇮🇪🇮🇱🇮🇲🇮🇳🇮🇴🇮🇶🇮🇷🇮🇸🇮🇹🇯🇪🇯🇲🇯🇴🇯🇵🇰🇪🇰🇬🇰🇭🇰🇮🇰🇲🇰🇳🇰🇵🇰🇷🇰🇼🇰🇾🇰🇿🇱🇦🇱🇧🇱🇨🇱🇮🇱🇰🇱🇷🇱🇸🇱🇹🇱🇺🇱🇻🇱🇾🇲🇦🇲🇨🇲🇩🇲🇪🇲🇫🇲🇬🇲🇭🇲🇰🇲🇱🇲🇲🇲🇳🇲🇴🇲🇵🇲🇶🇲🇷🇲🇸🇲🇹🇲🇺🇲🇻🇲🇼🇲🇽🇲🇾🇲🇿🇳🇦🇳🇨🇳🇪🇳🇫🇳🇬🇳🇮🇳🇱🇳🇴🇳🇵🇳🇷🇳🇺🇳🇿🇴🇲🇵🇦🇵🇪🇵🇫🇵🇬🇵🇭🇵🇰🇵🇱🇵🇲🇵🇳🇵🇷🇵🇸🇵🇹🇵🇼🇵🇾🇶🇦🇷🇪🇷🇴🇷🇸🇷🇺🇷🇼🇸🇦🇸🇧🇸🇨🇸🇩🇸🇪🇸🇬🇸🇭🇸🇮🇸🇯🇸🇰🇸🇱🇸🇲🇸🇳🇸🇴🇸🇷🇸🇸🇸🇹🇸🇻🇸🇽🇸🇾🇸🇿🇹🇦🇹🇨🇹🇩🇹🇫🇹🇬🇹🇭🇹🇯🇹🇰🇹🇱🇹🇲🇹🇳🇹🇴🇹🇷🇹🇹🇹🇻🇹🇼🇹🇿🇺🇦🇺🇬🇺🇲🇺🇳🇺🇸🇺🇾🇺🇿🇻🇦🇻🇨🇻🇪🇻🇬🇻🇮🇻🇳🇻🇺🇼🇫🇼🇸🇽🇰🇾🇪🇾🇹🇿🇦🇿🇲🇿🇼🏴󠁧󠁢󠁥󠁮󠁧󠁿🏴󠁧󠁢󠁳󠁣󠁴󠁿🏴󠁧󠁢󠁷󠁬󠁳󠁿\"\n  );\n  expect(() => emoji.parse(\":-)\")).toThrow();\n  expect(() => emoji.parse(\"😀 is an emoji\")).toThrow();\n  expect(() => emoji.parse(\"😀stuff\")).toThrow();\n  expect(() => emoji.parse(\"stuff😀\")).toThrow();\n});\n\ntest(\"nanoid\", () => {\n  const nanoid = z.string().nanoid(\"custom error\");\n  nanoid.parse(\"lfNZluvAxMkf7Q8C5H-QS\");\n  nanoid.parse(\"mIU_4PJWikaU8fMbmkouz\");\n  nanoid.parse(\"Hb9ZUtUa2JDm_dD-47EGv\");\n  nanoid.parse(\"5Noocgv_8vQ9oPijj4ioQ\");\n  const result = nanoid.safeParse(\"Xq90uDyhddC53KsoASYJGX\");\n  expect(result).toMatchObject({ success: false });\n\n  expect(result.error!.issues[0].message).toEqual(\"custom error\");\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"invalid_format\",\n        \"format\": \"nanoid\",\n        \"pattern\": \"/^[a-zA-Z0-9_-]{21}$/\",\n        \"path\": [],\n        \"message\": \"custom error\"\n      }\n    ]]\n  `);\n});\n\ntest(\"bad nanoid\", () => {\n  const nanoid = z.string().nanoid(\"custom error\");\n  nanoid.parse(\"ySh_984wpDUu7IQRrLXAp\");\n  const result = nanoid.safeParse(\"invalid nanoid\");\n  expect(result).toMatchObject({ success: false });\n\n  expect(result.error!.issues[0].message).toEqual(\"custom error\");\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"invalid_format\",\n        \"format\": \"nanoid\",\n        \"pattern\": \"/^[a-zA-Z0-9_-]{21}$/\",\n        \"path\": [],\n        \"message\": \"custom error\"\n      }\n    ]]\n  `);\n});\n\ntest(\"good uuid\", () => {\n  const uuid = z.string().uuid(\"custom error\");\n  const goodUuids = [\n    \"9491d710-3185-1e06-bea0-6a2f275345e0\",\n    \"9491d710-3185-2e06-bea0-6a2f275345e0\",\n    \"9491d710-3185-3e06-bea0-6a2f275345e0\",\n    \"9491d710-3185-4e06-bea0-6a2f275345e0\",\n    \"9491d710-3185-5e06-bea0-6a2f275345e0\",\n    \"9491d710-3185-5e06-aea0-6a2f275345e0\",\n    \"9491d710-3185-5e06-8ea0-6a2f275345e0\",\n    \"9491d710-3185-5e06-9ea0-6a2f275345e0\",\n    \"00000000-0000-0000-0000-000000000000\",\n  ];\n\n  for (const goodUuid of goodUuids) {\n    const result = uuid.safeParse(goodUuid);\n    expect(result.success).toEqual(true);\n  }\n});\n\ntest(`bad uuid`, () => {\n  const uuid = z.string().uuid(\"custom error\");\n  for (const badUuid of [\n    \"9491d710-3185-0e06-bea0-6a2f275345e0\",\n    \"9491d710-3185-5e06-0ea0-6a2f275345e0\",\n    \"d89e7b01-7598-ed11-9d7a-0022489382fd\", // new sequential id\n    \"b3ce60f8-e8b9-40f5-1150-172ede56ff74\", // Variant 0 - RFC 4122: Reserved, NCS backward compatibility\n    \"92e76bf9-28b3-4730-cd7f-cb6bc51f8c09\", // Variant 2 - RFC 4122: Reserved, Microsoft Corporation backward compatibility\n    \"invalid uuid\",\n    \"9491d710-3185-4e06-bea0-6a2f275345e0X\",\n    \"ffffffff-ffff-ffff-ffff-ffffffffffff\",\n  ]) {\n    const result = uuid.safeParse(badUuid);\n    expect(result).toMatchObject({ success: false });\n    expect(result.error?.issues[0].message).toEqual(\"custom error\");\n  }\n});\n\ntest(\"good guid\", () => {\n  const guid = z.string().guid(\"custom error\");\n  for (const goodGuid of [\n    \"9491d710-3185-4e06-bea0-6a2f275345e0\",\n    \"d89e7b01-7598-ed11-9d7a-0022489382fd\", // new sequential id\n    \"b3ce60f8-e8b9-40f5-1150-172ede56ff74\", // Variant 0 - RFC 4122: Reserved, NCS backward compatibility\n    \"92e76bf9-28b3-4730-cd7f-cb6bc51f8c09\", // Variant 2 - RFC 4122: Reserved, Microsoft Corporation backward compatibility\n    \"00000000-0000-0000-0000-000000000000\",\n    \"ffffffff-ffff-ffff-ffff-ffffffffffff\",\n  ]) {\n    const result = guid.safeParse(goodGuid);\n    expect(result.success).toEqual(true);\n  }\n});\n\ntest(\"bad guid\", () => {\n  const guid = z.string().guid(\"custom error\");\n  for (const badGuid of [\"9491d710-3185-4e06-bea0-6a2f275345e0X\"]) {\n    const result = guid.safeParse(badGuid);\n    expect(result).toMatchObject({ success: false });\n    expect(result.error?.issues[0].message).toEqual(\"custom error\");\n  }\n});\n\ntest(\"cuid\", () => {\n  const cuid = z.string().cuid();\n  cuid.parse(\"ckopqwooh000001la8mbi2im9\");\n  const result = cuid.safeParse(\"cifjhdsfhsd-invalid-cuid\");\n  expect(result).toMatchObject({ success: false });\n\n  expect(result.error!.issues[0].message).toEqual(\"Invalid cuid\");\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"invalid_format\",\n        \"format\": \"cuid\",\n        \"pattern\": \"/^[cC][^\\\\\\\\s-]{8,}$/\",\n        \"path\": [],\n        \"message\": \"Invalid cuid\"\n      }\n    ]]\n  `);\n});\n\ntest(\"cuid2\", () => {\n  const cuid2 = z.string().cuid2();\n  const validStrings = [\n    \"a\", // short string\n    \"tz4a98xxat96iws9zmbrgj3a\", // normal string\n    \"kf5vz6ssxe4zjcb409rjgo747tc5qjazgptvotk6\", // longer than require(\"@paralleldrive/cuid2\").bigLength\n  ];\n  for (const s of validStrings) {\n    cuid2.parse(s);\n  }\n\n  const invalidStrings = [\n    \"\", // empty string\n    \"tz4a98xxat96iws9zMbrgj3a\", // include uppercase\n    \"tz4a98xxat96iws-zmbrgj3a\", // involve symbols\n  ];\n  const results = invalidStrings.map((s) => cuid2.safeParse(s));\n  expect(results.every((r) => !r.success)).toEqual(true);\n  if (!results[0].success) {\n    expect(results[0].error.issues[0].message).toEqual(\"Invalid cuid2\");\n  }\n});\n\ntest(\"ulid\", () => {\n  const ulid = z.string().ulid();\n  ulid.parse(\"01ARZ3NDEKTSV4RRFFQ69G5FAV\");\n  const result = ulid.safeParse(\"invalidulid\");\n  expect(result).toMatchObject({ success: false });\n  const tooLong = \"01ARZ3NDEKTSV4RRFFQ69G5FAVA\";\n  expect(ulid.safeParse(tooLong)).toMatchObject({ success: false });\n\n  const caseInsensitive = ulid.safeParse(\"01arZ3nDeKTsV4RRffQ69G5FAV\");\n  expect(caseInsensitive.success).toEqual(true);\n\n  expect(result.error!.issues[0].message).toEqual(\"Invalid ULID\");\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"invalid_format\",\n        \"format\": \"ulid\",\n        \"pattern\": \"/^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/\",\n        \"path\": [],\n        \"message\": \"Invalid ULID\"\n      }\n    ]]\n  `);\n});\n\ntest(\"xid\", () => {\n  const xid = z.string().xid();\n  xid.parse(\"9m4e2mr0ui3e8a215n4g\");\n  const result = xid.safeParse(\"invalidxid\");\n  expect(result).toMatchObject({ success: false });\n\n  expect(result.error!.issues[0].message).toEqual(\"Invalid XID\");\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"string\",\n        \"code\": \"invalid_format\",\n        \"format\": \"xid\",\n        \"pattern\": \"/^[0-9a-vA-V]{20}$/\",\n        \"path\": [],\n        \"message\": \"Invalid XID\"\n      }\n    ]]\n  `);\n});\n\ntest(\"ksuid\", () => {\n  const ksuid = z.string().ksuid();\n  ksuid.parse(\"0o0t9hkGxgFLtd3lmJ4TSTeY0Vb\");\n  const result = ksuid.safeParse(\"invalidksuid\");\n  expect(result).toMatchObject({ success: false });\n  const tooLong = \"0o0t9hkGxgFLtd3lmJ4TSTeY0VbA\";\n  expect(ksuid.safeParse(tooLong)).toMatchObject({ success: false });\n  expect(result.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"ksuid\",\n        \"message\": \"Invalid KSUID\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^[A-Za-z0-9]{27}$/\",\n      },\n    ]\n  `);\n});\n\ntest(\"regex\", () => {\n  z.string()\n    .regex(/^moo+$/)\n    .parse(\"mooooo\");\n  expect(() => z.string().uuid().parse(\"purr\")).toThrow();\n});\n\ntest(\"regexp error message\", () => {\n  const result = z\n    .string()\n    .regex(/^moo+$/)\n    .safeParse(\"boooo\");\n  expect(result.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"regex\",\n        \"message\": \"Invalid string: must match pattern /^moo+$/\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^moo+$/\",\n      },\n    ]\n  `);\n\n  expect(() => z.string().uuid().parse(\"purr\")).toThrow();\n});\n\ntest(\"regexp error custom message\", () => {\n  const result = z\n    .string()\n    .regex(/^moo+$/, { message: \"Custom error message\" })\n    .safeParse(\"boooo\");\n  expect(result.error!.issues).toMatchInlineSnapshot(`\n    [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"regex\",\n        \"message\": \"Custom error message\",\n        \"origin\": \"string\",\n        \"path\": [],\n        \"pattern\": \"/^moo+$/\",\n      },\n    ]\n  `);\n\n  expect(() => z.string().uuid().parse(\"purr\")).toThrow();\n});\n\ntest(\"regex lastIndex reset\", () => {\n  const schema = z.string().regex(/^\\d+$/g);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n  expect(schema.safeParse(\"123\").success).toEqual(true);\n});\n\ntest(\"format\", () => {\n  expect(z.string().email().format).toEqual(\"email\");\n  expect(z.string().url().format).toEqual(\"url\");\n  expect(z.string().jwt().format).toEqual(\"jwt\");\n  expect(z.string().emoji().format).toEqual(\"emoji\");\n  expect(z.string().guid().format).toEqual(\"guid\");\n  expect(z.string().uuid().format).toEqual(\"uuid\");\n  expect(z.string().uuidv4().format).toEqual(\"uuid\");\n  expect(z.string().uuidv6().format).toEqual(\"uuid\");\n  expect(z.string().uuidv7().format).toEqual(\"uuid\");\n  expect(z.string().nanoid().format).toEqual(\"nanoid\");\n  expect(z.string().guid().format).toEqual(\"guid\");\n  expect(z.string().cuid().format).toEqual(\"cuid\");\n  expect(z.string().cuid2().format).toEqual(\"cuid2\");\n  expect(z.string().ulid().format).toEqual(\"ulid\");\n  expect(z.string().base64().format).toEqual(\"base64\");\n  // expect(z.string().jsonString().format).toEqual(\"json_string\");\n  // expect(z.string().json().format).toEqual(\"json_string\");\n  expect(z.string().xid().format).toEqual(\"xid\");\n  expect(z.string().ksuid().format).toEqual(\"ksuid\");\n  // expect(z.string().ip().format).toEqual(\"ip\");\n  expect(z.string().ipv4().format).toEqual(\"ipv4\");\n  expect(z.string().ipv6().format).toEqual(\"ipv6\");\n  expect(z.string().e164().format).toEqual(\"e164\");\n  expect(z.string().datetime().format).toEqual(\"datetime\");\n  expect(z.string().date().format).toEqual(\"date\");\n  expect(z.string().time().format).toEqual(\"time\");\n  expect(z.string().duration().format).toEqual(\"duration\");\n});\n\ntest(\"min max getters\", () => {\n  expect(z.string().min(5).minLength).toEqual(5);\n  expect(z.string().min(5).min(10).minLength).toEqual(10);\n  expect(z.string().minLength).toEqual(null);\n\n  expect(z.string().max(5).maxLength).toEqual(5);\n  expect(z.string().max(5).max(1).maxLength).toEqual(1);\n  expect(z.string().max(5).max(10).maxLength).toEqual(5);\n  expect(z.string().maxLength).toEqual(null);\n});\n\ntest(\"trim\", () => {\n  expect(z.string().trim().min(2).parse(\" 12 \")).toEqual(\"12\");\n\n  // ordering of methods is respected\n  expect(z.string().min(2).trim().parse(\" 1 \")).toEqual(\"1\");\n  expect(() => z.string().trim().min(2).parse(\" 1 \")).toThrow();\n});\n\ntest(\"lowerCase\", () => {\n  expect(z.string().toLowerCase().parse(\"ASDF\")).toEqual(\"asdf\");\n  expect(z.string().toUpperCase().parse(\"asdf\")).toEqual(\"ASDF\");\n});\n\n// test(\"IP validation\", () => {\n//   const ipSchema = z.string().ip();\n\n//   // General IP validation (accepts both v4 and v6)\n//   expect(ipSchema.safeParse(\"114.71.82.94\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"0.0.0.0\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"37.85.236.115\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"1e5e:e6c8:daac:514b:114b:e360:d8c0:682c\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"9d4:c956:420f:5788:4339:9b3b:2418:75c3\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"a6ea::2454:a5ce:94.105.123.75\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"474f:4c83::4e40:a47:ff95:0cda\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"d329:0:25b4:db47:a9d1:0:4926:0000\").success).toBe(true);\n//   expect(ipSchema.safeParse(\"e48:10fb:1499:3e28:e4b6:dea5:4692:912c\").success).toBe(true);\n\n//   expect(ipSchema.safeParse(\"d329:1be4:25b4:db47:a9d1:dc71:4926:992c:14af\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"d5e7:7214:2b78::3906:85e6:53cc:709:32ba\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"8f69::c757:395e:976e::3441\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"54cb::473f:d516:0.255.256.22\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"54cb::473f:d516:192.168.1\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"256.0.4.4\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"-1.0.555.4\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"0.0.0.0.0\").success).toBe(false);\n//   expect(ipSchema.safeParse(\"1.1.1\").success).toBe(false);\n// });\n\ntest(\"IPv4 validation\", () => {\n  const ipv4 = z.string().ipv4();\n\n  // Valid IPv4 addresses\n  expect(ipv4.safeParse(\"114.71.82.94\").success).toBe(true);\n  expect(ipv4.safeParse(\"0.0.0.0\").success).toBe(true);\n  expect(ipv4.safeParse(\"37.85.236.115\").success).toBe(true);\n  expect(ipv4.safeParse(\"192.168.0.1\").success).toBe(true);\n  expect(ipv4.safeParse(\"255.255.255.255\").success).toBe(true);\n  expect(ipv4.safeParse(\"1.2.3.4\").success).toBe(true);\n\n  // Invalid IPv4 addresses\n  expect(ipv4.safeParse(\"256.0.4.4\").success).toBe(false);\n  expect(ipv4.safeParse(\"-1.0.555.4\").success).toBe(false);\n  expect(ipv4.safeParse(\"0.0.0.0.0\").success).toBe(false);\n  expect(ipv4.safeParse(\"1.1.1\").success).toBe(false);\n  expect(ipv4.safeParse(\"1e5e:e6c8:daac:514b:114b:e360:d8c0:682c\").success).toBe(false);\n  expect(ipv4.safeParse(\"a6ea::2454:a5ce:94.105.123.75\").success).toBe(false);\n  expect(ipv4.safeParse(\"not an ip\").success).toBe(false);\n  expect(ipv4.safeParse(\"1.2.3\").success).toBe(false);\n  expect(ipv4.safeParse(\"1.2.3.4.5\").success).toBe(false);\n  expect(ipv4.safeParse(\"1.2.3.256\").success).toBe(false);\n\n  // Test specific error\n  expect(() => ipv4.parse(\"6097:adfa:6f0b:220d:db08:5021:6191:7990\")).toThrow();\n});\n\ntest(\"IPv6 validation\", () => {\n  const ipv6 = z.string().ipv6();\n\n  // Valid IPv6 addresses\n  expect(ipv6.safeParse(\"1e5e:e6c8:daac:514b:114b:e360:d8c0:682c\").success).toBe(true);\n  expect(ipv6.safeParse(\"9d4:c956:420f:5788:4339:9b3b:2418:75c3\").success).toBe(true);\n  expect(ipv6.safeParse(\"a6ea::2454:a5ce:94.105.123.75\").success).toBe(true);\n  expect(ipv6.safeParse(\"474f:4c83::4e40:a47:ff95:0cda\").success).toBe(true);\n  expect(ipv6.safeParse(\"d329:0:25b4:db47:a9d1:0:4926:0000\").success).toBe(true);\n  expect(ipv6.safeParse(\"e48:10fb:1499:3e28:e4b6:dea5:4692:912c\").success).toBe(true);\n  expect(ipv6.safeParse(\"::1\").success).toBe(true);\n  expect(ipv6.safeParse(\"2001:db8::\").success).toBe(true);\n  expect(ipv6.safeParse(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\").success).toBe(true);\n  expect(ipv6.safeParse(\"2001:db8::192.168.0.1\").success).toBe(true);\n  expect(ipv6.safeParse(\"::ffff:192.168.0.1\").success).toBe(true);\n  expect(ipv6.safeParse(\"::ffff:c000:0280\").success).toBe(true); // IPv4-mapped IPv6 address\n  expect(ipv6.safeParse(\"64:ff9b::192.168.0.1\").success).toBe(true); // IPv4/IPv6 translation\n\n  // Invalid IPv6 addresses\n  expect(ipv6.safeParse(\"d329:1be4:25b4:db47:a9d1:dc71:4926:992c:14af\").success).toBe(false);\n  expect(ipv6.safeParse(\"d5e7:7214:2b78::3906:85e6:53cc:709:32ba\").success).toBe(false);\n  expect(ipv6.safeParse(\"8f69::c757:395e:976e::3441\").success).toBe(false);\n  expect(ipv6.safeParse(\"54cb::473f:d516:0.255.256.22\").success).toBe(false);\n  expect(ipv6.safeParse(\"54cb::473f:d516:192.168.1\").success).toBe(false);\n  expect(ipv6.safeParse(\"114.71.82.94\").success).toBe(false);\n  expect(ipv6.safeParse(\"not an ip\").success).toBe(false);\n  expect(ipv6.safeParse(\"g123::1234:5678\").success).toBe(false);\n\n  // Test specific error\n  expect(() => ipv6.parse(\"254.164.77.1\")).toThrow();\n});\n\ntest(\"CIDR v4 validation\", () => {\n  const cidrV4 = z.string().cidrv4();\n\n  // Valid CIDR v4 addresses\n  expect(cidrV4.safeParse(\"192.168.0.0/24\").success).toBe(true);\n  expect(cidrV4.safeParse(\"10.0.0.0/8\").success).toBe(true);\n  expect(cidrV4.safeParse(\"172.16.0.0/12\").success).toBe(true);\n  expect(cidrV4.safeParse(\"0.0.0.0/0\").success).toBe(true);\n  expect(cidrV4.safeParse(\"255.255.255.255/32\").success).toBe(true);\n\n  // Invalid CIDR v4 addresses\n  expect(cidrV4.safeParse(\"192.168.0.0\").success).toBe(false); // Missing prefix\n  expect(cidrV4.safeParse(\"192.168.0.0/33\").success).toBe(false); // Invalid prefix length\n  expect(cidrV4.safeParse(\"256.0.0.0/24\").success).toBe(false); // Invalid IP\n  expect(cidrV4.safeParse(\"192.168.0.0/-1\").success).toBe(false); // Negative prefix length\n  expect(cidrV4.safeParse(\"not a cidr\").success).toBe(false); // Invalid format\n});\n\ntest(\"CIDR v6 validation\", () => {\n  const cidrV6 = z.string().cidrv6();\n\n  // Valid CIDR v6 addresses\n  expect(cidrV6.safeParse(\"2001:db8::/32\").success).toBe(true);\n  expect(cidrV6.safeParse(\"::/0\").success).toBe(true);\n  expect(cidrV6.safeParse(\"fe80::/10\").success).toBe(true);\n  expect(cidrV6.safeParse(\"::1/128\").success).toBe(true);\n  expect(cidrV6.safeParse(\"2001:0db8:85a3::/64\").success).toBe(true);\n\n  // Invalid CIDR v6 addresses\n  expect(cidrV6.safeParse(\"2001:db8::\").success).toBe(false); // Missing prefix\n  expect(cidrV6.safeParse(\"2001:db8::/129\").success).toBe(false); // Invalid prefix length\n  expect(cidrV6.safeParse(\"2001:db8::/abc\").success).toBe(false); // Invalid prefix format\n  expect(cidrV6.safeParse(\"not a cidr\").success).toBe(false); // Invalid format\n  expect(cidrV6.safeParse(\"192.168.0.0/24\").success).toBe(false); // IPv4 CIDR in v6 validation\n});\n\ntest(\"E.164 validation\", () => {\n  const e164Number = z.string().e164();\n  expect(e164Number.safeParse(\"+1555555\").success).toBe(true);\n\n  const validE164Numbers = [\n    \"+1555555\", // min-length (7 digits + '+')\n    \"+15555555\",\n    \"+155555555\",\n    \"+1555555555\",\n    \"+15555555555\",\n    \"+155555555555\",\n    \"+1555555555555\",\n    \"+15555555555555\",\n    \"+155555555555555\",\n    \"+105555555555555\",\n    \"+100555555555555\", // max-length (15 digits + '+')\n  ];\n\n  const invalidE164Numbers = [\n    \"\", // empty\n    \"+\", // only plus sign\n    \"-\", // wrong sign\n    \" 555555555\", // starts with space\n    \"555555555\", // missing plus sign\n    \"+1 555 555 555\", // space after plus sign\n    \"+1555 555 555\", // space between numbers\n    \"+1555+555\", // multiple plus signs\n    \"+1555555555555555\", // too long\n    \"+115abc55\", // non numeric characters in number part\n    \"+1555555 \", // space after number\n  ];\n\n  expect(validE164Numbers.every((number) => e164Number.safeParse(number).success)).toBe(true);\n  expect(invalidE164Numbers.every((number) => e164Number.safeParse(number).success === false)).toBe(true);\n});\n",
    "symbols": [
      {
        "name": "makeJwt",
        "kind": "function",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/classic/tests/string.test.ts",
        "startLine": 267,
        "endLine": 272
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/stringbool.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"z.stringbool\", () => {\n  const a = z.stringbool();\n  type a = z.infer<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<boolean>();\n  type a_in = z.input<typeof a>;\n  expectTypeOf<a_in>().toEqualTypeOf<string>();\n\n  expect(z.parse(a, \"true\")).toEqual(true);\n  expect(z.parse(a, \"yes\")).toEqual(true);\n  expect(z.parse(a, \"1\")).toEqual(true);\n  expect(z.parse(a, \"on\")).toEqual(true);\n  expect(z.parse(a, \"y\")).toEqual(true);\n  expect(z.parse(a, \"enabled\")).toEqual(true);\n  expect(z.parse(a, \"TRUE\")).toEqual(true);\n\n  expect(z.parse(a, \"false\")).toEqual(false);\n  expect(z.parse(a, \"no\")).toEqual(false);\n  expect(z.parse(a, \"0\")).toEqual(false);\n  expect(z.parse(a, \"off\")).toEqual(false);\n  expect(z.parse(a, \"n\")).toEqual(false);\n  expect(z.parse(a, \"disabled\")).toEqual(false);\n  expect(z.parse(a, \"FALSE\")).toEqual(false);\n\n  expect(z.safeParse(a, \"other\")).toMatchObject({ success: false });\n  expect(z.safeParse(a, \"\")).toMatchObject({ success: false });\n  expect(z.safeParse(a, undefined)).toMatchObject({ success: false });\n  expect(z.safeParse(a, {})).toMatchObject({ success: false });\n  expect(z.safeParse(a, true)).toMatchObject({ success: false });\n  expect(z.safeParse(a, false)).toMatchObject({ success: false });\n});\n\ntest(\"custom values\", () => {\n  const b = z.stringbool({\n    truthy: [\"y\"],\n    falsy: [\"N\"],\n  });\n  expect(z.parse(b, \"y\")).toEqual(true);\n  expect(z.parse(b, \"Y\")).toEqual(true);\n  expect(z.parse(b, \"n\")).toEqual(false);\n  expect(z.parse(b, \"N\")).toEqual(false);\n  expect(z.safeParse(b, \"true\")).toMatchObject({ success: false });\n  expect(z.safeParse(b, \"false\")).toMatchObject({ success: false });\n});\n\ntest(\"custom values - case sensitive\", () => {\n  const c = z.stringbool({\n    truthy: [\"y\"],\n    falsy: [\"N\"],\n    case: \"sensitive\",\n  });\n  expect(z.parse(c, \"y\")).toEqual(true);\n  expect(z.safeParse(c, \"Y\")).toMatchObject({ success: false });\n  expect(z.parse(c, \"N\")).toEqual(false);\n  expect(z.safeParse(c, \"n\")).toMatchObject({ success: false });\n  expect(z.safeParse(c, \"TRUE\")).toMatchObject({ success: false });\n});\n\n// test custom error messages\ntest(\"z.stringbool with custom error messages\", () => {\n  const a = z.stringbool(\"wrong!\");\n\n  expect(() => a.parse(\"\")).toThrowError(\"wrong!\");\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/template-literal.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\nconst empty = z.templateLiteral([]);\nconst hello = z.templateLiteral([\"hello\"]);\nconst world = z.templateLiteral([\"\", z.literal(\"world\")]);\nconst one = z.templateLiteral([1]);\nconst two = z.templateLiteral([\"\", z.literal(2)]);\nconst truee = z.templateLiteral([true]);\nconst anotherTrue = z.templateLiteral([\"\", z.literal(true)]);\nconst falsee = z.templateLiteral([false]);\nconst anotherFalse = z.templateLiteral([\"\", z.literal(false)]);\nconst nulll = z.templateLiteral([null]);\nconst anotherNull = z.templateLiteral([\"\", z.null()]);\nconst undefinedd = z.templateLiteral([undefined]);\nconst anotherUndefined = z.templateLiteral([\"\", z.undefined()]);\nconst anyString = z.templateLiteral([\"\", z.string()]);\nconst lazyString = z.templateLiteral([\"\", z.lazy(() => z.string())]);\nconst anyNumber = z.templateLiteral([\"\", z.number()]);\nconst anyInt = z.templateLiteral([\"\", z.number().int()]);\n// const anyFiniteNumber = z.templateLiteral([\"\", z.number().finite()]);\n// const anyNegativeNumber = z.templateLiteral([\"\", z.number().negative()]);\n// const anyPositiveNumber = z.templateLiteral([\"\", z.number().positive()]);\n// const zeroButInADumbWay = z.templateLiteral([\"\", z.number().nonnegative().nonpositive()]);\n// const finiteButInADumbWay = z.templateLiteral([\"\", z.number().min(5).max(10)]);\nconst bool = z.templateLiteral([\"\", z.boolean()]);\nconst bigone = z.templateLiteral([\"\", z.literal(BigInt(1))]);\nconst anyBigint = z.templateLiteral([\"\", z.bigint()]);\nconst nullableYo = z.templateLiteral([\"\", z.nullable(z.literal(\"yo\"))]);\nconst nullableString = z.templateLiteral([\"\", z.nullable(z.string())]);\nconst optionalYeah = z.templateLiteral([\"\", z.literal(\"yeah\").optional()]);\n\nconst optionalString = z.templateLiteral([\"\", z.string().optional()]);\nconst optionalNumber = z.templateLiteral([\"\", z.number().optional()]);\nconst nullishBruh = z.templateLiteral([\"\", z.literal(\"bruh\").nullish()]);\nconst nullishString = z.templateLiteral([\"\", z.string().nullish()]);\nconst cuid = z.templateLiteral([\"\", z.string().cuid()]);\nconst cuidZZZ = z.templateLiteral([\"\", z.string().cuid(), \"ZZZ\"]);\nconst cuid2 = z.templateLiteral([\"\", z.string().cuid2()]);\nconst datetime = z.templateLiteral([\"\", z.string().datetime()]);\nconst email = z.templateLiteral([\"\", z.string().email()]);\n// const ip = z.templateLiteral([\"\", z.string().ip()]);\nconst ipv4 = z.templateLiteral([\"\", z.string().ipv4()]);\nconst ipv6 = z.templateLiteral([\"\", z.string().ipv6()]);\nconst ulid = z.templateLiteral([\"\", z.string().ulid()]);\nconst uuid = z.templateLiteral([\"\", z.string().uuid()]);\nconst stringAToZ = z.templateLiteral([\"\", z.string().regex(/^[a-z]+$/)]);\nconst stringStartsWith = z.templateLiteral([\"\", z.string().startsWith(\"hello\")]);\nconst stringEndsWith = z.templateLiteral([\"\", z.string().endsWith(\"world\")]);\nconst stringMax5 = z.templateLiteral([\"\", z.string().max(5)]);\nconst stringMin5 = z.templateLiteral([\"\", z.string().min(5)]);\nconst stringLen5 = z.templateLiteral([\"\", z.string().length(5)]);\nconst stringMin5Max10 = z.templateLiteral([\"\", z.string().min(5).max(10)]);\nconst stringStartsWithMax5 = z.templateLiteral([\"\", z.string().startsWith(\"hello\").max(5)]);\nconst brandedString = z.templateLiteral([\"\", z.string().min(1).brand(\"myBrand\")]);\n// const anything = z.templateLiteral([\"\", z.any()]);\n\nconst url = z.templateLiteral([\"https://\", z.string().regex(/\\w+/), \".\", z.enum([\"com\", \"net\"])]);\n\nconst measurement = z.templateLiteral([\n  \"\",\n  z.number().finite(),\n  z.enum([\"px\", \"em\", \"rem\", \"vh\", \"vw\", \"vmin\", \"vmax\"]).optional(),\n]);\n\nconst connectionString = z.templateLiteral([\n  \"mongodb://\",\n  z\n    .templateLiteral([\n      \"\",\n      z.string().regex(/\\w+/).describe(\"username\"),\n      \":\",\n      z.string().regex(/\\w+/).describe(\"password\"),\n      \"@\",\n    ])\n    .optional(),\n  z.string().regex(/\\w+/).describe(\"host\"),\n  \":\",\n  z.number().finite().int().positive().describe(\"port\"),\n  z\n    .templateLiteral([\n      \"/\",\n      z.string().regex(/\\w+/).optional().describe(\"defaultauthdb\"),\n      z\n        .templateLiteral([\n          \"?\",\n          z\n            .string()\n            .regex(/^\\w+=\\w+(&\\w+=\\w+)*$/)\n            .optional()\n            .describe(\"options\"),\n        ])\n        .optional(),\n    ])\n    .optional(),\n]);\n\ntest(\"template literal type inference\", () => {\n  expectTypeOf<z.infer<typeof empty>>().toEqualTypeOf<``>();\n  expectTypeOf<z.infer<typeof hello>>().toEqualTypeOf<`hello`>();\n  expectTypeOf<z.infer<typeof world>>().toEqualTypeOf<`world`>();\n  expectTypeOf<z.infer<typeof one>>().toEqualTypeOf<`1`>();\n  expectTypeOf<z.infer<typeof two>>().toEqualTypeOf<`2`>();\n  expectTypeOf<z.infer<typeof truee>>().toEqualTypeOf<`true`>();\n  expectTypeOf<z.infer<typeof anotherTrue>>().toEqualTypeOf<`true`>();\n  expectTypeOf<z.infer<typeof falsee>>().toEqualTypeOf<`false`>();\n  expectTypeOf<z.infer<typeof anotherFalse>>().toEqualTypeOf<`false`>();\n  expectTypeOf<z.infer<typeof nulll>>().toEqualTypeOf<`null`>();\n  expectTypeOf<z.infer<typeof anotherNull>>().toEqualTypeOf<`null`>();\n  expectTypeOf<z.infer<typeof undefinedd>>().toEqualTypeOf<``>();\n  expectTypeOf<z.infer<typeof anotherUndefined>>().toEqualTypeOf<``>();\n  expectTypeOf<z.infer<typeof anyString>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof lazyString>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof anyNumber>>().toEqualTypeOf<`${number}`>();\n  expectTypeOf<z.infer<typeof anyInt>>().toEqualTypeOf<`${number}`>();\n  // expectTypeOf<z.infer<typeof anyFiniteNumber>>().toEqualTypeOf<`${number}`>();\n  // expectTypeOf<z.infer<typeof anyNegativeNumber>>().toEqualTypeOf<`${number}`>();\n  // expectTypeOf<z.infer<typeof anyPositiveNumber>>().toEqualTypeOf<`${number}`>();\n  // expectTypeOf<z.infer<typeof zeroButInADumbWay>>().toEqualTypeOf<`${number}`>();\n  // expectTypeOf<z.infer<typeof finiteButInADumbWay>>().toEqualTypeOf<`${number}`>();\n  expectTypeOf<z.infer<typeof bool>>().toEqualTypeOf<`true` | `false`>();\n  expectTypeOf<z.infer<typeof bigone>>().toEqualTypeOf<`${bigint}`>();\n  expectTypeOf<z.infer<typeof anyBigint>>().toEqualTypeOf<`${bigint}`>();\n  expectTypeOf<z.infer<typeof nullableYo>>().toEqualTypeOf<`yo` | `null`>();\n  expectTypeOf<z.infer<typeof nullableString>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof optionalYeah>>().toEqualTypeOf<`yeah` | ``>();\n  expectTypeOf<z.infer<typeof optionalString>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof optionalNumber>>().toEqualTypeOf<`${number}` | ``>();\n  expectTypeOf<z.infer<typeof nullishBruh>>().toEqualTypeOf<`bruh` | `null` | ``>();\n  expectTypeOf<z.infer<typeof nullishString>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof cuid>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof cuidZZZ>>().toEqualTypeOf<`${string}ZZZ`>();\n  expectTypeOf<z.infer<typeof cuid2>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof datetime>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof email>>().toEqualTypeOf<string>();\n  // expectTypeOf<z.infer<typeof ip>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof ipv4>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof ipv6>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof ulid>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof uuid>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringAToZ>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringStartsWith>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringEndsWith>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringMax5>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringMin5>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringLen5>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringMin5Max10>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof stringStartsWithMax5>>().toEqualTypeOf<string>();\n  expectTypeOf<z.infer<typeof brandedString>>().toEqualTypeOf<`${string & z.core.$brand<\"myBrand\">}`>();\n\n  // expectTypeOf<z.infer<typeof anything>>().toEqualTypeOf<`${any}`>();\n\n  expectTypeOf<z.infer<typeof url>>().toEqualTypeOf<`https://${string}.com` | `https://${string}.net`>();\n\n  expectTypeOf<z.infer<typeof measurement>>().toEqualTypeOf<\n    | `${number}`\n    | `${number}px`\n    | `${number}em`\n    | `${number}rem`\n    | `${number}vh`\n    | `${number}vw`\n    | `${number}vmin`\n    | `${number}vmax`\n  >();\n\n  expectTypeOf<z.infer<typeof connectionString>>().toEqualTypeOf<\n    | `mongodb://${string}:${number}`\n    | `mongodb://${string}:${number}/${string}`\n    | `mongodb://${string}:${number}/${string}?${string}`\n    | `mongodb://${string}:${string}@${string}:${number}`\n    | `mongodb://${string}:${string}@${string}:${number}/${string}`\n    | `mongodb://${string}:${string}@${string}:${number}/${string}?${string}`\n  >();\n});\n\ntest(\"template literal unsupported args\", () => {\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.object({})])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.array(z.object({}))])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.union([z.object({}), z.string()])])\n  ).toThrow();\n  // @ts-expect-error\n  expect(() => z.templateLiteral([z.date()])).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.custom<object>((_) => true)])\n  ).toThrow();\n  expect(() =>\n    z.templateLiteral([\n      // @ts-expect-error\n      z.discriminatedUnion(\"discriminator\", [z.object({}), z.object({})]),\n    ])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.function()])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.instanceof(class MyClass {})])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.intersection(z.object({}), z.object({}))])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.map(z.string(), z.string())])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.nullable(z.object({}))])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.optional(z.object({}))])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.promise()])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.record(z.unknown())])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.set(z.string())])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.symbol()])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.tuple([z.string()])])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.unknown()])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.void()])\n  ).toThrow();\n\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.never()])\n  ).toThrow();\n  // @ts-expect-error\n  expect(() => z.templateLiteral([z.nan()])).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.pipe(z.string(), z.string())])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.preprocess(() => true, z.boolean())])\n  ).toThrow();\n  expect(() =>\n    // @ts-expect-error\n    z.templateLiteral([z.object({}).brand(\"brand\")])\n  ).toThrow();\n\n  // these constraints aren't enforced but they shouldn't throw\n  z.templateLiteral([z.number().multipleOf(2)]);\n  z.templateLiteral([z.string().emoji()]);\n  z.templateLiteral([z.string().url()]);\n  z.templateLiteral([z.string().url()]);\n  z.templateLiteral([z.string().trim()]);\n  z.templateLiteral([z.string().includes(\"train\")]);\n  z.templateLiteral([z.string().toLowerCase()]);\n  z.templateLiteral([z.string().toUpperCase()]);\n});\n\ntest(\"template literal parsing - success - basic cases\", () => {\n  expect(() => z.templateLiteral([]).parse(7)).toThrow();\n\n  empty.parse(\"\");\n  hello.parse(\"hello\");\n  world.parse(\"world\");\n  one.parse(\"1\");\n  two.parse(\"2\");\n  truee.parse(\"true\");\n  anotherTrue.parse(\"true\");\n  falsee.parse(\"false\");\n  anotherFalse.parse(\"false\");\n  nulll.parse(\"null\");\n  anotherNull.parse(\"null\");\n  undefinedd.parse(\"undefined\");\n  anotherUndefined.parse(\"undefined\");\n  anyString.parse(\"blahblahblah\");\n  anyString.parse(\"\");\n  lazyString.parse(\"blahblahblah\");\n  lazyString.parse(\"\");\n  anyNumber.parse(\"123\");\n  anyNumber.parse(\"1.23\");\n  anyNumber.parse(\"0\");\n  anyNumber.parse(\"-1.23\");\n  anyNumber.parse(\"-123\");\n  // anyNumber.parse(\"Infinity\");\n  // anyNumber.parse(\"-Infinity\");\n  anyInt.parse(\"123\");\n  // anyInt.parse(\"-123\");\n  // anyFiniteNumber.parse(\"123\");\n  // anyFiniteNumber.parse(\"1.23\");\n  // anyFiniteNumber.parse(\"0\");\n  // anyFiniteNumber.parse(\"-1.23\");\n  // anyFiniteNumber.parse(\"-123\");\n  // anyNegativeNumber.parse(\"-123\");\n  // anyNegativeNumber.parse(\"-1.23\");\n  // anyNegativeNumber.parse(\"-Infinity\");\n  // anyPositiveNumber.parse(\"123\");\n  // anyPositiveNumber.parse(\"1.23\");\n  // anyPositiveNumber.parse(\"Infinity\");\n  // zeroButInADumbWay.parse(\"0\");\n  // zeroButInADumbWay.parse(\"00000\");\n  // finiteButInADumbWay.parse(\"5\");\n  // finiteButInADumbWay.parse(\"10\");\n  // finiteButInADumbWay.parse(\"6.66\");\n  bool.parse(\"true\");\n  bool.parse(\"false\");\n  bigone.parse(\"1\");\n  anyBigint.parse(\"123456\");\n  anyBigint.parse(\"0\");\n  // anyBigint.parse(\"-123456\");\n  nullableYo.parse(\"yo\");\n  nullableYo.parse(\"null\");\n  nullableString.parse(\"abc\");\n  nullableString.parse(\"null\");\n  optionalYeah.parse(\"yeah\");\n  optionalYeah.parse(\"\");\n  optionalString.parse(\"abc\");\n  optionalString.parse(\"\");\n  optionalNumber.parse(\"123\");\n  optionalNumber.parse(\"1.23\");\n  optionalNumber.parse(\"0\");\n  optionalNumber.parse(\"-1.23\");\n  optionalNumber.parse(\"-123\");\n  // optionalNumber.parse(\"Infinity\");\n  // optionalNumber.parse(\"-Infinity\");\n  nullishBruh.parse(\"bruh\");\n  nullishBruh.parse(\"null\");\n  nullishBruh.parse(\"\");\n  cuid.parse(\"cjld2cyuq0000t3rmniod1foy\");\n  cuidZZZ.parse(\"cjld2cyuq0000t3rmniod1foyZZZ\");\n  cuid2.parse(\"tz4a98xxat96iws9zmbrgj3a\");\n  datetime.parse(new Date().toISOString());\n  email.parse(\"info@example.com\");\n  // ip.parse(\"213.174.246.205\");\n  // ip.parse(\"c359:f57c:21e5:39eb:1187:e501:f936:b452\");\n  ipv4.parse(\"213.174.246.205\");\n  ipv6.parse(\"c359:f57c:21e5:39eb:1187:e501:f936:b452\");\n  ulid.parse(\"01GW3D2QZJBYB6P1Z1AE997VPW\");\n  uuid.parse(\"808989fd-3a6e-4af2-b607-737323a176f6\");\n  stringAToZ.parse(\"asudgaskhdgashd\");\n  stringStartsWith.parse(\"hello world\");\n  stringEndsWith.parse(\"hello world\");\n  stringMax5.parse(\"hello\");\n  stringMin5.parse(\"hello\");\n  stringLen5.parse(\"hello\");\n  stringMin5Max10.parse(\"hello worl\");\n  stringStartsWithMax5.parse(\"hello\");\n  brandedString.parse(\"branded string\");\n});\n\ntest(\"template literal parsing - failure - basic cases\", () => {\n  expect(() => empty.parse(\"a\")).toThrow();\n  expect(() => hello.parse(\"hello!\")).toThrow();\n  expect(() => hello.parse(\"!hello\")).toThrow();\n  expect(() => world.parse(\"world!\")).toThrow();\n  expect(() => world.parse(\"!world\")).toThrow();\n  expect(() => one.parse(\"2\")).toThrow();\n  expect(() => one.parse(\"12\")).toThrow();\n  expect(() => one.parse(\"21\")).toThrow();\n  expect(() => two.parse(\"1\")).toThrow();\n  expect(() => two.parse(\"21\")).toThrow();\n  expect(() => two.parse(\"12\")).toThrow();\n  expect(() => truee.parse(\"false\")).toThrow();\n  expect(() => truee.parse(\"1true\")).toThrow();\n  expect(() => truee.parse(\"true1\")).toThrow();\n  expect(() => anotherTrue.parse(\"false\")).toThrow();\n  expect(() => anotherTrue.parse(\"1true\")).toThrow();\n  expect(() => anotherTrue.parse(\"true1\")).toThrow();\n  expect(() => falsee.parse(\"true\")).toThrow();\n  expect(() => falsee.parse(\"1false\")).toThrow();\n  expect(() => falsee.parse(\"false1\")).toThrow();\n  expect(() => anotherFalse.parse(\"true\")).toThrow();\n  expect(() => anotherFalse.parse(\"1false\")).toThrow();\n  expect(() => anotherFalse.parse(\"false1\")).toThrow();\n  expect(() => nulll.parse(\"123\")).toThrow();\n  expect(() => nulll.parse(\"null1\")).toThrow();\n  expect(() => nulll.parse(\"1null\")).toThrow();\n  expect(() => anotherNull.parse(\"123\")).toThrow();\n  expect(() => anotherNull.parse(\"null1\")).toThrow();\n  expect(() => anotherNull.parse(\"1null\")).toThrow();\n  expect(() => undefinedd.parse(\"123\")).toThrow();\n  expect(() => undefinedd.parse(\"undefined1\")).toThrow();\n  expect(() => undefinedd.parse(\"1undefined\")).toThrow();\n  expect(() => anotherUndefined.parse(\"123\")).toThrow();\n  expect(() => anotherUndefined.parse(\"undefined1\")).toThrow();\n  expect(() => anotherUndefined.parse(\"1undefined\")).toThrow();\n  expect(() => anyNumber.parse(\"2a\")).toThrow();\n  expect(() => anyNumber.parse(\"a2\")).toThrow();\n  expect(() => anyNumber.parse(\"-2a\")).toThrow();\n  expect(() => anyNumber.parse(\"a-2\")).toThrow();\n  expect(() => anyNumber.parse(\"2.5a\")).toThrow();\n  expect(() => anyNumber.parse(\"a2.5\")).toThrow();\n  expect(() => anyNumber.parse(\"Infinitya\")).toThrow();\n  expect(() => anyNumber.parse(\"aInfinity\")).toThrow();\n  expect(() => anyNumber.parse(\"-Infinitya\")).toThrow();\n  expect(() => anyNumber.parse(\"a-Infinity\")).toThrow();\n  expect(() => anyNumber.parse(\"2e5\")).toThrow();\n  expect(() => anyNumber.parse(\"2e-5\")).toThrow();\n  expect(() => anyNumber.parse(\"2e+5\")).toThrow();\n  expect(() => anyNumber.parse(\"-2e5\")).toThrow();\n  expect(() => anyNumber.parse(\"-2e-5\")).toThrow();\n  expect(() => anyNumber.parse(\"-2e+5\")).toThrow();\n  expect(() => anyNumber.parse(\"2.1e5\")).toThrow();\n  expect(() => anyNumber.parse(\"2.1e-5\")).toThrow();\n  expect(() => anyNumber.parse(\"2.1e+5\")).toThrow();\n  expect(() => anyNumber.parse(\"-2.1e5\")).toThrow();\n  expect(() => anyNumber.parse(\"-2.1e-5\")).toThrow();\n  expect(() => anyNumber.parse(\"-2.1e+5\")).toThrow();\n  expect(() => anyNumber.parse(\"-Infinity\")).toThrow();\n  expect(() => anyNumber.parse(\"Infinity\")).toThrow();\n  expect(() => anyInt.parse(\"1.23\")).toThrow();\n  expect(() => anyInt.parse(\"-1.23\")).toThrow();\n  expect(() => anyInt.parse(\"d1\")).toThrow();\n  expect(() => anyInt.parse(\"1d\")).toThrow();\n  // expect(() => anyFiniteNumber.parse(\"Infinity\")).toThrow();\n  // expect(() => anyFiniteNumber.parse(\"-Infinity\")).toThrow();\n  // expect(() => anyFiniteNumber.parse(\"123a\")).toThrow();\n  // expect(() => anyFiniteNumber.parse(\"a123\")).toThrow();\n  // expect(() => anyNegativeNumber.parse(\"0\")).toThrow();\n  // expect(() => anyNegativeNumber.parse(\"1\")).toThrow();\n  // expect(() => anyNegativeNumber.parse(\"Infinity\")).toThrow();\n  // expect(() => anyPositiveNumber.parse(\"0\")).toThrow();\n  // expect(() => anyPositiveNumber.parse(\"-1\")).toThrow();\n  // expect(() => anyPositiveNumber.parse(\"-Infinity\")).toThrow();\n  // expect(() => zeroButInADumbWay.parse(\"1\")).toThrow();\n  // expect(() => zeroButInADumbWay.parse(\"-1\")).toThrow();\n  // expect(() => finiteButInADumbWay.parse(\"Infinity\")).toThrow();\n  // expect(() => finiteButInADumbWay.parse(\"-Infinity\")).toThrow();\n  // expect(() => finiteButInADumbWay.parse(\"-5\")).toThrow();\n  // expect(() => finiteButInADumbWay.parse(\"10a\")).toThrow();\n  // expect(() => finiteButInADumbWay.parse(\"a10\")).toThrow();\n  expect(() => bool.parse(\"123\")).toThrow();\n  expect(() => bigone.parse(\"2\")).toThrow();\n  expect(() => bigone.parse(\"c1\")).toThrow();\n  expect(() => anyBigint.parse(\"1.23\")).toThrow();\n  expect(() => anyBigint.parse(\"-1.23\")).toThrow();\n  expect(() => anyBigint.parse(\"c123\")).toThrow();\n  expect(() => nullableYo.parse(\"yo1\")).toThrow();\n  expect(() => nullableYo.parse(\"1yo\")).toThrow();\n  expect(() => nullableYo.parse(\"null1\")).toThrow();\n  expect(() => nullableYo.parse(\"1null\")).toThrow();\n  expect(() => optionalYeah.parse(\"yeah1\")).toThrow();\n  expect(() => optionalYeah.parse(\"1yeah\")).toThrow();\n  expect(() => optionalYeah.parse(\"undefined\")).toThrow();\n  expect(() => optionalNumber.parse(\"123a\")).toThrow();\n  expect(() => optionalNumber.parse(\"a123\")).toThrow();\n  // expect(() => optionalNumber.parse(\"Infinitya\")).toThrow();\n  // expect(() => optionalNumber.parse(\"aInfinity\")).toThrow();\n  expect(() => nullishBruh.parse(\"bruh1\")).toThrow();\n  expect(() => nullishBruh.parse(\"1bruh\")).toThrow();\n  expect(() => nullishBruh.parse(\"null1\")).toThrow();\n  expect(() => nullishBruh.parse(\"1null\")).toThrow();\n  expect(() => nullishBruh.parse(\"undefined\")).toThrow();\n  expect(() => cuid.parse(\"bjld2cyuq0000t3rmniod1foy\")).toThrow();\n  expect(() => cuid.parse(\"cjld2cyu\")).toThrow();\n  expect(() => cuid.parse(\"cjld2 cyu\")).toThrow();\n  expect(() => cuid.parse(\"cjld2cyuq0000t3rmniod1foy \")).toThrow();\n  expect(() => cuid.parse(\"1cjld2cyuq0000t3rmniod1foy\")).toThrow();\n  expect(() => cuidZZZ.parse(\"cjld2cyuq0000t3rmniod1foy\")).toThrow();\n  expect(() => cuidZZZ.parse(\"cjld2cyuq0000t3rmniod1foyZZY\")).toThrow();\n  expect(() => cuidZZZ.parse(\"cjld2cyuq0000t3rmniod1foyZZZ1\")).toThrow();\n  expect(() => cuidZZZ.parse(\"1cjld2cyuq0000t3rmniod1foyZZZ\")).toThrow();\n  expect(() => cuid2.parse(\"A9z4a98xxat96iws9zmbrgj3a\")).toThrow();\n  expect(() => cuid2.parse(\"tz4a98xxat96iws9zmbrgj3!\")).toThrow();\n  expect(() => datetime.parse(\"2022-01-01 00:00:00\")).toThrow();\n  expect(() => email.parse(\"info@example.com@\")).toThrow();\n  // expect(() => ip.parse(\"213.174.246:205\")).toThrow();\n  // expect(() => ip.parse(\"c359.f57c:21e5:39eb:1187:e501:f936:b452\")).toThrow();\n  expect(() => ipv4.parse(\"1213.174.246.205\")).toThrow();\n  expect(() => ipv4.parse(\"c359:f57c:21e5:39eb:1187:e501:f936:b452\")).toThrow();\n  expect(() => ipv6.parse(\"c359:f57c:21e5:39eb:1187:e501:f936:b4521\")).toThrow();\n  expect(() => ipv6.parse(\"213.174.246.205\")).toThrow();\n  expect(() => ulid.parse(\"01GW3D2QZJBYB6P1Z1AE997VPW!\")).toThrow();\n  expect(() => uuid.parse(\"808989fd-3a6e-4af2-b607-737323a176f6Z\")).toThrow();\n  expect(() => uuid.parse(\"Z808989fd-3a6e-4af2-b607-737323a176f6\")).toThrow();\n  expect(() => stringAToZ.parse(\"asdasdasd1\")).toThrow();\n  expect(() => stringAToZ.parse(\"1asdasdasd\")).toThrow();\n  expect(() => stringStartsWith.parse(\"ahello\")).toThrow();\n  expect(() => stringEndsWith.parse(\"worlda\")).toThrow();\n  expect(() => stringMax5.parse(\"123456\")).toThrow();\n  expect(() => stringMin5.parse(\"1234\")).toThrow();\n  expect(() => stringLen5.parse(\"123456\")).toThrow();\n  expect(() => stringLen5.parse(\"1234\")).toThrow();\n  expect(() => stringMin5Max10.parse(\"1234\")).toThrow();\n  expect(() => stringMin5Max10.parse(\"12345678901\")).toThrow();\n\n  // the \"startswith\" overrides the max length\n  // expect(() => stringStartsWithMax5.parse(\"hello1\")).toThrow();\n  expect(() => stringStartsWithMax5.parse(\"1hell\")).toThrow();\n  expect(() => brandedString.parse(\"\")).toThrow();\n});\n\ntest(\"regexes\", () => {\n  expect(empty._zod.pattern.source).toMatchInlineSnapshot(`\"^$\"`);\n  expect(hello._zod.pattern.source).toMatchInlineSnapshot(`\"^hello$\"`);\n  expect(world._zod.pattern.source).toMatchInlineSnapshot(`\"^(world)$\"`);\n  expect(one._zod.pattern.source).toMatchInlineSnapshot(`\"^1$\"`);\n  expect(two._zod.pattern.source).toMatchInlineSnapshot(`\"^(2)$\"`);\n  expect(truee._zod.pattern.source).toMatchInlineSnapshot(`\"^true$\"`);\n  expect(anotherTrue._zod.pattern.source).toMatchInlineSnapshot(`\"^(true)$\"`);\n  expect(falsee._zod.pattern.source).toMatchInlineSnapshot(`\"^false$\"`);\n  expect(anotherFalse._zod.pattern.source).toMatchInlineSnapshot(`\"^(false)$\"`);\n  expect(nulll._zod.pattern.source).toMatchInlineSnapshot(`\"^null$\"`);\n  expect(anotherNull._zod.pattern.source).toMatchInlineSnapshot(`\"^null$\"`);\n  expect(undefinedd._zod.pattern.source).toMatchInlineSnapshot(`\"^undefined$\"`);\n  expect(anotherUndefined._zod.pattern.source).toMatchInlineSnapshot(`\"^undefined$\"`);\n  expect(anyString._zod.pattern.source).toMatchInlineSnapshot(`\"^[\\\\s\\\\S]{0,}$\"`);\n  expect(lazyString._zod.pattern.source).toMatchInlineSnapshot(`\"^[\\\\s\\\\S]{0,}$\"`);\n  expect(anyNumber._zod.pattern.source).toMatchInlineSnapshot(`\"^-?\\\\d+(?:\\\\.\\\\d+)?$\"`);\n  expect(anyInt._zod.pattern.source).toMatchInlineSnapshot(`\"^\\\\d+$\"`);\n  // expect(anyFiniteNumber._zod.pattern.source).toMatchInlineSnapshot(`\"^-?\\\\d+(?:\\\\.\\\\d+)?$\"`);\n  // expect(anyNegativeNumber._zod.pattern.source).toMatchInlineSnapshot(`\"^-?\\\\d+(?:\\\\.\\\\d+)?$\"`);\n  // expect(anyPositiveNumber._zod.pattern.source).toMatchInlineSnapshot(`\"^-?\\\\d+(?:\\\\.\\\\d+)?$\"`);\n  // expect(zeroButInADumbWay._zod.pattern.source).toMatchInlineSnapshot(`\"^-?\\\\d+(?:\\\\.\\\\d+)?$\"`);\n  // expect(finiteButInADumbWay._zod.pattern.source).toMatchInlineSnapshot(`\"^-?\\\\d+(?:\\\\.\\\\d+)?$\"`);\n  expect(bool._zod.pattern.source).toMatchInlineSnapshot(`\"^true|false$\"`);\n  expect(bigone._zod.pattern.source).toMatchInlineSnapshot(`\"^(1)$\"`);\n  expect(anyBigint._zod.pattern.source).toMatchInlineSnapshot(`\"^\\\\d+n?$\"`);\n  expect(nullableYo._zod.pattern.source).toMatchInlineSnapshot(`\"^((yo)|null)$\"`);\n  expect(nullableString._zod.pattern.source).toMatchInlineSnapshot(`\"^([\\\\s\\\\S]{0,}|null)$\"`);\n  expect(optionalYeah._zod.pattern.source).toMatchInlineSnapshot(`\"^((yeah))?$\"`);\n  expect(optionalString._zod.pattern.source).toMatchInlineSnapshot(`\"^([\\\\s\\\\S]{0,})?$\"`);\n  expect(optionalNumber._zod.pattern.source).toMatchInlineSnapshot(`\"^(-?\\\\d+(?:\\\\.\\\\d+)?)?$\"`);\n  expect(nullishBruh._zod.pattern.source).toMatchInlineSnapshot(`\"^(((bruh)|null))?$\"`);\n  expect(nullishString._zod.pattern.source).toMatchInlineSnapshot(`\"^(([\\\\s\\\\S]{0,}|null))?$\"`);\n  expect(cuid._zod.pattern.source).toMatchInlineSnapshot(`\"^[cC][^\\\\s-]{8,}$\"`);\n  expect(cuidZZZ._zod.pattern.source).toMatchInlineSnapshot(`\"^[cC][^\\\\s-]{8,}ZZZ$\"`);\n  expect(cuid2._zod.pattern.source).toMatchInlineSnapshot(`\"^[0-9a-z]+$\"`);\n  expect(datetime._zod.pattern.source).toMatchInlineSnapshot(\n    `\"^(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))T(?:(?:[01]\\\\d|2[0-3]):[0-5]\\\\d(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?(?:Z))$\"`\n  );\n  expect(email._zod.pattern.source).toMatchInlineSnapshot(\n    `\"^(?!\\\\.)(?!.*\\\\.\\\\.)([A-Za-z0-9_'+\\\\-\\\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\\\-]*\\\\.)+[A-Za-z]{2,}$\"`\n  );\n  // expect(ip._zod.pattern.source).toMatchInlineSnapshot(\n  //   `\"^(^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$)|(^(([a-fA-F0-9]{1,4}:){7}|::([a-fA-F0-9]{1,4}:){0,6}|([a-fA-F0-9]{1,4}:){1}:([a-fA-F0-9]{1,4}:){0,5}|([a-fA-F0-9]{1,4}:){2}:([a-fA-F0-9]{1,4}:){0,4}|([a-fA-F0-9]{1,4}:){3}:([a-fA-F0-9]{1,4}:){0,3}|([a-fA-F0-9]{1,4}:){4}:([a-fA-F0-9]{1,4}:){0,2}|([a-fA-F0-9]{1,4}:){5}:([a-fA-F0-9]{1,4}:){0,1})([a-fA-F0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$)$\"`\n  // );\n  expect(ipv4._zod.pattern.source).toMatchInlineSnapshot(\n    `\"^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$\"`\n  );\n  expect(ipv6._zod.pattern.source).toMatchInlineSnapshot(\n    `\"^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$\"`\n  );\n  expect(ulid._zod.pattern.source).toMatchInlineSnapshot(`\"^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$\"`);\n  expect(uuid._zod.pattern.source).toMatchInlineSnapshot(\n    `\"^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$\"`\n  );\n  expect(stringAToZ._zod.pattern.source).toMatchInlineSnapshot(`\"^[a-z]+$\"`);\n  expect(stringStartsWith._zod.pattern.source).toMatchInlineSnapshot(`\"^hello.*$\"`);\n  expect(stringEndsWith._zod.pattern.source).toMatchInlineSnapshot(`\"^.*world$\"`);\n  expect(stringMax5._zod.pattern.source).toMatchInlineSnapshot(`\"^[\\\\s\\\\S]{0,5}$\"`);\n  expect(stringMin5._zod.pattern.source).toMatchInlineSnapshot(`\"^[\\\\s\\\\S]{5,}$\"`);\n  expect(stringLen5._zod.pattern.source).toMatchInlineSnapshot(`\"^[\\\\s\\\\S]{5,5}$\"`);\n  expect(stringMin5Max10._zod.pattern.source).toMatchInlineSnapshot(`\"^[\\\\s\\\\S]{5,10}$\"`);\n  expect(brandedString._zod.pattern.source).toMatchInlineSnapshot(`\"^[\\\\s\\\\S]{1,}$\"`);\n  expect(url._zod.pattern.source).toMatchInlineSnapshot(`\"^https:\\\\/\\\\/\\\\w+\\\\.(com|net)$\"`);\n  expect(measurement._zod.pattern.source).toMatchInlineSnapshot(`\"^-?\\\\d+(?:\\\\.\\\\d+)?((px|em|rem|vh|vw|vmin|vmax))?$\"`);\n  expect(connectionString._zod.pattern.source).toMatchInlineSnapshot(\n    `\"^mongodb:\\\\/\\\\/(\\\\w+:\\\\w+@)?\\\\w+:\\\\d+(\\\\/(\\\\w+)?(\\\\?(\\\\w+=\\\\w+(&\\\\w+=\\\\w+)*)?)?)?$\"`\n  );\n});\n\ntest(\"template literal parsing - success - complex cases\", () => {\n  url.parse(\"https://example.com\");\n  url.parse(\"https://speedtest.net\");\n\n  // measurement.parse(1);\n  // measurement.parse(1.1);\n  // measurement.parse(0);\n  // measurement.parse(-1.1);\n  // measurement.parse(-1);\n  measurement.parse(\"1\");\n  measurement.parse(\"1.1\");\n  measurement.parse(\"0\");\n  measurement.parse(\"-1\");\n  measurement.parse(\"-1.1\");\n  measurement.parse(\"1px\");\n  measurement.parse(\"1.1px\");\n  measurement.parse(\"0px\");\n  measurement.parse(\"-1px\");\n  measurement.parse(\"-1.1px\");\n  measurement.parse(\"1em\");\n  measurement.parse(\"1.1em\");\n  measurement.parse(\"0em\");\n  measurement.parse(\"-1em\");\n  measurement.parse(\"-1.1em\");\n  measurement.parse(\"1rem\");\n  measurement.parse(\"1.1rem\");\n  measurement.parse(\"0rem\");\n  measurement.parse(\"-1rem\");\n  measurement.parse(\"-1.1rem\");\n  measurement.parse(\"1vh\");\n  measurement.parse(\"1.1vh\");\n  measurement.parse(\"0vh\");\n  measurement.parse(\"-1vh\");\n  measurement.parse(\"-1.1vh\");\n  measurement.parse(\"1vw\");\n  measurement.parse(\"1.1vw\");\n  measurement.parse(\"0vw\");\n  measurement.parse(\"-1vw\");\n  measurement.parse(\"-1.1vw\");\n  measurement.parse(\"1vmin\");\n  measurement.parse(\"1.1vmin\");\n  measurement.parse(\"0vmin\");\n  measurement.parse(\"-1vmin\");\n  measurement.parse(\"-1.1vmin\");\n  measurement.parse(\"1vmax\");\n  measurement.parse(\"1.1vmax\");\n  measurement.parse(\"0vmax\");\n  measurement.parse(\"-1vmax\");\n  measurement.parse(\"-1.1vmax\");\n\n  connectionString.parse(\"mongodb://host:1234\");\n  connectionString.parse(\"mongodb://host:1234/\");\n  connectionString.parse(\"mongodb://host:1234/defaultauthdb\");\n  connectionString.parse(\"mongodb://host:1234/defaultauthdb?authSource=admin\");\n  connectionString.parse(\"mongodb://host:1234/defaultauthdb?authSource=admin&connectTimeoutMS=300000\");\n  connectionString.parse(\"mongodb://host:1234/?authSource=admin\");\n  connectionString.parse(\"mongodb://host:1234/?authSource=admin&connectTimeoutMS=300000\");\n  connectionString.parse(\"mongodb://username:password@host:1234\");\n  connectionString.parse(\"mongodb://username:password@host:1234/\");\n  connectionString.parse(\"mongodb://username:password@host:1234/defaultauthdb\");\n  connectionString.parse(\"mongodb://username:password@host:1234/defaultauthdb?authSource=admin\");\n  connectionString.parse(\n    \"mongodb://username:password@host:1234/defaultauthdb?authSource=admin&connectTimeoutMS=300000\"\n  );\n  connectionString.parse(\"mongodb://username:password@host:1234/?authSource=admin\");\n  connectionString.parse(\"mongodb://username:password@host:1234/?authSource=admin&connectTimeoutMS=300000\");\n});\n\ntest(\"template literal parsing - failure - complex cases\", () => {\n  expect(() => url.parse(\"http://example.com\")).toThrow();\n  expect(() => url.parse(\"https://.com\")).toThrow();\n  expect(() => url.parse(\"https://examplecom\")).toThrow();\n  expect(() => url.parse(\"https://example.org\")).toThrow();\n  expect(() => url.parse(\"https://example.net.il\")).toThrow();\n\n  expect(() => measurement.parse(\"1.1.1\")).toThrow();\n  expect(() => measurement.parse(\"Infinity\")).toThrow();\n  expect(() => measurement.parse(\"-Infinity\")).toThrow();\n  expect(() => measurement.parse(\"NaN\")).toThrow();\n  expect(() => measurement.parse(\"1%\")).toThrow();\n\n  expect(() => connectionString.parse(\"mongod://host:1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://:1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:d234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:12.34\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:-1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:-12.34\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://:password@host:1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://usernamepassword@host:1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://username:@host:1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://@host:1234\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:1234/defaultauthdb?authSourceadmin\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:1234/?authSourceadmin\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:1234/defaultauthdb?&authSource=admin\")).toThrow();\n  expect(() => connectionString.parse(\"mongodb://host:1234/?&authSource=admin\")).toThrow();\n});\n\ntest(\"template literal parsing - failure - issue format\", () => {\n  expect(anotherNull.safeParse(\"1null\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"template_literal\",\n        \"pattern\": \"^null$\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(cuidZZZ.safeParse(\"1cjld2cyuq0000t3rmniod1foyZZZ\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"template_literal\",\n        \"pattern\": \"^[cC][^\\\\\\\\s-]{8,}ZZZ$\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(stringMin5Max10.safeParse(\"1234\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"template_literal\",\n        \"pattern\": \"^[\\\\\\\\s\\\\\\\\S]{5,10}$\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n  expect(connectionString.safeParse(\"mongodb://host:1234/defaultauthdb?authSourceadmin\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"template_literal\",\n        \"pattern\": \"^mongodb:\\\\\\\\/\\\\\\\\/(\\\\\\\\w+:\\\\\\\\w+@)?\\\\\\\\w+:\\\\\\\\d+(\\\\\\\\/(\\\\\\\\w+)?(\\\\\\\\?(\\\\\\\\w+=\\\\\\\\w+(&\\\\\\\\w+=\\\\\\\\w+)*)?)?)?$\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n\n  expect(stringStartsWithMax5.safeParse(\"1hell\")).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"invalid_format\",\n        \"format\": \"template_literal\",\n        \"pattern\": \"^hello.*$\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/to-json-schema.test.ts",
    "content": "import { describe, expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n// import * as zCore from \"zod/v4/core\";\n\ndescribe(\"toJSONSchema\", () => {\n  test(\"primitive types\", () => {\n    expect(z.toJSONSchema(z.string())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.number())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"type\": \"number\",\n      }\n    `);\n    expect(z.toJSONSchema(z.boolean())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"type\": \"boolean\",\n      }\n    `);\n    expect(z.toJSONSchema(z.null())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"type\": \"null\",\n      }\n    `);\n    expect(z.toJSONSchema(z.undefined(), { unrepresentable: \"any\" })).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      }\n    `);\n    expect(z.toJSONSchema(z.any())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      }\n    `);\n    expect(z.toJSONSchema(z.unknown())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      }\n    `);\n    expect(z.toJSONSchema(z.never())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"not\": {},\n      }\n    `);\n    expect(z.toJSONSchema(z.email())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"email\",\n        \"pattern\": \"^(?!\\\\.)(?!.*\\\\.\\\\.)([A-Za-z0-9_'+\\\\-\\\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\\\-]*\\\\.)+[A-Za-z]{2,}$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.iso.datetime())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"date-time\",\n        \"pattern\": \"^(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))T(?:(?:[01]\\\\d|2[0-3]):[0-5]\\\\d(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?(?:Z))$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.iso.date())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"date\",\n        \"pattern\": \"^(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.iso.time())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"time\",\n        \"pattern\": \"^(?:[01]\\\\d|2[0-3]):[0-5]\\\\d(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.iso.duration())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"duration\",\n        \"pattern\": \"^P(?:(\\\\d+W)|(?!.*W)(?=\\\\d|T\\\\d)(\\\\d+Y)?(\\\\d+M)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?(\\\\d+([.,]\\\\d+)?S)?)?)$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.ipv4())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"ipv4\",\n        \"pattern\": \"^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.ipv6())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"ipv6\",\n        \"pattern\": \"^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.uuid())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"uuid\",\n        \"pattern\": \"^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.guid())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"uuid\",\n        \"pattern\": \"^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.url())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"uri\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.base64())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"contentEncoding\": \"base64\",\n        \"format\": \"base64\",\n        \"pattern\": \"^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.cuid())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"cuid\",\n        \"pattern\": \"^[cC][^\\\\s-]{8,}$\",\n        \"type\": \"string\",\n      }\n    `);\n    // expect(z.toJSONSchema(z.regex(/asdf/))).toMatchInlineSnapshot();\n    expect(z.toJSONSchema(z.emoji())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"emoji\",\n        \"pattern\": \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.nanoid())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"nanoid\",\n        \"pattern\": \"^[a-zA-Z0-9_-]{21}$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.cuid2())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"cuid2\",\n        \"pattern\": \"^[0-9a-z]+$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.ulid())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"ulid\",\n        \"pattern\": \"^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$\",\n        \"type\": \"string\",\n      }\n    `);\n    // expect(z.toJSONSchema(z.cidr())).toMatchInlineSnapshot();\n    expect(z.toJSONSchema(z.number())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"type\": \"number\",\n      }\n    `);\n    expect(z.toJSONSchema(z.int())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"maximum\": 9007199254740991,\n        \"minimum\": -9007199254740991,\n        \"type\": \"integer\",\n      }\n    `);\n    expect(z.toJSONSchema(z.int32())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"maximum\": 2147483647,\n        \"minimum\": -2147483648,\n        \"type\": \"integer\",\n      }\n    `);\n    expect(z.toJSONSchema(z.float32())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"maximum\": 3.4028234663852886e+38,\n        \"minimum\": -3.4028234663852886e+38,\n        \"type\": \"number\",\n      }\n    `);\n    expect(z.toJSONSchema(z.float64())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"maximum\": 1.7976931348623157e+308,\n        \"minimum\": -1.7976931348623157e+308,\n        \"type\": \"number\",\n      }\n    `);\n    expect(z.toJSONSchema(z.jwt())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"jwt\",\n        \"type\": \"string\",\n      }\n    `);\n  });\n\n  test(\"unsupported schema types\", () => {\n    expect(() => z.toJSONSchema(z.bigint())).toThrow(\"BigInt cannot be represented in JSON Schema\");\n    expect(() => z.toJSONSchema(z.int64())).toThrow(\"BigInt cannot be represented in JSON Schema\");\n    expect(() => z.toJSONSchema(z.symbol())).toThrow(\"Symbols cannot be represented in JSON Schema\");\n    expect(() => z.toJSONSchema(z.void())).toThrow(\"Void cannot be represented in JSON Schema\");\n    expect(() => z.toJSONSchema(z.undefined())).toThrow(\"Undefined cannot be represented in JSON Schema\");\n    expect(() => z.toJSONSchema(z.date())).toThrow(\"Date cannot be represented in JSON Schema\");\n    expect(() => z.toJSONSchema(z.map(z.string(), z.number()))).toThrow(\"Map cannot be represented in JSON Schema\");\n    expect(() => z.toJSONSchema(z.set(z.string()))).toThrow(\"Set cannot be represented in JSON Schema\");\n    expect(() => z.toJSONSchema(z.custom(() => true))).toThrow(\"Custom types cannot be represented in JSON Schema\");\n\n    // Transform\n    const transformSchema = z.string().transform((val) => Number.parseInt(val));\n    expect(() => z.toJSONSchema(transformSchema)).toThrow(\"Transforms cannot be represented in JSON Schema\");\n\n    // Static catch values\n    const staticCatchSchema = z.string().catch(() => \"sup\");\n    expect(z.toJSONSchema(staticCatchSchema)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"default\": \"sup\",\n        \"type\": \"string\",\n      }\n    `);\n\n    // Dynamic catch values\n    const dynamicCatchSchema = z.string().catch((ctx) => `${ctx.issues.length}`);\n    expect(() => z.toJSONSchema(dynamicCatchSchema)).toThrow(\"Dynamic catch values are not supported in JSON Schema\");\n  });\n\n  test(\"string formats\", () => {\n    expect(z.toJSONSchema(z.string().email())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"email\",\n        \"pattern\": \"^(?!\\\\.)(?!.*\\\\.\\\\.)([A-Za-z0-9_'+\\\\-\\\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\\\-]*\\\\.)+[A-Za-z]{2,}$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.string().uuid())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"uuid\",\n        \"pattern\": \"^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.iso.datetime())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"date-time\",\n        \"pattern\": \"^(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))T(?:(?:[01]\\\\d|2[0-3]):[0-5]\\\\d(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?(?:Z))$\",\n        \"type\": \"string\",\n      }\n    `);\n\n    expect(z.toJSONSchema(z.iso.date())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"date\",\n        \"pattern\": \"^(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.iso.time())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"time\",\n        \"pattern\": \"^(?:[01]\\\\d|2[0-3]):[0-5]\\\\d(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.iso.duration())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"duration\",\n        \"pattern\": \"^P(?:(\\\\d+W)|(?!.*W)(?=\\\\d|T\\\\d)(\\\\d+Y)?(\\\\d+M)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?(\\\\d+([.,]\\\\d+)?S)?)?)$\",\n        \"type\": \"string\",\n      }\n    `);\n    // expect(z.toJSONSchema(z.string().ip())).toMatchInlineSnapshot(`\n    //   {\n    //     \"pattern\": /\\\\(\\\\^\\\\(\\\\?:\\\\(\\\\?:25\\\\[0-5\\\\]\\\\|2\\\\[0-4\\\\]\\\\[0-9\\\\]\\\\|1\\\\[0-9\\\\]\\\\[0-9\\\\]\\\\|\\\\[1-9\\\\]\\\\[0-9\\\\]\\\\|\\\\[0-9\\\\]\\\\)\\\\\\\\\\\\.\\\\)\\\\{3\\\\}\\\\(\\\\?:25\\\\[0-5\\\\]\\\\|2\\\\[0-4\\\\]\\\\[0-9\\\\]\\\\|1\\\\[0-9\\\\]\\\\[0-9\\\\]\\\\|\\\\[1-9\\\\]\\\\[0-9\\\\]\\\\|\\\\[0-9\\\\]\\\\)\\\\$\\\\)\\\\|\\\\(\\\\^\\\\(\\\\(\\\\[a-fA-F0-9\\\\]\\\\{1,4\\\\}:\\\\)\\\\{7\\\\}\\\\|::\\\\(\\\\[a-fA-F0-9\\\\]\\\\{1,4\\\\}:\\\\)\\\\{0,6\\\\}\\\\|\\\\(\\\\[a-fA-F0-9\\\\]\\\\{1,4\\\\}:\\\\)\\\\{1\\\\}:\\\\(\\\\[a-fA-F0-9\\\\]\\\\{1,4\\\\}:\\\\)\\\\{0,5\\\\}\\\\|\\\\(\\\\[a-fA-F0-9\\\\]\\\\{1,4\\\\}:\\\\)\\\\{2\\\\}:\\\\(\\\\[a-fA-F0-9\\\\]\\\\{1,4\\\\}:\\\\)\\\\{0,4\\\\}\\\\|\\\\(\\\\[a-fA-F0-9\\\\]\\\\{1,4\\\\}:\\\\)\\\\{3\\\\}:\\\\(\\\\[a-fA-F0-9\\\\]\\\\{1,4\\\\}:\\\\)\\\\{0,3\\\\}\\\\|\\\\(\\\\[a-fA-F0-9\\\\]\\\\{1,4\\\\}:\\\\)\\\\{4\\\\}:\\\\(\\\\[a-fA-F0-9\\\\]\\\\{1,4\\\\}:\\\\)\\\\{0,2\\\\}\\\\|\\\\(\\\\[a-fA-F0-9\\\\]\\\\{1,4\\\\}:\\\\)\\\\{5\\\\}:\\\\(\\\\[a-fA-F0-9\\\\]\\\\{1,4\\\\}:\\\\)\\\\{0,1\\\\}\\\\)\\\\(\\\\[a-fA-F0-9\\\\]\\\\{1,4\\\\}\\\\|\\\\(\\\\(\\\\(25\\\\[0-5\\\\]\\\\)\\\\|\\\\(2\\\\[0-4\\\\]\\\\[0-9\\\\]\\\\)\\\\|\\\\(1\\\\[0-9\\\\]\\\\{2\\\\}\\\\)\\\\|\\\\(\\\\[0-9\\\\]\\\\{1,2\\\\}\\\\)\\\\)\\\\\\\\\\\\.\\\\)\\\\{3\\\\}\\\\(\\\\(25\\\\[0-5\\\\]\\\\)\\\\|\\\\(2\\\\[0-4\\\\]\\\\[0-9\\\\]\\\\)\\\\|\\\\(1\\\\[0-9\\\\]\\\\{2\\\\}\\\\)\\\\|\\\\(\\\\[0-9\\\\]\\\\{1,2\\\\}\\\\)\\\\)\\\\)\\\\$\\\\)/,\n    //     \"type\": \"string\",\n    //   }\n    // `);\n    expect(z.toJSONSchema(z.ipv4())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"ipv4\",\n        \"pattern\": \"^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$\",\n        \"type\": \"string\",\n      }\n    `);\n\n    expect(z.toJSONSchema(z.ipv6())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"ipv6\",\n        \"pattern\": \"^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$\",\n        \"type\": \"string\",\n      }\n    `);\n\n    expect(z.toJSONSchema(z.base64())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"contentEncoding\": \"base64\",\n        \"format\": \"base64\",\n        \"pattern\": \"^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.url())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"uri\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.guid())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"format\": \"uuid\",\n        \"pattern\": \"^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$\",\n        \"type\": \"string\",\n      }\n    `);\n    expect(z.toJSONSchema(z.string().regex(/asdf/))).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"pattern\": \"asdf\",\n        \"type\": \"string\",\n      }\n    `);\n  });\n\n  test(\"string patterns\", () => {\n    expect(\n      z.toJSONSchema(\n        z\n          .string()\n          .startsWith(\"hello\")\n          .includes(\"cruel\")\n          .includes(\"dark\", { position: 10 })\n          .endsWith(\"world\")\n          .regex(/stuff/)\n      )\n    ).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"allOf\": [\n          {\n            \"pattern\": \"^hello.*\",\n          },\n          {\n            \"pattern\": \"cruel\",\n          },\n          {\n            \"pattern\": \"^.{10}dark\",\n          },\n          {\n            \"pattern\": \".*world$\",\n          },\n          {\n            \"pattern\": \"stuff\",\n          },\n        ],\n        \"type\": \"string\",\n      }\n    `);\n\n    expect(\n      z.toJSONSchema(\n        z\n          .string()\n          .startsWith(\"hello\")\n          .includes(\"cruel\")\n          .includes(\"dark\", { position: 10 })\n          .endsWith(\"world\")\n          .regex(/stuff/),\n        {\n          target: \"draft-7\",\n        }\n      )\n    ).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n        \"allOf\": [\n          {\n            \"pattern\": \"^hello.*\",\n            \"type\": \"string\",\n          },\n          {\n            \"pattern\": \"cruel\",\n            \"type\": \"string\",\n          },\n          {\n            \"pattern\": \"^.{10}dark\",\n            \"type\": \"string\",\n          },\n          {\n            \"pattern\": \".*world$\",\n            \"type\": \"string\",\n          },\n          {\n            \"pattern\": \"stuff\",\n            \"type\": \"string\",\n          },\n        ],\n        \"type\": \"string\",\n      }\n    `);\n  });\n\n  test(\"number constraints\", () => {\n    expect(z.toJSONSchema(z.number().min(5).max(10))).toMatchInlineSnapshot(\n      `\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"maximum\": 10,\n        \"minimum\": 5,\n        \"type\": \"number\",\n      }\n    `\n    );\n\n    expect(z.toJSONSchema(z.number().gt(5).gt(10))).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"exclusiveMinimum\": 10,\n        \"type\": \"number\",\n      }\n    `);\n\n    expect(z.toJSONSchema(z.number().gt(5).gte(10))).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"minimum\": 10,\n        \"type\": \"number\",\n      }\n    `);\n\n    expect(z.toJSONSchema(z.number().lt(5).lt(3))).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"exclusiveMaximum\": 3,\n        \"type\": \"number\",\n      }\n    `);\n\n    expect(z.toJSONSchema(z.number().lt(5).lt(3).lte(2))).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"maximum\": 2,\n        \"type\": \"number\",\n      }\n    `);\n\n    expect(z.toJSONSchema(z.number().lt(5).lte(3))).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"maximum\": 3,\n        \"type\": \"number\",\n      }\n    `);\n\n    expect(z.toJSONSchema(z.number().gt(5).lt(10))).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"exclusiveMaximum\": 10,\n        \"exclusiveMinimum\": 5,\n        \"type\": \"number\",\n      }\n    `);\n    expect(z.toJSONSchema(z.number().gte(5).lte(10))).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"maximum\": 10,\n        \"minimum\": 5,\n        \"type\": \"number\",\n      }\n    `);\n    expect(z.toJSONSchema(z.number().positive())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"exclusiveMinimum\": 0,\n        \"type\": \"number\",\n      }\n    `);\n    expect(z.toJSONSchema(z.number().negative())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"exclusiveMaximum\": 0,\n        \"type\": \"number\",\n      }\n    `);\n    expect(z.toJSONSchema(z.number().nonpositive())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"maximum\": 0,\n        \"type\": \"number\",\n      }\n    `);\n    expect(z.toJSONSchema(z.number().nonnegative())).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"minimum\": 0,\n        \"type\": \"number\",\n      }\n    `);\n  });\n\n  test(\"arrays\", () => {\n    expect(z.toJSONSchema(z.array(z.string()))).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"items\": {\n          \"type\": \"string\",\n        },\n        \"type\": \"array\",\n      }\n    `);\n  });\n\n  test(\"unions\", () => {\n    const schema = z.union([z.string(), z.number()]);\n    expect(z.toJSONSchema(schema)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"anyOf\": [\n          {\n            \"type\": \"string\",\n          },\n          {\n            \"type\": \"number\",\n          },\n        ],\n      }\n    `);\n  });\n\n  test(\"intersections\", () => {\n    const schema = z.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));\n\n    expect(z.toJSONSchema(schema)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"allOf\": [\n          {\n            \"additionalProperties\": false,\n            \"properties\": {\n              \"name\": {\n                \"type\": \"string\",\n              },\n            },\n            \"required\": [\n              \"name\",\n            ],\n            \"type\": \"object\",\n          },\n          {\n            \"additionalProperties\": false,\n            \"properties\": {\n              \"age\": {\n                \"type\": \"number\",\n              },\n            },\n            \"required\": [\n              \"age\",\n            ],\n            \"type\": \"object\",\n          },\n        ],\n      }\n    `);\n  });\n\n  test(\"record\", () => {\n    const schema = z.record(z.string(), z.boolean());\n    expect(z.toJSONSchema(schema)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"additionalProperties\": {\n          \"type\": \"boolean\",\n        },\n        \"propertyNames\": {\n          \"type\": \"string\",\n        },\n        \"type\": \"object\",\n      }\n    `);\n  });\n\n  test(\"tuple\", () => {\n    const schema = z.tuple([z.string(), z.number()]).rest(z.boolean());\n    expect(z.toJSONSchema(schema)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"items\": {\n          \"type\": \"boolean\",\n        },\n        \"prefixItems\": [\n          {\n            \"type\": \"string\",\n          },\n          {\n            \"type\": \"number\",\n          },\n        ],\n        \"type\": \"array\",\n      }\n    `);\n  });\n\n  test(\"promise\", () => {\n    const schema = z.promise(z.string());\n    expect(z.toJSONSchema(schema)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"type\": \"string\",\n      }\n    `);\n  });\n\n  test(\"lazy\", () => {\n    const schema = z.lazy(() => z.string());\n    expect(z.toJSONSchema(schema)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"type\": \"string\",\n      }\n    `);\n  });\n\n  // enum\n  test(\"enum\", () => {\n    const a = z.enum([\"a\", \"b\", \"c\"]);\n    expect(z.toJSONSchema(a)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"enum\": [\n          \"a\",\n          \"b\",\n          \"c\",\n        ],\n        \"type\": \"string\",\n      }\n    `);\n\n    enum B {\n      A = 0,\n      B = 1,\n      C = 2,\n    }\n\n    const b = z.enum(B);\n    expect(z.toJSONSchema(b)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"enum\": [\n          0,\n          1,\n          2,\n        ],\n        \"type\": \"number\",\n      }\n    `);\n  });\n\n  // literal\n  test(\"literal\", () => {\n    const a = z.literal(\"hello\");\n    expect(z.toJSONSchema(a)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"const\": \"hello\",\n        \"type\": \"string\",\n      }\n    `);\n\n    const b = z.literal(7);\n    expect(z.toJSONSchema(b)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"const\": 7,\n        \"type\": \"number\",\n      }\n    `);\n\n    const c = z.literal([\"hello\", undefined, null, 5, BigInt(1324)]);\n    expect(() => z.toJSONSchema(c)).toThrow();\n\n    const d = z.literal([\"hello\", null, 5]);\n    expect(z.toJSONSchema(d)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"enum\": [\n          \"hello\",\n          null,\n          5,\n        ],\n      }\n    `);\n\n    const e = z.literal([\"hello\", \"zod\", \"v4\"]);\n    expect(z.toJSONSchema(e)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"enum\": [\n          \"hello\",\n          \"zod\",\n          \"v4\",\n        ],\n        \"type\": \"string\",\n      }\n    `);\n  });\n\n  // pipe\n  test(\"pipe\", () => {\n    const schema = z\n      .string()\n      .transform((val) => Number.parseInt(val))\n      .pipe(z.number());\n    expect(z.toJSONSchema(schema)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"type\": \"number\",\n      }\n    `);\n  });\n\n  test(\"simple objects\", () => {\n    const schema = z.object({\n      name: z.string(),\n      age: z.number(),\n    });\n\n    expect(z.toJSONSchema(schema)).toMatchInlineSnapshot(\n      `\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"age\": {\n            \"type\": \"number\",\n          },\n          \"name\": {\n            \"type\": \"string\",\n          },\n        },\n        \"required\": [\n          \"name\",\n          \"age\",\n        ],\n        \"type\": \"object\",\n      }\n    `\n    );\n  });\n\n  test(\"additionalproperties in z.object\", () => {\n    const a = z.object({\n      name: z.string(),\n    });\n    expect(z.toJSONSchema(a)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n          },\n        },\n        \"required\": [\n          \"name\",\n        ],\n        \"type\": \"object\",\n      }\n    `);\n    expect(z.toJSONSchema(a, { io: \"input\" })).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n          },\n        },\n        \"required\": [\n          \"name\",\n        ],\n        \"type\": \"object\",\n      }\n    `);\n    expect(\n      z.toJSONSchema(a, {\n        io: \"input\",\n        override(ctx) {\n          const def = ctx.zodSchema._zod.def;\n          if (def.type === \"object\" && !def.catchall) {\n            (ctx.jsonSchema as z.core.JSONSchema.ObjectSchema).additionalProperties = false;\n          }\n        },\n      })\n    ).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n          },\n        },\n        \"required\": [\n          \"name\",\n        ],\n        \"type\": \"object\",\n      }\n    `);\n  });\n\n  test(\"catchall objects\", () => {\n    const a = z.strictObject({\n      name: z.string(),\n      age: z.number(),\n    });\n\n    expect(z.toJSONSchema(a)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"age\": {\n            \"type\": \"number\",\n          },\n          \"name\": {\n            \"type\": \"string\",\n          },\n        },\n        \"required\": [\n          \"name\",\n          \"age\",\n        ],\n        \"type\": \"object\",\n      }\n    `);\n\n    const b = z\n      .object({\n        name: z.string(),\n      })\n      .catchall(z.string());\n\n    expect(z.toJSONSchema(b)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"additionalProperties\": {\n          \"type\": \"string\",\n        },\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n          },\n        },\n        \"required\": [\n          \"name\",\n        ],\n        \"type\": \"object\",\n      }\n    `);\n\n    const c = z.looseObject({\n      name: z.string(),\n    });\n\n    expect(z.toJSONSchema(c)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"additionalProperties\": {},\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n          },\n        },\n        \"required\": [\n          \"name\",\n        ],\n        \"type\": \"object\",\n      }\n    `);\n  });\n\n  test(\"optional fields - object\", () => {\n    const schema = z.object({\n      required: z.string(),\n      optional: z.string().optional(),\n      nonoptional: z.string().optional().nonoptional(),\n    });\n\n    const result = z.toJSONSchema(schema);\n\n    expect(result).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"nonoptional\": {\n            \"type\": \"string\",\n          },\n          \"optional\": {\n            \"type\": \"string\",\n          },\n          \"required\": {\n            \"type\": \"string\",\n          },\n        },\n        \"required\": [\n          \"required\",\n          \"nonoptional\",\n        ],\n        \"type\": \"object\",\n      }\n    `);\n  });\n\n  test(\"recursive object\", () => {\n    interface Category {\n      name: string;\n      subcategories: Category[];\n    }\n\n    const categorySchema: z.ZodType<Category> = z.object({\n      name: z.string(),\n      subcategories: z.array(z.lazy(() => categorySchema)),\n    });\n\n    const result = z.toJSONSchema(categorySchema);\n    expect(result).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n          },\n          \"subcategories\": {\n            \"items\": {\n              \"$ref\": \"#\",\n            },\n            \"type\": \"array\",\n          },\n        },\n        \"required\": [\n          \"name\",\n          \"subcategories\",\n        ],\n        \"type\": \"object\",\n      }\n    `);\n  });\n\n  test(\"simple interface\", () => {\n    const userSchema = z.object({\n      name: z.string(),\n      age: z.number().optional(),\n    });\n\n    const result = z.toJSONSchema(userSchema);\n    expect(result).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"age\": {\n            \"type\": \"number\",\n          },\n          \"name\": {\n            \"type\": \"string\",\n          },\n        },\n        \"required\": [\n          \"name\",\n        ],\n        \"type\": \"object\",\n      }\n    `);\n  });\n\n  test(\"catchall interface\", () => {\n    const a = z.strictObject({\n      name: z.string(),\n      age: z.number(),\n    });\n\n    expect(z.toJSONSchema(a)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"age\": {\n            \"type\": \"number\",\n          },\n          \"name\": {\n            \"type\": \"string\",\n          },\n        },\n        \"required\": [\n          \"name\",\n          \"age\",\n        ],\n        \"type\": \"object\",\n      }\n    `);\n\n    const b = z\n      .object({\n        name: z.string(),\n      })\n      .catchall(z.string());\n\n    expect(z.toJSONSchema(b)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"additionalProperties\": {\n          \"type\": \"string\",\n        },\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n          },\n        },\n        \"required\": [\n          \"name\",\n        ],\n        \"type\": \"object\",\n      }\n    `);\n\n    const c = z.looseObject({\n      name: z.string(),\n    });\n\n    expect(z.toJSONSchema(c)).toMatchInlineSnapshot(`\n      {\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"additionalProperties\": {},\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n          },\n        },\n        \"required\": [\n          \"name\",\n        ],\n        \"type\": \"object\",\n      }\n    `);\n  });\n\n  test(\"recursive interface schemas\", () => {\n    const TreeNodeSchema = z.object({\n      id: z.string(),\n      get children() {\n        return TreeNodeSchema;\n      },\n    });\n\n    const result = z.toJSONSchema(TreeNodeSchema);\n\n    // Should have definitions for recursive schema\n    expect(JSON.stringify(result, null, 2)).toMatchInlineSnapshot(\n      `\n      \"{\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\"\n          },\n          \"children\": {\n            \"$ref\": \"#\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"children\"\n        ],\n        \"additionalProperties\": false\n      }\"\n    `\n    );\n  });\n\n  test(\"mutually recursive interface schemas\", () => {\n    const FolderSchema = z.object({\n      name: z.string(),\n      get files() {\n        return z.array(FileSchema);\n      },\n    });\n\n    const FileSchema = z.object({\n      name: z.string(),\n      get parent() {\n        return FolderSchema;\n      },\n    });\n\n    const result = z.toJSONSchema(FolderSchema);\n\n    // Should have definitions for both schemas\n    expect(JSON.stringify(result, null, 2)).toMatchInlineSnapshot(\n      `\n      \"{\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"object\",\n              \"properties\": {\n                \"name\": {\n                  \"type\": \"string\"\n                },\n                \"parent\": {\n                  \"$ref\": \"#\"\n                }\n              },\n              \"required\": [\n                \"name\",\n                \"parent\"\n              ],\n              \"additionalProperties\": false\n            }\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"files\"\n        ],\n        \"additionalProperties\": false\n      }\"\n    `\n    );\n  });\n});\n\ntest(\"override\", () => {\n  const schema = z.z.toJSONSchema(z.string(), {\n    override: (ctx) => {\n      ctx.zodSchema;\n      ctx.jsonSchema;\n      ctx.jsonSchema.whatever = \"sup\";\n    },\n  });\n  expect(schema).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"type\": \"string\",\n      \"whatever\": \"sup\",\n    }\n  `);\n});\n\ntest(\"override: do not run on references\", () => {\n  let overrideCount = 0;\n  const schema = z\n    .union([z.string().date(), z.string().datetime(), z.string().datetime({ local: true })])\n    .meta({ a: true })\n    .transform((str) => new Date(str))\n    .meta({ b: true })\n    .pipe(z.date())\n    .meta({ c: true })\n    .brand(\"dateIn\");\n  z.z.toJSONSchema(schema, {\n    unrepresentable: \"any\",\n    io: \"input\",\n    override(_) {\n      overrideCount++;\n    },\n  });\n\n  expect(overrideCount).toBe(6);\n});\n\ntest(\"override with refs\", () => {\n  const a = z.string().optional();\n  const result = z.z.toJSONSchema(a, {\n    override(ctx) {\n      if (ctx.zodSchema._zod.def.type === \"string\") {\n        ctx.jsonSchema.type = \"STRING\" as \"string\";\n      }\n    },\n  });\n\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"type\": \"STRING\",\n    }\n  `);\n});\n\ntest(\"override execution order\", () => {\n  const schema = z.union([z.string(), z.number()]);\n  let unionSchema!: any;\n  z.z.toJSONSchema(schema, {\n    override(ctx) {\n      if (ctx.zodSchema._zod.def.type === \"union\") {\n        unionSchema = ctx.jsonSchema;\n      }\n    },\n  });\n\n  expect(unionSchema).toMatchInlineSnapshot(`\n    {\n      \"anyOf\": [\n        {\n          \"type\": \"string\",\n        },\n        {\n          \"type\": \"number\",\n        },\n      ],\n    }\n  `);\n});\n\ntest(\"override with path\", () => {\n  const userSchema = z.object({\n    name: z.string(),\n    age: z.number(),\n  });\n\n  const capturedPaths: (string | number)[][] = [];\n\n  z.toJSONSchema(userSchema, {\n    override(ctx) {\n      capturedPaths.push(ctx.path);\n    },\n  });\n\n  expect(capturedPaths).toMatchInlineSnapshot(`\n    [\n      [\n        \"properties\",\n        \"age\",\n      ],\n      [\n        \"properties\",\n        \"name\",\n      ],\n      [],\n    ]\n  `);\n});\n\ntest(\"pipe\", () => {\n  const mySchema = z\n    .string()\n    .transform((val) => val.length)\n    .pipe(z.number());\n  // ZodPipe\n\n  const a = z.z.toJSONSchema(mySchema);\n  expect(a).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"type\": \"number\",\n    }\n  `);\n  // => { type: \"number\" }\n\n  const b = z.z.toJSONSchema(mySchema, { io: \"input\" });\n  expect(b).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"type\": \"string\",\n    }\n  `);\n  // => { type: \"string\" }\n});\n\ntest(\"passthrough schemas\", () => {\n  const Internal = z.object({\n    num: z.number(),\n    str: z.string(),\n  });\n  //.meta({ id: \"Internal\" });\n\n  const External = z.object({\n    a: Internal,\n    b: Internal.optional(),\n    c: z.lazy(() => Internal),\n    d: z.promise(Internal),\n    e: z.pipe(Internal, Internal),\n  });\n\n  const result = z.z.toJSONSchema(External, {\n    reused: \"ref\",\n  });\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"$defs\": {\n        \"__schema0\": {\n          \"additionalProperties\": false,\n          \"properties\": {\n            \"num\": {\n              \"type\": \"number\",\n            },\n            \"str\": {\n              \"type\": \"string\",\n            },\n          },\n          \"required\": [\n            \"num\",\n            \"str\",\n          ],\n          \"type\": \"object\",\n        },\n      },\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"a\": {\n          \"$ref\": \"#/$defs/__schema0\",\n        },\n        \"b\": {\n          \"$ref\": \"#/$defs/__schema0\",\n        },\n        \"c\": {\n          \"$ref\": \"#/$defs/__schema0\",\n        },\n        \"d\": {\n          \"$ref\": \"#/$defs/__schema0\",\n        },\n        \"e\": {\n          \"$ref\": \"#/$defs/__schema0\",\n        },\n      },\n      \"required\": [\n        \"a\",\n        \"c\",\n        \"d\",\n        \"e\",\n      ],\n      \"type\": \"object\",\n    }\n  `);\n});\n\ntest(\"extract schemas with id\", () => {\n  const name = z.string().meta({ id: \"name\" });\n  const result = z.z.toJSONSchema(\n    z.object({\n      first_name: name,\n      last_name: name.nullable(),\n      middle_name: name.optional(),\n      age: z.number().meta({ id: \"age\" }),\n    })\n  );\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"$defs\": {\n        \"age\": {\n          \"id\": \"age\",\n          \"type\": \"number\",\n        },\n        \"name\": {\n          \"id\": \"name\",\n          \"type\": \"string\",\n        },\n      },\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"age\": {\n          \"$ref\": \"#/$defs/age\",\n        },\n        \"first_name\": {\n          \"$ref\": \"#/$defs/name\",\n        },\n        \"last_name\": {\n          \"anyOf\": [\n            {\n              \"$ref\": \"#/$defs/name\",\n            },\n            {\n              \"type\": \"null\",\n            },\n          ],\n        },\n        \"middle_name\": {\n          \"$ref\": \"#/$defs/name\",\n        },\n      },\n      \"required\": [\n        \"first_name\",\n        \"last_name\",\n        \"age\",\n      ],\n      \"type\": \"object\",\n    }\n  `);\n});\n\ntest(\"unrepresentable literal values are ignored\", () => {\n  const a = z.z.toJSONSchema(z.literal([\"hello\", null, 5, BigInt(1324), undefined]), { unrepresentable: \"any\" });\n  expect(a).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"enum\": [\n        \"hello\",\n        null,\n        5,\n        1324,\n      ],\n    }\n  `);\n\n  const b = z.z.toJSONSchema(z.literal([undefined, null, 5, BigInt(1324)]), { unrepresentable: \"any\" });\n  expect(b).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"enum\": [\n        null,\n        5,\n        1324,\n      ],\n    }\n  `);\n\n  const c = z.z.toJSONSchema(z.literal([undefined]), { unrepresentable: \"any\" });\n  expect(c).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    }\n  `);\n});\n\ntest(\"describe with id\", () => {\n  const jobId = z.string().meta({ id: \"jobId\" });\n\n  const a = z.z.toJSONSchema(\n    z.object({\n      current: jobId.describe(\"Current job\"),\n      previous: jobId.describe(\"Previous job\"),\n    })\n  );\n  expect(a).toMatchInlineSnapshot(`\n    {\n      \"$defs\": {\n        \"jobId\": {\n          \"id\": \"jobId\",\n          \"type\": \"string\",\n        },\n      },\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"current\": {\n          \"$ref\": \"#/$defs/jobId\",\n          \"description\": \"Current job\",\n        },\n        \"previous\": {\n          \"$ref\": \"#/$defs/jobId\",\n          \"description\": \"Previous job\",\n        },\n      },\n      \"required\": [\n        \"current\",\n        \"previous\",\n      ],\n      \"type\": \"object\",\n    }\n  `);\n});\n\ntest(\"overwrite id\", () => {\n  const jobId = z.string().meta({ id: \"aaa\" });\n\n  const a = z.z.toJSONSchema(\n    z.object({\n      current: jobId,\n      previous: jobId.meta({ id: \"bbb\" }),\n    })\n  );\n  expect(a).toMatchInlineSnapshot(`\n    {\n      \"$defs\": {\n        \"aaa\": {\n          \"id\": \"aaa\",\n          \"type\": \"string\",\n        },\n        \"bbb\": {\n          \"$ref\": \"#/$defs/aaa\",\n          \"id\": \"bbb\",\n        },\n      },\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"current\": {\n          \"$ref\": \"#/$defs/aaa\",\n        },\n        \"previous\": {\n          \"$ref\": \"#/$defs/bbb\",\n        },\n      },\n      \"required\": [\n        \"current\",\n        \"previous\",\n      ],\n      \"type\": \"object\",\n    }\n  `);\n\n  const b = z.z.toJSONSchema(\n    z.object({\n      current: jobId,\n      previous: jobId.meta({ id: \"ccc\" }),\n    }),\n    {\n      reused: \"ref\",\n    }\n  );\n  expect(b).toMatchInlineSnapshot(`\n    {\n      \"$defs\": {\n        \"aaa\": {\n          \"id\": \"aaa\",\n          \"type\": \"string\",\n        },\n        \"ccc\": {\n          \"$ref\": \"#/$defs/aaa\",\n          \"id\": \"ccc\",\n        },\n      },\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"current\": {\n          \"$ref\": \"#/$defs/aaa\",\n        },\n        \"previous\": {\n          \"$ref\": \"#/$defs/ccc\",\n        },\n      },\n      \"required\": [\n        \"current\",\n        \"previous\",\n      ],\n      \"type\": \"object\",\n    }\n  `);\n});\n\ntest(\"overwrite descriptions\", () => {\n  const field = z.string().describe(\"a\").describe(\"b\").describe(\"c\");\n\n  const a = z.z.toJSONSchema(\n    z.object({\n      d: field.describe(\"d\"),\n      e: field.describe(\"e\"),\n    })\n  );\n  expect(a).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"d\": {\n          \"description\": \"d\",\n          \"type\": \"string\",\n        },\n        \"e\": {\n          \"description\": \"e\",\n          \"type\": \"string\",\n        },\n      },\n      \"required\": [\n        \"d\",\n        \"e\",\n      ],\n      \"type\": \"object\",\n    }\n  `);\n\n  const b = z.z.toJSONSchema(\n    z.object({\n      d: field.describe(\"d\"),\n      e: field.describe(\"e\"),\n    }),\n    {\n      reused: \"ref\",\n    }\n  );\n  expect(b).toMatchInlineSnapshot(`\n    {\n      \"$defs\": {\n        \"__schema0\": {\n          \"description\": \"c\",\n          \"type\": \"string\",\n        },\n      },\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"d\": {\n          \"$ref\": \"#/$defs/__schema0\",\n          \"description\": \"d\",\n        },\n        \"e\": {\n          \"$ref\": \"#/$defs/__schema0\",\n          \"description\": \"e\",\n        },\n      },\n      \"required\": [\n        \"d\",\n        \"e\",\n      ],\n      \"type\": \"object\",\n    }\n  `);\n});\n\ntest(\"top-level readonly\", () => {\n  const A = z\n    .object({\n      name: z.string(),\n      get b() {\n        return B;\n      },\n    })\n    .readonly()\n    .meta({ id: \"A\" });\n  // z.globalRegistry.add(A, { id: \"A\" });\n  // .meta({ id: \"A\" });\n\n  const B = z\n    .object({\n      name: z.string(),\n      get a() {\n        return A;\n      },\n    })\n    .readonly()\n    .meta({ id: \"B\" });\n  // z.globalRegistry.add(B, { id: \"B\" });\n  // .meta({ id: \"B\" });\n\n  const result = z.z.toJSONSchema(A);\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"$defs\": {\n        \"B\": {\n          \"additionalProperties\": false,\n          \"id\": \"B\",\n          \"properties\": {\n            \"a\": {\n              \"$ref\": \"#\",\n            },\n            \"name\": {\n              \"type\": \"string\",\n            },\n          },\n          \"readOnly\": true,\n          \"required\": [\n            \"name\",\n            \"a\",\n          ],\n          \"type\": \"object\",\n        },\n      },\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"id\": \"A\",\n      \"properties\": {\n        \"b\": {\n          \"$ref\": \"#/$defs/B\",\n        },\n        \"name\": {\n          \"type\": \"string\",\n        },\n      },\n      \"readOnly\": true,\n      \"required\": [\n        \"name\",\n        \"b\",\n      ],\n      \"type\": \"object\",\n    }\n  `);\n});\n\ntest(\"basic registry\", () => {\n  const myRegistry = z.registry<{ id: string }>();\n  const User = z.object({\n    name: z.string(),\n    get posts() {\n      return z.array(Post);\n    },\n  });\n\n  const Post = z.object({\n    title: z.string(),\n    content: z.string(),\n    get author() {\n      return User;\n    },\n  });\n\n  myRegistry.add(User, { id: \"User\" });\n  myRegistry.add(Post, { id: \"Post\" });\n\n  const result = z.z.toJSONSchema(myRegistry, { uri: (id) => `https://example.com/${id}.json` });\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"schemas\": {\n        \"Post\": {\n          \"$id\": \"https://example.com/Post.json\",\n          \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n          \"additionalProperties\": false,\n          \"properties\": {\n            \"author\": {\n              \"$ref\": \"https://example.com/User.json\",\n            },\n            \"content\": {\n              \"type\": \"string\",\n            },\n            \"title\": {\n              \"type\": \"string\",\n            },\n          },\n          \"required\": [\n            \"title\",\n            \"content\",\n            \"author\",\n          ],\n          \"type\": \"object\",\n        },\n        \"User\": {\n          \"$id\": \"https://example.com/User.json\",\n          \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n          \"additionalProperties\": false,\n          \"properties\": {\n            \"name\": {\n              \"type\": \"string\",\n            },\n            \"posts\": {\n              \"items\": {\n                \"$ref\": \"https://example.com/Post.json\",\n              },\n              \"type\": \"array\",\n            },\n          },\n          \"required\": [\n            \"name\",\n            \"posts\",\n          ],\n          \"type\": \"object\",\n        },\n      },\n    }\n  `);\n});\n\ntest(\"_ref\", () => {\n  // const a = z.promise(z.string().describe(\"a\"));\n  const a = z.z.toJSONSchema(z.promise(z.string().describe(\"a\")));\n  expect(a).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"description\": \"a\",\n      \"type\": \"string\",\n    }\n  `);\n\n  const b = z.z.toJSONSchema(z.lazy(() => z.string().describe(\"a\")));\n  expect(b).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"description\": \"a\",\n      \"type\": \"string\",\n    }\n  `);\n\n  const c = z.z.toJSONSchema(z.optional(z.string().describe(\"a\")));\n  expect(c).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"description\": \"a\",\n      \"type\": \"string\",\n    }\n  `);\n});\n\ntest(\"defaults/prefaults\", () => {\n  const a = z\n    .string()\n    .transform((val) => val.length)\n    .pipe(z.number());\n  const b = a.prefault(\"hello\");\n  const c = a.default(1234);\n\n  // a\n  expect(z.toJSONSchema(a)).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"type\": \"number\",\n    }\n  `);\n  expect(z.toJSONSchema(a, { io: \"input\" })).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"type\": \"string\",\n    }\n  `);\n\n  // b\n  expect(z.toJSONSchema(b)).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"type\": \"number\",\n    }\n  `);\n  expect(z.toJSONSchema(b, { io: \"input\" })).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"default\": \"hello\",\n      \"type\": \"string\",\n    }\n  `);\n  // c\n  expect(z.toJSONSchema(c)).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"default\": 1234,\n      \"type\": \"number\",\n    }\n  `);\n  expect(z.toJSONSchema(c, { io: \"input\" })).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"type\": \"string\",\n    }\n  `);\n});\n\ntest(\"input type\", () => {\n  const schema = z.object({\n    a: z.string(),\n    b: z.string().optional(),\n    c: z.string().default(\"hello\"),\n    d: z.string().nullable(),\n    e: z.string().prefault(\"hello\"),\n    f: z.string().catch(\"hello\"),\n    g: z.never(),\n    h: z.union([z.string(), z.number().default(2)]),\n    i: z.union([z.string(), z.string().optional()]),\n  });\n  expect(z.toJSONSchema(schema, { io: \"input\" })).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"properties\": {\n        \"a\": {\n          \"type\": \"string\",\n        },\n        \"b\": {\n          \"type\": \"string\",\n        },\n        \"c\": {\n          \"default\": \"hello\",\n          \"type\": \"string\",\n        },\n        \"d\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\",\n            },\n            {\n              \"type\": \"null\",\n            },\n          ],\n        },\n        \"e\": {\n          \"default\": \"hello\",\n          \"type\": \"string\",\n        },\n        \"f\": {\n          \"default\": \"hello\",\n          \"type\": \"string\",\n        },\n        \"g\": {\n          \"not\": {},\n        },\n        \"h\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\",\n            },\n            {\n              \"default\": 2,\n              \"type\": \"number\",\n            },\n          ],\n        },\n        \"i\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\",\n            },\n            {\n              \"type\": \"string\",\n            },\n          ],\n        },\n      },\n      \"required\": [\n        \"a\",\n        \"d\",\n        \"g\",\n      ],\n      \"type\": \"object\",\n    }\n  `);\n  expect(z.toJSONSchema(schema, { io: \"output\" })).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"a\": {\n          \"type\": \"string\",\n        },\n        \"b\": {\n          \"type\": \"string\",\n        },\n        \"c\": {\n          \"default\": \"hello\",\n          \"type\": \"string\",\n        },\n        \"d\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\",\n            },\n            {\n              \"type\": \"null\",\n            },\n          ],\n        },\n        \"e\": {\n          \"type\": \"string\",\n        },\n        \"f\": {\n          \"default\": \"hello\",\n          \"type\": \"string\",\n        },\n        \"g\": {\n          \"not\": {},\n        },\n        \"h\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\",\n            },\n            {\n              \"default\": 2,\n              \"type\": \"number\",\n            },\n          ],\n        },\n        \"i\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\",\n            },\n            {\n              \"type\": \"string\",\n            },\n          ],\n        },\n      },\n      \"required\": [\n        \"a\",\n        \"c\",\n        \"d\",\n        \"e\",\n        \"f\",\n        \"g\",\n        \"h\",\n      ],\n      \"type\": \"object\",\n    }\n  `);\n});\n\ntest(\"examples on pipe\", () => {\n  const schema = z\n    .string()\n    .meta({ examples: [\"test\"] })\n    .transform(Number)\n    // .pipe(z.transform(Number).meta({ examples: [4] }))\n    .meta({ examples: [4] });\n\n  const i = z.z.toJSONSchema(schema, { io: \"input\", unrepresentable: \"any\" });\n  expect(i).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"examples\": [\n        \"test\",\n      ],\n      \"type\": \"string\",\n    }\n  `);\n  const o = z.z.toJSONSchema(schema, { io: \"output\", unrepresentable: \"any\" });\n  expect(o).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"examples\": [\n        4,\n      ],\n    }\n  `);\n});\n\n// test(\"number checks\", () => {\n//   expect(z.z.toJSONSchema(z.number().int())).toMatchInlineSnapshot(`\n//     {\n//       \"maximum\": 9007199254740991,\n//       \"minimum\": -9007199254740991,\n//       \"type\": \"integer\",\n//     }\n//   `);\n//   expect(z.z.toJSONSchema(z.int())).toMatchInlineSnapshot(`\n//     {\n//       \"maximum\": 9007199254740991,\n//       \"minimum\": -9007199254740991,\n//       \"type\": \"integer\",\n//     }\n//   `);\n//   expect(z.z.toJSONSchema(z.int().positive())).toMatchInlineSnapshot(`\n//     {\n//       \"exclusiveMinimum\": 0,\n//       \"maximum\": 9007199254740991,\n//       \"minimum\": -9007199254740991,\n//       \"type\": \"integer\",\n//     }\n//   `);\n//   expect(z.z.toJSONSchema(z.int().nonnegative())).toMatchInlineSnapshot(`\n//     {\n//       \"maximum\": 9007199254740991,\n//       \"minimum\": 0,\n//       \"type\": \"integer\",\n//     }\n//   `);\n//   expect(z.z.toJSONSchema(z.int().gt(0))).toMatchInlineSnapshot(`\n//     {\n//       \"exclusiveMinimum\": 0,\n//       \"maximum\": 9007199254740991,\n//       \"minimum\": -9007199254740991,\n//       \"type\": \"integer\",\n//     }\n//   `);\n//   expect(z.z.toJSONSchema(z.int().gte(0))).toMatchInlineSnapshot(`\n//     {\n//       \"maximum\": 9007199254740991,\n//       \"minimum\": 0,\n//       \"type\": \"integer\",\n//     }\n//   `);\n\n// });\n\ntest(\"use output type for preprocess\", () => {\n  const a = z.preprocess((val) => String(val), z.string());\n\n  expect(z.toJSONSchema(a, { io: \"input\" })).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"type\": \"string\",\n    }\n  `);\n});\n\n// test(\"isTransforming\", () => {\n//   const tx = z.core.isTransforming;\n//   expect(tx(z.string())).toEqual(false);\n//   expect(tx(z.string().transform((val) => val))).toEqual(true);\n//   expect(tx(z.string().pipe(z.string()))).toEqual(false);\n//   expect(\n//     tx(\n//       z\n//         .string()\n//         .transform((val) => val)\n//         .pipe(z.string())\n//     )\n//   ).toEqual(true);\n\n//   const a = z.transform((val) => val);\n//   expect(tx(z.transform((val) => val))).toEqual(true);\n//   expect(tx(a.optional())).toEqual(true);\n\n//   const b = z.string().optional();\n//   expect(tx(b)).toEqual(false);\n\n//   const c = z.string().prefault(\"hello\");\n//   expect(tx(c)).toEqual(false);\n\n//   const d = z.string().default(\"hello\");\n//   expect(tx(d)).toEqual(false);\n// });\n\ntest(\"flatten simple intersections\", () => {\n  const FirstSchema = z.object({\n    testNum: z.number(),\n  });\n\n  const SecondSchema = z.object({\n    testStr: z.string(),\n  });\n\n  const ThirdSchema = z.object({\n    testBool: z.boolean(),\n  });\n\n  const HelloSchema = FirstSchema.and(SecondSchema).and(ThirdSchema).describe(\"123\");\n\n  // Zod 3\n  // console.log(JSON.stringify(zodToJsonSchema(HelloSchema), null, 2));\n\n  // Zod 4\n  const result = z.toJSONSchema(HelloSchema, { target: \"draft-7\" });\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n      \"allOf\": [\n        {\n          \"additionalProperties\": false,\n          \"properties\": {\n            \"testNum\": {\n              \"type\": \"number\",\n            },\n          },\n          \"required\": [\n            \"testNum\",\n          ],\n          \"type\": \"object\",\n        },\n        {\n          \"additionalProperties\": false,\n          \"properties\": {\n            \"testStr\": {\n              \"type\": \"string\",\n            },\n          },\n          \"required\": [\n            \"testStr\",\n          ],\n          \"type\": \"object\",\n        },\n        {\n          \"additionalProperties\": false,\n          \"properties\": {\n            \"testBool\": {\n              \"type\": \"boolean\",\n            },\n          },\n          \"required\": [\n            \"testBool\",\n          ],\n          \"type\": \"object\",\n        },\n      ],\n      \"description\": \"123\",\n    }\n  `);\n});\n\ntest(\"z.file()\", () => {\n  const a = z.file();\n  expect(z.toJSONSchema(a)).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"contentEncoding\": \"binary\",\n      \"format\": \"binary\",\n      \"type\": \"string\",\n    }\n  `);\n\n  const b = z.file().mime(\"image/png\").min(1000).max(10000);\n  expect(z.toJSONSchema(b)).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"contentEncoding\": \"binary\",\n      \"contentMediaType\": \"image/png\",\n      \"format\": \"binary\",\n      \"maxLength\": 10000,\n      \"minLength\": 1000,\n      \"type\": \"string\",\n    }\n  `);\n\n  const c = z.file().mime([\"image/png\", \"image/jpg\"]).min(1000).max(10000);\n  expect(z.toJSONSchema(c)).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"anyOf\": [\n        {\n          \"contentEncoding\": \"binary\",\n          \"contentMediaType\": \"image/png\",\n          \"format\": \"binary\",\n          \"maxLength\": 10000,\n          \"minLength\": 1000,\n          \"type\": \"string\",\n        },\n        {\n          \"contentEncoding\": \"binary\",\n          \"contentMediaType\": \"image/jpg\",\n          \"format\": \"binary\",\n          \"maxLength\": 10000,\n          \"minLength\": 1000,\n          \"type\": \"string\",\n        },\n      ],\n    }\n  `);\n});\n\ntest(\"custom toJSONSchema\", () => {\n  const schema = z.instanceof(Date);\n  schema._zod.toJSONSchema = () => ({\n    type: \"string\",\n    format: \"date-time\",\n  });\n\n  expect(z.toJSONSchema(schema)).toMatchInlineSnapshot(`\n    {\n      \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n      \"format\": \"date-time\",\n      \"type\": \"string\",\n    }\n  `);\n});\n\ntest(\"cycle detection - root\", () => {\n  const schema = z.object({\n    name: z.string(),\n    get subcategories() {\n      return z.array(schema);\n    },\n  });\n\n  expect(() => z.toJSONSchema(schema, { cycles: \"throw\" })).toThrowErrorMatchingInlineSnapshot(`\n    [Error: Cycle detected: #/properties/subcategories/items/<root>\n\n    Set the \\`cycles\\` parameter to \\`\"ref\"\\` to resolve cyclical schemas with defs.]\n  `);\n});\n\ntest(\"cycle detection - mutual recursion\", () => {\n  const A = z.object({\n    name: z.string(),\n    get subcategories() {\n      return z.array(B);\n    },\n  });\n\n  const B = z.object({\n    name: z.string(),\n    get subcategories() {\n      return z.array(A);\n    },\n  });\n\n  expect(() => z.toJSONSchema(A, { cycles: \"throw\" })).toThrowErrorMatchingInlineSnapshot(`\n    [Error: Cycle detected: #/properties/subcategories/items/properties/subcategories/items/<root>\n\n    Set the \\`cycles\\` parameter to \\`\"ref\"\\` to resolve cyclical schemas with defs.]\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/transform.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"transform ctx.addIssue with parse\", () => {\n  const strs = [\"foo\", \"bar\"];\n  const schema = z.string().transform((data, ctx) => {\n    const i = strs.indexOf(data);\n    if (i === -1) {\n      ctx.addIssue({\n        input: data,\n        code: \"custom\",\n        message: `${data} is not one of our allowed strings`,\n      });\n    }\n    return data.length;\n  });\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n  expect(result.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"message\": \"asdf is not one of our allowed strings\",\n        \"path\": []\n      }\n    ]]\n  `);\n});\n\ntest(\"transform ctx.addIssue with parseAsync\", async () => {\n  const strs = [\"foo\", \"bar\"];\n\n  const result = await z\n    .string()\n    .transform(async (data, ctx) => {\n      const i = strs.indexOf(data);\n      if (i === -1) {\n        ctx.addIssue({\n          input: data,\n          code: \"custom\",\n          message: `${data} is not one of our allowed strings`,\n        });\n      }\n      return data.length;\n    })\n    .safeParseAsync(\"asdf\");\n\n  expect(result).toMatchInlineSnapshot(`\n    {\n      \"error\": [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"message\": \"asdf is not one of our allowed strings\",\n        \"path\": []\n      }\n    ]],\n      \"success\": false,\n    }\n  `);\n});\n\ntest(\"z.NEVER in transform\", () => {\n  const foo = z\n    .number()\n    .optional()\n    .transform((val, ctx) => {\n      if (!val) {\n        ctx.addIssue({\n          input: val,\n          code: z.ZodIssueCode.custom,\n          message: \"bad\",\n        });\n        return z.NEVER;\n      }\n      return val;\n    });\n  type foo = z.infer<typeof foo>;\n  expectTypeOf<foo>().toEqualTypeOf<number>();\n  const arg = foo.safeParse(undefined);\n  if (!arg.success) {\n    expect(arg.error.issues[0].message).toEqual(\"bad\");\n  }\n});\n\ntest(\"basic transformations\", () => {\n  const r1 = z\n    .string()\n    .transform((data) => data.length)\n    .parse(\"asdf\");\n  expect(r1).toEqual(4);\n});\n\ntest(\"coercion\", () => {\n  const numToString = z.number().transform((n) => String(n));\n  const data = z\n    .object({\n      id: numToString,\n    })\n    .parse({ id: 5 });\n\n  expect(data).toEqual({ id: \"5\" });\n});\n\ntest(\"async coercion\", async () => {\n  const numToString = z.number().transform(async (n) => String(n));\n  const data = await z\n    .object({\n      id: numToString,\n    })\n    .parseAsync({ id: 5 });\n\n  expect(data).toEqual({ id: \"5\" });\n});\n\ntest(\"sync coercion async error\", async () => {\n  const asyncNumberToString = z.number().transform(async (n) => String(n));\n  expect(() =>\n    z\n      .object({\n        id: asyncNumberToString,\n      })\n      .parse({ id: 5 })\n  ).toThrow();\n  // expect(data).toEqual({ id: '5' });\n});\n\ntest(\"default\", () => {\n  const data = z.string().default(\"asdf\").parse(undefined); // => \"asdf\"\n  expect(data).toEqual(\"asdf\");\n});\n\ntest(\"dynamic default\", () => {\n  const data = z\n    .string()\n    .default(() => \"string\")\n    .parse(undefined); // => \"asdf\"\n  expect(data).toEqual(\"string\");\n});\n\ntest(\"default when property is null or undefined\", () => {\n  const data = z\n    .object({\n      foo: z.boolean().nullable().default(true),\n      bar: z.boolean().default(true),\n    })\n    .parse({ foo: null });\n\n  expect(data).toEqual({ foo: null, bar: true });\n});\n\ntest(\"default with falsy values\", () => {\n  const schema = z.object({\n    emptyStr: z.string().default(\"def\"),\n    zero: z.number().default(5),\n    falseBoolean: z.boolean().default(true),\n  });\n  const input = { emptyStr: \"\", zero: 0, falseBoolean: true };\n  const output = schema.parse(input);\n  // defaults are not supposed to be used\n  expect(output).toEqual(input);\n});\n\ntest(\"object typing\", () => {\n  const stringToNumber = z.string().transform((arg) => Number.parseFloat(arg));\n\n  const t1 = z.object({\n    stringToNumber,\n  });\n\n  type t1 = z.input<typeof t1>;\n  type t2 = z.output<typeof t1>;\n\n  expectTypeOf<t1>().toEqualTypeOf<{ stringToNumber: string }>();\n  expectTypeOf<t2>().toEqualTypeOf<{ stringToNumber: number }>();\n});\n\ntest(\"transform method overloads\", () => {\n  const t1 = z.string().transform((val) => val.toUpperCase());\n  expect(t1.parse(\"asdf\")).toEqual(\"ASDF\");\n\n  const t2 = z.string().transform((val) => val.length);\n  expect(t2.parse(\"asdf\")).toEqual(4);\n});\n\ntest(\"multiple transformers\", () => {\n  const stringToNumber = z.string().transform((arg) => Number.parseFloat(arg));\n\n  const doubler = stringToNumber.transform((val) => {\n    return val * 2;\n  });\n  expect(doubler.parse(\"5\")).toEqual(10);\n});\n\ntest(\"short circuit on dirty\", () => {\n  const schema = z\n    .string()\n    .refine(() => false)\n    .transform((val) => val.toUpperCase());\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]]\n  `);\n\n  const result2 = schema.safeParse(1234);\n  expect(result2.success).toEqual(false);\n  if (!result2.success) {\n    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);\n  }\n});\n\ntest(\"async short circuit on dirty\", async () => {\n  const schema = z\n    .string()\n    .refine(() => false)\n    .transform((val) => val.toUpperCase());\n  const result = await schema.spa(\"asdf\");\n  expect(result.success).toEqual(false);\n\n  expect(result.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"custom\",\n        \"path\": [],\n        \"message\": \"Invalid input\"\n      }\n    ]]\n  `);\n\n  const result2 = await schema.spa(1234);\n  expect(result2.success).toEqual(false);\n\n  expect(result2.error).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"string\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected string, received number\"\n      }\n    ]]\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/tuple.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\n\ntest(\"successful validation\", () => {\n  const testTuple = z.tuple([z.string(), z.number()]);\n  expectTypeOf<typeof testTuple._output>().toEqualTypeOf<[string, number]>();\n\n  const val = testTuple.parse([\"asdf\", 1234]);\n  expect(val).toEqual(val);\n\n  const r1 = testTuple.safeParse([\"asdf\", \"asdf\"]);\n  expect(r1.success).toEqual(false);\n  expect(r1.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          1\n        ],\n        \"message\": \"Invalid input: expected number, received string\"\n      }\n    ]]\n  `);\n\n  const r2 = testTuple.safeParse([\"asdf\", 1234, true]);\n  expect(r2.success).toEqual(false);\n  expect(r2.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"array\",\n        \"code\": \"too_big\",\n        \"maximum\": 2,\n        \"path\": [],\n        \"message\": \"Too big: expected array to have <2 items\"\n      }\n    ]]\n  `);\n\n  const r3 = testTuple.safeParse({});\n  expect(r3.success).toEqual(false);\n  expect(r3.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"tuple\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected tuple, received object\"\n      }\n    ]]\n  `);\n});\n\ntest(\"async validation\", async () => {\n  const testTuple = z\n    .tuple([z.string().refine(async () => true), z.number().refine(async () => true)])\n    .refine(async () => true);\n  expectTypeOf<typeof testTuple._output>().toEqualTypeOf<[string, number]>();\n\n  const val = await testTuple.parseAsync([\"asdf\", 1234]);\n  expect(val).toEqual(val);\n\n  const r1 = await testTuple.safeParseAsync([\"asdf\", \"asdf\"]);\n  expect(r1.success).toEqual(false);\n  expect(r1.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"number\",\n        \"code\": \"invalid_type\",\n        \"path\": [\n          1\n        ],\n        \"message\": \"Invalid input: expected number, received string\"\n      }\n    ]]\n  `);\n\n  const r2 = await testTuple.safeParseAsync([\"asdf\", 1234, true]);\n  expect(r2.success).toEqual(false);\n  expect(r2.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"origin\": \"array\",\n        \"code\": \"too_big\",\n        \"maximum\": 2,\n        \"path\": [],\n        \"message\": \"Too big: expected array to have <2 items\"\n      }\n    ]]\n  `);\n\n  const r3 = await testTuple.safeParseAsync({});\n  expect(r3.success).toEqual(false);\n  expect(r3.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"expected\": \"tuple\",\n        \"code\": \"invalid_type\",\n        \"path\": [],\n        \"message\": \"Invalid input: expected tuple, received object\"\n      }\n    ]]\n  `);\n});\n\ntest(\"tuple with optional elements\", () => {\n  const myTuple = z.tuple([z.string(), z.number().optional(), z.string().optional()]).rest(z.boolean());\n  expectTypeOf<typeof myTuple._output>().toEqualTypeOf<[string, number?, string?, ...boolean[]]>();\n\n  const goodData = [[\"asdf\"], [\"asdf\", 1234], [\"asdf\", 1234, \"asdf\"], [\"asdf\", 1234, \"asdf\", true, false, true]];\n  for (const data of goodData) {\n    expect(myTuple.parse(data)).toEqual(data);\n  }\n\n  const badData = [\n    [\"asdf\", \"asdf\"],\n    [\"asdf\", 1234, \"asdf\", \"asdf\"],\n    [\"asdf\", 1234, \"asdf\", true, false, \"asdf\"],\n  ];\n  for (const data of badData) {\n    expect(() => myTuple.parse(data)).toThrow();\n  }\n});\n\ntest(\"tuple with optional elements followed by required\", () => {\n  const myTuple = z.tuple([z.string(), z.number().optional(), z.string()]).rest(z.boolean());\n  expectTypeOf<typeof myTuple._output>().toEqualTypeOf<[string, number | undefined, string, ...boolean[]]>();\n\n  const goodData = [\n    [\"asdf\", 1234, \"asdf\"],\n    [\"asdf\", 1234, \"asdf\", true, false, true],\n  ];\n  for (const data of goodData) {\n    expect(myTuple.parse(data)).toEqual(data);\n  }\n\n  const badData = [\n    [\"asdf\"],\n    [\"asdf\", 1234],\n    [\"asdf\", 1234, \"asdf\", \"asdf\"],\n    [\"asdf\", 1234, \"asdf\", true, false, \"asdf\"],\n  ];\n  for (const data of badData) {\n    expect(() => myTuple.parse(data)).toThrow();\n  }\n});\n\ntest(\"tuple with rest schema\", () => {\n  const myTuple = z.tuple([z.string(), z.number()]).rest(z.boolean());\n  expect(myTuple.parse([\"asdf\", 1234, true, false, true])).toEqual([\"asdf\", 1234, true, false, true]);\n\n  expect(myTuple.parse([\"asdf\", 1234])).toEqual([\"asdf\", 1234]);\n\n  expect(() => myTuple.parse([\"asdf\", 1234, \"asdf\"])).toThrow();\n  type t1 = z.output<typeof myTuple>;\n\n  expectTypeOf<t1>().toEqualTypeOf<[string, number, ...boolean[]]>();\n});\n\ntest(\"sparse array input\", () => {\n  const schema = z.tuple([z.string(), z.number()]);\n  expect(() => schema.parse(new Array(2))).toThrow();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/union.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"function parsing\", () => {\n  const schema = z.union([z.string().refine(() => false), z.number().refine(() => false)]);\n  const result = schema.safeParse(\"asdf\");\n  expect(result.success).toEqual(false);\n});\n\ntest(\"union 2\", () => {\n  const result = z.union([z.number(), z.string().refine(() => false)]).safeParse(\"a\");\n  expect(result.success).toEqual(false);\n});\n\ntest(\"return valid over invalid\", () => {\n  const schema = z.union([\n    z.object({\n      email: z.string().email(),\n    }),\n    z.string(),\n  ]);\n  expect(schema.parse(\"asdf\")).toEqual(\"asdf\");\n  expect(schema.parse({ email: \"asdlkjf@lkajsdf.com\" })).toEqual({\n    email: \"asdlkjf@lkajsdf.com\",\n  });\n});\n\ntest(\"return errors from both union arms\", () => {\n  const result = z.union([z.number(), z.string().refine(() => false)]).safeParse(\"a\");\n  expect(result.success).toEqual(false);\n  if (!result.success) {\n    expect(result.error.issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"invalid_union\",\n          \"errors\": [\n            [\n              {\n                \"code\": \"invalid_type\",\n                \"expected\": \"number\",\n                \"message\": \"Invalid input: expected number, received string\",\n                \"path\": [],\n              },\n            ],\n            [\n              {\n                \"code\": \"custom\",\n                \"message\": \"Invalid input\",\n                \"path\": [],\n              },\n            ],\n          ],\n          \"message\": \"Invalid input\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"options getter\", async () => {\n  const union = z.union([z.string(), z.number()]);\n  union.options[0].parse(\"asdf\");\n  union.options[1].parse(1234);\n  await union.options[0].parseAsync(\"asdf\");\n  await union.options[1].parseAsync(1234);\n});\n\ntest(\"readonly union\", async () => {\n  const options = [z.string(), z.number()] as const;\n  const union = z.union(options);\n  union.parse(\"asdf\");\n  union.parse(12);\n});\n\ntest(\"union inferred types\", () => {\n  const test = z.object({}).or(z.array(z.object({})));\n\n  type Test = z.output<typeof test>; // <— any\n  expectTypeOf<Test>().toEqualTypeOf<Record<string, never> | Array<Record<string, never>>>();\n});\n\ntest(\"union values\", () => {\n  const schema = z.union([z.literal(\"a\"), z.literal(\"b\"), z.literal(\"c\")]);\n\n  expect(schema._zod.values).toMatchInlineSnapshot(`\n    Set {\n      \"a\",\n      \"b\",\n      \"c\",\n    }\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/validations.test.ts",
    "content": "import { expect, test } from \"vitest\";\n\nimport * as z from \"zod/v4\";\n\ntest(\"string length\", async () => {\n  try {\n    await z.string().length(4).parseAsync(\"asd\");\n  } catch (err) {\n    // (\"String must contain exactly 4 character(s)\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_small\",\n          \"exact\": true,\n          \"inclusive\": true,\n          \"message\": \"Too small: expected string to have >=4 characters\",\n          \"minimum\": 4,\n          \"origin\": \"string\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n\n  try {\n    await z.string().length(4).parseAsync(\"asdaa\");\n  } catch (err) {\n    // (\"String must contain exactly 4 character(s)\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_big\",\n          \"exact\": true,\n          \"inclusive\": true,\n          \"maximum\": 4,\n          \"message\": \"Too big: expected string to have <=4 characters\",\n          \"origin\": \"string\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"string min/max\", async () => {\n  try {\n    await z.string().min(4).parseAsync(\"asd\");\n  } catch (err) {\n    // (\"String must contain at least 4 character(s)\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_small\",\n          \"inclusive\": true,\n          \"message\": \"Too small: expected string to have >=4 characters\",\n          \"minimum\": 4,\n          \"origin\": \"string\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"string max\", async () => {\n  try {\n    await z.string().max(4).parseAsync(\"aasdfsdfsd\");\n  } catch (err) {\n    // (\"String must contain at most 4 character(s)\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_big\",\n          \"inclusive\": true,\n          \"maximum\": 4,\n          \"message\": \"Too big: expected string to have <=4 characters\",\n          \"origin\": \"string\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number min\", async () => {\n  try {\n    await z.number().min(3).parseAsync(2);\n  } catch (err) {\n    // (\"Number must be greater than or equal to 3\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_small\",\n          \"inclusive\": true,\n          \"message\": \"Too small: expected number to be >=3\",\n          \"minimum\": 3,\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number gte\", async () => {\n  try {\n    await z.number().gte(3).parseAsync(2);\n  } catch (err) {\n    // (\"Number must be greater than or equal to 3\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_small\",\n          \"inclusive\": true,\n          \"message\": \"Too small: expected number to be >=3\",\n          \"minimum\": 3,\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number gt\", async () => {\n  try {\n    await z.number().gt(3).parseAsync(3);\n  } catch (err) {\n    // (\"Number must be greater than or equal to 3\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_small\",\n          \"inclusive\": false,\n          \"message\": \"Too small: expected number to be >3\",\n          \"minimum\": 3,\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number max\", async () => {\n  try {\n    await z.number().max(3).parseAsync(4);\n  } catch (err) {\n    // (\"Number must be less than or equal to 3\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_big\",\n          \"inclusive\": true,\n          \"maximum\": 3,\n          \"message\": \"Too big: expected number to be <=3\",\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number lte\", async () => {\n  try {\n    await z.number().lte(3).parseAsync(4);\n  } catch (err) {\n    // (\"Number must be less than or equal to 3\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_big\",\n          \"inclusive\": true,\n          \"maximum\": 3,\n          \"message\": \"Too big: expected number to be <=3\",\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number lt\", async () => {\n  try {\n    await z.number().lt(3).parseAsync(3);\n  } catch (err) {\n    // (\"Number must be less than or equal to 3\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_big\",\n          \"inclusive\": false,\n          \"maximum\": 3,\n          \"message\": \"Too big: expected number to be <3\",\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number nonnegative\", async () => {\n  try {\n    await z.number().nonnegative().parseAsync(-1);\n  } catch (err) {\n    // (\"Number must be greater than or equal to 0\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_small\",\n          \"inclusive\": true,\n          \"message\": \"Too small: expected number to be >=0\",\n          \"minimum\": 0,\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number nonpositive\", async () => {\n  try {\n    await z.number().nonpositive().parseAsync(1);\n  } catch (err) {\n    // (\"Number must be less than or equal to 0\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_big\",\n          \"inclusive\": true,\n          \"maximum\": 0,\n          \"message\": \"Too big: expected number to be <=0\",\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number negative\", async () => {\n  try {\n    await z.number().negative().parseAsync(1);\n  } catch (err) {\n    // (\"Number must be less than 0\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_big\",\n          \"inclusive\": false,\n          \"maximum\": 0,\n          \"message\": \"Too big: expected number to be <0\",\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n\ntest(\"number positive\", async () => {\n  try {\n    await z.number().positive().parseAsync(-1);\n  } catch (err) {\n    // (\"Number must be greater than 0\");\n    expect((err as z.ZodError).issues).toMatchInlineSnapshot(`\n      [\n        {\n          \"code\": \"too_small\",\n          \"inclusive\": false,\n          \"message\": \"Too small: expected number to be >0\",\n          \"minimum\": 0,\n          \"origin\": \"number\",\n          \"path\": [],\n        },\n      ]\n    `);\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/classic/tests/void.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4\";\ntest(\"void\", () => {\n  const v = z.void();\n  v.parse(undefined);\n\n  expect(() => v.parse(null)).toThrow();\n  expect(() => v.parse(\"\")).toThrow();\n\n  type v = z.infer<typeof v>;\n  expectTypeOf<v>().toEqualTypeOf<void>();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/tests/index.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v3\";\n\ntest(\"test\", () => {\n  expect(true).toBe(true);\n});\n\ntest(\"test2\", () => {\n  expect(() => z.string().parse(234)).toThrowErrorMatchingInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"string\",\n        \"received\": \"number\",\n        \"path\": [],\n        \"message\": \"Expected string, received number\"\n      }\n    ]]\n  `);\n});\n\ntest(\"async validation\", async () => {\n  const testTuple = z\n    .tuple([z.string().refine(async () => true), z.number().refine(async () => true)])\n    .refine(async () => true);\n  expectTypeOf<typeof testTuple._output>().toEqualTypeOf<[string, number]>();\n\n  const val = await testTuple.parseAsync([\"asdf\", 1234]);\n  expect(val).toEqual(val);\n\n  const r1 = await testTuple.safeParseAsync([\"asdf\", \"asdf\"]);\n  expect(r1.success).toEqual(false);\n  expect(r1.error!).toMatchInlineSnapshot(`\n    [ZodError: [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"number\",\n        \"received\": \"string\",\n        \"path\": [\n          1\n        ],\n        \"message\": \"Expected number, received string\"\n      }\n    ]]\n  `);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/tests/assignability.test.ts",
    "content": "import { test } from \"vitest\";\n\nimport * as z from \"zod/v4-mini\";\n\ntest(\"assignability\", () => {\n  // $ZodString\n  z.string() satisfies z.core.$ZodString;\n\n  // $ZodNumber\n  z.number() satisfies z.core.$ZodNumber;\n\n  // $ZodBigInt\n  z.bigint() satisfies z.core.$ZodBigInt;\n\n  // $ZodBoolean\n  z.boolean() satisfies z.core.$ZodBoolean;\n\n  // $ZodDate\n  z.date() satisfies z.core.$ZodDate;\n\n  // $ZodSymbol\n  z.symbol() satisfies z.core.$ZodSymbol;\n\n  // $ZodUndefined\n  z.undefined() satisfies z.core.$ZodUndefined;\n\n  // $ZodNullable\n  z.nullable(z.string()) satisfies z.core.$ZodNullable;\n\n  // $ZodNull\n  z.null() satisfies z.core.$ZodNull;\n\n  // $ZodAny\n  z.any() satisfies z.core.$ZodAny;\n\n  // $ZodUnknown\n  z.unknown() satisfies z.core.$ZodUnknown;\n\n  // $ZodNever\n  z.never() satisfies z.core.$ZodNever;\n\n  // $ZodVoid\n  z.void() satisfies z.core.$ZodVoid;\n\n  // $ZodArray\n  z.array(z.string()) satisfies z.core.$ZodArray;\n\n  // $ZodObject\n  z.object({ key: z.string() }) satisfies z.core.$ZodObject;\n\n  // $ZodUnion\n  z.union([z.string(), z.number()]) satisfies z.core.$ZodUnion;\n\n  // $ZodIntersection\n  z.intersection(z.string(), z.number()) satisfies z.core.$ZodIntersection;\n\n  // $ZodTuple\n  z.tuple([z.string(), z.number()]) satisfies z.core.$ZodTuple;\n\n  // $ZodRecord\n  z.record(z.string(), z.number()) satisfies z.core.$ZodRecord;\n\n  // $ZodMap\n  z.map(z.string(), z.number()) satisfies z.core.$ZodMap;\n\n  // $ZodSet\n  z.set(z.string()) satisfies z.core.$ZodSet;\n\n  // $ZodLiteral\n  z.literal(\"example\") satisfies z.core.$ZodLiteral;\n\n  // $ZodEnum\n  z.enum([\"a\", \"b\", \"c\"]) satisfies z.core.$ZodEnum;\n\n  // $ZodPromise\n  z.promise(z.string()) satisfies z.core.$ZodPromise;\n\n  // $ZodLazy\n  const lazySchema = z.lazy(() => z.string());\n  lazySchema satisfies z.core.$ZodLazy;\n\n  // $ZodOptional\n  z.optional(z.string()) satisfies z.core.$ZodOptional;\n\n  // $ZodDefault\n  z._default(z.string(), \"default\") satisfies z.core.$ZodDefault;\n\n  // $ZodTemplateLiteral\n  z.templateLiteral([z.literal(\"a\"), z.literal(\"b\")]) satisfies z.core.$ZodTemplateLiteral;\n\n  // $ZodCustom\n  z.custom<string>((val) => typeof val === \"string\") satisfies z.core.$ZodCustom;\n\n  // $ZodTransform\n  z.transform((val) => val as string) satisfies z.core.$ZodTransform;\n\n  // $ZodNonOptional\n  z.nonoptional(z.optional(z.string())) satisfies z.core.$ZodNonOptional;\n\n  // $ZodReadonly\n  z.readonly(z.object({ key: z.string() })) satisfies z.core.$ZodReadonly;\n\n  // $ZodNaN\n  z.nan() satisfies z.core.$ZodNaN;\n\n  // $ZodPipe\n  z.pipe(z.unknown(), z.number()) satisfies z.core.$ZodPipe;\n\n  // $ZodSuccess\n  z.success(z.string()) satisfies z.core.$ZodSuccess;\n\n  // $ZodCatch\n  z.catch(z.string(), \"fallback\") satisfies z.core.$ZodCatch;\n\n  // $ZodFile\n  z.file() satisfies z.core.$ZodFile;\n});\n\ntest(\"assignability with type narrowing\", () => {\n  type _RefinedSchema<T extends z.ZodMiniType<object> | z.ZodMiniUnion> = T extends z.ZodMiniUnion\n    ? RefinedUnionSchema<T> // <-- Type instantiation is excessively deep and possibly infinite.\n    : T extends z.ZodMiniType<object>\n      ? RefinedTypeSchema<z.output<T>> // <-- Type instantiation is excessively deep and possibly infinite.\n      : never;\n\n  type RefinedTypeSchema<T extends object> = T;\n\n  type RefinedUnionSchema<T extends z.ZodMiniUnion> = T;\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/tests/brand.test.ts",
    "content": "import { expectTypeOf, test } from \"vitest\";\nimport * as z from \"../index.js\";\n\ntest(\"branded types\", () => {\n  const mySchema = z\n    .object({\n      name: z.string(),\n    })\n    .brand<\"superschema\">();\n\n  // simple branding\n  type MySchema = z.infer<typeof mySchema>;\n  // Using true for type equality assertion\n  expectTypeOf<MySchema>().toEqualTypeOf<{ name: string } & z.$brand<\"superschema\">>();\n\n  const doStuff = (arg: MySchema) => arg;\n  doStuff(z.parse(mySchema, { name: \"hello there\" }));\n\n  // inheritance\n  const extendedSchema = mySchema.brand<\"subschema\">();\n  type ExtendedSchema = z.infer<typeof extendedSchema>;\n  expectTypeOf<ExtendedSchema>().toEqualTypeOf<{ name: string } & z.$brand<\"superschema\"> & z.$brand<\"subschema\">>();\n\n  doStuff(z.parse(extendedSchema, { name: \"hello again\" }));\n\n  // number branding\n  const numberSchema = z.number().brand<42>();\n  type NumberSchema = z.infer<typeof numberSchema>;\n  expectTypeOf<NumberSchema>().toEqualTypeOf<number & { [z.$brand]: { 42: true } }>();\n\n  // symbol branding\n  const MyBrand: unique symbol = Symbol(\"hello\");\n  type MyBrand = typeof MyBrand;\n  const symbolBrand = z.number().brand<\"sup\">().brand<typeof MyBrand>();\n  type SymbolBrand = z.infer<typeof symbolBrand>;\n  // number & { [z.$brand]: { sup: true, [MyBrand]: true } }\n  expectTypeOf<SymbolBrand>().toEqualTypeOf<number & z.$brand<\"sup\"> & z.$brand<MyBrand>>();\n\n  // keeping brands out of input types\n  const age = z.number().brand<\"age\">();\n  type Age1 = z.infer<typeof age>;\n  type AgeInput1 = z.input<typeof age>;\n\n  // Using not for type inequality assertion\n  expectTypeOf<AgeInput1>().not.toEqualTypeOf<Age1>();\n  expectTypeOf<number>().toEqualTypeOf<AgeInput1>();\n  expectTypeOf<number & z.$brand<\"age\">>().toEqualTypeOf<Age1>();\n\n  // @ts-expect-error\n  doStuff({ name: \"hello there!\" });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/tests/checks.test.ts",
    "content": "import { expect, test } from \"vitest\";\nimport * as z from \"../index.js\";\n\n// lt;\ntest(\"z.lt\", () => {\n  const a = z.number().check(z.lt(10));\n  expect(z.safeParse(a, 9).success).toEqual(true);\n  expect(z.safeParse(a, 9).data).toEqual(9);\n  expect(z.safeParse(a, 10).success).toEqual(false);\n});\n\n// lte;\ntest(\"z.lte\", () => {\n  const a = z.number().check(z.lte(10));\n  expect(z.safeParse(a, 10).success).toEqual(true);\n  expect(z.safeParse(a, 10).data).toEqual(10);\n  expect(z.safeParse(a, 11).success).toEqual(false);\n});\n\n// min;\ntest(\"z.max\", () => {\n  const a = z.number().check(z.maximum(10));\n  expect(z.safeParse(a, 10).success).toEqual(true);\n  expect(z.safeParse(a, 10).data).toEqual(10);\n  expect(z.safeParse(a, 11).success).toEqual(false);\n});\n\n// gt;\ntest(\"z.gt\", () => {\n  const a = z.number().check(z.gt(10));\n  expect(z.safeParse(a, 11).success).toEqual(true);\n  expect(z.safeParse(a, 11).data).toEqual(11);\n  expect(z.safeParse(a, 10).success).toEqual(false);\n});\n\n// gte;\ntest(\"z.gte\", () => {\n  const a = z.number().check(z.gte(10));\n  expect(z.safeParse(a, 10).success).toEqual(true);\n  expect(z.safeParse(a, 10).data).toEqual(10);\n  expect(z.safeParse(a, 9).success).toEqual(false);\n});\n\n// min;\ntest(\"z.min\", () => {\n  const a = z.number().check(z.minimum(10));\n  expect(z.safeParse(a, 10).success).toEqual(true);\n  expect(z.safeParse(a, 10).data).toEqual(10);\n  expect(z.safeParse(a, 9).success).toEqual(false);\n});\n\n// maxSize;\ntest(\"z.maxLength\", () => {\n  const a = z.array(z.string()).check(z.maxLength(3));\n  expect(z.safeParse(a, [\"a\", \"b\", \"c\"]).success).toEqual(true);\n  expect(z.safeParse(a, [\"a\", \"b\", \"c\", \"d\"]).success).toEqual(false);\n});\n\n// minSize;\ntest(\"z.minLength\", () => {\n  const a = z.array(z.string()).check(z.minLength(3));\n  expect(z.safeParse(a, [\"a\", \"b\"]).success).toEqual(false);\n  expect(z.safeParse(a, [\"a\", \"b\", \"c\"]).success).toEqual(true);\n});\n\n// size;\ntest(\"z.length\", () => {\n  const a = z.array(z.string()).check(z.length(3));\n  expect(z.safeParse(a, [\"a\", \"b\"]).success).toEqual(false);\n  expect(z.safeParse(a, [\"a\", \"b\", \"c\"]).success).toEqual(true);\n  expect(z.safeParse(a, [\"a\", \"b\", \"c\", \"d\"]).success).toEqual(false);\n});\n\n// regex;\ntest(\"z.regex\", () => {\n  const a = z.string().check(z.regex(/^aaa$/));\n  expect(z.safeParse(a, \"aaa\")).toMatchObject({ success: true, data: \"aaa\" });\n  expect(z.safeParse(a, \"aa\")).toMatchObject({ success: false });\n});\n\n// includes;\ntest(\"z.includes\", () => {\n  const a = z.string().check(z.includes(\"asdf\"));\n  z.parse(a, \"qqqasdfqqq\");\n  z.parse(a, \"asdf\");\n  z.parse(a, \"qqqasdf\");\n  z.parse(a, \"asdfqqq\");\n  expect(z.safeParse(a, \"qqq\")).toMatchObject({ success: false });\n});\n\n// startsWith;\ntest(\"z.startsWith\", () => {\n  const a = z.string().check(z.startsWith(\"asdf\"));\n  z.parse(a, \"asdf\");\n  z.parse(a, \"asdfqqq\");\n  expect(z.safeParse(a, \"qqq\")).toMatchObject({ success: false });\n});\n\n// endsWith;\ntest(\"z.endsWith\", () => {\n  const a = z.string().check(z.endsWith(\"asdf\"));\n  z.parse(a, \"asdf\");\n  z.parse(a, \"qqqasdf\");\n  expect(z.safeParse(a, \"asdfqqq\")).toMatchObject({ success: false });\n});\n\n// lowercase;\ntest(\"z.lowercase\", () => {\n  const a = z.string().check(z.lowercase());\n  z.parse(a, \"asdf\");\n  expect(z.safeParse(a, \"ASDF\")).toMatchObject({ success: false });\n});\n\n// uppercase;\ntest(\"z.uppercase\", () => {\n  const a = z.string().check(z.uppercase());\n  z.parse(a, \"ASDF\");\n  expect(z.safeParse(a, \"asdf\")).toMatchObject({ success: false });\n});\n\n// filename;\n// fileType;\n// overwrite;\ntest(\"z.overwrite\", () => {\n  const a = z.string().check(z.overwrite((val) => val.toUpperCase()));\n  expect(z.safeParse(a, \"asdf\")).toMatchObject({ data: \"ASDF\" });\n});\n\n// normalize;\n// trim;\n// toLowerCase;\n// toUpperCase;\n// property\n\ntest(\"abort early\", () => {\n  const schema = z.string().check(\n    z.refine((val) => val.length > 1),\n    z.refine((val) => val.length > 2, { abort: true }),\n    z.refine((val) => val.length > 3)\n  );\n  const data = \"\";\n  const result = z.safeParse(schema, data);\n  expect(result.error!.issues.length).toEqual(2);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/tests/computed.test.ts",
    "content": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4-mini\";\nimport { util as zc } from \"zod/v4/core\";\n\ntest(\"min/max\", () => {\n  const a = z.number().check(z.minimum(5), z.minimum(6), z.minimum(7), z.maximum(10), z.maximum(11), z.maximum(12));\n\n  expect(a._zod.bag.minimum).toEqual(7);\n  expect(a._zod.bag.maximum).toEqual(10);\n});\n\ntest(\"multipleOf\", () => {\n  const b = z.number().check(z.multipleOf(5));\n  expect(b._zod.bag.multipleOf).toEqual(5);\n});\n\ntest(\"int64 format\", () => {\n  const c = z.int64();\n  expect(c._zod.bag.format).toEqual(\"int64\");\n  expect(c._zod.bag.minimum).toEqual(zc.BIGINT_FORMAT_RANGES.int64[0]);\n  expect(c._zod.bag.maximum).toEqual(zc.BIGINT_FORMAT_RANGES.int64[1]);\n});\n\ntest(\"int32 format\", () => {\n  const d = z.int32();\n  expect(d._zod.bag.format).toEqual(\"int32\");\n  expect(d._zod.bag.minimum).toEqual(zc.NUMBER_FORMAT_RANGES.int32[0]);\n  expect(d._zod.bag.maximum).toEqual(zc.NUMBER_FORMAT_RANGES.int32[1]);\n});\n\ntest(\"array size\", () => {\n  const e = z.array(z.string()).check(z.length(5));\n  expect(e._zod.bag.length).toEqual(5);\n  expect(e._zod.bag.minimum).toEqual(5);\n  expect(e._zod.bag.maximum).toEqual(5);\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/tests/error.test.ts",
    "content": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4-mini\";\n\ntest(\"no locale by default\", () => {\n  const result = z.safeParse(z.string(), 12);\n  expect(result.success).toEqual(false);\n  expect(result.error!.issues.length).toEqual(1);\n  expect(result.error!.issues[0].message).toEqual(\"Invalid input\");\n});\n\ntest(\"error inheritance\", () => {\n  const e1 = z.string().safeParse(123).error!;\n  expect(e1).toBeInstanceOf(z.core.$ZodError);\n  // expect(e1).not.toBeInstanceOf(Error);\n\n  try {\n    z.string().parse(123);\n  } catch (e2) {\n    expect(e2).toBeInstanceOf(z.core.$ZodRealError);\n    expect(e2).toBeInstanceOf(Error);\n  }\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/tests/functions.test.ts",
    "content": "import { expect, test } from \"vitest\";\n// import * as z from \"zod/v4/core\";\n\ntest(\"z.function\", () => {\n  expect(true).toEqual(true);\n});\n\n// test(\"z.function\", () => {\n//   const a = z.function({\n//     args: z.tuple([z.string()]),\n//     returns: z.string(),\n//   });\n\n//   const myFunc = a.implement((name: string | number) => `Hello, ${name}!`);\n\n//   expect(myFunc(\"world\")).toEqual(\"Hello, world!\");\n//   expect(() => myFunc(123 as any)).toThrow();\n\n//   // this won't run\n//   () => {\n//     // @ts-expect-error\n//     const r = myFunc(123);\n//     expectTypeOf(r).toEqualTypeOf<string>();\n//   };\n// });\n\n// test(\"z.function async\", async () => {\n//   const b = z.function({\n//     args: z.tuple([z.string()]).$check(async (_) => {}),\n//     returns: z.string().$check(async (_) => {}),\n//   });\n//   const myFuncAsync = b.implementAsync(async (name) => `Hello, ${name}!`);\n\n//   expect(await myFuncAsync(\"world\")).toEqual(\"Hello, world!\");\n//   expect(myFuncAsync(123 as any)).rejects.toThrow();\n\n//   // this won't run\n//   () => {\n//     // @ts-expect-error\n//     const r = myFuncAsync(123);\n//     expectTypeOf(r).toEqualTypeOf<Promise<string>>();\n//   };\n// });\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/tests/index.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4-mini\";\nimport type { util } from \"zod/v4/core\";\n\ntest(\"z.boolean\", () => {\n  const a = z.boolean();\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, false)).toEqual(false);\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"true\")).toThrow();\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<boolean>();\n});\n\ntest(\"z.bigint\", () => {\n  const a = z.bigint();\n  expect(z.parse(a, BigInt(123))).toEqual(BigInt(123));\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n});\n\ntest(\"z.symbol\", () => {\n  const a = z.symbol();\n  const sym = Symbol();\n  expect(z.parse(a, sym)).toEqual(sym);\n  expect(() => z.parse(a, \"symbol\")).toThrow();\n});\n\ntest(\"z.date\", () => {\n  const a = z.date();\n  const date = new Date();\n  expect(z.parse(a, date)).toEqual(date);\n  expect(() => z.parse(a, \"date\")).toThrow();\n});\n\ntest(\"z.coerce.string\", () => {\n  const a = z.coerce.string();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n  expect(z.parse(a, true)).toEqual(\"true\");\n  expect(z.parse(a, null)).toEqual(\"null\");\n  expect(z.parse(a, undefined)).toEqual(\"undefined\");\n});\n\ntest(\"z.coerce.number\", () => {\n  const a = z.coerce.number();\n  expect(z.parse(a, \"123\")).toEqual(123);\n  expect(z.parse(a, \"123.45\")).toEqual(123.45);\n  expect(z.parse(a, true)).toEqual(1);\n  expect(z.parse(a, false)).toEqual(0);\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.coerce.boolean\", () => {\n  const a = z.coerce.boolean();\n  // test booleans\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, false)).toEqual(false);\n  expect(z.parse(a, \"true\")).toEqual(true);\n  expect(z.parse(a, \"false\")).toEqual(true);\n  expect(z.parse(a, 1)).toEqual(true);\n  expect(z.parse(a, 0)).toEqual(false);\n  expect(z.parse(a, {})).toEqual(true);\n  expect(z.parse(a, [])).toEqual(true);\n  expect(z.parse(a, undefined)).toEqual(false);\n  expect(z.parse(a, null)).toEqual(false);\n  expect(z.parse(a, \"\")).toEqual(false);\n});\n\ntest(\"z.coerce.bigint\", () => {\n  const a = z.coerce.bigint();\n  expect(z.parse(a, \"123\")).toEqual(BigInt(123));\n  expect(z.parse(a, 123)).toEqual(BigInt(123));\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.coerce.date\", () => {\n  const a = z.coerce.date();\n  const date = new Date();\n  expect(z.parse(a, date.toISOString())).toEqual(date);\n  expect(z.parse(a, date.getTime())).toEqual(date);\n  expect(() => z.parse(a, \"invalid date\")).toThrow();\n});\n\ntest(\"z.iso.datetime\", () => {\n  const d1 = \"2021-01-01T00:00:00Z\";\n  const d2 = \"2021-01-01T00:00:00.123Z\";\n  const d3 = \"2021-01-01T00:00:00\";\n  const d4 = \"2021-01-01T00:00:00+07:00\";\n  const d5 = \"bad data\";\n\n  // local: false, offset: false, precision: null\n  const a = z.iso.datetime();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(true);\n  expect(z.safeParse(a, d3).success).toEqual(false);\n  expect(z.safeParse(a, d4).success).toEqual(false);\n  expect(z.safeParse(a, d5).success).toEqual(false);\n\n  const b = z.iso.datetime({ local: true });\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(true);\n  expect(z.safeParse(b, d3).success).toEqual(true);\n  expect(z.safeParse(b, d4).success).toEqual(false);\n  expect(z.safeParse(b, d5).success).toEqual(false);\n\n  const c = z.iso.datetime({ offset: true });\n  expect(z.safeParse(c, d1).success).toEqual(true);\n  expect(z.safeParse(c, d2).success).toEqual(true);\n  expect(z.safeParse(c, d3).success).toEqual(false);\n  expect(z.safeParse(c, d4).success).toEqual(true);\n  expect(z.safeParse(c, d5).success).toEqual(false);\n\n  const d = z.iso.datetime({ precision: 3 });\n  expect(z.safeParse(d, d1).success).toEqual(false);\n  expect(z.safeParse(d, d2).success).toEqual(true);\n  expect(z.safeParse(d, d3).success).toEqual(false);\n  expect(z.safeParse(d, d4).success).toEqual(false);\n  expect(z.safeParse(d, d5).success).toEqual(false);\n});\n\ntest(\"z.iso.date\", () => {\n  const d1 = \"2021-01-01\";\n  const d2 = \"bad data\";\n\n  const a = z.iso.date();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(false);\n\n  const b = z.string().check(z.iso.date());\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(false);\n});\n\ntest(\"z.iso.time\", () => {\n  const d1 = \"00:00:00\";\n  const d2 = \"00:00:00.123\";\n  const d3 = \"bad data\";\n\n  const a = z.iso.time();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(true);\n  expect(z.safeParse(a, d3).success).toEqual(false);\n\n  const b = z.iso.time({ precision: 3 });\n  expect(z.safeParse(b, d1).success).toEqual(false);\n  expect(z.safeParse(b, d2).success).toEqual(true);\n  expect(z.safeParse(b, d3).success).toEqual(false);\n\n  const c = z.string().check(z.iso.time());\n  expect(z.safeParse(c, d1).success).toEqual(true);\n  expect(z.safeParse(c, d2).success).toEqual(true);\n  expect(z.safeParse(c, d3).success).toEqual(false);\n});\n\ntest(\"z.iso.duration\", () => {\n  const d1 = \"P3Y6M4DT12H30M5S\";\n  const d2 = \"bad data\";\n\n  const a = z.iso.duration();\n  expect(z.safeParse(a, d1).success).toEqual(true);\n  expect(z.safeParse(a, d2).success).toEqual(false);\n\n  const b = z.string().check(z.iso.duration());\n  expect(z.safeParse(b, d1).success).toEqual(true);\n  expect(z.safeParse(b, d2).success).toEqual(false);\n});\n\ntest(\"z.undefined\", () => {\n  const a = z.undefined();\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, \"undefined\")).toThrow();\n});\n\ntest(\"z.null\", () => {\n  const a = z.null();\n  expect(z.parse(a, null)).toEqual(null);\n  expect(() => z.parse(a, \"null\")).toThrow();\n});\n\ntest(\"z.any\", () => {\n  const a = z.any();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  z.parse(a, {});\n  z.parse(a, []);\n  z.parse(a, Symbol());\n  z.parse(a, new Date());\n});\n\ntest(\"z.unknown\", () => {\n  const a = z.unknown();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  z.parse(a, {});\n  z.parse(a, []);\n  z.parse(a, Symbol());\n  z.parse(a, new Date());\n});\n\ntest(\"z.never\", () => {\n  const a = z.never();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.void\", () => {\n  const a = z.void();\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, null)).toThrow();\n});\n\ntest(\"z.array\", () => {\n  const a = z.array(z.string());\n  expect(z.parse(a, [\"hello\", \"world\"])).toEqual([\"hello\", \"world\"]);\n  expect(() => z.parse(a, [123])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.union\", () => {\n  const a = z.union([z.string(), z.number()]);\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(() => z.parse(a, true)).toThrow();\n});\n\ntest(\"z.intersection\", () => {\n  const a = z.intersection(z.object({ a: z.string() }), z.object({ b: z.number() }));\n  expect(z.parse(a, { a: \"hello\", b: 123 })).toEqual({ a: \"hello\", b: 123 });\n  expect(() => z.parse(a, { a: \"hello\" })).toThrow();\n  expect(() => z.parse(a, { b: 123 })).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.tuple\", () => {\n  const a = z.tuple([z.string(), z.number()]);\n  expect(z.parse(a, [\"hello\", 123])).toEqual([\"hello\", 123]);\n  expect(() => z.parse(a, [\"hello\", \"world\"])).toThrow();\n  expect(() => z.parse(a, [123, 456])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  // tuple with rest\n  const b = z.tuple([z.string(), z.number(), z.optional(z.string())], z.boolean());\n  type b = z.output<typeof b>;\n\n  expectTypeOf<b>().toEqualTypeOf<[string, number, string?, ...boolean[]]>();\n  const datas = [\n    [\"hello\", 123],\n    [\"hello\", 123, \"world\"],\n    [\"hello\", 123, \"world\", true],\n    [\"hello\", 123, \"world\", true, false, true],\n  ];\n  for (const data of datas) {\n    expect(z.parse(b, data)).toEqual(data);\n  }\n\n  expect(() => z.parse(b, [\"hello\", 123, 123])).toThrow();\n  expect(() => z.parse(b, [\"hello\", 123, \"world\", 123])).toThrow();\n\n  // tuple with readonly args\n  const cArgs = [z.string(), z.number(), z.optional(z.string())] as const;\n  const c = z.tuple(cArgs, z.boolean());\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<[string, number, string?, ...boolean[]]>();\n});\n\ntest(\"z.record\", () => {\n  // record schema with enum keys\n  const a = z.record(z.string(), z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Record<string, string>>();\n\n  const b = z.record(z.union([z.string(), z.number(), z.symbol()]), z.string());\n  type b = z.output<typeof b>;\n  expectTypeOf<b>().toEqualTypeOf<Record<string | number | symbol, string>>();\n  expect(z.parse(b, { a: \"hello\", 1: \"world\", [Symbol.for(\"asdf\")]: \"symbol\" })).toEqual({\n    a: \"hello\",\n    1: \"world\",\n    [Symbol.for(\"asdf\")]: \"symbol\",\n  });\n\n  // enum keys\n  const c = z.record(z.enum([\"a\", \"b\", \"c\"]), z.string());\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<Record<\"a\" | \"b\" | \"c\", string>>();\n  expect(z.parse(c, { a: \"hello\", b: \"world\", c: \"world\" })).toEqual({\n    a: \"hello\",\n    b: \"world\",\n    c: \"world\",\n  });\n  // missing keys\n  expect(() => z.parse(c, { a: \"hello\", b: \"world\" })).toThrow();\n  // extra keys\n  expect(() => z.parse(c, { a: \"hello\", b: \"world\", c: \"world\", d: \"world\" })).toThrow();\n});\n\ntest(\"z.map\", () => {\n  const a = z.map(z.string(), z.number());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Map<string, number>>();\n  expect(z.parse(a, new Map([[\"hello\", 123]]))).toEqual(new Map([[\"hello\", 123]]));\n  expect(() => z.parse(a, new Map([[\"hello\", \"world\"]]))).toThrow();\n  expect(() => z.parse(a, new Map([[1243, \"world\"]]))).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  const r1 = z.safeParse(a, new Map([[123, 123]]));\n  expect(r1.error?.issues[0].code).toEqual(\"invalid_type\");\n  expect(r1.error?.issues[0].path).toEqual([123]);\n\n  const r2: any = z.safeParse(a, new Map([[BigInt(123), 123]]));\n  expect(r2.error!.issues[0].code).toEqual(\"invalid_key\");\n  expect(r2.error!.issues[0].path).toEqual([]);\n\n  const r3: any = z.safeParse(a, new Map([[\"hello\", \"world\"]]));\n  expect(r3.error!.issues[0].code).toEqual(\"invalid_type\");\n  expect(r3.error!.issues[0].path).toEqual([\"hello\"]);\n});\n\ntest(\"z.map invalid_element\", () => {\n  const a = z.map(z.bigint(), z.number());\n  const r1 = z.safeParse(a, new Map([[BigInt(123), BigInt(123)]]));\n\n  expect(r1.error!.issues[0].code).toEqual(\"invalid_element\");\n  expect(r1.error!.issues[0].path).toEqual([]);\n});\n\ntest(\"z.map async\", async () => {\n  const a = z.map(z.string().check(z.refine(async () => true)), z.number().check(z.refine(async () => true)));\n  const d1 = new Map([[\"hello\", 123]]);\n  expect(await z.parseAsync(a, d1)).toEqual(d1);\n\n  await expect(z.parseAsync(a, new Map([[123, 123]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, new Map([[\"hi\", \"world\"]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, new Map([[1243, \"world\"]]))).rejects.toThrow();\n  await expect(z.parseAsync(a, \"hello\")).rejects.toThrow();\n\n  const r = await z.safeParseAsync(a, new Map([[123, 123]]));\n  expect(r.success).toEqual(false);\n  expect(r.error!.issues[0].code).toEqual(\"invalid_type\");\n  expect(r.error!.issues[0].path).toEqual([123]);\n});\n\ntest(\"z.set\", () => {\n  const a = z.set(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Set<string>>();\n  expect(z.parse(a, new Set([\"hello\", \"world\"]))).toEqual(new Set([\"hello\", \"world\"]));\n  expect(() => z.parse(a, new Set([123]))).toThrow();\n  expect(() => z.parse(a, [\"hello\", \"world\"])).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  const b = z.set(z.number());\n  expect(z.parse(b, new Set([1, 2, 3]))).toEqual(new Set([1, 2, 3]));\n  expect(() => z.parse(b, new Set([\"hello\"]))).toThrow();\n  expect(() => z.parse(b, [1, 2, 3])).toThrow();\n  expect(() => z.parse(b, 123)).toThrow();\n});\n\ntest(\"z.enum\", () => {\n  const a = z.enum([\"A\", \"B\", \"C\"]);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<\"A\" | \"B\" | \"C\">();\n  expect(z.parse(a, \"A\")).toEqual(\"A\");\n  expect(z.parse(a, \"B\")).toEqual(\"B\");\n  expect(z.parse(a, \"C\")).toEqual(\"C\");\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // expect(a.enum.A).toEqual(\"A\");\n  // expect(a.enum.B).toEqual(\"B\");\n  // expect(a.enum.C).toEqual(\"C\");\n  // expect((a.enum as any).D).toEqual(undefined);\n});\n\ntest(\"z.enum - native\", () => {\n  enum NativeEnum {\n    A = \"A\",\n    B = \"B\",\n    C = \"C\",\n  }\n  const a = z.enum(NativeEnum);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<NativeEnum>();\n  expect(z.parse(a, NativeEnum.A)).toEqual(NativeEnum.A);\n  expect(z.parse(a, NativeEnum.B)).toEqual(NativeEnum.B);\n  expect(z.parse(a, NativeEnum.C)).toEqual(NativeEnum.C);\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // test a.enum\n  a;\n  // expect(a.enum.A).toEqual(NativeEnum.A);\n  // expect(a.enum.B).toEqual(NativeEnum.B);\n  // expect(a.enum.C).toEqual(NativeEnum.C);\n});\n\ntest(\"z.nativeEnum\", () => {\n  enum NativeEnum {\n    A = \"A\",\n    B = \"B\",\n    C = \"C\",\n  }\n  const a = z.nativeEnum(NativeEnum);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<NativeEnum>();\n  expect(z.parse(a, NativeEnum.A)).toEqual(NativeEnum.A);\n  expect(z.parse(a, NativeEnum.B)).toEqual(NativeEnum.B);\n  expect(z.parse(a, NativeEnum.C)).toEqual(NativeEnum.C);\n  expect(() => z.parse(a, \"D\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // test a.enum\n  a;\n  // expect(a.enum.A).toEqual(NativeEnum.A);\n  // expect(a.enum.B).toEqual(NativeEnum.B);\n  // expect(a.enum.C).toEqual(NativeEnum.C);\n});\n\ntest(\"z.literal\", () => {\n  const a = z.literal(\"hello\");\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<\"hello\">();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, \"world\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  z.literal([\"adf\"] as const);\n});\n\ntest(\"z.file\", () => {\n  const a = z.file();\n  const file = new File([\"content\"], \"filename.txt\", { type: \"text/plain\" });\n  expect(z.parse(a, file)).toEqual(file);\n  expect(() => z.parse(a, \"file\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.transform\", () => {\n  const a = z.pipe(\n    z.string(),\n    z.transform((val) => val.toUpperCase())\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"HELLO\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.transform async\", async () => {\n  const a = z.pipe(\n    z.string(),\n    z.transform(async (val) => val.toUpperCase())\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(await z.parseAsync(a, \"hello\")).toEqual(\"HELLO\");\n  await expect(() => z.parseAsync(a, 123)).rejects.toThrow();\n});\n\ntest(\"z.preprocess\", () => {\n  const a = z.pipe(\n    z.transform((val) => String(val).toUpperCase()),\n    z.string()\n  );\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n  expect(z.parse(a, true)).toEqual(\"TRUE\");\n  expect(z.parse(a, BigInt(1234))).toEqual(\"1234\");\n  // expect(() => z.parse(a, Symbol(\"asdf\"))).toThrow();\n});\n\n// test(\"z.preprocess async\", () => {\n//   const a = z.preprocess(async (val) => String(val), z.string());\n//   type a = z.output<typeof a>;\n//   expectTypeOf<a>().toEqualTypeOf<string>();\n//   expect(z.parse(a, 123)).toEqual(\"123\");\n//   expect(z.parse(a, true)).toEqual(\"true\");\n//   expect(() => z.parse(a, {})).toThrow();\n// });\n\ntest(\"z.optional\", () => {\n  const a = z.optional(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string | undefined>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, undefined)).toEqual(undefined);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.nullable\", () => {\n  const a = z.nullable(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string | null>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, null)).toEqual(null);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.default\", () => {\n  const a = z._default(z.string(), \"default\");\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, undefined)).toEqual(\"default\");\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n\n  const b = z._default(z.string(), () => \"default\");\n  expect(z.parse(b, undefined)).toEqual(\"default\");\n  expect(z.parse(b, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(b, 123)).toThrow();\n});\n\ntest(\"z.catch\", () => {\n  const a = z.catch(z.string(), \"default\");\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(\"default\");\n\n  const b = z.catch(z.string(), () => \"default\");\n  expect(z.parse(b, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(b, 123)).toEqual(\"default\");\n\n  const c = z.catch(z.string(), (ctx) => {\n    return `${ctx.error.issues.length}issues`;\n  });\n  expect(z.parse(c, 1234)).toEqual(\"1issues\");\n});\n\ntest(\"z.nan\", () => {\n  const a = z.nan();\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<number>();\n  expect(z.parse(a, Number.NaN)).toEqual(Number.NaN);\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, \"NaN\")).toThrow();\n});\n\ntest(\"z.pipe\", () => {\n  const a = z.pipe(\n    z.pipe(\n      z.string(),\n      z.transform((val) => val.length)\n    ),\n    z.number()\n  );\n  type a_in = z.input<typeof a>;\n  expectTypeOf<a_in>().toEqualTypeOf<string>();\n  type a_out = z.output<typeof a>;\n  expectTypeOf<a_out>().toEqualTypeOf<number>();\n\n  expect(z.parse(a, \"123\")).toEqual(3);\n  expect(z.parse(a, \"hello\")).toEqual(5);\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.readonly\", () => {\n  const a = z.readonly(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<Readonly<string>>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.templateLiteral\", () => {\n  const a = z.templateLiteral([z.string(), z.number()]);\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<`${string}${number}`>();\n  expect(z.parse(a, \"hello123\")).toEqual(\"hello123\");\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  expect(() => z.parse(a, 123)).toThrow();\n\n  // multipart\n  const b = z.templateLiteral([z.string(), z.number(), z.string()]);\n  type b = z.output<typeof b>;\n  expectTypeOf<b>().toEqualTypeOf<`${string}${number}${string}`>();\n  expect(z.parse(b, \"hello123world\")).toEqual(\"hello123world\");\n  expect(z.parse(b, \"123\")).toEqual(\"123\");\n  expect(() => z.parse(b, \"hello\")).toThrow();\n  expect(() => z.parse(b, 123)).toThrow();\n\n  // include boolean\n  const c = z.templateLiteral([z.string(), z.boolean()]);\n  type c = z.output<typeof c>;\n  expectTypeOf<c>().toEqualTypeOf<`${string}${boolean}`>();\n  expect(z.parse(c, \"hellotrue\")).toEqual(\"hellotrue\");\n  expect(z.parse(c, \"hellofalse\")).toEqual(\"hellofalse\");\n  expect(() => z.parse(c, \"hello\")).toThrow();\n  expect(() => z.parse(c, 123)).toThrow();\n\n  // include literal prefix\n  const d = z.templateLiteral([z.literal(\"hello\"), z.number()]);\n  type d = z.output<typeof d>;\n  expectTypeOf<d>().toEqualTypeOf<`hello${number}`>();\n  expect(z.parse(d, \"hello123\")).toEqual(\"hello123\");\n  expect(() => z.parse(d, 123)).toThrow();\n  expect(() => z.parse(d, \"world123\")).toThrow();\n\n  // include literal union\n  const e = z.templateLiteral([z.literal([\"aa\", \"bb\"]), z.number()]);\n  type e = z.output<typeof e>;\n  expectTypeOf<e>().toEqualTypeOf<`aa${number}` | `bb${number}`>();\n  expect(z.parse(e, \"aa123\")).toEqual(\"aa123\");\n  expect(z.parse(e, \"bb123\")).toEqual(\"bb123\");\n  expect(() => z.parse(e, \"cc123\")).toThrow();\n  expect(() => z.parse(e, 123)).toThrow();\n});\n\n// this returns both a schema and a check\ntest(\"z.custom\", () => {\n  const a = z.custom((val) => {\n    return typeof val === \"string\";\n  });\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n\n  const b = z.string().check(z.custom((val) => val.length > 3));\n\n  expect(z.parse(b, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(b, \"hi\")).toThrow();\n});\n\ntest(\"z.check\", () => {\n  // this is a more flexible version of z.custom that accepts an arbitrary _parse logic\n  // the function should return core.$ZodResult\n  const a = z.any().check(\n    z.check<string>((ctx) => {\n      if (typeof ctx.value === \"string\") return;\n      ctx.issues.push({\n        code: \"custom\",\n        origin: \"custom\",\n        message: \"Expected a string\",\n        input: ctx.value,\n      });\n    })\n  );\n  expect(z.safeParse(a, \"hello\")).toMatchObject({\n    success: true,\n    data: \"hello\",\n  });\n  expect(z.safeParse(a, 123)).toMatchObject({\n    success: false,\n    error: { issues: [{ code: \"custom\", message: \"Expected a string\" }] },\n  });\n});\n\ntest(\"z.instanceof\", () => {\n  class A {}\n\n  const a = z.instanceof(A);\n  expect(z.parse(a, new A())).toBeInstanceOf(A);\n  expect(() => z.parse(a, {})).toThrow();\n});\n\ntest(\"z.refine\", () => {\n  const a = z.number().check(\n    z.refine((val) => val > 3),\n    z.refine((val) => val < 10)\n  );\n  expect(z.parse(a, 5)).toEqual(5);\n  expect(() => z.parse(a, 2)).toThrow();\n  expect(() => z.parse(a, 11)).toThrow();\n  expect(() => z.parse(a, \"hi\")).toThrow();\n});\n\n// test(\"z.superRefine\", () => {\n//   const a = z.number([\n//     z.superRefine((val, ctx) => {\n//       if (val < 3) {\n//         return ctx.addIssue({\n//           code: \"custom\",\n//           origin: \"custom\",\n//           message: \"Too small\",\n//           input: val,\n//         });\n//       }\n//       if (val > 10) {\n//         return ctx.addIssue(\"Too big\");\n//       }\n//     }),\n//   ]);\n\n//   expect(z.parse(a, 5)).toEqual(5);\n//   expect(() => z.parse(a, 2)).toThrow();\n//   expect(() => z.parse(a, 11)).toThrow();\n//   expect(() => z.parse(a, \"hi\")).toThrow();\n// });\n\ntest(\"z.transform\", () => {\n  const a = z.transform((val: number) => {\n    return `${val}`;\n  });\n  type a_in = z.input<typeof a>;\n  expectTypeOf<a_in>().toEqualTypeOf<number>();\n  type a_out = z.output<typeof a>;\n  expectTypeOf<a_out>().toEqualTypeOf<string>();\n  expect(z.parse(a, 123)).toEqual(\"123\");\n});\n\ntest(\"z.$brand()\", () => {\n  const a = z.string().brand<\"my-brand\">();\n  type a = z.output<typeof a>;\n  const branded = (_: a) => {};\n  // @ts-expect-error\n  branded(\"asdf\");\n});\n\ntest(\"z.lazy\", () => {\n  const a = z.lazy(() => z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\n// schema that validates JSON-like data\ntest(\"z.json\", () => {\n  const a = z.json();\n  type a = z.output<typeof a>;\n  a._zod.output;\n\n  expectTypeOf<a>().toEqualTypeOf<util.JSONType>();\n\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, true)).toEqual(true);\n  expect(z.parse(a, null)).toEqual(null);\n  expect(z.parse(a, {})).toEqual({});\n  expect(z.parse(a, { a: \"hello\" })).toEqual({ a: \"hello\" });\n  expect(z.parse(a, [1, 2, 3])).toEqual([1, 2, 3]);\n  expect(z.parse(a, [{ a: \"hello\" }])).toEqual([{ a: \"hello\" }]);\n\n  // fail cases\n  expect(() => z.parse(a, new Date())).toThrow();\n  expect(() => z.parse(a, Symbol())).toThrow();\n  expect(() => z.parse(a, { a: new Date() })).toThrow();\n  expect(() => z.parse(a, undefined)).toThrow();\n  expect(() => z.parse(a, { a: undefined })).toThrow();\n});\n\ntest(\"z.stringbool\", () => {\n  const a = z.stringbool();\n\n  expect(z.parse(a, \"true\")).toEqual(true);\n  expect(z.parse(a, \"yes\")).toEqual(true);\n  expect(z.parse(a, \"1\")).toEqual(true);\n  expect(z.parse(a, \"on\")).toEqual(true);\n  expect(z.parse(a, \"y\")).toEqual(true);\n  expect(z.parse(a, \"enabled\")).toEqual(true);\n  expect(z.parse(a, \"TRUE\")).toEqual(true);\n\n  expect(z.parse(a, \"false\")).toEqual(false);\n  expect(z.parse(a, \"no\")).toEqual(false);\n  expect(z.parse(a, \"0\")).toEqual(false);\n  expect(z.parse(a, \"off\")).toEqual(false);\n  expect(z.parse(a, \"n\")).toEqual(false);\n  expect(z.parse(a, \"disabled\")).toEqual(false);\n  expect(z.parse(a, \"FALSE\")).toEqual(false);\n\n  expect(z.safeParse(a, \"other\")).toMatchObject({ success: false });\n  expect(z.safeParse(a, \"\")).toMatchObject({ success: false });\n  expect(z.safeParse(a, undefined)).toMatchObject({ success: false });\n  expect(z.safeParse(a, {})).toMatchObject({ success: false });\n  expect(z.safeParse(a, true)).toMatchObject({ success: false });\n  expect(z.safeParse(a, false)).toMatchObject({ success: false });\n\n  const b = z.stringbool({\n    truthy: [\"y\"],\n    falsy: [\"n\"],\n  });\n  expect(z.parse(b, \"y\")).toEqual(true);\n  expect(z.parse(b, \"n\")).toEqual(false);\n  expect(z.safeParse(b, \"true\")).toMatchObject({ success: false });\n  expect(z.safeParse(b, \"false\")).toMatchObject({ success: false });\n\n  const c = z.stringbool({\n    case: \"sensitive\",\n  });\n  expect(z.parse(c, \"true\")).toEqual(true);\n  expect(z.safeParse(c, \"TRUE\")).toMatchObject({ success: false });\n});\n\n// promise\ntest(\"z.promise\", async () => {\n  const a = z.promise(z.string());\n  type a = z.output<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n\n  expect(await z.safeParseAsync(a, Promise.resolve(\"hello\"))).toMatchObject({\n    success: true,\n    data: \"hello\",\n  });\n  expect(await z.safeParseAsync(a, Promise.resolve(123))).toMatchObject({\n    success: false,\n  });\n\n  const b = z.string();\n  expect(() => z.parse(b, Promise.resolve(\"hello\"))).toThrow();\n});\n\n// test(\"type assertions\", () => {\n//   const schema = z.pipe(\n//     z.string(),\n//     z.transform((val) => val.length)\n//   );\n//   schema.assertInput<string>();\n//   // @ts-expect-error\n//   schema.assertInput<number>();\n\n//   schema.assertOutput<number>();\n//   // @ts-expect-error\n//   schema.assertOutput<string>();\n// });\n\ntest(\"z.pipe type enforcement\", () => {\n  z.pipe(\n    z.pipe(\n      z.string().check(z.regex(/asdf/)),\n      z.transform((v) => new Date(v))\n    ),\n    z.date().check(z.maximum(new Date()))\n  );\n});\n\ntest(\"def typing\", () => {\n  z.string().def.type satisfies \"string\";\n  z.email().def.format satisfies \"email\";\n  z.number().def.type satisfies \"number\";\n  z.float64().def.format satisfies z.core.$ZodNumberFormats;\n  z.bigint().def.type satisfies \"bigint\";\n  z.boolean().def.type satisfies \"boolean\";\n  z.date().def.type satisfies \"date\";\n  z.symbol().def.type satisfies \"symbol\";\n  z.undefined().def.type satisfies \"undefined\";\n  z.nullable(z.string()).def.type satisfies \"nullable\";\n  z.null().def.type satisfies \"null\";\n  z.any().def.type satisfies \"any\";\n  z.unknown().def.type satisfies \"unknown\";\n  z.never().def.type satisfies \"never\";\n  z.void().def.type satisfies \"void\";\n  z.array(z.string()).def.type satisfies \"array\";\n  z.object({ key: z.string() }).def.type satisfies \"object\";\n  z.union([z.string(), z.number()]).def.type satisfies \"union\";\n  z.intersection(z.string(), z.number()).def.type satisfies \"intersection\";\n  z.tuple([z.string(), z.number()]).def.type satisfies \"tuple\";\n  z.record(z.string(), z.number()).def.type satisfies \"record\";\n  z.map(z.string(), z.number()).def.type satisfies \"map\";\n  z.set(z.string()).def.type satisfies \"set\";\n  z.literal(\"example\").def.type satisfies \"literal\";\n  expectTypeOf(z.literal(\"example\").def.values).toEqualTypeOf<\"example\"[]>();\n  z.enum([\"a\", \"b\", \"c\"]).def.type satisfies \"enum\";\n  z.promise(z.string()).def.type satisfies \"promise\";\n  z.lazy(() => z.string()).def.type satisfies \"lazy\";\n  z.optional(z.string()).def.type satisfies \"optional\";\n  z._default(z.string(), \"default\").def.type satisfies \"default\";\n  z.templateLiteral([z.literal(\"a\"), z.literal(\"b\")]).def.type satisfies \"template_literal\";\n  z.custom<string>((val) => typeof val === \"string\").def.type satisfies \"custom\";\n  z.transform((val) => val as string).def.type satisfies \"transform\";\n  z.nonoptional(z.string()).def.type satisfies \"nonoptional\";\n  z.readonly(z.unknown()).def.type satisfies \"readonly\";\n  z.nan().def.type satisfies \"nan\";\n  z.pipe(z.unknown(), z.number()).def.type satisfies \"pipe\";\n  z.success(z.string()).def.type satisfies \"success\";\n  z.catch(z.string(), \"fallback\").def.type satisfies \"catch\";\n  z.file().def.type satisfies \"file\";\n});\n",
    "symbols": [
      {
        "name": "A",
        "kind": "class",
        "file": "C:/Users/Vipac/Desktop/final_project/mcp-rag-server/node_modules/zod/src/v4/mini/tests/index.test.ts",
        "startLine": 653,
        "endLine": 653
      }
    ]
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/tests/number.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4-mini\";\n\ntest(\"z.number\", () => {\n  const a = z.number();\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(z.parse(a, 123.45)).toEqual(123.45);\n  expect(() => z.parse(a, \"123\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n\n  type a = z.infer<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<number>();\n});\n\ntest(\"z.number async\", async () => {\n  const a = z.number().check(z.refine(async (_) => _ > 0));\n  await expect(z.parseAsync(a, 123)).resolves.toEqual(123);\n  await expect(() => z.parseAsync(a, -123)).rejects.toThrow();\n  await expect(() => z.parseAsync(a, \"123\")).rejects.toThrow();\n});\n\ntest(\"z.int\", () => {\n  const a = z.int();\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(() => z.parse(a, 123.45)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n});\n\ntest(\"z.float32\", () => {\n  const a = z.float32();\n  expect(z.parse(a, 123.45)).toEqual(123.45);\n  expect(() => z.parse(a, \"123.45\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n  // -3.4028234663852886e38, 3.4028234663852886e38;\n  expect(() => z.parse(a, 3.4028234663852886e38 * 2)).toThrow(); // Exceeds max\n  expect(() => z.parse(a, -3.4028234663852886e38 * 2)).toThrow(); // Exceeds min\n});\n\ntest(\"z.float64\", () => {\n  const a = z.float64();\n  expect(z.parse(a, 123.45)).toEqual(123.45);\n  expect(() => z.parse(a, \"123.45\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n  expect(() => z.parse(a, 1.7976931348623157e308 * 2)).toThrow(); // Exceeds max\n  expect(() => z.parse(a, -1.7976931348623157e308 * 2)).toThrow(); // Exceeds min\n});\n\ntest(\"z.int32\", () => {\n  const a = z.int32();\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(() => z.parse(a, 123.45)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n  expect(() => z.parse(a, 2147483648)).toThrow(); // Exceeds max\n  expect(() => z.parse(a, -2147483649)).toThrow(); // Exceeds min\n});\n\ntest(\"z.uint32\", () => {\n  const a = z.uint32();\n  expect(z.parse(a, 123)).toEqual(123);\n  expect(() => z.parse(a, -123)).toThrow();\n  expect(() => z.parse(a, 123.45)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n  expect(() => z.parse(a, 4294967296)).toThrow(); // Exceeds max\n  expect(() => z.parse(a, -1)).toThrow(); // Below min\n});\n\ntest(\"z.int64\", () => {\n  const a = z.int64();\n  expect(z.parse(a, BigInt(123))).toEqual(BigInt(123));\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, 123.45)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n  expect(() => z.parse(a, BigInt(\"9223372036854775808\"))).toThrow();\n  expect(() => z.parse(a, BigInt(\"-9223372036854775809\"))).toThrow();\n  // expect(() => z.parse(a, BigInt(\"9223372036854775808\"))).toThrow(); // Exceeds max\n  // expect(() => z.parse(a, BigInt(\"-9223372036854775809\"))).toThrow(); // Exceeds min\n});\n\ntest(\"z.uint64\", () => {\n  const a = z.uint64();\n  expect(z.parse(a, BigInt(123))).toEqual(BigInt(123));\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, -123)).toThrow();\n  expect(() => z.parse(a, 123.45)).toThrow();\n  expect(() => z.parse(a, \"123\")).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n  expect(() => z.parse(a, BigInt(\"18446744073709551616\"))).toThrow(); // Exceeds max\n  expect(() => z.parse(a, BigInt(\"-1\"))).toThrow(); // Below min\n  // expect(() => z.parse(a, BigInt(\"18446744073709551616\"))).toThrow(); // Exceeds max\n  // expect(() => z.parse(a, BigInt(\"-1\"))).toThrow(); // Below min\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/tests/object.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4-mini\";\n\ntest(\"z.object\", () => {\n  const a = z.object({\n    name: z.string(),\n    age: z.number(),\n    points: z.optional(z.number()),\n    \"test?\": z.boolean(),\n  });\n\n  a._zod.def.shape[\"test?\"];\n  a._zod.def.shape.points._zod.optin;\n\n  type a = z.output<typeof a>;\n\n  expectTypeOf<a>().toEqualTypeOf<{\n    name: string;\n    age: number;\n    points?: number;\n    \"test?\": boolean;\n  }>();\n  expect(z.parse(a, { name: \"john\", age: 30, \"test?\": true })).toEqual({\n    name: \"john\",\n    age: 30,\n    \"test?\": true,\n  });\n  // \"test?\" is required in ZodObject\n  expect(() => z.parse(a, { name: \"john\", age: \"30\" })).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n\n  // null prototype\n  const schema = z.object({ a: z.string() });\n  const obj = Object.create(null);\n  obj.a = \"foo\";\n  expect(schema.parse(obj)).toEqual({ a: \"foo\" });\n});\n\ntest(\"z.object().check()\", () => {\n  const a = z.object({\n    name: z.string(),\n    age: z.number(),\n    points: z.optional(z.number()),\n    \"test?\": z.boolean(),\n  });\n\n  type a = z.output<typeof a>;\n\n  a.check(({ value }) => {\n    expectTypeOf(value).toEqualTypeOf<a>();\n  });\n});\n\ntest(\"z.strictObject\", () => {\n  const a = z.strictObject({\n    name: z.string(),\n  });\n  expect(z.parse(a, { name: \"john\" })).toEqual({ name: \"john\" });\n  expect(() => z.parse(a, { name: \"john\", age: 30 })).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.looseObject\", () => {\n  const a = z.looseObject({\n    name: z.string(),\n    age: z.number(),\n  });\n  expect(z.parse(a, { name: \"john\", age: 30 })).toEqual({\n    name: \"john\",\n    age: 30,\n  });\n  expect(z.parse(a, { name: \"john\", age: 30, extra: true })).toEqual({\n    name: \"john\",\n    age: 30,\n    extra: true,\n  });\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\nconst userSchema = z.object({\n  name: z.string(),\n  age: z.number(),\n  email: z.optional(z.string()),\n});\n\ntest(\"z.keyof\", () => {\n  // z.keyof returns an enum schema of the keys of an object schema\n  const userKeysSchema = z.keyof(userSchema);\n  type UserKeys = z.infer<typeof userKeysSchema>;\n  expectTypeOf<UserKeys>().toEqualTypeOf<\"name\" | \"age\" | \"email\">();\n  expect(userKeysSchema).toBeDefined();\n  expect(z.safeParse(userKeysSchema, \"name\").success).toBe(true);\n  expect(z.safeParse(userKeysSchema, \"age\").success).toBe(true);\n  expect(z.safeParse(userKeysSchema, \"email\").success).toBe(true);\n  expect(z.safeParse(userKeysSchema, \"isAdmin\").success).toBe(false);\n});\n\ntest(\"z.extend\", () => {\n  const extendedSchema = z.extend(userSchema, {\n    isAdmin: z.boolean(),\n  });\n  type ExtendedUser = z.infer<typeof extendedSchema>;\n  expectTypeOf<ExtendedUser>().toEqualTypeOf<{\n    name: string;\n    age: number;\n    email?: string;\n    isAdmin: boolean;\n  }>();\n  expect(extendedSchema).toBeDefined();\n  expect(z.safeParse(extendedSchema, { name: \"John\", age: 30, isAdmin: true }).success).toBe(true);\n});\n\ntest(\"z.pick\", () => {\n  const pickedSchema = z.pick(userSchema, { name: true, email: true });\n  type PickedUser = z.infer<typeof pickedSchema>;\n  expectTypeOf<PickedUser>().toEqualTypeOf<{ name: string; email?: string }>();\n  expect(pickedSchema).toBeDefined();\n  expect(z.safeParse(pickedSchema, { name: \"John\", email: \"john@example.com\" }).success).toBe(true);\n});\n\ntest(\"z.omit\", () => {\n  const omittedSchema = z.omit(userSchema, { age: true });\n  type OmittedUser = z.infer<typeof omittedSchema>;\n  expectTypeOf<OmittedUser>().toEqualTypeOf<{\n    name: string;\n    email?: string | undefined;\n  }>();\n  expect(omittedSchema).toBeDefined();\n  expect(Reflect.ownKeys(omittedSchema._zod.def.shape)).toEqual([\"name\", \"email\"]);\n  expect(z.safeParse(omittedSchema, { name: \"John\", email: \"john@example.com\" }).success).toBe(true);\n});\n\ntest(\"z.partial\", () => {\n  const partialSchema = z.partial(userSchema);\n  type PartialUser = z.infer<typeof partialSchema>;\n  expectTypeOf<PartialUser>().toEqualTypeOf<{\n    name?: string;\n    age?: number;\n    email?: string;\n  }>();\n  expect(z.safeParse(partialSchema, { name: \"John\" }).success).toBe(true);\n});\n\ntest(\"z.partial with mask\", () => {\n  const partialSchemaWithMask = z.partial(userSchema, { name: true });\n  type PartialUserWithMask = z.infer<typeof partialSchemaWithMask>;\n  expectTypeOf<PartialUserWithMask>().toEqualTypeOf<{\n    name?: string;\n    age: number;\n    email?: string;\n  }>();\n  expect(z.safeParse(partialSchemaWithMask, { age: 30 }).success).toBe(true);\n  expect(z.safeParse(partialSchemaWithMask, { name: \"John\" }).success).toBe(false);\n});\n\ntest(\"z.catchall\", () => {\n  // z.catchall()\n  const schema = z.catchall(\n    z.object({\n      name: z.string(),\n      // age: z.number(),\n    }),\n    z.string()\n  );\n\n  type schemaIn = z.input<typeof schema>;\n  type schemaOut = z.output<typeof schema>;\n  expectTypeOf<schemaIn>().toEqualTypeOf<{\n    name: string;\n    [key: string]: string;\n  }>();\n\n  expectTypeOf<schemaOut>().toEqualTypeOf<{\n    name: string;\n    [key: string]: string;\n  }>();\n\n  schema.parse({\n    name: \"john\",\n    age: \"30\",\n    extra: \"extra value\",\n  });\n\n  expect(() => schema.parse({ name: \"john\", age: 30 })).toThrow();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/tests/prototypes.test.ts",
    "content": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4-mini\";\n\ndeclare module \"zod/v4/core\" {\n  interface $ZodType {\n    /** @deprecated */\n    _core(): string;\n  }\n}\n\ntest(\"prototype extension\", () => {\n  z.core.$ZodType.prototype._core = function () {\n    return \"_core\";\n  };\n\n  // should pass\n  const result = z.string()._core();\n  expect(result).toBe(\"_core\");\n  // expectTypeOf<typeof result>().toEqualTypeOf<string>();\n\n  // clean up\n  z.ZodMiniType.prototype._core = undefined;\n});\n\ndeclare module \"zod/v4/mini\" {\n  interface ZodMiniType {\n    /** @deprecated */\n    _mini(): string;\n  }\n}\n\ntest(\"prototype extension\", () => {\n  z.ZodMiniType.prototype._mini = function () {\n    return \"_mini\";\n  };\n\n  // should pass\n  const result = z.string()._mini();\n  expect(result).toBe(\"_mini\");\n\n  // clean up\n  z.ZodMiniType.prototype._mini = undefined;\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/tests/recursive-types.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport { z } from \"zod/v4-mini\";\n\ntest(\"recursion with z.lazy\", () => {\n  const data = {\n    name: \"I\",\n    subcategories: [\n      {\n        name: \"A\",\n        subcategories: [\n          {\n            name: \"1\",\n            subcategories: [\n              {\n                name: \"a\",\n                subcategories: [],\n              },\n            ],\n          },\n        ],\n      },\n    ],\n  };\n\n  const Category = z.object({\n    name: z.string(),\n    get subcategories(): z.ZodMiniOptional<z.ZodMiniArray<typeof Category>> {\n      return z.optional(z.array(Category));\n    },\n  });\n  Category.parse(data);\n\n  type Category = z.infer<typeof Category>;\n  interface _Category {\n    name: string;\n    subcategories?: _Category[];\n  }\n  expectTypeOf<Category>().toEqualTypeOf<_Category>();\n});\n\ntest(\"recursion involving union type\", () => {\n  const data = {\n    value: 1,\n    next: {\n      value: 2,\n      next: {\n        value: 3,\n        next: {\n          value: 4,\n          next: null,\n        },\n      },\n    },\n  };\n\n  const LL = z.object({\n    value: z.number(),\n    get next(): z.ZodMiniNullable<typeof LL> {\n      return z.nullable(LL);\n    },\n  });\n\n  LL.parse(data);\n  type LL = z.infer<typeof LL>;\n  type _LL = {\n    value: number;\n    next: _LL | null;\n  };\n  expectTypeOf<LL>().toEqualTypeOf<_LL>();\n});\n\ntest(\"mutual recursion - native\", () => {\n  const Alazy = z.object({\n    val: z.number(),\n    get b() {\n      return z.optional(Blazy);\n    },\n  });\n\n  const Blazy = z.object({\n    val: z.number(),\n    get a() {\n      return z.optional(Alazy);\n    },\n  });\n  const testData = {\n    val: 1,\n    b: {\n      val: 5,\n      a: {\n        val: 3,\n        b: {\n          val: 4,\n          a: {\n            val: 2,\n            b: {\n              val: 1,\n            },\n          },\n        },\n      },\n    },\n  };\n\n  Alazy.parse(testData);\n  Blazy.parse(testData.b);\n\n  type Alazy = z.infer<typeof Alazy>;\n  type Blazy = z.infer<typeof Blazy>;\n  interface _Alazy {\n    val: number;\n    b?: _Blazy | undefined;\n  }\n  interface _Blazy {\n    val: number;\n    a?: _Alazy | undefined;\n  }\n  expectTypeOf<Alazy>().toEqualTypeOf<_Alazy>();\n  expectTypeOf<Blazy>().toEqualTypeOf<_Blazy>();\n\n  expect(() => Alazy.parse({ val: \"asdf\" })).toThrow();\n});\n\ntest(\"pick and omit with getter\", () => {\n  const Category = z.strictObject({\n    name: z.string(),\n    get subcategories() {\n      return z.array(Category);\n    },\n  });\n\n  type Category = z.infer<typeof Category>;\n  interface _Category {\n    name: string;\n    subcategories: _Category[];\n  }\n  expectTypeOf<Category>().toEqualTypeOf<_Category>();\n\n  const PickedCategory = z.pick(Category, { name: true });\n  const OmittedCategory = z.omit(Category, { subcategories: true });\n  type PickedCategory = z.infer<typeof PickedCategory>;\n  type OmittedCategory = z.infer<typeof OmittedCategory>;\n  interface _PickedCategory {\n    name: string;\n  }\n  interface _OmittedCategory {\n    name: string;\n  }\n  expectTypeOf<PickedCategory>().toEqualTypeOf<_PickedCategory>();\n  expectTypeOf<OmittedCategory>().toEqualTypeOf<_OmittedCategory>();\n\n  const picked = { name: \"test\" };\n  const omitted = { name: \"test\" };\n\n  PickedCategory.parse(picked);\n  OmittedCategory.parse(omitted);\n\n  expect(() => PickedCategory.parse({ name: \"test\", subcategories: [] })).toThrow();\n  expect(() => OmittedCategory.parse({ name: \"test\", subcategories: [] })).toThrow();\n});\n\ntest(\"deferred self-recursion\", () => {\n  const Feature = z.object({\n    title: z.string(),\n    get features(): z.ZodMiniOptional<z.ZodMiniArray<typeof Feature>> {\n      return z.optional(z.array(Feature)); //.optional();\n    },\n  });\n  type Feature = z.infer<typeof Feature>;\n\n  const Output = z.object({\n    id: z.int(), //.nonnegative(),\n    name: z.string(),\n    features: z.array(Feature), //.array(), // <—\n  });\n\n  type Output = z.output<typeof Output>;\n\n  type _Feature = {\n    title: string;\n    features?: _Feature[] | undefined;\n  };\n\n  type _Output = {\n    id: number;\n    name: string;\n    features: _Feature[];\n  };\n\n  expectTypeOf<Feature>().toEqualTypeOf<_Feature>();\n  expectTypeOf<Output>().toEqualTypeOf<_Output>();\n});\n\ntest(\"recursion compatibility\", () => {\n  // array\n  const A = z.object({\n    get subcategories() {\n      return z.array(A);\n    },\n  });\n  // tuple\n  const B = z.object({\n    get subcategories() {\n      return z.tuple([B, B]);\n    },\n  });\n  // object\n  const C = z.object({\n    get subcategories() {\n      return z.object({\n        subcategories: C,\n      });\n    },\n  });\n  // union\n  const D = z.object({\n    get subcategories() {\n      return z.union([D, z.string()]);\n    },\n  });\n  // intersection\n  const E = z.object({\n    get subcategories() {\n      return z.intersection(E, E);\n    },\n  });\n  // record\n  const F = z.object({\n    get subcategories() {\n      return z.record(z.string(), F);\n    },\n  });\n  // map\n  const G = z.object({\n    get subcategories() {\n      return z.map(z.string(), G);\n    },\n  });\n  // set\n  const H = z.object({\n    get subcategories() {\n      return z.set(H);\n    },\n  });\n  // optional\n  const I = z.object({\n    get subcategories() {\n      return z.optional(I);\n    },\n  });\n  // nullable\n  const J = z.object({\n    get subcategories() {\n      return z.nullable(J);\n    },\n  });\n  // optional\n  const L = z.object({\n    get subcategories() {\n      return z.optional(L);\n    },\n  });\n  // nullable\n  const M = z.object({\n    get subcategories() {\n      return z.nullable(M);\n    },\n  });\n  // nonoptional\n  const N = z.object({\n    get subcategories() {\n      return z.nonoptional(N);\n    },\n  });\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/mini/tests/string.test.ts",
    "content": "import { expect, expectTypeOf, test } from \"vitest\";\nimport * as z from \"zod/v4-mini\";\n\nconst FAIL = { success: false };\n\ntest(\"z.string\", async () => {\n  const a = z.string();\n  expect(z.parse(a, \"hello\")).toEqual(\"hello\");\n  expect(() => z.parse(a, 123)).toThrow();\n  expect(() => z.parse(a, false)).toThrow();\n  type a = z.infer<typeof a>;\n  expectTypeOf<a>().toEqualTypeOf<string>();\n});\n\n// test(\"z.string with description\", () => {\n//   const a = z.string({ description: \"string description\" });\n//   a._def;\n//   expect(a._def.description).toEqual(\"string description\");\n// });\n\ntest(\"z.string with custom error\", () => {\n  const a = z.string({ error: () => \"BAD\" });\n  expect(z.safeParse(a, 123).error!.issues[0].message).toEqual(\"BAD\");\n});\n\ntest(\"inference in checks\", () => {\n  const a = z.string().check(z.refine((val) => val.length));\n  z.parse(a, \"___\");\n  expect(() => z.parse(a, \"\")).toThrow();\n  const b = z.string().check(z.refine((val) => val.length));\n  z.parse(b, \"___\");\n  expect(() => z.parse(b, \"\")).toThrow();\n  const c = z.string().check(z.refine((val) => val.length));\n  z.parse(c, \"___\");\n  expect(() => z.parse(c, \"\")).toThrow();\n  const d = z.string().check(z.refine((val) => val.length));\n  z.parse(d, \"___\");\n  expect(() => z.parse(d, \"\")).toThrow();\n});\n\ntest(\"z.string async\", async () => {\n  // async\n  const a = z.string().check(z.refine(async (val) => val.length));\n  expect(await z.parseAsync(a, \"___\")).toEqual(\"___\");\n  await expect(() => z.parseAsync(a, \"\")).rejects.toThrowError();\n});\n\ntest(\"z.uuid\", () => {\n  const a = z.uuid();\n  // parse uuid\n  z.parse(a, \"550e8400-e29b-41d4-a716-446655440000\");\n  z.parse(a, \"550e8400-e29b-61d4-a716-446655440000\");\n\n  // bad uuid\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  // wrong type\n  expect(() => z.parse(a, 123)).toThrow();\n\n  const b = z.uuidv4();\n  z.parse(b, \"550e8400-e29b-41d4-a716-446655440000\");\n  expect(z.safeParse(b, \"550e8400-e29b-61d4-a716-446655440000\")).toMatchObject(FAIL);\n\n  const c = z.uuidv6();\n  z.parse(c, \"550e8400-e29b-61d4-a716-446655440000\");\n  expect(z.safeParse(c, \"550e8400-e29b-41d4-a716-446655440000\")).toMatchObject(FAIL);\n\n  const d = z.uuidv7();\n  z.parse(d, \"550e8400-e29b-71d4-a716-446655440000\");\n  expect(z.safeParse(d, \"550e8400-e29b-41d4-a716-446655440000\")).toMatchObject(FAIL);\n  expect(z.safeParse(d, \"550e8400-e29b-61d4-a716-446655440000\")).toMatchObject(FAIL);\n});\n\ntest(\"z.email\", () => {\n  const a = z.email();\n  expect(z.parse(a, \"test@test.com\")).toEqual(\"test@test.com\");\n  expect(() => z.parse(a, \"test\")).toThrow();\n  expect(z.safeParse(a, \"bad email\", { error: () => \"bad email\" }).error!.issues[0].message).toEqual(\"bad email\");\n\n  const b = z.email(\"bad email\");\n  expect(z.safeParse(b, \"bad email\").error!.issues[0].message).toEqual(\"bad email\");\n\n  const c = z.email({ error: \"bad email\" });\n  expect(z.safeParse(c, \"bad email\").error!.issues[0].message).toEqual(\"bad email\");\n\n  const d = z.email({ error: () => \"bad email\" });\n  expect(z.safeParse(d, \"bad email\").error!.issues[0].message).toEqual(\"bad email\");\n});\n\ntest(\"z.url\", () => {\n  const a = z.url();\n  // valid URLs\n  expect(a.parse(\"http://example.com\")).toEqual(\"http://example.com\");\n  expect(a.parse(\"https://example.com\")).toEqual(\"https://example.com\");\n  expect(a.parse(\"ftp://example.com\")).toEqual(\"ftp://example.com\");\n  expect(a.parse(\"http://sub.example.com\")).toEqual(\"http://sub.example.com\");\n  expect(a.parse(\"https://example.com/path?query=123#fragment\")).toEqual(\"https://example.com/path?query=123#fragment\");\n  expect(a.parse(\"http://localhost\")).toEqual(\"http://localhost\");\n  expect(a.parse(\"https://localhost\")).toEqual(\"https://localhost\");\n  expect(a.parse(\"http://localhost:3000\")).toEqual(\"http://localhost:3000\");\n  expect(a.parse(\"https://localhost:3000\")).toEqual(\"https://localhost:3000\");\n\n  // test trimming\n  expect(a.parse(\"  http://example.com  \")).toEqual(\"http://example.com\");\n  expect(a.parse(\"  http://example.com/\")).toEqual(\"http://example.com/\");\n  expect(a.parse(\"  http://example.com\")).toEqual(\"http://example.com\");\n  expect(a.parse(\"  http://example.com//\")).toEqual(\"http://example.com//\");\n\n  // invalid URLs\n  expect(() => a.parse(\"not-a-url\")).toThrow();\n  // expect(() => a.parse(\"http:/example.com\")).toThrow();\n  expect(() => a.parse(\"://example.com\")).toThrow();\n  expect(() => a.parse(\"http://\")).toThrow();\n  expect(() => a.parse(\"example.com\")).toThrow();\n\n  // wrong type\n  expect(() => a.parse(123)).toThrow();\n  expect(() => a.parse(null)).toThrow();\n  expect(() => a.parse(undefined)).toThrow();\n});\n\ntest(\"z.url with optional hostname regex\", () => {\n  const a = z.url({ hostname: /example\\.com$/ });\n  expect(a.parse(\"http://example.com\")).toEqual(\"http://example.com\");\n  expect(a.parse(\"https://sub.example.com\")).toEqual(\"https://sub.example.com\");\n  expect(() => a.parse(\"http://examples.com\")).toThrow();\n  expect(() => a.parse(\"http://example.org\")).toThrow();\n  expect(() => a.parse(\"asdf\")).toThrow();\n});\n\ntest(\"z.url - file urls\", () => {\n  // file URLs\n  const a = z.url({ hostname: /.*/ }); // allow any hostname\n  expect(a.parse(\"file:///path/to/file.txt\")).toEqual(\"file:///path/to/file.txt\");\n  expect(a.parse(\"file:///C:/path/to/file.txt\")).toEqual(\"file:///C:/path/to/file.txt\");\n  expect(a.parse(\"file:///C:/path/to/file.txt?query=123#fragment\")).toEqual(\n    \"file:///C:/path/to/file.txt?query=123#fragment\"\n  );\n});\ntest(\"z.url with optional protocol regex\", () => {\n  const a = z.url({ protocol: /^https?$/ });\n  expect(a.parse(\"http://example.com\")).toEqual(\"http://example.com\");\n  expect(a.parse(\"https://example.com\")).toEqual(\"https://example.com\");\n  expect(() => a.parse(\"ftp://example.com\")).toThrow();\n  expect(() => a.parse(\"mailto:example@example.com\")).toThrow();\n  expect(() => a.parse(\"asdf\")).toThrow();\n});\n\ntest(\"z.url with both hostname and protocol regexes\", () => {\n  const a = z.url({ hostname: /example\\.com$/, protocol: /^https$/ });\n  expect(a.parse(\"https://example.com\")).toEqual(\"https://example.com\");\n  expect(a.parse(\"https://sub.example.com\")).toEqual(\"https://sub.example.com\");\n  expect(() => a.parse(\"http://example.com\")).toThrow();\n  expect(() => a.parse(\"https://example.org\")).toThrow();\n  expect(() => a.parse(\"ftp://example.com\")).toThrow();\n  expect(() => a.parse(\"asdf\")).toThrow();\n});\n\ntest(\"z.url with invalid regex patterns\", () => {\n  const a = z.url({ hostname: /a+$/, protocol: /^ftp$/ });\n  a.parse(\"ftp://a\");\n  a.parse(\"ftp://aaaaaaaa\");\n  expect(() => a.parse(\"http://aaa\")).toThrow();\n  expect(() => a.parse(\"https://example.com\")).toThrow();\n  expect(() => a.parse(\"ftp://asdfasdf\")).toThrow();\n  expect(() => a.parse(\"ftp://invalid\")).toThrow();\n});\n\ntest(\"z.emoji\", () => {\n  const a = z.emoji();\n  expect(z.parse(a, \"😀\")).toEqual(\"😀\");\n  expect(() => z.parse(a, \"hello\")).toThrow();\n});\n\ntest(\"z.nanoid\", () => {\n  const a = z.nanoid();\n  expect(z.parse(a, \"8FHZpIxleEK3axQRBNNjN\")).toEqual(\"8FHZpIxleEK3axQRBNNjN\");\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.cuid\", () => {\n  const a = z.cuid();\n  expect(z.parse(a, \"cixs7y0c0000f7x3b1z6m3w6r\")).toEqual(\"cixs7y0c0000f7x3b1z6m3w6r\");\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.cuid2\", () => {\n  const a = z.cuid2();\n  expect(z.parse(a, \"cixs7y0c0000f7x3b1z6m3w6r\")).toEqual(\"cixs7y0c0000f7x3b1z6m3w6r\");\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.ulid\", () => {\n  const a = z.ulid();\n  expect(z.parse(a, \"01ETGRM9QYVX6S9V2F3B6JXG4N\")).toEqual(\"01ETGRM9QYVX6S9V2F3B6JXG4N\");\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.xid\", () => {\n  const a = z.xid();\n  expect(z.parse(a, \"9m4e2mr0ui3e8a215n4g\")).toEqual(\"9m4e2mr0ui3e8a215n4g\");\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\ntest(\"z.ksuid\", () => {\n  const a = z.ksuid();\n  expect(z.parse(a, \"2naeRjTrrHJAkfd3tOuEjw90WCA\")).toEqual(\"2naeRjTrrHJAkfd3tOuEjw90WCA\");\n  expect(() => z.parse(a, \"abc\")).toThrow();\n});\n\n// test(\"z.ip\", () => {\n//   const a = z.ip();\n//   expect(z.parse(a, \"127.0.0.1\")).toEqual(\"127.0.0.1\");\n//   expect(z.parse(a, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")).toEqual(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\");\n//   expect(() => z.parse(a, \"abc\")).toThrow();\n// });\n\ntest(\"z.ipv4\", () => {\n  const a = z.ipv4();\n  // valid ipv4\n  expect(z.parse(a, \"192.168.1.1\")).toEqual(\"192.168.1.1\");\n  expect(z.parse(a, \"255.255.255.255\")).toEqual(\"255.255.255.255\");\n  // invalid ipv4\n  expect(() => z.parse(a, \"999.999.999.999\")).toThrow();\n  expect(() => z.parse(a, \"256.256.256.256\")).toThrow();\n  expect(() => z.parse(a, \"192.168.1\")).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  // wrong type\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.ipv6\", () => {\n  const a = z.ipv6();\n  // valid ipv6\n  expect(z.parse(a, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")).toEqual(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\");\n  expect(z.parse(a, \"::1\")).toEqual(\"::1\");\n  // invalid ipv6\n  expect(() => z.parse(a, \"2001:db8::85a3::8a2e:370:7334\")).toThrow();\n  expect(() => z.parse(a, \"2001:db8:85a3:0:0:8a2e:370g:7334\")).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  // wrong type\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.base64\", () => {\n  const a = z.base64();\n  // valid base64\n  expect(z.parse(a, \"SGVsbG8gd29ybGQ=\")).toEqual(\"SGVsbG8gd29ybGQ=\");\n  expect(z.parse(a, \"U29tZSBvdGhlciBzdHJpbmc=\")).toEqual(\"U29tZSBvdGhlciBzdHJpbmc=\");\n  // invalid base64\n  expect(() => z.parse(a, \"SGVsbG8gd29ybGQ\")).toThrow();\n  expect(() => z.parse(a, \"U29tZSBvdGhlciBzdHJpbmc\")).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  // wrong type\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\n// test(\"z.jsonString\", () => {\n//   const a = z.jsonString();\n//   // valid JSON string\n//   expect(z.parse(a, '{\"key\":\"value\"}')).toEqual('{\"key\":\"value\"}');\n//   expect(z.parse(a, '[\"item1\", \"item2\"]')).toEqual('[\"item1\", \"item2\"]');\n//   // invalid JSON string\n//   expect(() => z.parse(a, '{\"key\":value}')).toThrow();\n//   expect(() => z.parse(a, '[\"item1\", \"item2\"')).toThrow();\n//   expect(() => z.parse(a, \"hello\")).toThrow();\n//   // wrong type\n//   expect(() => z.parse(a, 123)).toThrow();\n// });\n\ntest(\"z.e164\", () => {\n  const a = z.e164();\n  // valid e164\n  expect(z.parse(a, \"+1234567890\")).toEqual(\"+1234567890\");\n  expect(z.parse(a, \"+19876543210\")).toEqual(\"+19876543210\");\n  // invalid e164\n  expect(() => z.parse(a, \"1234567890\")).toThrow();\n  expect(() => z.parse(a, \"+12345\")).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  // wrong type\n  expect(() => z.parse(a, 123)).toThrow();\n});\n\ntest(\"z.jwt\", () => {\n  const a = z.jwt();\n  // valid jwt\n  expect(\n    z.parse(\n      a,\n      \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\"\n    )\n  ).toEqual(\n    \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\"\n  );\n  // invalid jwt\n  expect(() => z.parse(a, \"invalid.jwt.token\")).toThrow();\n  expect(() => z.parse(a, \"hello\")).toThrow();\n  // wrong type\n  expect(() => z.parse(a, 123)).toThrow();\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/tests/locales/be.test.ts",
    "content": "import { describe, expect, it } from \"vitest\";\nimport be from \"../../../locales/be.js\";\n\ndescribe(\"Belarusian localization\", () => {\n  const localeError = be().localeError;\n\n  describe(\"pluralization rules\", () => {\n    for (const { type, cases } of TEST_CASES) {\n      describe(`${type} pluralization`, () => {\n        for (const { count, expected } of cases) {\n          it(`correctly pluralizes ${count} ${type}`, () => {\n            const error = localeError({\n              code: \"too_small\",\n              minimum: count,\n              type: \"number\",\n              inclusive: true,\n              path: [],\n              origin: type,\n              input: count - 1,\n            });\n            expect(error).toContain(expected);\n          });\n        }\n      });\n    }\n\n    it(\"handles negative numbers correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: -2,\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: -3,\n      });\n      expect(error).toContain(\"-2 элементы\");\n    });\n\n    it(\"handles zero correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: 0,\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: -1,\n      });\n      expect(error).toContain(\"0 элементаў\");\n    });\n\n    it(\"handles bigint values correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: BigInt(21),\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: BigInt(20),\n      });\n      expect(error).toContain(\"21 элемент\");\n    });\n  });\n});\n\nconst TEST_CASES = [\n  {\n    type: \"array\",\n    cases: [\n      { count: 1, expected: \"1 элемент\" },\n      { count: 2, expected: \"2 элементы\" },\n      { count: 5, expected: \"5 элементаў\" },\n      { count: 11, expected: \"11 элементаў\" },\n      { count: 21, expected: \"21 элемент\" },\n      { count: 22, expected: \"22 элементы\" },\n      { count: 25, expected: \"25 элементаў\" },\n      { count: 101, expected: \"101 элемент\" },\n      { count: 111, expected: \"111 элементаў\" },\n    ],\n  },\n  {\n    type: \"set\",\n    cases: [\n      { count: 1, expected: \"1 элемент\" },\n      { count: 2, expected: \"2 элементы\" },\n      { count: 5, expected: \"5 элементаў\" },\n      { count: 11, expected: \"11 элементаў\" },\n      { count: 21, expected: \"21 элемент\" },\n      { count: 22, expected: \"22 элементы\" },\n      { count: 25, expected: \"25 элементаў\" },\n      { count: 101, expected: \"101 элемент\" },\n      { count: 111, expected: \"111 элементаў\" },\n    ],\n  },\n  {\n    type: \"string\",\n    cases: [\n      { count: 1, expected: \"1 сімвал\" },\n      { count: 2, expected: \"2 сімвалы\" },\n      { count: 5, expected: \"5 сімвалаў\" },\n      { count: 11, expected: \"11 сімвалаў\" },\n      { count: 21, expected: \"21 сімвал\" },\n      { count: 22, expected: \"22 сімвалы\" },\n      { count: 25, expected: \"25 сімвалаў\" },\n    ],\n  },\n  {\n    type: \"file\",\n    cases: [\n      { count: 0, expected: \"0 байтаў\" },\n      { count: 1, expected: \"1 байт\" },\n      { count: 2, expected: \"2 байты\" },\n      { count: 5, expected: \"5 байтаў\" },\n      { count: 11, expected: \"11 байтаў\" },\n      { count: 21, expected: \"21 байт\" },\n      { count: 22, expected: \"22 байты\" },\n      { count: 25, expected: \"25 байтаў\" },\n      { count: 101, expected: \"101 байт\" },\n      { count: 110, expected: \"110 байтаў\" },\n    ],\n  },\n] as const;\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/tests/locales/en.test.ts",
    "content": "import { expect, test } from \"vitest\";\nimport { parsedType } from \"../../../locales/en.js\";\n\ntest(\"parsedType\", () => {\n  expect(parsedType(\"string\")).toBe(\"string\");\n  expect(parsedType(1)).toBe(\"number\");\n  expect(parsedType(true)).toBe(\"boolean\");\n  expect(parsedType(null)).toBe(\"null\");\n  expect(parsedType(undefined)).toBe(\"undefined\");\n  expect(parsedType([])).toBe(\"array\");\n  expect(parsedType({})).toBe(\"object\");\n  expect(parsedType(new Date())).toBe(\"Date\");\n  expect(parsedType(new Map())).toBe(\"Map\");\n  expect(parsedType(new Set())).toBe(\"Set\");\n  expect(parsedType(new Error())).toBe(\"Error\");\n\n  const nullPrototype = Object.create(null);\n  expect(parsedType(nullPrototype)).toBe(\"object\");\n\n  const doubleNullPrototype = Object.create(Object.create(null));\n  expect(parsedType(doubleNullPrototype)).toBe(\"object\");\n});\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/tests/locales/ru.test.ts",
    "content": "import { describe, expect, it } from \"vitest\";\nimport ru from \"../../../locales/ru.js\";\n\ndescribe(\"Russian localization\", () => {\n  const localeError = ru().localeError;\n\n  describe(\"pluralization rules\", () => {\n    for (const { type, cases } of TEST_CASES) {\n      describe(`${type} pluralization`, () => {\n        for (const { count, expected } of cases) {\n          it(`correctly pluralizes ${count} ${type}`, () => {\n            const error = localeError({\n              code: \"too_small\",\n              minimum: count,\n              type: \"number\",\n              inclusive: true,\n              path: [],\n              origin: type,\n              input: count - 1,\n            });\n\n            expect(error).toContain(expected);\n          });\n        }\n      });\n    }\n\n    it(\"handles negative numbers correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: -2,\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: -3,\n      });\n\n      expect(error).toContain(\"-2 элемента\");\n    });\n\n    it(\"handles zero correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: 0,\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: -1,\n      });\n\n      expect(error).toContain(\"0 элементов\");\n    });\n\n    it(\"handles bigint values correctly\", () => {\n      const error = localeError({\n        code: \"too_small\",\n        minimum: BigInt(21),\n        type: \"number\",\n        inclusive: true,\n        path: [],\n        origin: \"array\",\n        input: BigInt(20),\n      });\n\n      expect(error).toContain(\"21 элемент\");\n    });\n  });\n});\n\nconst TEST_CASES = [\n  {\n    type: \"array\",\n    cases: [\n      { count: 1, expected: \"1 элемент\" },\n      { count: 2, expected: \"2 элемента\" },\n      { count: 5, expected: \"5 элементов\" },\n      { count: 11, expected: \"11 элементов\" },\n      { count: 21, expected: \"21 элемент\" },\n      { count: 22, expected: \"22 элемента\" },\n      { count: 25, expected: \"25 элементов\" },\n      { count: 101, expected: \"101 элемент\" },\n      { count: 111, expected: \"111 элементов\" },\n    ],\n  },\n  {\n    type: \"set\",\n    cases: [\n      { count: 1, expected: \"1 элемент\" },\n      { count: 2, expected: \"2 элемента\" },\n      { count: 5, expected: \"5 элементов\" },\n      { count: 11, expected: \"11 элементов\" },\n      { count: 21, expected: \"21 элемент\" },\n      { count: 22, expected: \"22 элемента\" },\n      { count: 25, expected: \"25 элементов\" },\n      { count: 101, expected: \"101 элемент\" },\n      { count: 111, expected: \"111 элементов\" },\n    ],\n  },\n  {\n    type: \"string\",\n    cases: [\n      { count: 1, expected: \"1 символ\" },\n      { count: 2, expected: \"2 символа\" },\n      { count: 5, expected: \"5 символов\" },\n      { count: 11, expected: \"11 символов\" },\n      { count: 21, expected: \"21 символ\" },\n      { count: 22, expected: \"22 символа\" },\n      { count: 25, expected: \"25 символов\" },\n    ],\n  },\n  {\n    type: \"file\",\n    cases: [\n      { count: 0, expected: \"0 байт\" },\n      { count: 1, expected: \"1 байт\" },\n      { count: 2, expected: \"2 байта\" },\n      { count: 5, expected: \"5 байт\" },\n      { count: 11, expected: \"11 байт\" },\n      { count: 21, expected: \"21 байт\" },\n      { count: 22, expected: \"22 байта\" },\n      { count: 25, expected: \"25 байт\" },\n      { count: 101, expected: \"101 байт\" },\n      { count: 110, expected: \"110 байт\" },\n    ],\n  },\n] as const;\n",
    "symbols": []
  },
  {
    "path": "mcp-rag-server/node_modules/zod/src/v4/core/tests/locales/tr.test.ts",
    "content": "import { expect, test } from \"vitest\";\nimport * as z from \"zod/v4\";\nimport { parsedType } from \"../../../locales/tr.js\";\n\ntest(\"parsedType\", () => {\n  expect(parsedType(\"string\")).toBe(\"string\");\n  expect(parsedType(1)).toBe(\"number\");\n  expect(parsedType(true)).toBe(\"boolean\");\n  expect(parsedType(null)).toBe(\"null\");\n  expect(parsedType(undefined)).toBe(\"undefined\");\n  expect(parsedType([])).toBe(\"array\");\n  expect(parsedType({})).toBe(\"object\");\n  expect(parsedType(new Date())).toBe(\"Date\");\n  expect(parsedType(new Map())).toBe(\"Map\");\n  expect(parsedType(new Set())).toBe(\"Set\");\n  expect(parsedType(new Error())).toBe(\"Error\");\n\n  const nullPrototype = Object.create(null);\n  expect(parsedType(nullPrototype)).toBe(\"object\");\n\n  const doubleNullPrototype = Object.create(Object.create(null));\n  expect(parsedType(doubleNullPrototype)).toBe(\"object\");\n\n  expect(parsedType(Number.NaN)).toBe(\"NaN\");\n});\n\ntest(\"locales - tr\", () => {\n  z.config(z.locales.tr());\n\n  const invalidType = z.number().safeParse(\"a\");\n  expect(invalidType.error!.issues[0].code).toBe(\"invalid_type\");\n  expect(invalidType.error!.issues[0].message).toBe(\"Geçersiz değer: beklenen number, alınan string\");\n\n  const invalidType2 = z.string().safeParse(1);\n  expect(invalidType2.error!.issues[0].code).toBe(\"invalid_type\");\n  expect(invalidType2.error!.issues[0].message).toBe(\"Geçersiz değer: beklenen string, alınan number\");\n\n  const invalidValue = z.enum([\"a\", \"b\"]).safeParse(1);\n  expect(invalidValue.error!.issues[0].code).toBe(\"invalid_value\");\n  expect(invalidValue.error!.issues[0].message).toBe('Geçersiz seçenek: aşağıdakilerden biri olmalı: \"a\"|\"b\"');\n\n  const tooBig = z.number().max(10).safeParse(15);\n  expect(tooBig.error!.issues[0].code).toBe(\"too_big\");\n  expect(tooBig.error!.issues[0].message).toBe(\"Çok büyük: beklenen number <=10\");\n\n  const tooSmall = z.number().min(10).safeParse(5);\n  expect(tooSmall.error!.issues[0].code).toBe(\"too_small\");\n  expect(tooSmall.error!.issues[0].message).toBe(\"Çok küçük: beklenen number >=10\");\n\n  const invalidFormatRegex = z.string().regex(/abcd/).safeParse(\"invalid-string\");\n  expect(invalidFormatRegex.error!.issues[0].code).toBe(\"invalid_format\");\n  expect(invalidFormatRegex.error!.issues[0].message).toBe(\"Geçersiz metin: /abcd/ desenine uymalı\");\n\n  const invalidFormatStartsWith = z.string().startsWith(\"abcd\").safeParse(\"invalid-string\");\n  expect(invalidFormatStartsWith.error!.issues[0].code).toBe(\"invalid_format\");\n  expect(invalidFormatStartsWith.error!.issues[0].message).toBe('Geçersiz metin: \"abcd\" ile başlamalı');\n\n  const notMultipleOf = z.number().multipleOf(3).safeParse(10);\n  expect(notMultipleOf.error!.issues[0].code).toBe(\"not_multiple_of\");\n  expect(notMultipleOf.error!.issues[0].message).toBe(\"Geçersiz sayı: 3 ile tam bölünebilmeli\");\n\n  const unrecognizedKeys = z.object({ a: z.string(), b: z.number() }).strict().safeParse({ a: \"a\", b: 1, c: 2 });\n  expect(unrecognizedKeys.error!.issues[0].code).toBe(\"unrecognized_keys\");\n  expect(unrecognizedKeys.error!.issues[0].message).toBe('Tanınmayan anahtar: \"c\"');\n\n  const invalidUnion = z.union([z.string(), z.number()]).safeParse(true);\n  expect(invalidUnion.error!.issues[0].code).toBe(\"invalid_union\");\n  expect(invalidUnion.error!.issues[0].message).toBe(\"Geçersiz değer\");\n});\n",
    "symbols": []
  }
]